(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["static\\development\\pages\\index.js"],{

/***/ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

module.exports = _arrayLikeToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return arrayLikeToArray(arr);
}

module.exports = _arrayWithoutHoles;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/construct.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/construct.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

var isNativeReflectConstruct = __webpack_require__(/*! ./isNativeReflectConstruct */ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/extends.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/extends.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _extends; });
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inheritsLoose; });
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectWithoutPropertiesLoose; });
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireWildcard.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

function _getRequireWildcardCache() {
  if (typeof WeakMap !== "function") return null;
  var cache = new WeakMap();

  _getRequireWildcardCache = function _getRequireWildcardCache() {
    return cache;
  };

  return cache;
}

function _interopRequireWildcard(obj) {
  if (obj && obj.__esModule) {
    return obj;
  }

  if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
    return {
      "default": obj
    };
  }

  var cache = _getRequireWildcardCache();

  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }

  var newObj = {};
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;

      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }

  newObj["default"] = obj;

  if (cache) {
    cache.set(obj, newObj);
  }

  return newObj;
}

module.exports = _interopRequireWildcard;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

module.exports = _isNativeReflectConstruct;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArray.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArray.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

module.exports = _iterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableRest.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableRest;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/nonIterableSpread.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

module.exports = _nonIterableSpread;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/slicedToArray.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithHoles = __webpack_require__(/*! ./arrayWithHoles */ "./node_modules/@babel/runtime/helpers/arrayWithHoles.js");

var iterableToArrayLimit = __webpack_require__(/*! ./iterableToArrayLimit */ "./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableRest = __webpack_require__(/*! ./nonIterableRest */ "./node_modules/@babel/runtime/helpers/nonIterableRest.js");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toConsumableArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toConsumableArray.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(/*! ./arrayWithoutHoles */ "./node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");

var iterableToArray = __webpack_require__(/*! ./iterableToArray */ "./node_modules/@babel/runtime/helpers/iterableToArray.js");

var unsupportedIterableToArray = __webpack_require__(/*! ./unsupportedIterableToArray */ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");

var nonIterableSpread = __webpack_require__(/*! ./nonIterableSpread */ "./node_modules/@babel/runtime/helpers/nonIterableSpread.js");

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var arrayLikeToArray = __webpack_require__(/*! ./arrayLikeToArray */ "./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

module.exports = _unsupportedIterableToArray;

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "./node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");
var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");
var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");
var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");
var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");
var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */
module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };
  return error;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = [
    'baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer',
    'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
    'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress',
    'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent',
    'httpsAgent', 'cancelToken', 'socketPath'
  ];

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });

  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  var axiosKeys = valueFromConfig2Keys
    .concat(mergeDeepPropertiesKeys)
    .concat(defaultToConfig2Keys);

  var otherKeys = Object
    .keys(config2)
    .filter(function filterAxiosKeys(key) {
      return axiosKeys.indexOf(key) === -1;
    });

  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });

  return config;
};


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError(
      'Request failed with status code ' + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};


/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) { /* Ignore */ }
    }
    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).
    replace(/%40/gi, '@').
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return (typeof FormData !== 'undefined') && (val instanceof FormData);
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function deepMerge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};


/***/ }),

/***/ "./node_modules/clsx/dist/clsx.m.js":
/*!******************************************!*\
  !*** ./node_modules/clsx/dist/clsx.m.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
function toVal(mix) {
	var k, y, str='';

	if (typeof mix === 'string' || typeof mix === 'number') {
		str += mix;
	} else if (typeof mix === 'object') {
		if (Array.isArray(mix)) {
			for (k=0; k < mix.length; k++) {
				if (mix[k]) {
					if (y = toVal(mix[k])) {
						str && (str += ' ');
						str += y;
					}
				}
			}
		} else {
			for (k in mix) {
				if (mix[k]) {
					str && (str += ' ');
					str += k;
				}
			}
		}
	}

	return str;
}

/* harmony default export */ __webpack_exports__["default"] = (function () {
	var i=0, tmp, x, str='';
	while (i < arguments.length) {
		if (tmp = arguments[i++]) {
			if (x = toVal(tmp)) {
				str && (str += ' ');
				str += x
			}
		}
	}
	return str;
});


/***/ }),

/***/ "./node_modules/dom-helpers/esm/addClass.js":
/*!**************************************************!*\
  !*** ./node_modules/dom-helpers/esm/addClass.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return addClass; });
/* harmony import */ var _hasClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./hasClass */ "./node_modules/dom-helpers/esm/hasClass.js");

/**
 * Adds a CSS class to a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */

function addClass(element, className) {
  if (element.classList) element.classList.add(className);else if (!Object(_hasClass__WEBPACK_IMPORTED_MODULE_0__["default"])(element, className)) if (typeof element.className === 'string') element.className = element.className + " " + className;else element.setAttribute('class', (element.className && element.className.baseVal || '') + " " + className);
}

/***/ }),

/***/ "./node_modules/dom-helpers/esm/hasClass.js":
/*!**************************************************!*\
  !*** ./node_modules/dom-helpers/esm/hasClass.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return hasClass; });
/**
 * Checks if a given element has a CSS class.
 * 
 * @param element the element
 * @param className the CSS class name
 */
function hasClass(element, className) {
  if (element.classList) return !!className && element.classList.contains(className);
  return (" " + (element.className.baseVal || element.className) + " ").indexOf(" " + className + " ") !== -1;
}

/***/ }),

/***/ "./node_modules/dom-helpers/esm/removeClass.js":
/*!*****************************************************!*\
  !*** ./node_modules/dom-helpers/esm/removeClass.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return removeClass; });
function replaceClassName(origClass, classToRemove) {
  return origClass.replace(new RegExp("(^|\\s)" + classToRemove + "(?:\\s|$)", 'g'), '$1').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');
}
/**
 * Removes a CSS class from a given element.
 * 
 * @param element the element
 * @param className the CSS class name
 */


function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else if (typeof element.className === 'string') {
    element.className = replaceClassName(element.className, className);
  } else {
    element.setAttribute('class', replaceClassName(element.className && element.className.baseVal || '', className));
  }
}

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),

/***/ "./node_modules/native-url/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/native-url/dist/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var e,t=(e=__webpack_require__(/*! querystring */ "./node_modules/querystring-es3/index.js"))&&"object"==typeof e&&"default"in e?e.default:e,r=/https?|ftp|gopher|file/;function o(e){"string"==typeof e&&(e=g(e));var o=function(e,t,r){var o=e.auth,a=e.hostname,s=e.protocol||"",c=e.pathname||"",h=e.hash||"",p=e.query||"",n=!1;o=o?encodeURIComponent(o).replace(/%3A/i,":")+"@":"",e.host?n=o+e.host:a&&(n=o+(~a.indexOf(":")?"["+a+"]":a),e.port&&(n+=":"+e.port)),p&&"object"==typeof p&&(p=t.encode(p));var l=e.search||p&&"?"+p||"";return s&&":"!==s.substr(-1)&&(s+=":"),e.slashes||(!s||r.test(s))&&!1!==n?(n="//"+(n||""),c&&"/"!==c[0]&&(c="/"+c)):n||(n=""),h&&"#"!==h[0]&&(h="#"+h),l&&"?"!==l[0]&&(l="?"+l),{protocol:s,host:n,pathname:c=c.replace(/[?#]/g,encodeURIComponent),search:l=l.replace("#","%23"),hash:h}}(e,t,r);return""+o.protocol+o.host+o.pathname+o.search+o.hash}var a="http://",s="w.w",c=a+s,h=/^([a-z0-9.+-]*:\/\/\/)([a-z0-9.+-]:\/*)?/i,p=/https?|ftp|gopher|file/;function n(e,t){var r="string"==typeof e?g(e):e;e="object"==typeof e?o(e):e;var s=g(t),n="";r.protocol&&!r.slashes&&(n=r.protocol,e=e.replace(r.protocol,""),n+="/"===t[0]||"/"===e[0]?"/":""),n&&s.protocol&&(n="",s.slashes||(n=s.protocol,t=t.replace(s.protocol,"")));var l=e.match(h);l&&!s.protocol&&(e=e.substr((n=l[1]+(l[2]||"")).length),/^\/\/[^/]/.test(t)&&(n=n.slice(0,-1)));var i=new URL(e,c+"/"),f=new URL(t,i).toString().replace(c,""),u=s.protocol||r.protocol;return u+=r.slashes||s.slashes?"//":"",!n&&u?f=f.replace(a,u):n&&(f=f.replace(a,"")),p.test(f)||~t.indexOf(".")||"/"===e.slice(-1)||"/"===t.slice(-1)||"/"!==f.slice(-1)||(f=f.slice(0,-1)),n&&(f=n+("/"===f[0]?f.substr(1):f)),f}function l(){}l.parse=g,l.format=o,l.resolve=n,l.resolveObject=n;var i=/^https?|ftp|gopher|file/,f=/^(.*?)([#?].*)/,u=/^([a-z0-9.+-]*:)(\/{0,3})(.*)/i,m=/^([a-z0-9.+-]*:)?\/\/\/*/i,v=/^([a-z0-9.+-]*:)(\/{0,2})\[(.*)\]$/i;function d(e){try{return decodeURI(e)}catch(t){return e}}function g(e,r,a){if(void 0===r&&(r=!1),void 0===a&&(a=!1),e&&"object"==typeof e&&e instanceof l)return e;var h=(e=e.trim()).match(f);e=h?d(h[1]).replace(/\\/g,"/")+h[2]:d(e).replace(/\\/g,"/"),v.test(e)&&"/"!==e.slice(-1)&&(e+="/");var p=!/(^javascript)/.test(e)&&e.match(u),n=m.test(e),g="";p&&(i.test(p[1])||(g=p[1].toLowerCase(),e=""+p[2]+p[3]),p[2]||(n=!1,i.test(p[1])?(g=p[1],e=""+p[3]):e="//"+p[3]),3!==p[2].length&&1!==p[2].length||(g=p[1],e="/"+p[3]));var b,y=(h?h[1]:e).match(/(:[0-9]+)/),j="";y&&y[1]&&3===y[1].length&&(e=e.replace(j=y[1],j+"00"));var w=new l,x="",U="";try{b=new URL(e)}catch(t){x=t,g||a||!/^\/\//.test(e)||/^\/\/.+[@.]/.test(e)||(U="/",e=e.substr(1));try{b=new URL(e,c)}catch(e){return w.protocol=g,w.href=g,w}}w.slashes=n&&!U,w.host=b.host===s?"":b.host,w.hostname=b.hostname===s?"":b.hostname.replace(/(\[|\])/g,""),w.protocol=x?g||null:b.protocol,w.search=b.search.replace(/\\/g,"%5C"),w.hash=b.hash.replace(/\\/g,"%5C");var R=e.split("#");!w.search&&~R[0].indexOf("?")&&(w.search="?"),w.hash||""!==R[1]||(w.hash="#"),w.query=r?t.decode(b.search.substr(1)):w.search.substr(1),w.pathname=U+d(b.pathname).replace(/"/g,"%22"),"about:"===w.protocol&&"blank"===w.pathname&&(w.protocol="",w.pathname=""),x&&"/"!==e[0]&&(w.pathname=w.pathname.substr(1)),g&&!i.test(g)&&"/"!==e.slice(-1)&&"/"===w.pathname&&(w.pathname=""),w.path=w.pathname+w.search,w.auth=[b.username,b.password].map(decodeURIComponent).filter(Boolean).join(":"),w.port=b.port,j&&(w.host=w.host.replace(j+"00",j),w.port=w.port.slice(0,-2)),w.href=U?""+w.pathname+w.search+w.hash:o(w);var O=/^(file)/.test(w.href)?["host","hostname"]:[];return Object.keys(w).forEach(function(e){~O.indexOf(e)||(w[e]=w[e]||null)}),w}exports.parse=g,exports.format=o,exports.resolve=n,exports.resolveObject=function(e,t){return g(n(e,t))},exports.Url=l;
//# sourceMappingURL=index.js.map


/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object-assign.js":
/*!***********************************************************************************************************************!*\
  !*** delegated ./node_modules/next/dist/build/polyfills/object-assign.js from dll-reference dll_5030f387d328e4415785 ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_5030f387d328e4415785 */ "dll-reference dll_5030f387d328e4415785"))("./node_modules/next/dist/build/polyfills/object-assign.js");

/***/ }),

/***/ "./node_modules/next/dist/build/polyfills/object.assign/index.js":
/*!***********************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object.assign/index.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var assign=Object.assign.bind(Object);function g(){return assign;}Object.defineProperties(g(),{implementation:{get:g},shim:{value:g},getPolyfill:{value:g}});module.exports=g();
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CSkripsi%5Cmicro%20services%5CFRONTEND%5Cfrontpage%5Csrc%5Cpages%5Cindex.js!./":
/*!**********************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CSkripsi%5Cmicro%20services%5CFRONTEND%5Cfrontpage%5Csrc%5Cpages%5Cindex.js ***!
  \**********************************************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


    (window.__NEXT_P = window.__NEXT_P || []).push([
      "/",
      function () {
        return __webpack_require__(/*! ./src/pages/index.js */ "./src/pages/index.js");
      }
    ]);
  

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

exports.__esModule = true;
exports["default"] = void 0;

var _react = _interopRequireWildcard(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _utils = __webpack_require__(/*! ../next-server/lib/utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _router = _interopRequireDefault(__webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js"));

var _router2 = __webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js");

function isLocal(href) {
  var url = (0, _url.parse)(href, false, true);
  var origin = (0, _url.parse)((0, _utils.getLocationOrigin)(), false, true);
  return !url.host || url.protocol === origin.protocol && url.host === origin.host;
}

function memoizedFormatUrl(formatFunc) {
  var lastHref = null;
  var lastAs = null;
  var lastResult = null;
  return function (href, as) {
    if (lastResult && href === lastHref && as === lastAs) {
      return lastResult;
    }

    var result = formatFunc(href, as);
    lastHref = href;
    lastAs = as;
    lastResult = result;
    return result;
  };
}

function formatUrl(url) {
  return url && typeof url === 'object' ? (0, _utils.formatWithValidation)(url) : url;
}

var observer;
var listeners = new Map();
var IntersectionObserver = true ? window.IntersectionObserver : undefined;
var prefetched = {};

function getObserver() {
  // Return shared instance of IntersectionObserver if already created
  if (observer) {
    return observer;
  } // Only create shared IntersectionObserver if supported in browser


  if (!IntersectionObserver) {
    return undefined;
  }

  return observer = new IntersectionObserver(function (entries) {
    entries.forEach(function (entry) {
      if (!listeners.has(entry.target)) {
        return;
      }

      var cb = listeners.get(entry.target);

      if (entry.isIntersecting || entry.intersectionRatio > 0) {
        observer.unobserve(entry.target);
        listeners["delete"](entry.target);
        cb();
      }
    });
  }, {
    rootMargin: '200px'
  });
}

var listenToIntersections = function listenToIntersections(el, cb) {
  var observer = getObserver();

  if (!observer) {
    return function () {};
  }

  observer.observe(el);
  listeners.set(el, cb);
  return function () {
    try {
      observer.unobserve(el);
    } catch (err) {
      console.error(err);
    }

    listeners["delete"](el);
  };
};

var Link = /*#__PURE__*/function (_react$Component) {
  _inherits(Link, _react$Component);

  var _super = _createSuper(Link);

  function Link(props) {
    var _this;

    _classCallCheck(this, Link);

    _this = _super.call(this, props);
    _this.p = void 0;

    _this.cleanUpListeners = function () {};

    _this.formatUrls = memoizedFormatUrl(function (href, asHref) {
      return {
        href: (0, _router2.addBasePath)(formatUrl(href)),
        as: asHref ? (0, _router2.addBasePath)(formatUrl(asHref)) : asHref
      };
    });

    _this.linkClicked = function (e) {
      var _e$currentTarget = e.currentTarget,
          nodeName = _e$currentTarget.nodeName,
          target = _e$currentTarget.target;

      if (nodeName === 'A' && (target && target !== '_self' || e.metaKey || e.ctrlKey || e.shiftKey || e.nativeEvent && e.nativeEvent.which === 2)) {
        // ignore click for new tab / new window behavior
        return;
      }

      var _this$formatUrls = _this.formatUrls(_this.props.href, _this.props.as),
          href = _this$formatUrls.href,
          as = _this$formatUrls.as;

      if (!isLocal(href)) {
        // ignore click if it's outside our scope (e.g. https://google.com)
        return;
      }

      var pathname = window.location.pathname;
      href = (0, _url.resolve)(pathname, href);
      as = as ? (0, _url.resolve)(pathname, as) : href;
      e.preventDefault(); //  avoid scroll for urls with anchor refs

      var scroll = _this.props.scroll;

      if (scroll == null) {
        scroll = as.indexOf('#') < 0;
      } // replace state instead of push if prop is present


      _router["default"][_this.props.replace ? 'replace' : 'push'](href, as, {
        shallow: _this.props.shallow
      }).then(function (success) {
        if (!success) return;

        if (scroll) {
          window.scrollTo(0, 0);
          document.body.focus();
        }
      });
    };

    if (true) {
      if (props.prefetch) {
        console.warn('Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://err.sh/vercel/next.js/prefetch-true-deprecated');
      }
    }

    _this.p = props.prefetch !== false;
    return _this;
  }

  _createClass(Link, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.cleanUpListeners();
    }
  }, {
    key: "getPaths",
    value: function getPaths() {
      var pathname = window.location.pathname;

      var _this$formatUrls2 = this.formatUrls(this.props.href, this.props.as),
          parsedHref = _this$formatUrls2.href,
          parsedAs = _this$formatUrls2.as;

      var resolvedHref = (0, _url.resolve)(pathname, parsedHref);
      return [resolvedHref, parsedAs ? (0, _url.resolve)(pathname, parsedAs) : resolvedHref];
    }
  }, {
    key: "handleRef",
    value: function handleRef(ref) {
      var _this2 = this;

      if (this.p && IntersectionObserver && ref && ref.tagName) {
        this.cleanUpListeners();
        var isPrefetched = prefetched[this.getPaths().join( // Join on an invalid URI character
        '%')];

        if (!isPrefetched) {
          this.cleanUpListeners = listenToIntersections(ref, function () {
            _this2.prefetch();
          });
        }
      }
    } // The function is memoized so that no extra lifecycles are needed
    // as per https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html

  }, {
    key: "prefetch",
    value: function prefetch(options) {
      if (!this.p || false) return; // Prefetch the JSON page if asked (only in the client)

      var paths = this.getPaths(); // We need to handle a prefetch error here since we may be
      // loading with priority which can reject but we don't
      // want to force navigation since this is only a prefetch

      _router["default"].prefetch(paths[
      /* href */
      0], paths[
      /* asPath */
      1], options)["catch"](function (err) {
        if (true) {
          // rethrow to show invalid URL errors
          throw err;
        }
      });

      prefetched[paths.join( // Join on an invalid URI character
      '%')] = true;
    }
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;

      var children = this.props.children;

      var _this$formatUrls3 = this.formatUrls(this.props.href, this.props.as),
          href = _this$formatUrls3.href,
          as = _this$formatUrls3.as; // Deprecated. Warning shown by propType check. If the children provided is a string (<Link>example</Link>) we wrap it in an <a> tag


      if (typeof children === 'string') {
        children = /*#__PURE__*/_react["default"].createElement("a", null, children);
      } // This will return the first child, if multiple are provided it will throw an error


      var child = _react.Children.only(children);

      var props = {
        ref: function ref(el) {
          _this3.handleRef(el);

          if (child && typeof child === 'object' && child.ref) {
            if (typeof child.ref === 'function') child.ref(el);else if (typeof child.ref === 'object') {
              child.ref.current = el;
            }
          }
        },
        onMouseEnter: function onMouseEnter(e) {
          if (child.props && typeof child.props.onMouseEnter === 'function') {
            child.props.onMouseEnter(e);
          }

          _this3.prefetch({
            priority: true
          });
        },
        onClick: function onClick(e) {
          if (child.props && typeof child.props.onClick === 'function') {
            child.props.onClick(e);
          }

          if (!e.defaultPrevented) {
            _this3.linkClicked(e);
          }
        }
      }; // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is
      // defined, we specify the current 'href', so that repetition is not needed by the user

      if (this.props.passHref || child.type === 'a' && !('href' in child.props)) {
        props.href = as || href;
      } // Add the ending slash to the paths. So, we can serve the
      // "<page>/index.html" directly.


      if (false) { var rewriteUrlForNextExport; }

      return _react["default"].cloneElement(child, props);
    }
  }]);

  return Link;
}(_react.Component);

if (true) {
  var warn = (0, _utils.execOnce)(console.error); // This module gets removed by webpack.IgnorePlugin

  var PropTypes = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");

  var exact = __webpack_require__(/*! prop-types-exact */ "./node_modules/prop-types-exact/build/index.js"); // @ts-ignore the property is supported, when declaring it on the class it outputs an extra bit of code which is not needed.


  Link.propTypes = exact({
    href: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired,
    as: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    prefetch: PropTypes.bool,
    replace: PropTypes.bool,
    shallow: PropTypes.bool,
    passHref: PropTypes.bool,
    scroll: PropTypes.bool,
    children: PropTypes.oneOfType([PropTypes.element, function (props, propName) {
      var value = props[propName];

      if (typeof value === 'string') {
        warn("Warning: You're using a string directly inside <Link>. This usage has been deprecated. Please add an <a> tag as child of <Link>");
      }

      return null;
    }]).isRequired
  });
}

var _default = Link;
exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/router.js":
/*!*************************************************!*\
  !*** ./node_modules/next/dist/client/router.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _construct = __webpack_require__(/*! @babel/runtime/helpers/construct */ "./node_modules/@babel/runtime/helpers/construct.js");

var _s = $RefreshSig$();

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var _interopRequireWildcard = __webpack_require__(/*! @babel/runtime/helpers/interopRequireWildcard */ "./node_modules/@babel/runtime/helpers/interopRequireWildcard.js");

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports.useRouter = useRouter;
exports.makePublicRouterInstance = makePublicRouterInstance;
exports.createRouter = exports.withRouter = exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router2 = _interopRequireWildcard(__webpack_require__(/*! ../next-server/lib/router/router */ "./node_modules/next/dist/next-server/lib/router/router.js"));

exports.Router = _router2["default"];
exports.NextRouter = _router2.NextRouter;

var _routerContext = __webpack_require__(/*! ../next-server/lib/router-context */ "./node_modules/next/dist/next-server/lib/router-context.js");

var _withRouter = _interopRequireDefault(__webpack_require__(/*! ./with-router */ "./node_modules/next/dist/client/with-router.js"));

exports.withRouter = _withRouter["default"];
/* global window */

var singletonRouter = {
  router: null,
  // holds the actual router instance
  readyCallbacks: [],
  ready: function ready(cb) {
    if (this.router) return cb();

    if (true) {
      this.readyCallbacks.push(cb);
    }
  }
}; // Create public properties and methods of the router in the singletonRouter

var urlPropertyFields = ['pathname', 'route', 'query', 'asPath', 'components', 'isFallback', 'basePath'];
var routerEvents = ['routeChangeStart', 'beforeHistoryChange', 'routeChangeComplete', 'routeChangeError', 'hashChangeStart', 'hashChangeComplete'];
var coreMethodFields = ['push', 'replace', 'reload', 'back', 'prefetch', 'beforePopState']; // Events is a static property on the router, the router doesn't have to be initialized to use it

Object.defineProperty(singletonRouter, 'events', {
  get: function get() {
    return _router2["default"].events;
  }
});
urlPropertyFields.forEach(function (field) {
  // Here we need to use Object.defineProperty because, we need to return
  // the property assigned to the actual router
  // The value might get changed as we change routes and this is the
  // proper way to access it
  Object.defineProperty(singletonRouter, field, {
    get: function get() {
      var router = getRouter();
      return router[field];
    }
  });
});
coreMethodFields.forEach(function (field) {
  // We don't really know the types here, so we add them later instead
  ;

  singletonRouter[field] = function () {
    var router = getRouter();
    return router[field].apply(router, arguments);
  };
});
routerEvents.forEach(function (event) {
  singletonRouter.ready(function () {
    _router2["default"].events.on(event, function () {
      var eventField = "on".concat(event.charAt(0).toUpperCase()).concat(event.substring(1));
      var _singletonRouter = singletonRouter;

      if (_singletonRouter[eventField]) {
        try {
          _singletonRouter[eventField].apply(_singletonRouter, arguments);
        } catch (err) {
          // tslint:disable-next-line:no-console
          console.error("Error when running the Router event: ".concat(eventField)); // tslint:disable-next-line:no-console

          console.error("".concat(err.message, "\n").concat(err.stack));
        }
      }
    });
  });
});

function getRouter() {
  if (!singletonRouter.router) {
    var message = 'No router instance found.\n' + 'You should only use "next/router" inside the client side of your app.\n';
    throw new Error(message);
  }

  return singletonRouter.router;
} // Export the singletonRouter and this is the public API.


var _default = singletonRouter; // Reexport the withRoute HOC

exports["default"] = _default;

function useRouter() {
  _s();

  return _react["default"].useContext(_routerContext.RouterContext);
} // INTERNAL APIS
// -------------
// (do not use following exports inside the app)
// Create a router and assign it as the singleton instance.
// This is used in client side when we are initilizing the app.
// This should **not** use inside the server.


_s(useRouter, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

var createRouter = function createRouter() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  singletonRouter.router = _construct(_router2["default"], args);
  singletonRouter.readyCallbacks.forEach(function (cb) {
    return cb();
  });
  singletonRouter.readyCallbacks = [];
  return singletonRouter.router;
}; // This function is used to create the `withRouter` router instance


exports.createRouter = createRouter;

function makePublicRouterInstance(router) {
  var _router = router;
  var instance = {};

  var _iterator = _createForOfIteratorHelper(urlPropertyFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var property = _step.value;

      if (typeof _router[property] === 'object') {
        instance[property] = Object.assign({}, _router[property]); // makes sure query is not stateful

        continue;
      }

      instance[property] = _router[property];
    } // Events is a static property on the router, the router doesn't have to be initialized to use it

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  instance.events = _router2["default"].events;
  coreMethodFields.forEach(function (field) {
    instance[field] = function () {
      return _router[field].apply(_router, arguments);
    };
  });
  return instance;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/client/with-router.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/client/with-router.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js");

exports.__esModule = true;
exports["default"] = withRouter;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _router = __webpack_require__(/*! ./router */ "./node_modules/next/dist/client/router.js");

function withRouter(ComposedComponent) {
  function WithRouterWrapper(props) {
    return /*#__PURE__*/_react["default"].createElement(ComposedComponent, Object.assign({
      router: (0, _router.useRouter)()
    }, props));
  }

  WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps // This is needed to allow checking for custom getInitialProps in _app
  ;
  WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;

  if (true) {
    var name = ComposedComponent.displayName || ComposedComponent.name || 'Unknown';
    WithRouterWrapper.displayName = "withRouter(".concat(name, ")");
  }

  return WithRouterWrapper;
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp-context.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp-context.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.AmpStateContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var AmpStateContext = _react["default"].createContext({});

exports.AmpStateContext = AmpStateContext;

if (true) {
  AmpStateContext.displayName = 'AmpStateContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/amp.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/amp.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _s = $RefreshSig$();

exports.__esModule = true;
exports.isInAmpMode = isInAmpMode;
exports.useAmp = useAmp;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function isInAmpMode() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ampFirst = _ref.ampFirst,
      ampFirst = _ref$ampFirst === void 0 ? false : _ref$ampFirst,
      _ref$hybrid = _ref.hybrid,
      hybrid = _ref$hybrid === void 0 ? false : _ref$hybrid,
      _ref$hasQuery = _ref.hasQuery,
      hasQuery = _ref$hasQuery === void 0 ? false : _ref$hasQuery;

  return ampFirst || hybrid && hasQuery;
}

function useAmp() {
  _s();

  // Don't assign the context value to a variable to save bytes
  return isInAmpMode(_react["default"].useContext(_ampContext.AmpStateContext));
}

_s(useAmp, "gDsCjeeItUuvgOWf1v4qoK9RF6k=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head-manager-context.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head-manager-context.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.HeadManagerContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var HeadManagerContext = _react["default"].createContext(null);

exports.HeadManagerContext = HeadManagerContext;

if (true) {
  HeadManagerContext.displayName = 'HeadManagerContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/head.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/head.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.defaultHead = defaultHead;
exports["default"] = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

var _sideEffect = _interopRequireDefault(__webpack_require__(/*! ./side-effect */ "./node_modules/next/dist/next-server/lib/side-effect.js"));

var _ampContext = __webpack_require__(/*! ./amp-context */ "./node_modules/next/dist/next-server/lib/amp-context.js");

var _headManagerContext = __webpack_require__(/*! ./head-manager-context */ "./node_modules/next/dist/next-server/lib/head-manager-context.js");

var _amp = __webpack_require__(/*! ./amp */ "./node_modules/next/dist/next-server/lib/amp.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function defaultHead() {
  var inAmpMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
  var head = [/*#__PURE__*/_react["default"].createElement("meta", {
    charSet: "utf-8"
  })];

  if (!inAmpMode) {
    head.push( /*#__PURE__*/_react["default"].createElement("meta", {
      name: "viewport",
      content: "width=device-width"
    }));
  }

  return head;
}

function onlyReactElement(list, child) {
  // React children can be "string" or "number" in this case we ignore them for backwards compat
  if (typeof child === 'string' || typeof child === 'number') {
    return list;
  } // Adds support for React.Fragment


  if (child.type === _react["default"].Fragment) {
    return list.concat(_react["default"].Children.toArray(child.props.children).reduce(function (fragmentList, fragmentChild) {
      if (typeof fragmentChild === 'string' || typeof fragmentChild === 'number') {
        return fragmentList;
      }

      return fragmentList.concat(fragmentChild);
    }, []));
  }

  return list.concat(child);
}

var METATYPES = ['name', 'httpEquiv', 'charSet', 'itemProp'];
/*
returns a function for filtering head child elements
which shouldn't be duplicated, like <title/>
Also adds support for deduplicated `key` properties
*/

function unique() {
  var keys = new Set();
  var tags = new Set();
  var metaTypes = new Set();
  var metaCategories = {};
  return function (h) {
    var unique = true;

    if (h.key && typeof h.key !== 'number' && h.key.indexOf('$') > 0) {
      var key = h.key.slice(h.key.indexOf('$') + 1);

      if (keys.has(key)) {
        unique = false;
      } else {
        keys.add(key);
      }
    } // eslint-disable-next-line default-case


    switch (h.type) {
      case 'title':
      case 'base':
        if (tags.has(h.type)) {
          unique = false;
        } else {
          tags.add(h.type);
        }

        break;

      case 'meta':
        for (var i = 0, len = METATYPES.length; i < len; i++) {
          var metatype = METATYPES[i];
          if (!h.props.hasOwnProperty(metatype)) continue;

          if (metatype === 'charSet') {
            if (metaTypes.has(metatype)) {
              unique = false;
            } else {
              metaTypes.add(metatype);
            }
          } else {
            var category = h.props[metatype];
            var categories = metaCategories[metatype] || new Set();

            if (categories.has(category)) {
              unique = false;
            } else {
              categories.add(category);
              metaCategories[metatype] = categories;
            }
          }
        }

        break;
    }

    return unique;
  };
}
/**
*
* @param headElements List of multiple <Head> instances
*/


function reduceComponents(headElements, props) {
  return headElements.reduce(function (list, headElement) {
    var headElementChildren = _react["default"].Children.toArray(headElement.props.children);

    return list.concat(headElementChildren);
  }, []).reduce(onlyReactElement, []).reverse().concat(defaultHead(props.inAmpMode)).filter(unique()).reverse().map(function (c, i) {
    var key = c.key || i;
    return _react["default"].cloneElement(c, {
      key: key
    });
  });
}

var Effect = (0, _sideEffect["default"])();
/**
* This component injects elements to `<head>` of your page.
* To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.
*/

function Head(_ref) {
  var children = _ref.children;
  return /*#__PURE__*/_react["default"].createElement(_ampContext.AmpStateContext.Consumer, null, function (ampState) {
    return /*#__PURE__*/_react["default"].createElement(_headManagerContext.HeadManagerContext.Consumer, null, function (updateHead) {
      return /*#__PURE__*/_react["default"].createElement(Effect, {
        reduceComponentsToState: reduceComponents,
        handleStateChange: updateHead,
        inAmpMode: (0, _amp.isInAmpMode)(ampState)
      }, children);
    });
  });
}

_c = Head;
Head.rewind = Effect.rewind;
var _default = Head;
exports["default"] = _default;

var _c;

$RefreshReg$(_c, "Head");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/mitt.js":
/*!********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/mitt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports["default"] = mitt;
/*
MIT License
Copyright (c) Jason Miller (https://jasonformat.com/)
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
// This file is based on https://github.com/developit/mitt/blob/v1.1.3/src/index.js
// It's been edited for the needs of this script
// See the LICENSE at the top of the file

function mitt() {
  var all = Object.create(null);
  return {
    on: function on(type, handler) {
      ;
      (all[type] || (all[type] = [])).push(handler);
    },
    off: function off(type, handler) {
      if (all[type]) {
        // tslint:disable-next-line:no-bitwise
        all[type].splice(all[type].indexOf(handler) >>> 0, 1);
      }
    },
    emit: function emit(type) {
      for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        evts[_key - 1] = arguments[_key];
      }

      // eslint-disable-next-line array-callback-return
      ;
      (all[type] || []).slice().map(function (handler) {
        handler.apply(void 0, evts);
      });
    }
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router-context.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router-context.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.RouterContext = void 0;

var _react = _interopRequireDefault(__webpack_require__(/*! react */ "./node_modules/react/index.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

var RouterContext = _react["default"].createContext(null);

exports.RouterContext = RouterContext;

if (true) {
  RouterContext.displayName = 'RouterContext';
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/router.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/router.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

var _slicedToArray = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ "./node_modules/@babel/runtime/helpers/slicedToArray.js");

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

exports.__esModule = true;
exports.addBasePath = addBasePath;
exports.delBasePath = delBasePath;
exports["default"] = void 0;

var _url2 = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");

var _mitt = _interopRequireDefault(__webpack_require__(/*! ../mitt */ "./node_modules/next/dist/next-server/lib/mitt.js"));

var _utils = __webpack_require__(/*! ../utils */ "./node_modules/next/dist/next-server/lib/utils.js");

var _isDynamic = __webpack_require__(/*! ./utils/is-dynamic */ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js");

var _routeMatcher = __webpack_require__(/*! ./utils/route-matcher */ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js");

var _routeRegex = __webpack_require__(/*! ./utils/route-regex */ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js");

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
/* global __NEXT_DATA__ */
// tslint:disable:no-console


var basePath =  false || '';

function addBasePath(path) {
  return path.indexOf(basePath) !== 0 ? basePath + path : path;
}

function delBasePath(path) {
  return path.indexOf(basePath) === 0 ? path.substr(basePath.length) || '/' : path;
}

function toRoute(path) {
  return path.replace(/\/$/, '') || '/';
}

var prepareRoute = function prepareRoute(path) {
  return toRoute(!path || path === '/' ? '/index' : path);
};

function fetchNextData(pathname, query, isServerRender, cb) {
  var attempts = isServerRender ? 3 : 1;

  function getResponse() {
    return fetch((0, _utils.formatWithValidation)({
      pathname: addBasePath( // @ts-ignore __NEXT_DATA__
      "/_next/data/".concat(__NEXT_DATA__.buildId).concat(delBasePath(pathname), ".json")),
      query: query
    }), {
      // Cookies are required to be present for Next.js' SSG "Preview Mode".
      // Cookies may also be required for `getServerSideProps`.
      //
      // > `fetch` won’t send cookies, unless you set the credentials init
      // > option.
      // https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
      //
      // > For maximum browser compatibility when it comes to sending &
      // > receiving cookies, always supply the `credentials: 'same-origin'`
      // > option instead of relying on the default.
      // https://github.com/github/fetch#caveats
      credentials: 'same-origin'
    }).then(function (res) {
      if (!res.ok) {
        if (--attempts > 0 && res.status >= 500) {
          return getResponse();
        }

        throw new Error("Failed to load static props");
      }

      return res.json();
    });
  }

  return getResponse().then(function (data) {
    return cb ? cb(data) : data;
  })["catch"](function (err) {
    // We should only trigger a server-side transition if this was caused
    // on a client-side transition. Otherwise, we'd get into an infinite
    // loop.
    if (!isServerRender) {
      ;
      err.code = 'PAGE_LOAD_ERROR';
    }

    throw err;
  });
}

var Router = /*#__PURE__*/function () {
  /**
  * Map of all components loaded in `Router`
  */
  // Static Data Cache
  function Router(_pathname, _query, _as2, _ref) {
    var _this = this;

    var initialProps = _ref.initialProps,
        pageLoader = _ref.pageLoader,
        App = _ref.App,
        wrapApp = _ref.wrapApp,
        Component = _ref.Component,
        err = _ref.err,
        subscription = _ref.subscription,
        isFallback = _ref.isFallback;

    _classCallCheck(this, Router);

    this.route = void 0;
    this.pathname = void 0;
    this.query = void 0;
    this.asPath = void 0;
    this.basePath = void 0;
    this.components = void 0;
    this.sdc = {};
    this.sub = void 0;
    this.clc = void 0;
    this.pageLoader = void 0;
    this._bps = void 0;
    this.events = void 0;
    this._wrapApp = void 0;
    this.isSsr = void 0;
    this.isFallback = void 0;

    this.onPopState = function (e) {
      if (!e.state) {
        // We get state as undefined for two reasons.
        //  1. With older safari (< 8) and older chrome (< 34)
        //  2. When the URL changed with #
        //
        // In the both cases, we don't need to proceed and change the route.
        // (as it's already changed)
        // But we can simply replace the state with the new changes.
        // Actually, for (1) we don't need to nothing. But it's hard to detect that event.
        // So, doing the following for (1) does no harm.
        var pathname = _this.pathname,
            query = _this.query;

        _this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: pathname,
          query: query
        }), (0, _utils.getURL)());

        return;
      } // Make sure we don't re-render on initial load,
      // can be caused by navigating back from an external site


      if (e.state && _this.isSsr && e.state.as === _this.asPath && (0, _url2.parse)(e.state.url).pathname === _this.pathname) {
        return;
      } // If the downstream application returns falsy, return.
      // They will then be responsible for handling the event.


      if (_this._bps && !_this._bps(e.state)) {
        return;
      }

      var _e$state = e.state,
          url = _e$state.url,
          as = _e$state.as,
          options = _e$state.options;

      if (true) {
        if (typeof url === 'undefined' || typeof as === 'undefined') {
          console.warn('`popstate` event triggered but `event.state` did not have `url` or `as` https://err.sh/vercel/next.js/popstate-state-empty');
        }
      }

      _this.replace(url, as, options);
    };

    this._getStaticData = function (asPath) {
      var pathname = prepareRoute((0, _url2.parse)(asPath).pathname);
      return  false ? undefined : fetchNextData(pathname, null, _this.isSsr, function (data) {
        return _this.sdc[pathname] = data;
      });
    };

    this._getServerData = function (asPath) {
      var _ref2 = (0, _url2.parse)(asPath, true),
          pathname = _ref2.pathname,
          query = _ref2.query;

      pathname = prepareRoute(pathname);
      return fetchNextData(pathname, query, _this.isSsr);
    }; // represents the current component key


    this.route = toRoute(_pathname); // set up the component cache (by route keys)

    this.components = {}; // We should not keep the cache, if there's an error
    // Otherwise, this cause issues when when going back and
    // come again to the errored page.

    if (_pathname !== '/_error') {
      this.components[this.route] = {
        Component: Component,
        props: initialProps,
        err: err,
        __N_SSG: initialProps && initialProps.__N_SSG,
        __N_SSP: initialProps && initialProps.__N_SSP
      };
    }

    this.components['/_app'] = {
      Component: App
    }; // Backwards compat for Router.router.events
    // TODO: Should be remove the following major version as it was never documented

    this.events = Router.events;
    this.pageLoader = pageLoader;
    this.pathname = _pathname;
    this.query = _query; // if auto prerendered and dynamic route wait to update asPath
    // until after mount to prevent hydration mismatch

    this.asPath = // @ts-ignore this is temporarily global (attached to window)
    (0, _isDynamic.isDynamicRoute)(_pathname) && __NEXT_DATA__.autoExport ? _pathname : _as2;
    this.basePath = basePath;
    this.sub = subscription;
    this.clc = null;
    this._wrapApp = wrapApp; // make sure to ignore extra popState in safari on navigating
    // back from external site

    this.isSsr = true;
    this.isFallback = isFallback;

    if (true) {
      // make sure "as" doesn't start with double slashes or else it can
      // throw an error as it's considered invalid
      if (_as2.substr(0, 2) !== '//') {
        // in order for `e.state` to work on the `onpopstate` event
        // we have to register the initial route upon initialization
        this.changeState('replaceState', (0, _utils.formatWithValidation)({
          pathname: _pathname,
          query: _query
        }), _as2);
      }

      window.addEventListener('popstate', this.onPopState);
    }
  } // @deprecated backwards compatibility even though it's a private method.


  _createClass(Router, [{
    key: "update",
    value: function update(route, mod) {
      var Component = mod["default"] || mod;
      var data = this.components[route];

      if (!data) {
        throw new Error("Cannot update unavailable route: ".concat(route));
      }

      var newData = Object.assign({}, data, {
        Component: Component,
        __N_SSG: mod.__N_SSG,
        __N_SSP: mod.__N_SSP
      });
      this.components[route] = newData; // pages/_app.js updated

      if (route === '/_app') {
        this.notify(this.components[this.route]);
        return;
      }

      if (route === this.route) {
        this.notify(newData);
      }
    }
  }, {
    key: "reload",
    value: function reload() {
      window.location.reload();
    }
    /**
    * Go back in history
    */

  }, {
    key: "back",
    value: function back() {
      window.history.back();
    }
    /**
    * Performs a `pushState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "push",
    value: function push(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('pushState', url, as, options);
    }
    /**
    * Performs a `replaceState` with arguments
    * @param url of the route
    * @param as masks `url` for the browser
    * @param options object you can define `shallow` and other options
    */

  }, {
    key: "replace",
    value: function replace(url) {
      var as = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.change('replaceState', url, as, options);
    }
  }, {
    key: "change",
    value: function change(method, _url, _as, options) {
      var _this2 = this;

      return new Promise(function (resolve, reject) {
        if (!options._h) {
          _this2.isSsr = false;
        } // marking route changes as a navigation start entry


        if (_utils.ST) {
          performance.mark('routeChange');
        } // If url and as provided as an object representation,
        // we'll format them into the string version here.


        var url = typeof _url === 'object' ? (0, _utils.formatWithValidation)(_url) : _url;
        var as = typeof _as === 'object' ? (0, _utils.formatWithValidation)(_as) : _as;
        url = addBasePath(url);
        as = addBasePath(as); // Add the ending slash to the paths. So, we can serve the
        // "<page>/index.html" directly for the SSR page.

        if (false) { var rewriteUrlForNextExport; }

        _this2.abortComponentLoad(as); // If the url change is only related to a hash change
        // We should not proceed. We should only change the state.
        // WARNING: `_h` is an internal option for handing Next.js client-side
        // hydration. Your app should _never_ use this property. It may change at
        // any time without notice.


        if (!options._h && _this2.onlyAHashChange(as)) {
          _this2.asPath = as;
          Router.events.emit('hashChangeStart', as);

          _this2.changeState(method, url, as, options);

          _this2.scrollToHash(as);

          Router.events.emit('hashChangeComplete', as);
          return resolve(true);
        }

        var _ref3 = (0, _url2.parse)(url, true),
            pathname = _ref3.pathname,
            query = _ref3.query,
            protocol = _ref3.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return resolve(false);
        } // If asked to change the current URL we should reload the current page
        // (not location.reload() but reload getInitialProps and other Next.js stuffs)
        // We also need to set the method = replaceState always
        // as this should not go into the history (That's how browsers work)
        // We should compare the new asPath to the current asPath, not the url


        if (!_this2.urlIsNew(as)) {
          method = 'replaceState';
        }

        var route = toRoute(pathname);
        var _options$shallow = options.shallow,
            shallow = _options$shallow === void 0 ? false : _options$shallow;

        if ((0, _isDynamic.isDynamicRoute)(route)) {
          var _ref4 = (0, _url2.parse)(as),
              asPathname = _ref4.pathname;

          var routeRegex = (0, _routeRegex.getRouteRegex)(route);
          var routeMatch = (0, _routeMatcher.getRouteMatcher)(routeRegex)(asPathname);

          if (!routeMatch) {
            var missingParams = Object.keys(routeRegex.groups).filter(function (param) {
              return !query[param];
            });

            if (missingParams.length > 0) {
              if (true) {
                console.warn("Mismatching `as` and `href` failed to manually provide " + "the params: ".concat(missingParams.join(', '), " in the `href`'s `query`"));
              }

              return reject(new Error("The provided `as` value (".concat(asPathname, ") is incompatible with the `href` value (").concat(route, "). ") + "Read more: https://err.sh/vercel/next.js/incompatible-href-as"));
            }
          } else {
            // Merge params into `query`, overwriting any specified in search
            Object.assign(query, routeMatch);
          }
        }

        Router.events.emit('routeChangeStart', as); // If shallow is true and the route exists in the router cache we reuse the previous result

        _this2.getRouteInfo(route, pathname, query, as, shallow).then(function (routeInfo) {
          var error = routeInfo.error;

          if (error && error.cancelled) {
            return resolve(false);
          }

          Router.events.emit('beforeHistoryChange', as);

          _this2.changeState(method, url, as, options);

          if (true) {
            var appComp = _this2.components['/_app'].Component;
            window.next.isPrerendered = appComp.getInitialProps === appComp.origGetInitialProps && !routeInfo.Component.getInitialProps;
          }

          _this2.set(route, pathname, query, as, routeInfo).then(function () {
            if (error) {
              Router.events.emit('routeChangeError', error, as);
              throw error;
            }

            Router.events.emit('routeChangeComplete', as);
            return resolve(true);
          });
        }, reject);
      });
    }
  }, {
    key: "changeState",
    value: function changeState(method, url, as) {
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (true) {
        if (typeof window.history === 'undefined') {
          console.error("Warning: window.history is not available.");
          return;
        }

        if (typeof window.history[method] === 'undefined') {
          console.error("Warning: window.history.".concat(method, " is not available"));
          return;
        }
      }

      if (method !== 'pushState' || (0, _utils.getURL)() !== as) {
        window.history[method]({
          url: url,
          as: as,
          options: options
        }, // Most browsers currently ignores this parameter, although they may use it in the future.
        // Passing the empty string here should be safe against future changes to the method.
        // https://developer.mozilla.org/en-US/docs/Web/API/History/replaceState
        '', as);
      }
    }
  }, {
    key: "getRouteInfo",
    value: function getRouteInfo(route, pathname, query, as) {
      var _this3 = this;

      var shallow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var cachedRouteInfo = this.components[route]; // If there is a shallow route transition possible
      // If the route is already rendered on the screen.

      if (shallow && cachedRouteInfo && this.route === route) {
        return Promise.resolve(cachedRouteInfo);
      }

      var handleError = function handleError(err, loadErrorFail) {
        return new Promise(function (resolve) {
          if (err.code === 'PAGE_LOAD_ERROR' || loadErrorFail) {
            // If we can't load the page it could be one of following reasons
            //  1. Page doesn't exists
            //  2. Page does exist in a different zone
            //  3. Internal error while loading the page
            // So, doing a hard reload is the proper way to deal with this.
            window.location.href = as; // Changing the URL doesn't block executing the current code path.
            // So, we need to mark it as a cancelled error and stop the routing logic.

            err.cancelled = true; // @ts-ignore TODO: fix the control flow here

            return resolve({
              error: err
            });
          }

          if (err.cancelled) {
            // @ts-ignore TODO: fix the control flow here
            return resolve({
              error: err
            });
          }

          resolve(_this3.fetchComponent('/_error').then(function (res) {
            var Component = res.page;
            var routeInfo = {
              Component: Component,
              err: err
            };
            return new Promise(function (resolve) {
              _this3.getInitialProps(Component, {
                err: err,
                pathname: pathname,
                query: query
              }).then(function (props) {
                routeInfo.props = props;
                routeInfo.error = err;
                resolve(routeInfo);
              }, function (gipErr) {
                console.error('Error in error page `getInitialProps`: ', gipErr);
                routeInfo.error = err;
                routeInfo.props = {};
                resolve(routeInfo);
              });
            });
          })["catch"](function (err) {
            return handleError(err, true);
          }));
        });
      };

      return new Promise(function (resolve, reject) {
        if (cachedRouteInfo) {
          return resolve(cachedRouteInfo);
        }

        _this3.fetchComponent(route).then(function (res) {
          return resolve({
            Component: res.page,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          });
        }, reject);
      }).then(function (routeInfo) {
        var Component = routeInfo.Component,
            __N_SSG = routeInfo.__N_SSG,
            __N_SSP = routeInfo.__N_SSP;

        if (true) {
          var _require = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js"),
              isValidElementType = _require.isValidElementType;

          if (!isValidElementType(Component)) {
            throw new Error("The default export is not a React Component in page: \"".concat(pathname, "\""));
          }
        }

        return _this3._getData(function () {
          return __N_SSG ? _this3._getStaticData(as) : __N_SSP ? _this3._getServerData(as) : _this3.getInitialProps(Component, // we provide AppTree later so this needs to be `any`
          {
            pathname: pathname,
            query: query,
            asPath: as
          });
        }).then(function (props) {
          routeInfo.props = props;
          _this3.components[route] = routeInfo;
          return routeInfo;
        });
      })["catch"](handleError);
    }
  }, {
    key: "set",
    value: function set(route, pathname, query, as, data) {
      this.isFallback = false;
      this.route = route;
      this.pathname = pathname;
      this.query = query;
      this.asPath = as;
      return this.notify(data);
    }
    /**
    * Callback to execute before replacing router state
    * @param cb callback to be executed
    */

  }, {
    key: "beforePopState",
    value: function beforePopState(cb) {
      this._bps = cb;
    }
  }, {
    key: "onlyAHashChange",
    value: function onlyAHashChange(as) {
      if (!this.asPath) return false;

      var _this$asPath$split = this.asPath.split('#'),
          _this$asPath$split2 = _slicedToArray(_this$asPath$split, 2),
          oldUrlNoHash = _this$asPath$split2[0],
          oldHash = _this$asPath$split2[1];

      var _as$split = as.split('#'),
          _as$split2 = _slicedToArray(_as$split, 2),
          newUrlNoHash = _as$split2[0],
          newHash = _as$split2[1]; // Makes sure we scroll to the provided hash if the url/hash are the same


      if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
        return true;
      } // If the urls are change, there's more than a hash change


      if (oldUrlNoHash !== newUrlNoHash) {
        return false;
      } // If the hash has changed, then it's a hash only change.
      // This check is necessary to handle both the enter and
      // leave hash === '' cases. The identity case falls through
      // and is treated as a next reload.


      return oldHash !== newHash;
    }
  }, {
    key: "scrollToHash",
    value: function scrollToHash(as) {
      var _as$split3 = as.split('#'),
          _as$split4 = _slicedToArray(_as$split3, 2),
          hash = _as$split4[1]; // Scroll to top if the hash is just `#` with no value


      if (hash === '') {
        window.scrollTo(0, 0);
        return;
      } // First we check if the element by id is found


      var idEl = document.getElementById(hash);

      if (idEl) {
        idEl.scrollIntoView();
        return;
      } // If there's no element with the id, we check the `name` property
      // To mirror browsers


      var nameEl = document.getElementsByName(hash)[0];

      if (nameEl) {
        nameEl.scrollIntoView();
      }
    }
  }, {
    key: "urlIsNew",
    value: function urlIsNew(asPath) {
      return this.asPath !== asPath;
    }
    /**
    * Prefetch page code, you may wait for the data during page rendering.
    * This feature only works in production!
    * @param url the href of prefetched page
    * @param asPath the as path of the prefetched page
    */

  }, {
    key: "prefetch",
    value: function prefetch(url) {
      var _this4 = this;

      var asPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : url;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return new Promise(function (resolve, reject) {
        var _ref5 = (0, _url2.parse)(url),
            pathname = _ref5.pathname,
            protocol = _ref5.protocol;

        if (!pathname || protocol) {
          if (true) {
            throw new Error("Invalid href passed to router: ".concat(url, " https://err.sh/vercel/next.js/invalid-href-passed"));
          }

          return;
        } // Prefetch is not supported in development mode because it would trigger on-demand-entries


        if (true) {
          return;
        }

        var route = delBasePath(toRoute(pathname));
        Promise.all([_this4.pageLoader.prefetchData(url, delBasePath(asPath)), _this4.pageLoader[options.priority ? 'loadPage' : 'prefetch'](route)]).then(function () {
          return resolve();
        }, reject);
      });
    }
  }, {
    key: "fetchComponent",
    value: function () {
      var _fetchComponent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(route) {
        var cancelled, cancel, componentResult, error;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cancelled = false;

                cancel = this.clc = function () {
                  cancelled = true;
                };

                route = delBasePath(route);
                _context.next = 5;
                return this.pageLoader.loadPage(route);

              case 5:
                componentResult = _context.sent;

                if (!cancelled) {
                  _context.next = 10;
                  break;
                }

                error = new Error("Abort fetching component for route: \"".concat(route, "\""));
                error.cancelled = true;
                throw error;

              case 10:
                if (cancel === this.clc) {
                  this.clc = null;
                }

                return _context.abrupt("return", componentResult);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function fetchComponent(_x) {
        return _fetchComponent.apply(this, arguments);
      }

      return fetchComponent;
    }()
  }, {
    key: "_getData",
    value: function _getData(fn) {
      var _this5 = this;

      var cancelled = false;

      var cancel = function cancel() {
        cancelled = true;
      };

      this.clc = cancel;
      return fn().then(function (data) {
        if (cancel === _this5.clc) {
          _this5.clc = null;
        }

        if (cancelled) {
          var err = new Error('Loading initial props cancelled');
          err.cancelled = true;
          throw err;
        }

        return data;
      });
    }
  }, {
    key: "getInitialProps",
    value: function getInitialProps(Component, ctx) {
      var App = this.components['/_app'].Component;

      var AppTree = this._wrapApp(App);

      ctx.AppTree = AppTree;
      return (0, _utils.loadGetInitialProps)(App, {
        AppTree: AppTree,
        Component: Component,
        router: this,
        ctx: ctx
      });
    }
  }, {
    key: "abortComponentLoad",
    value: function abortComponentLoad(as) {
      if (this.clc) {
        var e = new Error('Route Cancelled');
        e.cancelled = true;
        Router.events.emit('routeChangeError', e, as);
        this.clc();
        this.clc = null;
      }
    }
  }, {
    key: "notify",
    value: function notify(data) {
      return this.sub(data, this.components['/_app'].Component);
    }
  }], [{
    key: "_rewriteUrlForNextExport",
    value: function _rewriteUrlForNextExport(url) {
      if (false) { var rewriteUrlForNextExport; } else {
        return url;
      }
    }
  }]);

  return Router;
}();

exports["default"] = Router;
Router.events = (0, _mitt["default"])();

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js":
/*!***************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/is-dynamic.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.isDynamicRoute = isDynamicRoute; // Identify /[param]/ in route string

var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;

function isDynamicRoute(route) {
  return TEST_ROUTE.test(route);
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js":
/*!******************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-matcher.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteMatcher = getRouteMatcher;

function getRouteMatcher(routeRegex) {
  var re = routeRegex.re,
      groups = routeRegex.groups;
  return function (pathname) {
    var routeMatch = re.exec(pathname);

    if (!routeMatch) {
      return false;
    }

    var decode = function decode(param) {
      try {
        return decodeURIComponent(param);
      } catch (_) {
        var err = new Error('failed to decode param');
        err.code = 'DECODE_FAILED';
        throw err;
      }
    };

    var params = {};
    Object.keys(groups).forEach(function (slugName) {
      var g = groups[slugName];
      var m = routeMatch[g.pos];

      if (m !== undefined) {
        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {
          return decode(entry);
        }) : g.repeat ? [decode(m)] : decode(m);
      }
    });
    return params;
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/router/utils/route-regex.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/router/utils/route-regex.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

exports.__esModule = true;
exports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module
// to reduce bytes

function escapeRegex(str) {
  return str.replace(/[|\\{}()[\]^$+*?.-]/g, '\\$&');
}

function getRouteRegex(normalizedRoute) {
  // Escape all characters that could be considered RegEx
  var escapedRoute = escapeRegex(normalizedRoute.replace(/\/$/, '') || '/');
  var groups = {};
  var groupIndex = 1;
  var parameterizedRoute = escapedRoute.replace(/\/\\\[([^/]+?)\\\](?=\/|$)/g, function (_, $1) {
    var isOptional = /^\\\[.*\\\]$/.test($1);

    if (isOptional) {
      $1 = $1.slice(2, -2);
    }

    var isCatchAll = /^(\\\.){3}/.test($1);

    if (isCatchAll) {
      $1 = $1.slice(6);
    }

    groups[$1 // Un-escape key
    .replace(/\\([|\\{}()[\]^$+*?.-])/g, '$1') // eslint-disable-next-line no-sequences
    ] = {
      pos: groupIndex++,
      repeat: isCatchAll
    };
    return isCatchAll ? isOptional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';
  });
  var namedParameterizedRoute; // dead code eliminate for browser since it's only needed
  // while generating routes-manifest

  if (false) {}

  return {
    re: new RegExp('^' + parameterizedRoute + '(?:/)?$', 'i'),
    groups: groups,
    namedRegex: namedParameterizedRoute ? "^".concat(namedParameterizedRoute, "(?:/)?$") : undefined
  };
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/side-effect.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/side-effect.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _classCallCheck = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");

var _createClass = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");

var _assertThisInitialized = __webpack_require__(/*! @babel/runtime/helpers/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

var _inherits = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");

var _possibleConstructorReturn = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");

var _getPrototypeOf = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");

var _toConsumableArray = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ "./node_modules/@babel/runtime/helpers/toConsumableArray.js");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

exports.__esModule = true;
exports["default"] = void 0;

var _react = __webpack_require__(/*! react */ "./node_modules/react/index.js");

var isServer = false;

var _default = function _default() {
  var mountedInstances = new Set();
  var state;

  function emitChange(component) {
    state = component.props.reduceComponentsToState(_toConsumableArray(mountedInstances), component.props);

    if (component.props.handleStateChange) {
      component.props.handleStateChange(state);
    }
  }

  return /*#__PURE__*/function (_react$Component) {
    _inherits(_class, _react$Component);

    var _super = _createSuper(_class);

    function _class(props) {
      var _this;

      _classCallCheck(this, _class);

      _this = _super.call(this, props);

      if (isServer) {
        mountedInstances.add(_assertThisInitialized(_this));
        emitChange(_assertThisInitialized(_this));
      }

      return _this;
    }

    _createClass(_class, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        mountedInstances.add(this);
        emitChange(this);
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        emitChange(this);
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        mountedInstances["delete"](this);
        emitChange(this);
      }
    }, {
      key: "render",
      value: function render() {
        return null;
      }
    }], [{
      key: "rewind",
      value: // Used when server rendering
      function rewind() {
        var recordedState = state;
        state = undefined;
        mountedInstances.clear();
        return recordedState;
      }
    }]);

    return _class;
  }(_react.Component);
};

exports["default"] = _default;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/dist/next-server/lib/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/next-server/lib/utils.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {

var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");

var _asyncToGenerator = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js");

exports.__esModule = true;
exports.execOnce = execOnce;
exports.getLocationOrigin = getLocationOrigin;
exports.getURL = getURL;
exports.getDisplayName = getDisplayName;
exports.isResSent = isResSent;
exports.loadGetInitialProps = loadGetInitialProps;
exports.formatWithValidation = formatWithValidation;
exports.ST = exports.SP = exports.urlObjectKeys = void 0;

var _url = __webpack_require__(/*! url */ "./node_modules/native-url/dist/index.js");
/**
* Utils
*/


function execOnce(fn) {
  var used = false;
  var result;
  return function () {
    if (!used) {
      used = true;
      result = fn.apply(void 0, arguments);
    }

    return result;
  };
}

function getLocationOrigin() {
  var _window$location = window.location,
      protocol = _window$location.protocol,
      hostname = _window$location.hostname,
      port = _window$location.port;
  return "".concat(protocol, "//").concat(hostname).concat(port ? ':' + port : '');
}

function getURL() {
  var href = window.location.href;
  var origin = getLocationOrigin();
  return href.substring(origin.length);
}

function getDisplayName(Component) {
  return typeof Component === 'string' ? Component : Component.displayName || Component.name || 'Unknown';
}

function isResSent(res) {
  return res.finished || res.headersSent;
}

function loadGetInitialProps(_x, _x2) {
  return _loadGetInitialProps.apply(this, arguments);
}

function _loadGetInitialProps() {
  _loadGetInitialProps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(App, ctx) {
    var _App$prototype, message, res, props, _message;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (false) {}

            if (!((_App$prototype = App.prototype) === null || _App$prototype === void 0 ? void 0 : _App$prototype.getInitialProps)) {
              _context.next = 4;
              break;
            }

            message = "\"".concat(getDisplayName(App), ".getInitialProps()\" is defined as an instance method - visit https://err.sh/vercel/next.js/get-initial-props-as-an-instance-method for more information.");
            throw new Error(message);

          case 4:
            // when called from _app `ctx` is nested in `ctx`
            res = ctx.res || ctx.ctx && ctx.ctx.res;

            if (App.getInitialProps) {
              _context.next = 12;
              break;
            }

            if (!(ctx.ctx && ctx.Component)) {
              _context.next = 11;
              break;
            }

            _context.next = 9;
            return loadGetInitialProps(ctx.Component, ctx.ctx);

          case 9:
            _context.t0 = _context.sent;
            return _context.abrupt("return", {
              pageProps: _context.t0
            });

          case 11:
            return _context.abrupt("return", {});

          case 12:
            _context.next = 14;
            return App.getInitialProps(ctx);

          case 14:
            props = _context.sent;

            if (!(res && isResSent(res))) {
              _context.next = 17;
              break;
            }

            return _context.abrupt("return", props);

          case 17:
            if (props) {
              _context.next = 20;
              break;
            }

            _message = "\"".concat(getDisplayName(App), ".getInitialProps()\" should resolve to an object. But found \"").concat(props, "\" instead.");
            throw new Error(_message);

          case 20:
            if (true) {
              if (Object.keys(props).length === 0 && !ctx.ctx) {
                console.warn("".concat(getDisplayName(App), " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://err.sh/vercel/next.js/empty-object-getInitialProps"));
              }
            }

            return _context.abrupt("return", props);

          case 22:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadGetInitialProps.apply(this, arguments);
}

var urlObjectKeys = ['auth', 'hash', 'host', 'hostname', 'href', 'path', 'pathname', 'port', 'protocol', 'query', 'search', 'slashes'];
exports.urlObjectKeys = urlObjectKeys;

function formatWithValidation(url, options) {
  if (true) {
    if (url !== null && typeof url === 'object') {
      Object.keys(url).forEach(function (key) {
        if (urlObjectKeys.indexOf(key) === -1) {
          console.warn("Unknown key passed via urlObject into url.format: ".concat(key));
        }
      });
    }
  }

  return (0, _url.format)(url, options);
}

var SP = typeof performance !== 'undefined';
exports.SP = SP;
var ST = SP && typeof performance.mark === 'function' && typeof performance.measure === 'function';
exports.ST = ST;

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./dist/client/link */ "./node_modules/next/dist/client/link.js")


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/prop-types-exact/build/helpers/isPlainObject.js":
/*!**********************************************************************!*\
  !*** ./node_modules/prop-types-exact/build/helpers/isPlainObject.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports['default'] = isPlainObject;
function isPlainObject(x) {
  return x && (typeof x === 'undefined' ? 'undefined' : _typeof(x)) === 'object' && !Array.isArray(x);
}
module.exports = exports['default'];
//# sourceMappingURL=isPlainObject.js.map

/***/ }),

/***/ "./node_modules/prop-types-exact/build/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prop-types-exact/build/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports['default'] = forbidExtraProps;

var _object = __webpack_require__(/*! object.assign */ "./node_modules/next/dist/build/polyfills/object.assign/index.js");

var _object2 = _interopRequireDefault(_object);

var _has = __webpack_require__(/*! has */ "./node_modules/has/src/index.js");

var _has2 = _interopRequireDefault(_has);

var _isPlainObject = __webpack_require__(/*! ./helpers/isPlainObject */ "./node_modules/prop-types-exact/build/helpers/isPlainObject.js");

var _isPlainObject2 = _interopRequireDefault(_isPlainObject);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var zeroWidthSpace = '\u200B';
var specialProperty = 'prop-types-exact: ' + zeroWidthSpace;
var semaphore = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for'](specialProperty) : /* istanbul ignore next */specialProperty;

function brand(fn) {
  return (0, _object2['default'])(fn, _defineProperty({}, specialProperty, semaphore));
}

function isBranded(value) {
  return value && value[specialProperty] === semaphore;
}

function forbidExtraProps(propTypes) {
  if (!(0, _isPlainObject2['default'])(propTypes)) {
    throw new TypeError('given propTypes must be an object');
  }
  if ((0, _has2['default'])(propTypes, specialProperty) && !isBranded(propTypes[specialProperty])) {
    throw new TypeError('Against all odds, you created a propType for a prop that uses both the zero-width space and our custom string - which, sadly, conflicts with `prop-types-exact`');
  }

  return (0, _object2['default'])({}, propTypes, _defineProperty({}, specialProperty, brand(function () {
    function forbidUnknownProps(props, _, componentName) {
      var unknownProps = Object.keys(props).filter(function (prop) {
        return !(0, _has2['default'])(propTypes, prop);
      });
      if (unknownProps.length > 0) {
        return new TypeError(String(componentName) + ': unknown props found: ' + String(unknownProps.join(', ')));
      }
      return null;
    }

    return forbidUnknownProps;
  }())));
}
module.exports = exports['default'];
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/prop-types/checkPropTypes.js":
/*!*********************************************************************************************************!*\
  !*** delegated ./node_modules/prop-types/checkPropTypes.js from dll-reference dll_5030f387d328e4415785 ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_5030f387d328e4415785 */ "dll-reference dll_5030f387d328e4415785"))("./node_modules/prop-types/checkPropTypes.js");

/***/ }),

/***/ "./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");
var assign = __webpack_require__(/*! object-assign */ "./node_modules/next/dist/build/polyfills/object-assign.js");

var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ "./node_modules/prop-types/lib/ReactPropTypesSecret.js");
var checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ "./node_modules/prop-types/checkPropTypes.js");

var has = Function.call.bind(Object.prototype.hasOwnProperty);
var printWarning = function() {};

if (true) {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (true) {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ( true && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName  + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if (true) {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : undefined;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),

/***/ "./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (true) {
  var ReactIs = __webpack_require__(/*! react-is */ "./node_modules/react-is/index.js");

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ "./node_modules/prop-types/factoryWithTypeCheckers.js")(ReactIs.isElement, throwOnDirectAccess);
} else {}


/***/ }),

/***/ "./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*******************************************************************************************************************!*\
  !*** delegated ./node_modules/prop-types/lib/ReactPropTypesSecret.js from dll-reference dll_5030f387d328e4415785 ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_5030f387d328e4415785 */ "dll-reference dll_5030f387d328e4415785"))("./node_modules/prop-types/lib/ReactPropTypesSecret.js");

/***/ }),

/***/ "./node_modules/querystring-es3/decode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/decode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/querystring-es3/encode.js":
/*!************************************************!*\
  !*** ./node_modules/querystring-es3/encode.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "./node_modules/querystring-es3/index.js":
/*!***********************************************!*\
  !*** ./node_modules/querystring-es3/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "./node_modules/react-dom/index.js":
/*!***********************************************************************************************!*\
  !*** delegated ./node_modules/react-dom/index.js from dll-reference dll_5030f387d328e4415785 ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_5030f387d328e4415785 */ "dll-reference dll_5030f387d328e4415785"))("./node_modules/react-dom/index.js");

/***/ }),

/***/ "./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */





if (true) {
  (function() {
'use strict';

// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol = typeof Symbol === 'function' && Symbol.for;
var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
// (unstable) APIs that have been removed. Can we remove the symbols?

var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;

function isValidElementType(type) {
  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
}

function typeOf(object) {
  if (typeof object === 'object' && object !== null) {
    var $$typeof = object.$$typeof;

    switch ($$typeof) {
      case REACT_ELEMENT_TYPE:
        var type = object.type;

        switch (type) {
          case REACT_ASYNC_MODE_TYPE:
          case REACT_CONCURRENT_MODE_TYPE:
          case REACT_FRAGMENT_TYPE:
          case REACT_PROFILER_TYPE:
          case REACT_STRICT_MODE_TYPE:
          case REACT_SUSPENSE_TYPE:
            return type;

          default:
            var $$typeofType = type && type.$$typeof;

            switch ($$typeofType) {
              case REACT_CONTEXT_TYPE:
              case REACT_FORWARD_REF_TYPE:
              case REACT_LAZY_TYPE:
              case REACT_MEMO_TYPE:
              case REACT_PROVIDER_TYPE:
                return $$typeofType;

              default:
                return $$typeof;
            }

        }

      case REACT_PORTAL_TYPE:
        return $$typeof;
    }
  }

  return undefined;
} // AsyncMode is deprecated along with isAsyncMode

var AsyncMode = REACT_ASYNC_MODE_TYPE;
var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
var ContextConsumer = REACT_CONTEXT_TYPE;
var ContextProvider = REACT_PROVIDER_TYPE;
var Element = REACT_ELEMENT_TYPE;
var ForwardRef = REACT_FORWARD_REF_TYPE;
var Fragment = REACT_FRAGMENT_TYPE;
var Lazy = REACT_LAZY_TYPE;
var Memo = REACT_MEMO_TYPE;
var Portal = REACT_PORTAL_TYPE;
var Profiler = REACT_PROFILER_TYPE;
var StrictMode = REACT_STRICT_MODE_TYPE;
var Suspense = REACT_SUSPENSE_TYPE;
var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated

function isAsyncMode(object) {
  {
    if (!hasWarnedAboutDeprecatedIsAsyncMode) {
      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint

      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
    }
  }

  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
}
function isConcurrentMode(object) {
  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
}
function isContextConsumer(object) {
  return typeOf(object) === REACT_CONTEXT_TYPE;
}
function isContextProvider(object) {
  return typeOf(object) === REACT_PROVIDER_TYPE;
}
function isElement(object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
}
function isForwardRef(object) {
  return typeOf(object) === REACT_FORWARD_REF_TYPE;
}
function isFragment(object) {
  return typeOf(object) === REACT_FRAGMENT_TYPE;
}
function isLazy(object) {
  return typeOf(object) === REACT_LAZY_TYPE;
}
function isMemo(object) {
  return typeOf(object) === REACT_MEMO_TYPE;
}
function isPortal(object) {
  return typeOf(object) === REACT_PORTAL_TYPE;
}
function isProfiler(object) {
  return typeOf(object) === REACT_PROFILER_TYPE;
}
function isStrictMode(object) {
  return typeOf(object) === REACT_STRICT_MODE_TYPE;
}
function isSuspense(object) {
  return typeOf(object) === REACT_SUSPENSE_TYPE;
}

exports.AsyncMode = AsyncMode;
exports.ConcurrentMode = ConcurrentMode;
exports.ContextConsumer = ContextConsumer;
exports.ContextProvider = ContextProvider;
exports.Element = Element;
exports.ForwardRef = ForwardRef;
exports.Fragment = Fragment;
exports.Lazy = Lazy;
exports.Memo = Memo;
exports.Portal = Portal;
exports.Profiler = Profiler;
exports.StrictMode = StrictMode;
exports.Suspense = Suspense;
exports.isAsyncMode = isAsyncMode;
exports.isConcurrentMode = isConcurrentMode;
exports.isContextConsumer = isContextConsumer;
exports.isContextProvider = isContextProvider;
exports.isElement = isElement;
exports.isForwardRef = isForwardRef;
exports.isFragment = isFragment;
exports.isLazy = isLazy;
exports.isMemo = isMemo;
exports.isPortal = isPortal;
exports.isProfiler = isProfiler;
exports.isStrictMode = isStrictMode;
exports.isSuspense = isSuspense;
exports.isValidElementType = isValidElementType;
exports.typeOf = typeOf;
  })();
}


/***/ }),

/***/ "./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (false) {} else {
  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ "./node_modules/react-is/cjs/react-is.development.js");
}


/***/ }),

/***/ "./node_modules/react-toastify/dist/react-toastify.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-toastify/dist/react-toastify.esm.js ***!
  \****************************************************************/
/*! exports provided: Bounce, Flip, Slide, ToastContainer, Zoom, collapseToast, cssTransition, toast, useToast, useToastContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Flip", function() { return Flip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Slide", function() { return Slide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToastContainer", function() { return ToastContainer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Zoom", function() { return Zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "collapseToast", function() { return collapseToast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssTransition", function() { return cssTransition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toast", function() { return toast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useToast", function() { return useToast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "useToastContainer", function() { return useToastContainer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_transition_group__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-transition-group */ "./node_modules/react-transition-group/esm/index.js");
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);






function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function isNum(v) {
  return typeof v === 'number' && !isNaN(v);
}
function isBool(v) {
  return typeof v === 'boolean';
}
function isStr(v) {
  return typeof v === 'string';
}
function isFn(v) {
  return typeof v === 'function';
}
function parseClassName(v) {
  return isStr(v) || isFn(v) ? v : null;
}
function objectValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}
function hasToastId(toastId) {
  return toastId === 0 || toastId;
}
function getAutoCloseDelay(toastAutoClose, containerAutoClose) {
  return toastAutoClose === false || isNum(toastAutoClose) && toastAutoClose > 0 ? toastAutoClose : containerAutoClose;
}
var canUseDom = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
function canBeRendered(content) {
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(content) || isStr(content) || isFn(content) || isNum(content);
}

var POSITION = {
  TOP_LEFT: 'top-left',
  TOP_RIGHT: 'top-right',
  TOP_CENTER: 'top-center',
  BOTTOM_LEFT: 'bottom-left',
  BOTTOM_RIGHT: 'bottom-right',
  BOTTOM_CENTER: 'bottom-center'
};
var TYPE = {
  INFO: 'info',
  SUCCESS: 'success',
  WARNING: 'warning',
  ERROR: 'error',
  DEFAULT: 'default',
  DARK: 'dark'
};

/**
 * Used to collapse toast after exit animation
 */
function collapseToast(node, done, duration
/* COLLAPSE_DURATION */
) {
  if (duration === void 0) {
    duration = 300;
  }

  var height = node.scrollHeight;
  var style = node.style;
  requestAnimationFrame(function () {
    style.minHeight = 'initial';
    style.height = height + 'px';
    style.transition = "all " + duration + "ms";
    requestAnimationFrame(function () {
      style.height = '0';
      style.padding = '0';
      style.margin = '0';
      setTimeout(function () {
        return done();
      }, duration);
    });
  });
}

function cssTransition(_ref) {
  var enter = _ref.enter,
      exit = _ref.exit,
      _ref$duration = _ref.duration,
      duration = _ref$duration === void 0 ? 750 : _ref$duration,
      _ref$appendPosition = _ref.appendPosition,
      appendPosition = _ref$appendPosition === void 0 ? false : _ref$appendPosition,
      _ref$collapse = _ref.collapse,
      collapse = _ref$collapse === void 0 ? true : _ref$collapse,
      _ref$collapseDuration = _ref.collapseDuration,
      collapseDuration = _ref$collapseDuration === void 0 ? 300 : _ref$collapseDuration;
  var enterDuration, exitDuration;

  if (Array.isArray(duration) && duration.length === 2) {
    enterDuration = duration[0];
    exitDuration = duration[1];
  } else {
    enterDuration = exitDuration = duration;
  }

  return function ToastTransition(_ref2) {
    var children = _ref2.children,
        position = _ref2.position,
        preventExitTransition = _ref2.preventExitTransition,
        done = _ref2.done,
        props = _objectWithoutPropertiesLoose(_ref2, ["children", "position", "preventExitTransition", "done"]);

    var enterClassName = appendPosition ? enter + "--" + position : enter;
    var exitClassName = appendPosition ? exit + "--" + position : exit;

    var onEnter = function onEnter() {
      var node = props.nodeRef.current;

      if (node) {
        node.classList.add(enterClassName);
        node.style.animationFillMode = 'forwards';
        node.style.animationDuration = enterDuration + "ms";
      }
    };

    var onEntered = function onEntered() {
      var node = props.nodeRef.current;

      if (node) {
        node.classList.remove(enterClassName);
        node.style.removeProperty('animationFillMode');
        node.style.removeProperty('animationDuration');
      }
    };

    var onExited = function onExited() {
      var node = props.nodeRef.current;

      if (node) {
        node.removeEventListener('animationend', onExited);
        collapse ? collapseToast(node, done, collapseDuration) : done();
      }
    };

    var onExit = function onExit() {
      var node = props.nodeRef.current;

      if (node) {
        node.classList.add(exitClassName);
        node.style.animationFillMode = 'forwards';
        node.style.animationDuration = exitDuration + "ms";
        node.addEventListener('animationend', onExited);
      }
    };

    return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(react_transition_group__WEBPACK_IMPORTED_MODULE_1__["Transition"], Object.assign({}, props, {
      timeout: preventExitTransition ? collapse ? collapseDuration : 50
      /* DEBOUNCE_DURATION */
      : {
        enter: enterDuration,
        exit: collapse ? exitDuration + collapseDuration : exitDuration + 50
        /* DEBOUNCE_DURATION */

      },
      onEnter: onEnter,
      onEntered: onEntered,
      onExit: preventExitTransition ? onExited : onExit,
      unmountOnExit: true
    }), children);
  };
}

var eventManager = {
  list: /*#__PURE__*/new Map(),
  emitQueue: /*#__PURE__*/new Map(),
  on: function on(event, callback) {
    this.list.has(event) || this.list.set(event, []);
    this.list.get(event).push(callback);
    return this;
  },
  off: function off(event, callback) {
    if (callback) {
      var cb = this.list.get(event).filter(function (cb) {
        return cb !== callback;
      });
      this.list.set(event, cb);
      return this;
    }

    this.list["delete"](event);
    return this;
  },
  cancelEmit: function cancelEmit(event) {
    var timers = this.emitQueue.get(event);

    if (timers) {
      timers.forEach(function (timer) {
        return clearTimeout(timer);
      });
      this.emitQueue["delete"](event);
    }

    return this;
  },

  /**
   * Enqueue the event at the end of the call stack
   * Doing so let the user call toast as follow:
   * toast('1')
   * toast('2')
   * toast('3')
   * Without setTimemout the code above will not work
   */
  emit: function emit(event) {
    var _this = this;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    this.list.has(event) && this.list.get(event).forEach(function (callback) {
      var timer = setTimeout(function () {
        // @ts-ignore
        callback.apply(void 0, args);
      }, 0);
      _this.emitQueue.has(event) || _this.emitQueue.set(event, []);

      _this.emitQueue.get(event).push(timer);
    });
  }
};

/**
 * `useKeeper` is a helper around `useRef`.
 *
 * You don't need to access the `.current`property to get the value
 * If refresh is set to true. The ref will be updated every render
 */

function useKeeper(arg, refresh) {
  if (refresh === void 0) {
    refresh = false;
  }

  var ref = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(arg);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (refresh) ref.current = arg;
  });
  return ref.current;
}

function reducer(state, action) {
  switch (action.type) {
    case 'ADD':
      return [].concat(state, [action.toastId]).filter(function (id) {
        return id !== action.staleId;
      });

    case 'REMOVE':
      return hasToastId(action.toastId) ? state.filter(function (id) {
        return id !== action.toastId;
      }) : [];
  }
}

function useToastContainer(props) {
  var _useReducer = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(function (x) {
    return x + 1;
  }, 0),
      forceUpdate = _useReducer[1];

  var _useReducer2 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useReducer"])(reducer, []),
      toast = _useReducer2[0],
      dispatch = _useReducer2[1];

  var containerRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var toastCount = useKeeper(0);
  var queue = useKeeper([]);
  var collection = useKeeper({});
  var instance = useKeeper({
    toastKey: 1,
    displayedToast: 0,
    props: props,
    containerId: null,
    isToastActive: isToastActive,
    getToast: function getToast(id) {
      return collection[id] || null;
    }
  });
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    instance.containerId = props.containerId;
    eventManager.cancelEmit(3
    /* WillUnmount */
    ).on(0
    /* Show */
    , buildToast).on(1
    /* Clear */
    , function (toastId) {
      return containerRef.current && removeToast(toastId);
    }).on(5
    /* ClearWaitingQueue */
    , clearWaitingQueue).emit(2
    /* DidMount */
    , instance);
    return function () {
      return eventManager.emit(3
      /* WillUnmount */
      , instance);
    };
  }, []);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    instance.isToastActive = isToastActive;
    instance.displayedToast = toast.length;
    eventManager.emit(4
    /* Change */
    , toast.length, props.containerId);
  }, [toast]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    instance.props = props;
  });

  function isToastActive(id) {
    return toast.indexOf(id) !== -1;
  }

  function clearWaitingQueue(_ref) {
    var containerId = _ref.containerId;
    var _instance$props = instance.props,
        limit = _instance$props.limit,
        enableMultiContainer = _instance$props.enableMultiContainer;

    if (limit && (!containerId || instance.containerId === containerId && enableMultiContainer)) {
      toastCount -= queue.length;
      queue = [];
    }
  }

  function removeToast(toastId) {
    var queueLen = queue.length;
    toastCount = hasToastId(toastId) ? toastCount - 1 : toastCount - instance.displayedToast;
    if (toastCount < 0) toastCount = 0;

    if (queueLen > 0) {
      var freeSlot = hasToastId(toastId) ? 1 : instance.props.limit;

      if (queueLen === 1 || freeSlot === 1) {
        instance.displayedToast++;
        dequeueToast();
      } else {
        var toDequeue = freeSlot > queueLen ? queueLen : freeSlot;
        instance.displayedToast = toDequeue;

        for (var i = 0; i < toDequeue; i++) {
          dequeueToast();
        }
      }
    }

    dispatch({
      type: 'REMOVE',
      toastId: toastId
    });
  }

  function dequeueToast() {
    var _queue$shift = queue.shift(),
        toastContent = _queue$shift.toastContent,
        toastProps = _queue$shift.toastProps,
        staleId = _queue$shift.staleId; // ensure that exit transition has been completed, hence the timeout


    setTimeout(function () {
      appendToast(toastContent, toastProps, staleId);
    }, 500);
  }
  /**
   * check if a container is attached to the dom
   * check for multi-container, build only if associated
   * check for duplicate toastId if no update
   */


  function isNotValid(_ref2) {
    var containerId = _ref2.containerId,
        toastId = _ref2.toastId,
        updateId = _ref2.updateId;
    return !containerRef.current || instance.props.enableMultiContainer && containerId !== instance.props.containerId || instance.isToastActive(toastId) && updateId == null ? true : false;
  } // this function and all the function called inside needs to rely on ref(`useKeeper`)


  function buildToast(content, _ref3) {
    var delay = _ref3.delay,
        staleId = _ref3.staleId,
        options = _objectWithoutPropertiesLoose(_ref3, ["delay", "staleId"]);

    if (!canBeRendered(content) || isNotValid(options)) return;
    var toastId = options.toastId,
        updateId = options.updateId;
    var props = instance.props,
        isToastActive = instance.isToastActive;

    var closeToast = function closeToast() {
      return removeToast(toastId);
    };

    var isNotAnUpdate = !isToastActive(toastId);
    if (isNotAnUpdate) toastCount++;
    var toastProps = {
      toastId: toastId,
      updateId: updateId,
      key: options.key || instance.toastKey++,
      type: options.type,
      closeToast: closeToast,
      closeButton: options.closeButton,
      rtl: props.rtl,
      position: options.position || props.position,
      transition: options.transition || props.transition,
      className: parseClassName(options.className || props.toastClassName),
      bodyClassName: parseClassName(options.bodyClassName || props.bodyClassName),
      style: options.style || props.toastStyle,
      bodyStyle: options.bodyStyle || props.bodyStyle,
      onClick: options.onClick || props.onClick,
      pauseOnHover: isBool(options.pauseOnHover) ? options.pauseOnHover : props.pauseOnHover,
      pauseOnFocusLoss: isBool(options.pauseOnFocusLoss) ? options.pauseOnFocusLoss : props.pauseOnFocusLoss,
      draggable: isBool(options.draggable) ? options.draggable : props.draggable,
      draggablePercent: isNum(options.draggablePercent) ? options.draggablePercent : props.draggablePercent,
      closeOnClick: isBool(options.closeOnClick) ? options.closeOnClick : props.closeOnClick,
      progressClassName: parseClassName(options.progressClassName || props.progressClassName),
      progressStyle: options.progressStyle || props.progressStyle,
      autoClose: getAutoCloseDelay(options.autoClose, props.autoClose),
      hideProgressBar: isBool(options.hideProgressBar) ? options.hideProgressBar : props.hideProgressBar,
      progress: options.progress,
      role: isStr(options.role) ? options.role : props.role,
      deleteToast: function deleteToast() {
        removeFromCollection(toastId);
      }
    };
    if (isFn(options.onOpen)) toastProps.onOpen = options.onOpen;
    if (isFn(options.onClose)) toastProps.onClose = options.onClose;
    var closeButton = props.closeButton;

    if (options.closeButton === false || canBeRendered(options.closeButton)) {
      closeButton = options.closeButton;
    } else if (options.closeButton === true) {
      closeButton = canBeRendered(props.closeButton) ? props.closeButton : true;
    }

    toastProps.closeButton = closeButton;
    var toastContent = content;

    if (Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(content) && !isStr(content.type)) {
      toastContent = Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(content, {
        closeToast: closeToast,
        toastProps: toastProps
      });
    } else if (isFn(content)) {
      toastContent = content({
        closeToast: closeToast,
        toastProps: toastProps
      });
    } // not handling limit + delay by design. Waiting for user feedback first


    if (props.limit && props.limit > 0 && toastCount > props.limit && isNotAnUpdate) {
      queue.push({
        toastContent: toastContent,
        toastProps: toastProps,
        staleId: staleId
      });
    } else if (isNum(delay) && delay > 0) {
      setTimeout(function () {
        appendToast(toastContent, toastProps, staleId);
      }, delay);
    } else {
      appendToast(toastContent, toastProps, staleId);
    }
  }

  function appendToast(content, toastProps, staleId) {
    var toastId = toastProps.toastId;
    collection[toastId] = {
      content: content,
      props: toastProps
    };
    dispatch({
      type: 'ADD',
      toastId: toastId,
      staleId: staleId
    });
  }

  function removeFromCollection(toastId) {
    delete collection[toastId];
    forceUpdate();
  }

  function getToastToRender(cb) {
    var toastToRender = {};
    var toastList = props.newestOnTop ? Object.keys(collection).reverse() : Object.keys(collection);

    for (var i = 0; i < toastList.length; i++) {
      var _toast = collection[toastList[i]];
      var position = _toast.props.position;
      toastToRender[position] || (toastToRender[position] = []);
      toastToRender[position].push(_toast);
    }

    return Object.keys(toastToRender).map(function (p) {
      return cb(p, toastToRender[p]);
    });
  }

  return {
    getToastToRender: getToastToRender,
    collection: collection,
    containerRef: containerRef,
    isToastActive: isToastActive
  };
}

function getX(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX;
}

function getY(e) {
  return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY;
}

function useToast(props) {
  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(true),
      isRunning = _useState[0],
      setIsRunning = _useState[1];

  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(false),
      preventExitTransition = _useState2[0],
      setPreventExitTransition = _useState2[1];

  var toastRef = Object(react__WEBPACK_IMPORTED_MODULE_0__["useRef"])(null);
  var drag = useKeeper({
    start: 0,
    x: 0,
    y: 0,
    deltaX: 0,
    removalDistance: 0,
    canCloseOnClick: true,
    canDrag: false,
    boundingRect: null
  });
  var syncProps = useKeeper(props, true);
  var autoClose = props.autoClose,
      pauseOnHover = props.pauseOnHover,
      closeToast = props.closeToast,
      onClick = props.onClick,
      closeOnClick = props.closeOnClick;
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    if (isFn(props.onOpen)) props.onOpen(Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(props.children) && props.children.props);
    return function () {
      if (isFn(syncProps.onClose)) syncProps.onClose(Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(syncProps.children) && syncProps.children.props);
    };
  }, []);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    props.draggable && bindDragEvents();
    return function () {
      props.draggable && unbindDragEvents();
    };
  }, [props.draggable]);
  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    props.pauseOnFocusLoss && bindFocusEvents();
    return function () {
      props.pauseOnFocusLoss && unbindFocusEvents();
    };
  }, [props.pauseOnFocusLoss]);

  function onDragStart(e) {
    var toast = toastRef.current;
    drag.canCloseOnClick = true;
    drag.canDrag = true;
    drag.boundingRect = toast.getBoundingClientRect();
    toast.style.transition = '';
    drag.start = drag.x = getX(e.nativeEvent);
    drag.removalDistance = toast.offsetWidth * (props.draggablePercent / 100);
  }

  function onDragTransitionEnd() {
    if (drag.boundingRect) {
      var _drag$boundingRect = drag.boundingRect,
          top = _drag$boundingRect.top,
          bottom = _drag$boundingRect.bottom,
          left = _drag$boundingRect.left,
          right = _drag$boundingRect.right;

      if (props.pauseOnHover && drag.x >= left && drag.x <= right && drag.y >= top && drag.y <= bottom) {
        pauseToast();
      } else {
        playToast();
      }
    }
  }

  function playToast() {
    setIsRunning(true);
  }

  function pauseToast() {
    setIsRunning(false);
  }

  function bindFocusEvents() {
    window.addEventListener('focus', playToast);
    window.addEventListener('blur', pauseToast);
  }

  function unbindFocusEvents() {
    window.removeEventListener('focus', playToast);
    window.removeEventListener('blur', pauseToast);
  }

  function bindDragEvents() {
    document.addEventListener('mousemove', onDragMove);
    document.addEventListener('mouseup', onDragEnd);
    document.addEventListener('touchmove', onDragMove);
    document.addEventListener('touchend', onDragEnd);
  }

  function unbindDragEvents() {
    document.removeEventListener('mousemove', onDragMove);
    document.removeEventListener('mouseup', onDragEnd);
    document.removeEventListener('touchmove', onDragMove);
    document.removeEventListener('touchend', onDragEnd);
  }

  function onDragMove(e) {
    e.preventDefault();
    var toast = toastRef.current;

    if (drag.canDrag) {
      if (isRunning) pauseToast();
      drag.x = getX(e);
      drag.deltaX = drag.x - drag.start;
      drag.y = getY(e); // prevent false positif during a toast click

      if (drag.start !== drag.x) drag.canCloseOnClick = false;
      toast.style.transform = "translateX(" + drag.deltaX + "px)";
      toast.style.opacity = "" + (1 - Math.abs(drag.deltaX / drag.removalDistance));
    }
  }

  function onDragEnd() {
    var toast = toastRef.current;

    if (drag.canDrag) {
      drag.canDrag = false;

      if (Math.abs(drag.deltaX) > drag.removalDistance) {
        setPreventExitTransition(true);
        props.closeToast();
        return;
      }

      toast.style.transition = 'transform 0.2s, opacity 0.2s';
      toast.style.transform = 'translateX(0)';
      toast.style.opacity = '1';
    }
  }

  var eventHandlers = {
    onMouseDown: onDragStart,
    onTouchStart: onDragStart,
    onMouseUp: onDragTransitionEnd,
    onTouchEnd: onDragTransitionEnd
  };

  if (autoClose && pauseOnHover) {
    eventHandlers.onMouseEnter = pauseToast;
    eventHandlers.onMouseLeave = playToast;
  } // prevent toast from closing when user drags the toast


  if (closeOnClick) {
    eventHandlers.onClick = function (e) {
      onClick && onClick(e);
      drag.canCloseOnClick && closeToast();
    };
  }

  return {
    playToast: playToast,
    pauseToast: pauseToast,
    isRunning: isRunning,
    preventExitTransition: preventExitTransition,
    toastRef: toastRef,
    eventHandlers: eventHandlers
  };
}

function CloseButton(_ref) {
  var closeToast = _ref.closeToast,
      type = _ref.type,
      _ref$ariaLabel = _ref.ariaLabel,
      ariaLabel = _ref$ariaLabel === void 0 ? 'close' : _ref$ariaLabel;
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("button", {
    className: "Toastify"
    /* CSS_NAMESPACE */
    + "__close-button " + "Toastify"
    /* CSS_NAMESPACE */
    + "__close-button--" + type,
    type: "button",
    onClick: function onClick(e) {
      e.stopPropagation();
      closeToast(e);
    },
    "aria-label": ariaLabel
  }, Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("svg", {
    "aria-hidden": "true",
    viewBox: "0 0 14 16"
  }, Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("path", {
    fillRule: "evenodd",
    d: "M7.71 8.23l3.75 3.75-1.48 1.48-3.75-3.75-3.75 3.75L1 11.98l3.75-3.75L1 4.48 2.48 3l3.75 3.75L9.98 3l1.48 1.48-3.75 3.75z"
  })));
}

function ProgressBar(_ref) {
  var _ref2, _animationEvent;

  var delay = _ref.delay,
      isRunning = _ref.isRunning,
      closeToast = _ref.closeToast,
      type = _ref.type,
      hide = _ref.hide,
      className = _ref.className,
      userStyle = _ref.style,
      controlledProgress = _ref.controlledProgress,
      progress = _ref.progress,
      rtl = _ref.rtl,
      isIn = _ref.isIn;

  var style = _extends({}, userStyle, {
    animationDuration: delay + "ms",
    animationPlayState: isRunning ? 'running' : 'paused',
    opacity: hide ? 0 : 1
  });

  if (controlledProgress) style.transform = "scaleX(" + progress + ")";
  var defaultClassArr = ["Toastify"
  /* CSS_NAMESPACE */
  + "__progress-bar", controlledProgress ? "Toastify"
  /* CSS_NAMESPACE */
  + "__progress-bar--controlled" : "Toastify"
  /* CSS_NAMESPACE */
  + "__progress-bar--animated", "Toastify"
  /* CSS_NAMESPACE */
  + "__progress-bar--" + type, (_ref2 = {}, _ref2["Toastify"
  /* CSS_NAMESPACE */
  + "__progress-bar--rtl"] = rtl, _ref2)];
  var classNames = isFn(className) ? className({
    rtl: rtl,
    type: type,
    defaultClassName: clsx__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, defaultClassArr)
  }) : clsx__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, [].concat(defaultClassArr, [className])); // 🧐 controlledProgress is derived from progress
  // so if controlledProgress is set
  // it means that this is also the case for progress

  var animationEvent = (_animationEvent = {}, _animationEvent[controlledProgress && progress >= 1 ? 'onTransitionEnd' : 'onAnimationEnd'] = controlledProgress && progress < 1 ? null : function () {
    isIn && closeToast();
  }, _animationEvent);
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div", Object.assign({
    className: classNames,
    style: style
  }, animationEvent));
}
ProgressBar.defaultProps = {
  type: TYPE.DEFAULT,
  hide: false
};

var Toast = function Toast(props) {
  var _ref;

  var _useToast = useToast(props),
      isRunning = _useToast.isRunning,
      preventExitTransition = _useToast.preventExitTransition,
      toastRef = _useToast.toastRef,
      eventHandlers = _useToast.eventHandlers;

  var closeButton = props.closeButton,
      children = props.children,
      autoClose = props.autoClose,
      onClick = props.onClick,
      type = props.type,
      hideProgressBar = props.hideProgressBar,
      closeToast = props.closeToast,
      Transition = props.transition,
      position = props.position,
      className = props.className,
      style = props.style,
      bodyClassName = props.bodyClassName,
      bodyStyle = props.bodyStyle,
      progressClassName = props.progressClassName,
      progressStyle = props.progressStyle,
      updateId = props.updateId,
      role = props.role,
      progress = props.progress,
      rtl = props.rtl,
      toastId = props.toastId,
      deleteToast = props.deleteToast;
  var defaultClassArr = ["Toastify"
  /* CSS_NAMESPACE */
  + "__toast", "Toastify"
  /* CSS_NAMESPACE */
  + "__toast--" + type, (_ref = {}, _ref["Toastify"
  /* CSS_NAMESPACE */
  + "__toast--rtl"] = rtl, _ref)];
  var cssClasses = isFn(className) ? className({
    rtl: rtl,
    position: position,
    type: type,
    defaultClassName: clsx__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, defaultClassArr)
  }) : clsx__WEBPACK_IMPORTED_MODULE_2__["default"].apply(void 0, [].concat(defaultClassArr, [className]));
  var controlledProgress = !!progress;

  function renderCloseButton(closeButton) {
    if (!closeButton) return;
    var props = {
      closeToast: closeToast,
      type: type
    };
    if (isFn(closeButton)) return closeButton(props);
    if (Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(closeButton)) return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(closeButton, props);
  }

  return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(Transition, {
    "in": props["in"],
    appear: true,
    done: deleteToast,
    position: position,
    preventExitTransition: preventExitTransition,
    nodeRef: toastRef
  }, Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div", Object.assign({
    id: toastId,
    onClick: onClick,
    className: cssClasses || undefined
  }, eventHandlers, {
    style: style,
    ref: toastRef
  }), Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div", Object.assign({}, props["in"] && {
    role: role
  }, {
    className: isFn(bodyClassName) ? bodyClassName({
      type: type
    }) : Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])("Toastify"
    /* CSS_NAMESPACE */
    + "__toast-body", bodyClassName),
    style: bodyStyle
  }), children), renderCloseButton(closeButton), (autoClose || controlledProgress) && Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(ProgressBar, Object.assign({}, updateId && !controlledProgress ? {
    key: "pb-" + updateId
  } : {}, {
    rtl: rtl,
    delay: autoClose,
    isRunning: isRunning,
    isIn: props["in"],
    closeToast: closeToast,
    hide: hideProgressBar,
    type: type,
    style: progressStyle,
    className: progressClassName,
    controlledProgress: controlledProgress,
    progress: progress
  }))));
};

var Bounce = /*#__PURE__*/cssTransition({
  enter: "Toastify"
  /* CSS_NAMESPACE */
  + "__bounce-enter",
  exit: "Toastify"
  /* CSS_NAMESPACE */
  + "__bounce-exit",
  appendPosition: true
});
var Slide = /*#__PURE__*/cssTransition({
  enter: "Toastify"
  /* CSS_NAMESPACE */
  + "__slide-enter",
  exit: "Toastify"
  /* CSS_NAMESPACE */
  + "__slide-exit",
  duration: [450, 750],
  appendPosition: true
});
var Zoom = /*#__PURE__*/cssTransition({
  enter: "Toastify"
  /* CSS_NAMESPACE */
  + "__zoom-enter",
  exit: "Toastify"
  /* CSS_NAMESPACE */
  + "__zoom-exit"
});
var Flip = /*#__PURE__*/cssTransition({
  enter: "Toastify"
  /* CSS_NAMESPACE */
  + "__flip-enter",
  exit: "Toastify"
  /* CSS_NAMESPACE */
  + "__flip-exit"
});

var ToastPositioner = function ToastPositioner(_ref) {
  var children = _ref.children,
      className = _ref.className,
      style = _ref.style,
      rest = _objectWithoutPropertiesLoose(_ref, ["children", "className", "style"]);

  // Monkey patch react-transition-group
  // As exit transition is broken with strict mode
  delete rest["in"];
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div", {
    className: className,
    style: style
  }, react__WEBPACK_IMPORTED_MODULE_0__["Children"].map(children, function (child) {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, rest);
  }));
};

var ToastContainer = function ToastContainer(props) {
  var _useToastContainer = useToastContainer(props),
      getToastToRender = _useToastContainer.getToastToRender,
      containerRef = _useToastContainer.containerRef,
      isToastActive = _useToastContainer.isToastActive;

  var className = props.className,
      style = props.style,
      rtl = props.rtl,
      containerId = props.containerId;
  return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])("div", {
    ref: containerRef,
    className: "Toastify"
    /* CSS_NAMESPACE */
    ,
    id: containerId
  }, getToastToRender(function (position, toastList) {
    var _cx, _cx2;

    var swag = {
      className: isFn(className) ? className({
        position: position,
        rtl: rtl,
        defaultClassName: Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])("Toastify"
        /* CSS_NAMESPACE */
        + "__toast-container", "Toastify"
        /* CSS_NAMESPACE */
        + "__toast-container--" + position, (_cx = {}, _cx["Toastify"
        /* CSS_NAMESPACE */
        + "__toast-container--rtl"] = rtl, _cx))
      }) : Object(clsx__WEBPACK_IMPORTED_MODULE_2__["default"])("Toastify"
      /* CSS_NAMESPACE */
      + "__toast-container", "Toastify"
      /* CSS_NAMESPACE */
      + "__toast-container--" + position, (_cx2 = {}, _cx2["Toastify"
      /* CSS_NAMESPACE */
      + "__toast-container--rtl"] = rtl, _cx2), parseClassName(className)),
      style: toastList.length === 0 ? _extends({}, style, {
        pointerEvents: 'none'
      }) : _extends({}, style)
    };
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(ToastPositioner, Object.assign({}, swag, {
      key: "container-" + position
    }), toastList.map(function (_ref) {
      var content = _ref.content,
          toastProps = _ref.props;
      return Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(Toast, Object.assign({}, toastProps, {
        "in": isToastActive(toastProps.toastId),
        key: "toast-" + toastProps.key,
        closeButton: toastProps.closeButton === true ? CloseButton : toastProps.closeButton
      }), content);
    }));
  }));
};

if (true) {
  // @ts-ignore
  ToastContainer.propTypes = {
    // @ts-ignore
    position: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOf( /*#__PURE__*/objectValues(POSITION)),
    // @ts-ignore
    autoClose: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number]),
    // @ts-ignore
    closeButton: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.node, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func]),
    hideProgressBar: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    pauseOnHover: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    closeOnClick: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    newestOnTop: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    className: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.any,
    style: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
    toastClassName: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string]),
    bodyClassName: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string]),
    progressClassName: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string]),
    progressStyle: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.object,
    transition: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,
    rtl: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    draggable: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    draggablePercent: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number,
    pauseOnFocusLoss: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    enableMultiContainer: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.bool,
    containerId: /*#__PURE__*/prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.number]),
    role: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string,
    onClick: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
  };
}

ToastContainer.defaultProps = {
  position: POSITION.TOP_RIGHT,
  transition: Bounce,
  rtl: false,
  autoClose: 5000,
  hideProgressBar: false,
  closeButton: CloseButton,
  pauseOnHover: true,
  pauseOnFocusLoss: true,
  closeOnClick: true,
  newestOnTop: false,
  draggable: true,
  draggablePercent: 80,
  role: 'alert'
};

var containers = /*#__PURE__*/new Map();
var latestInstance;
var containerDomNode;
var containerConfig;
var queue = [];
var lazy = false;
/**
 * Check whether any container is currently mounted in the DOM
 */

function isAnyContainerMounted() {
  return containers.size > 0;
}
/**
 * Get the container by id. Returns the last container declared when no id is given.
 */


function getContainer(containerId) {
  if (!isAnyContainerMounted()) return null;
  return containers.get(!containerId ? latestInstance : containerId);
}
/**
 * Get the toast by id, given it's in the DOM, otherwise returns null
 */


function getToast(toastId, _ref) {
  var containerId = _ref.containerId;
  var container = getContainer(containerId);
  if (!container) return null;
  return container.getToast(toastId);
}
/**
 * Generate a random toastId
 */


function generateToastId() {
  return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10);
}
/**
 * Generate a toastId or use the one provided
 */


function getToastId(options) {
  if (options && (isStr(options.toastId) || isNum(options.toastId))) {
    return options.toastId;
  }

  return generateToastId();
}
/**
 * If the container is not mounted, the toast is enqueued and
 * the container lazy mounted
 */


function dispatchToast(content, options) {
  if (isAnyContainerMounted()) {
    eventManager.emit(0
    /* Show */
    , content, options);
  } else {
    queue.push({
      content: content,
      options: options
    });

    if (lazy && canUseDom) {
      lazy = false;
      containerDomNode = document.createElement('div');
      document.body.appendChild(containerDomNode);
      Object(react_dom__WEBPACK_IMPORTED_MODULE_4__["render"])(Object(react__WEBPACK_IMPORTED_MODULE_0__["createElement"])(ToastContainer, Object.assign({}, containerConfig)), containerDomNode);
    }
  }

  return options.toastId;
}
/**
 * Merge provided options with the defaults settings and generate the toastId
 */


function mergeOptions(type, options) {
  return _extends({}, options, {
    type: options && options.type || type,
    toastId: getToastId(options)
  });
}

var toast = function toast(content, options) {
  return dispatchToast(content, mergeOptions(TYPE.DEFAULT, options));
};

toast.success = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.SUCCESS, options));
};

toast.info = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.INFO, options));
};

toast.error = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.ERROR, options));
};

toast.warning = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.WARNING, options));
};

toast.dark = function (content, options) {
  return dispatchToast(content, mergeOptions(TYPE.DARK, options));
};
/**
 * Maybe I should remove warning in favor of warn, I don't know
 */


toast.warn = toast.warning;
/**
 * Remove toast programmaticaly
 */

toast.dismiss = function (id) {
  return isAnyContainerMounted() && eventManager.emit(1
  /* Clear */
  , id);
};
/**
 * Clear waiting queue when limit is used
 */


toast.clearWaitingQueue = function (params) {
  if (params === void 0) {
    params = {};
  }

  return isAnyContainerMounted() && eventManager.emit(5
  /* ClearWaitingQueue */
  , params);
};
/**
 * return true if one container is displaying the toast
 */


toast.isActive = function (id) {
  var isToastActive = false;
  containers.forEach(function (container) {
    if (container.isToastActive && container.isToastActive(id)) {
      isToastActive = true;
    }
  });
  return isToastActive;
};

toast.update = function (toastId, options) {
  if (options === void 0) {
    options = {};
  }

  // if you call toast and toast.update directly nothing will be displayed
  // this is why I defered the update
  setTimeout(function () {
    var toast = getToast(toastId, options);

    if (toast) {
      var oldOptions = toast.props,
          oldContent = toast.content;

      var nextOptions = _extends({}, oldOptions, options, {
        toastId: options.toastId || toastId,
        updateId: generateToastId()
      });

      if (nextOptions.toastId !== toastId) nextOptions.staleId = toastId;
      var content = typeof nextOptions.render !== 'undefined' ? nextOptions.render : oldContent;
      delete nextOptions.render;
      dispatchToast(content, nextOptions);
    }
  }, 0);
};
/**
 * Used for controlled progress bar.
 */


toast.done = function (id) {
  toast.update(id, {
    progress: 1
  });
};
/**
 * Track changes. The callback get the number of toast displayed
 *
 */


toast.onChange = function (callback) {
  if (isFn(callback)) {
    eventManager.on(4
    /* Change */
    , callback);
  }

  return function () {
    isFn(callback) && eventManager.off(4
    /* Change */
    , callback);
  };
};
/**
 * Configure the ToastContainer when lazy mounted
 */


toast.configure = function (config) {
  if (config === void 0) {
    config = {};
  }

  lazy = true;
  containerConfig = config;
};

toast.POSITION = POSITION;
toast.TYPE = TYPE;
/**
 * Wait until the ToastContainer is mounted to dispatch the toast
 * and attach isActive method
 */

eventManager.on(2
/* DidMount */
, function (containerInstance) {
  latestInstance = containerInstance.containerId || containerInstance;
  containers.set(latestInstance, containerInstance);
  queue.forEach(function (item) {
    eventManager.emit(0
    /* Show */
    , item.content, item.options);
  });
  queue = [];
}).on(3
/* WillUnmount */
, function (containerInstance) {
  containers["delete"](containerInstance.containerId || containerInstance);

  if (containers.size === 0) {
    eventManager.off(0
    /* Show */
    ).off(1
    /* Clear */
    ).off(5
    /* ClearWaitingQueue */
    );
  }

  if (canUseDom && containerDomNode) {
    document.body.removeChild(containerDomNode);
  }
});


//# sourceMappingURL=react-toastify.esm.js.map


/***/ }),

/***/ "./node_modules/react-transition-group/esm/CSSTransition.js":
/*!******************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/CSSTransition.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var dom_helpers_addClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! dom-helpers/addClass */ "./node_modules/dom-helpers/esm/addClass.js");
/* harmony import */ var dom_helpers_removeClass__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! dom-helpers/removeClass */ "./node_modules/dom-helpers/esm/removeClass.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Transition */ "./node_modules/react-transition-group/esm/Transition.js");
/* harmony import */ var _utils_PropTypes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/PropTypes */ "./node_modules/react-transition-group/esm/utils/PropTypes.js");










var _addClass = function addClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return Object(dom_helpers_addClass__WEBPACK_IMPORTED_MODULE_4__["default"])(node, c);
  });
};

var removeClass = function removeClass(node, classes) {
  return node && classes && classes.split(' ').forEach(function (c) {
    return Object(dom_helpers_removeClass__WEBPACK_IMPORTED_MODULE_5__["default"])(node, c);
  });
};
/**
 * A transition component inspired by the excellent
 * [ng-animate](https://docs.angularjs.org/api/ngAnimate) library, you should
 * use it if you're using CSS transitions or animations. It's built upon the
 * [`Transition`](https://reactcommunity.org/react-transition-group/transition)
 * component, so it inherits all of its props.
 *
 * `CSSTransition` applies a pair of class names during the `appear`, `enter`,
 * and `exit` states of the transition. The first class is applied and then a
 * second `*-active` class in order to activate the CSS transition. After the
 * transition, matching `*-done` class names are applied to persist the
 * transition state.
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <CSSTransition in={inProp} timeout={200} classNames="my-node">
 *         <div>
 *           {"I'll receive my-node-* classes"}
 *         </div>
 *       </CSSTransition>
 *       <button type="button" onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the `in` prop is set to `true`, the child component will first receive
 * the class `example-enter`, then the `example-enter-active` will be added in
 * the next tick. `CSSTransition` [forces a
 * reflow](https://github.com/reactjs/react-transition-group/blob/5007303e729a74be66a21c3e2205e4916821524b/src/CSSTransition.js#L208-L215)
 * between before adding the `example-enter-active`. This is an important trick
 * because it allows us to transition between `example-enter` and
 * `example-enter-active` even though they were added immediately one after
 * another. Most notably, this is what makes it possible for us to animate
 * _appearance_.
 *
 * ```css
 * .my-node-enter {
 *   opacity: 0;
 * }
 * .my-node-enter-active {
 *   opacity: 1;
 *   transition: opacity 200ms;
 * }
 * .my-node-exit {
 *   opacity: 1;
 * }
 * .my-node-exit-active {
 *   opacity: 0;
 *   transition: opacity 200ms;
 * }
 * ```
 *
 * `*-active` classes represent which styles you want to animate **to**, so it's
 * important to add `transition` declaration only to them, otherwise transitions
 * might not behave as intended! This might not be obvious when the transitions
 * are symmetrical, i.e. when `*-enter-active` is the same as `*-exit`, like in
 * the example above (minus `transition`), but it becomes apparent in more
 * complex transitions.
 *
 * **Note**: If you're using the
 * [`appear`](http://reactcommunity.org/react-transition-group/transition#Transition-prop-appear)
 * prop, make sure to define styles for `.appear-*` classes as well.
 */


var CSSTransition = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_2__["default"])(CSSTransition, _React$Component);

  function CSSTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.appliedClasses = {
      appear: {},
      enter: {},
      exit: {}
    };

    _this.onEnter = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument[0],
          appearing = _this$resolveArgument[1];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, appearing ? 'appear' : 'enter', 'base');

      if (_this.props.onEnter) {
        _this.props.onEnter(maybeNode, maybeAppearing);
      }
    };

    _this.onEntering = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument2 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument2[0],
          appearing = _this$resolveArgument2[1];

      var type = appearing ? 'appear' : 'enter';

      _this.addClass(node, type, 'active');

      if (_this.props.onEntering) {
        _this.props.onEntering(maybeNode, maybeAppearing);
      }
    };

    _this.onEntered = function (maybeNode, maybeAppearing) {
      var _this$resolveArgument3 = _this.resolveArguments(maybeNode, maybeAppearing),
          node = _this$resolveArgument3[0],
          appearing = _this$resolveArgument3[1];

      var type = appearing ? 'appear' : 'enter';

      _this.removeClasses(node, type);

      _this.addClass(node, type, 'done');

      if (_this.props.onEntered) {
        _this.props.onEntered(maybeNode, maybeAppearing);
      }
    };

    _this.onExit = function (maybeNode) {
      var _this$resolveArgument4 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument4[0];

      _this.removeClasses(node, 'appear');

      _this.removeClasses(node, 'enter');

      _this.addClass(node, 'exit', 'base');

      if (_this.props.onExit) {
        _this.props.onExit(maybeNode);
      }
    };

    _this.onExiting = function (maybeNode) {
      var _this$resolveArgument5 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument5[0];

      _this.addClass(node, 'exit', 'active');

      if (_this.props.onExiting) {
        _this.props.onExiting(maybeNode);
      }
    };

    _this.onExited = function (maybeNode) {
      var _this$resolveArgument6 = _this.resolveArguments(maybeNode),
          node = _this$resolveArgument6[0];

      _this.removeClasses(node, 'exit');

      _this.addClass(node, 'exit', 'done');

      if (_this.props.onExited) {
        _this.props.onExited(maybeNode);
      }
    };

    _this.resolveArguments = function (maybeNode, maybeAppearing) {
      return _this.props.nodeRef ? [_this.props.nodeRef.current, maybeNode] // here `maybeNode` is actually `appearing`
      : [maybeNode, maybeAppearing];
    };

    _this.getClassNames = function (type) {
      var classNames = _this.props.classNames;
      var isStringClassNames = typeof classNames === 'string';
      var prefix = isStringClassNames && classNames ? classNames + "-" : '';
      var baseClassName = isStringClassNames ? "" + prefix + type : classNames[type];
      var activeClassName = isStringClassNames ? baseClassName + "-active" : classNames[type + "Active"];
      var doneClassName = isStringClassNames ? baseClassName + "-done" : classNames[type + "Done"];
      return {
        baseClassName: baseClassName,
        activeClassName: activeClassName,
        doneClassName: doneClassName
      };
    };

    return _this;
  }

  var _proto = CSSTransition.prototype;

  _proto.addClass = function addClass(node, type, phase) {
    var className = this.getClassNames(type)[phase + "ClassName"];

    var _this$getClassNames = this.getClassNames('enter'),
        doneClassName = _this$getClassNames.doneClassName;

    if (type === 'appear' && phase === 'done' && doneClassName) {
      className += " " + doneClassName;
    } // This is to force a repaint,
    // which is necessary in order to transition styles when adding a class name.


    if (phase === 'active') {
      /* eslint-disable no-unused-expressions */
      node && node.scrollTop;
    }

    if (className) {
      this.appliedClasses[type][phase] = className;

      _addClass(node, className);
    }
  };

  _proto.removeClasses = function removeClasses(node, type) {
    var _this$appliedClasses$ = this.appliedClasses[type],
        baseClassName = _this$appliedClasses$.base,
        activeClassName = _this$appliedClasses$.active,
        doneClassName = _this$appliedClasses$.done;
    this.appliedClasses[type] = {};

    if (baseClassName) {
      removeClass(node, baseClassName);
    }

    if (activeClassName) {
      removeClass(node, activeClassName);
    }

    if (doneClassName) {
      removeClass(node, doneClassName);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        _ = _this$props.classNames,
        props = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(_this$props, ["classNames"]);

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_6___default.a.createElement(_Transition__WEBPACK_IMPORTED_MODULE_7__["default"], Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, props, {
      onEnter: this.onEnter,
      onEntered: this.onEntered,
      onEntering: this.onEntering,
      onExit: this.onExit,
      onExiting: this.onExiting,
      onExited: this.onExited
    }));
  };

  return CSSTransition;
}(react__WEBPACK_IMPORTED_MODULE_6___default.a.Component);

CSSTransition.defaultProps = {
  classNames: ''
};
CSSTransition.propTypes =  true ? Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _Transition__WEBPACK_IMPORTED_MODULE_7__["default"].propTypes, {
  /**
   * The animation classNames applied to the component as it appears, enters,
   * exits or has finished the transition. A single name can be provided, which
   * will be suffixed for each stage, e.g. `classNames="fade"` applies:
   *
   * - `fade-appear`, `fade-appear-active`, `fade-appear-done`
   * - `fade-enter`, `fade-enter-active`, `fade-enter-done`
   * - `fade-exit`, `fade-exit-active`, `fade-exit-done`
   *
   * A few details to note about how these classes are applied:
   *
   * 1. They are _joined_ with the ones that are already defined on the child
   *    component, so if you want to add some base styles, you can use
   *    `className` without worrying that it will be overridden.
   *
   * 2. If the transition component mounts with `in={false}`, no classes are
   *    applied yet. You might be expecting `*-exit-done`, but if you think
   *    about it, a component cannot finish exiting if it hasn't entered yet.
   *
   * 2. `fade-appear-done` and `fade-enter-done` will _both_ be applied. This
   *    allows you to define different behavior for when appearing is done and
   *    when regular entering is done, using selectors like
   *    `.fade-enter-done:not(.fade-appear-done)`. For example, you could apply
   *    an epic entrance animation when element first appears in the DOM using
   *    [Animate.css](https://daneden.github.io/animate.css/). Otherwise you can
   *    simply use `fade-enter-done` for defining both cases.
   *
   * Each individual classNames can also be specified independently like:
   *
   * ```js
   * classNames={{
   *  appear: 'my-appear',
   *  appearActive: 'my-active-appear',
   *  appearDone: 'my-done-appear',
   *  enter: 'my-enter',
   *  enterActive: 'my-active-enter',
   *  enterDone: 'my-done-enter',
   *  exit: 'my-exit',
   *  exitActive: 'my-active-exit',
   *  exitDone: 'my-done-exit',
   * }}
   * ```
   *
   * If you want to set these classes using CSS Modules:
   *
   * ```js
   * import styles from './styles.css';
   * ```
   *
   * you might want to use camelCase in your CSS file, that way could simply
   * spread them instead of listing them one by one:
   *
   * ```js
   * classNames={{ ...styles }}
   * ```
   *
   * @type {string | {
   *  appear?: string,
   *  appearActive?: string,
   *  appearDone?: string,
   *  enter?: string,
   *  enterActive?: string,
   *  enterDone?: string,
   *  exit?: string,
   *  exitActive?: string,
   *  exitDone?: string,
   * }}
   */
  classNames: _utils_PropTypes__WEBPACK_IMPORTED_MODULE_8__["classNamesShape"],

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or 'appear' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEnter: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter-active' or
   * 'appear-active' class is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

  /**
   * A `<Transition>` callback fired immediately after the 'enter' or
   * 'appear' classes are **removed** and the `done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntered: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' class is
   * applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExit: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit-active' is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExiting: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func,

  /**
   * A `<Transition>` callback fired immediately after the 'exit' classes
   * are **removed** and the `exit-done` class is added to the DOM node.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement)
   */
  onExited: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.func
}) : undefined;
/* harmony default export */ __webpack_exports__["default"] = (CSSTransition);

/***/ }),

/***/ "./node_modules/react-transition-group/esm/ReplaceTransition.js":
/*!**********************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/ReplaceTransition.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _TransitionGroup__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TransitionGroup */ "./node_modules/react-transition-group/esm/TransitionGroup.js");






/**
 * The `<ReplaceTransition>` component is a specialized `Transition` component
 * that animates between two children.
 *
 * ```jsx
 * <ReplaceTransition in>
 *   <Fade><div>I appear first</div></Fade>
 *   <Fade><div>I replace the above</div></Fade>
 * </ReplaceTransition>
 * ```
 */

var ReplaceTransition = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(ReplaceTransition, _React$Component);

  function ReplaceTransition() {
    var _this;

    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
      _args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;

    _this.handleEnter = function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return _this.handleLifecycle('onEnter', 0, args);
    };

    _this.handleEntering = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return _this.handleLifecycle('onEntering', 0, args);
    };

    _this.handleEntered = function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return _this.handleLifecycle('onEntered', 0, args);
    };

    _this.handleExit = function () {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      return _this.handleLifecycle('onExit', 1, args);
    };

    _this.handleExiting = function () {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      return _this.handleLifecycle('onExiting', 1, args);
    };

    _this.handleExited = function () {
      for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      return _this.handleLifecycle('onExited', 1, args);
    };

    return _this;
  }

  var _proto = ReplaceTransition.prototype;

  _proto.handleLifecycle = function handleLifecycle(handler, idx, originalArgs) {
    var _child$props;

    var children = this.props.children;
    var child = react__WEBPACK_IMPORTED_MODULE_3___default.a.Children.toArray(children)[idx];
    if (child.props[handler]) (_child$props = child.props)[handler].apply(_child$props, originalArgs);

    if (this.props[handler]) {
      var maybeNode = child.props.nodeRef ? undefined : react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.findDOMNode(this);
      this.props[handler](maybeNode);
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        inProp = _this$props.in,
        props = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_this$props, ["children", "in"]);

    var _React$Children$toArr = react__WEBPACK_IMPORTED_MODULE_3___default.a.Children.toArray(children),
        first = _React$Children$toArr[0],
        second = _React$Children$toArr[1];

    delete props.onEnter;
    delete props.onEntering;
    delete props.onEntered;
    delete props.onExit;
    delete props.onExiting;
    delete props.onExited;
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(_TransitionGroup__WEBPACK_IMPORTED_MODULE_5__["default"], props, inProp ? react__WEBPACK_IMPORTED_MODULE_3___default.a.cloneElement(first, {
      key: 'first',
      onEnter: this.handleEnter,
      onEntering: this.handleEntering,
      onEntered: this.handleEntered
    }) : react__WEBPACK_IMPORTED_MODULE_3___default.a.cloneElement(second, {
      key: 'second',
      onEnter: this.handleExit,
      onEntering: this.handleExiting,
      onEntered: this.handleExited
    }));
  };

  return ReplaceTransition;
}(react__WEBPACK_IMPORTED_MODULE_3___default.a.Component);

ReplaceTransition.propTypes =  true ? {
  in: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool.isRequired,
  children: function children(props, propName) {
    if (react__WEBPACK_IMPORTED_MODULE_3___default.a.Children.count(props[propName]) !== 2) return new Error("\"" + propName + "\" must be exactly two transition components.");
    return null;
  }
} : undefined;
/* harmony default export */ __webpack_exports__["default"] = (ReplaceTransition);

/***/ }),

/***/ "./node_modules/react-transition-group/esm/SwitchTransition.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/SwitchTransition.js ***!
  \*********************************************************************/
/*! exports provided: modes, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "modes", function() { return modes; });
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Transition */ "./node_modules/react-transition-group/esm/Transition.js");
/* harmony import */ var _TransitionGroupContext__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TransitionGroupContext */ "./node_modules/react-transition-group/esm/TransitionGroupContext.js");


var _leaveRenders, _enterRenders;






function areChildrenDifferent(oldChildren, newChildren) {
  if (oldChildren === newChildren) return false;

  if (react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(oldChildren) && react__WEBPACK_IMPORTED_MODULE_1___default.a.isValidElement(newChildren) && oldChildren.key != null && oldChildren.key === newChildren.key) {
    return false;
  }

  return true;
}
/**
 * Enum of modes for SwitchTransition component
 * @enum { string }
 */


var modes = {
  out: 'out-in',
  in: 'in-out'
};

var callHook = function callHook(element, name, cb) {
  return function () {
    var _element$props;

    element.props[name] && (_element$props = element.props)[name].apply(_element$props, arguments);
    cb();
  };
};

var leaveRenders = (_leaveRenders = {}, _leaveRenders[modes.out] = function (_ref) {
  var current = _ref.current,
      changeState = _ref.changeState;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(_Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERING"], null);
    })
  });
}, _leaveRenders[modes.in] = function (_ref2) {
  var current = _ref2.current,
      changeState = _ref2.changeState,
      children = _ref2.children;
  return [current, react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(_Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERING"]);
    })
  })];
}, _leaveRenders);
var enterRenders = (_enterRenders = {}, _enterRenders[modes.out] = function (_ref3) {
  var children = _ref3.children,
      changeState = _ref3.changeState;
  return react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(children, {
    in: true,
    onEntered: callHook(children, 'onEntered', function () {
      changeState(_Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERED"], react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(children, {
        in: true
      }));
    })
  });
}, _enterRenders[modes.in] = function (_ref4) {
  var current = _ref4.current,
      children = _ref4.children,
      changeState = _ref4.changeState;
  return [react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(current, {
    in: false,
    onExited: callHook(current, 'onExited', function () {
      changeState(_Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERED"], react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(children, {
        in: true
      }));
    })
  }), react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(children, {
    in: true
  })];
}, _enterRenders);
/**
 * A transition component inspired by the [vue transition modes](https://vuejs.org/v2/guide/transitions.html#Transition-Modes).
 * You can use it when you want to control the render between state transitions.
 * Based on the selected mode and the child's key which is the `Transition` or `CSSTransition` component, the `SwitchTransition` makes a consistent transition between them.
 *
 * If the `out-in` mode is selected, the `SwitchTransition` waits until the old child leaves and then inserts a new child.
 * If the `in-out` mode is selected, the `SwitchTransition` inserts a new child first, waits for the new child to enter and then removes the old child.
 *
 * **Note**: If you want the animation to happen simultaneously
 * (that is, to have the old child removed and a new child inserted **at the same time**),
 * you should use
 * [`TransitionGroup`](https://reactcommunity.org/react-transition-group/transition-group)
 * instead.
 *
 * ```jsx
 * function App() {
 *  const [state, setState] = useState(false);
 *  return (
 *    <SwitchTransition>
 *      <CSSTransition
 *        key={state ? "Goodbye, world!" : "Hello, world!"}
 *        addEndListener={(node, done) => node.addEventListener("transitionend", done, false)}
 *        classNames='fade'
 *      >
 *        <button onClick={() => setState(state => !state)}>
 *          {state ? "Goodbye, world!" : "Hello, world!"}
 *        </button>
 *      </CSSTransition>
 *    </SwitchTransition>
 *  );
 * }
 * ```
 *
 * ```css
 * .fade-enter{
 *    opacity: 0;
 * }
 * .fade-exit{
 *    opacity: 1;
 * }
 * .fade-enter-active{
 *    opacity: 1;
 * }
 * .fade-exit-active{
 *    opacity: 0;
 * }
 * .fade-enter-active,
 * .fade-exit-active{
 *    transition: opacity 500ms;
 * }
 * ```
 */

var SwitchTransition = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(SwitchTransition, _React$Component);

  function SwitchTransition() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.state = {
      status: _Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERED"],
      current: null
    };
    _this.appeared = false;

    _this.changeState = function (status, current) {
      if (current === void 0) {
        current = _this.state.current;
      }

      _this.setState({
        status: status,
        current: current
      });
    };

    return _this;
  }

  var _proto = SwitchTransition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.appeared = true;
  };

  SwitchTransition.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (props.children == null) {
      return {
        current: null
      };
    }

    if (state.status === _Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERING"] && props.mode === modes.in) {
      return {
        status: _Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERING"]
      };
    }

    if (state.current && areChildrenDifferent(state.current, props.children)) {
      return {
        status: _Transition__WEBPACK_IMPORTED_MODULE_3__["EXITING"]
      };
    }

    return {
      current: react__WEBPACK_IMPORTED_MODULE_1___default.a.cloneElement(props.children, {
        in: true
      })
    };
  };

  _proto.render = function render() {
    var _this$props = this.props,
        children = _this$props.children,
        mode = _this$props.mode,
        _this$state = this.state,
        status = _this$state.status,
        current = _this$state.current;
    var data = {
      children: children,
      current: current,
      changeState: this.changeState,
      status: status
    };
    var component;

    switch (status) {
      case _Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERING"]:
        component = enterRenders[mode](data);
        break;

      case _Transition__WEBPACK_IMPORTED_MODULE_3__["EXITING"]:
        component = leaveRenders[mode](data);
        break;

      case _Transition__WEBPACK_IMPORTED_MODULE_3__["ENTERED"]:
        component = current;
    }

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(_TransitionGroupContext__WEBPACK_IMPORTED_MODULE_4__["default"].Provider, {
      value: {
        isMounting: !this.appeared
      }
    }, component);
  };

  return SwitchTransition;
}(react__WEBPACK_IMPORTED_MODULE_1___default.a.Component);

SwitchTransition.propTypes =  true ? {
  /**
   * Transition modes.
   * `out-in`: Current element transitions out first, then when complete, the new element transitions in.
   * `in-out`: New element transitions in first, then when complete, the current element transitions out.
   *
   * @type {'out-in'|'in-out'}
   */
  mode: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOf([modes.in, modes.out]),

  /**
   * Any `Transition` or `CSSTransition` component.
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.element.isRequired])
} : undefined;
SwitchTransition.defaultProps = {
  mode: modes.out
};
/* harmony default export */ __webpack_exports__["default"] = (SwitchTransition);

/***/ }),

/***/ "./node_modules/react-transition-group/esm/Transition.js":
/*!***************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/Transition.js ***!
  \***************************************************************/
/*! exports provided: UNMOUNTED, EXITED, ENTERING, ENTERED, EXITING, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNMOUNTED", function() { return UNMOUNTED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXITED", function() { return EXITED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENTERING", function() { return ENTERING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ENTERED", function() { return ENTERED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXITING", function() { return EXITING; });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ "./node_modules/react-dom/index.js");
/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./node_modules/react-transition-group/esm/config.js");
/* harmony import */ var _utils_PropTypes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/PropTypes */ "./node_modules/react-transition-group/esm/utils/PropTypes.js");
/* harmony import */ var _TransitionGroupContext__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TransitionGroupContext */ "./node_modules/react-transition-group/esm/TransitionGroupContext.js");








var UNMOUNTED = 'unmounted';
var EXITED = 'exited';
var ENTERING = 'entering';
var ENTERED = 'entered';
var EXITING = 'exiting';
/**
 * The Transition component lets you describe a transition from one component
 * state to another _over time_ with a simple declarative API. Most commonly
 * it's used to animate the mounting and unmounting of a component, but can also
 * be used to describe in-place transition states as well.
 *
 * ---
 *
 * **Note**: `Transition` is a platform-agnostic base component. If you're using
 * transitions in CSS, you'll probably want to use
 * [`CSSTransition`](https://reactcommunity.org/react-transition-group/css-transition)
 * instead. It inherits all the features of `Transition`, but contains
 * additional features necessary to play nice with CSS transitions (hence the
 * name of the component).
 *
 * ---
 *
 * By default the `Transition` component does not alter the behavior of the
 * component it renders, it only tracks "enter" and "exit" states for the
 * components. It's up to you to give meaning and effect to those states. For
 * example we can add styles to a component when it enters or exits:
 *
 * ```jsx
 * import { Transition } from 'react-transition-group';
 *
 * const duration = 300;
 *
 * const defaultStyle = {
 *   transition: `opacity ${duration}ms ease-in-out`,
 *   opacity: 0,
 * }
 *
 * const transitionStyles = {
 *   entering: { opacity: 1 },
 *   entered:  { opacity: 1 },
 *   exiting:  { opacity: 0 },
 *   exited:  { opacity: 0 },
 * };
 *
 * const Fade = ({ in: inProp }) => (
 *   <Transition in={inProp} timeout={duration}>
 *     {state => (
 *       <div style={{
 *         ...defaultStyle,
 *         ...transitionStyles[state]
 *       }}>
 *         I'm a fade Transition!
 *       </div>
 *     )}
 *   </Transition>
 * );
 * ```
 *
 * There are 4 main states a Transition can be in:
 *  - `'entering'`
 *  - `'entered'`
 *  - `'exiting'`
 *  - `'exited'`
 *
 * Transition state is toggled via the `in` prop. When `true` the component
 * begins the "Enter" stage. During this stage, the component will shift from
 * its current transition state, to `'entering'` for the duration of the
 * transition and then to the `'entered'` stage once it's complete. Let's take
 * the following example (we'll use the
 * [useState](https://reactjs.org/docs/hooks-reference.html#usestate) hook):
 *
 * ```jsx
 * function App() {
 *   const [inProp, setInProp] = useState(false);
 *   return (
 *     <div>
 *       <Transition in={inProp} timeout={500}>
 *         {state => (
 *           // ...
 *         )}
 *       </Transition>
 *       <button onClick={() => setInProp(true)}>
 *         Click to Enter
 *       </button>
 *     </div>
 *   );
 * }
 * ```
 *
 * When the button is clicked the component will shift to the `'entering'` state
 * and stay there for 500ms (the value of `timeout`) before it finally switches
 * to `'entered'`.
 *
 * When `in` is `false` the same thing happens except the state moves from
 * `'exiting'` to `'exited'`.
 */

var Transition = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(Transition, _React$Component);

  function Transition(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context; // In the context of a TransitionGroup all enters are really appears

    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;

    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }

    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }

  Transition.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;

    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }

    return null;
  } // getSnapshotBeforeUpdate(prevProps) {
  //   let nextStatus = null
  //   if (prevProps !== this.props) {
  //     const { status } = this.state
  //     if (this.props.in) {
  //       if (status !== ENTERING && status !== ENTERED) {
  //         nextStatus = ENTERING
  //       }
  //     } else {
  //       if (status === ENTERING || status === ENTERED) {
  //         nextStatus = EXITING
  //       }
  //     }
  //   }
  //   return { nextStatus }
  // }
  ;

  var _proto = Transition.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;

    if (prevProps !== this.props) {
      var status = this.state.status;

      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }

    this.updateStatus(false, nextStatus);
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };

  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;

    if (timeout != null && typeof timeout !== 'number') {
      exit = timeout.exit;
      enter = timeout.enter; // TODO: remove fallback for next major

      appear = timeout.appear !== undefined ? timeout.appear : enter;
    }

    return {
      exit: exit,
      enter: enter,
      appear: appear
    };
  };

  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }

    if (nextStatus !== null) {
      // nextStatus will always be ENTERING or EXITING.
      this.cancelNextCallback();

      if (nextStatus === ENTERING) {
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };

  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;

    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;

    var _ref2 = this.props.nodeRef ? [appearing] : [react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.findDOMNode(this), appearing],
        maybeNode = _ref2[0],
        maybeAppearing = _ref2[1];

    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter; // no enter animation skip right to ENTERED
    // if we are mounting and running this it means appear _must_ be set

    if (!mounting && !enter || _config__WEBPACK_IMPORTED_MODULE_5__["default"].disabled) {
      this.safeSetState({
        status: ENTERED
      }, function () {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }

    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function () {
      _this2.props.onEntering(maybeNode, maybeAppearing);

      _this2.onTransitionEnd(enterTimeout, function () {
        _this2.safeSetState({
          status: ENTERED
        }, function () {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };

  _proto.performExit = function performExit() {
    var _this3 = this;

    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? undefined : react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.findDOMNode(this); // no exit animation skip right to EXITED

    if (!exit || _config__WEBPACK_IMPORTED_MODULE_5__["default"].disabled) {
      this.safeSetState({
        status: EXITED
      }, function () {
        _this3.props.onExited(maybeNode);
      });
      return;
    }

    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function () {
      _this3.props.onExiting(maybeNode);

      _this3.onTransitionEnd(timeouts.exit, function () {
        _this3.safeSetState({
          status: EXITED
        }, function () {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };

  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };

  _proto.safeSetState = function safeSetState(nextState, callback) {
    // This shouldn't be necessary, but there are weird race conditions with
    // setState callbacks and unmounting in testing, so always make sure that
    // we can cancel any pending setState callbacks after we unmount.
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };

  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;

    var active = true;

    this.nextCallback = function (event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };

    this.nextCallback.cancel = function () {
      active = false;
    };

    return this.nextCallback;
  };

  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node = this.props.nodeRef ? this.props.nodeRef.current : react_dom__WEBPACK_IMPORTED_MODULE_4___default.a.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;

    if (!node || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }

    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node, this.nextCallback],
          maybeNode = _ref3[0],
          maybeNextCallback = _ref3[1];

      this.props.addEndListener(maybeNode, maybeNextCallback);
    }

    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };

  _proto.render = function render() {
    var status = this.state.status;

    if (status === UNMOUNTED) {
      return null;
    }

    var _this$props = this.props,
        children = _this$props.children,
        _in = _this$props.in,
        _mountOnEnter = _this$props.mountOnEnter,
        _unmountOnExit = _this$props.unmountOnExit,
        _appear = _this$props.appear,
        _enter = _this$props.enter,
        _exit = _this$props.exit,
        _timeout = _this$props.timeout,
        _addEndListener = _this$props.addEndListener,
        _onEnter = _this$props.onEnter,
        _onEntering = _this$props.onEntering,
        _onEntered = _this$props.onEntered,
        _onExit = _this$props.onExit,
        _onExiting = _this$props.onExiting,
        _onExited = _this$props.onExited,
        _nodeRef = _this$props.nodeRef,
        childProps = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);

    return (
      /*#__PURE__*/
      // allows for nested Transitions
      react__WEBPACK_IMPORTED_MODULE_3___default.a.createElement(_TransitionGroupContext__WEBPACK_IMPORTED_MODULE_7__["default"].Provider, {
        value: null
      }, typeof children === 'function' ? children(status, childProps) : react__WEBPACK_IMPORTED_MODULE_3___default.a.cloneElement(react__WEBPACK_IMPORTED_MODULE_3___default.a.Children.only(children), childProps))
    );
  };

  return Transition;
}(react__WEBPACK_IMPORTED_MODULE_3___default.a.Component);

Transition.contextType = _TransitionGroupContext__WEBPACK_IMPORTED_MODULE_7__["default"];
Transition.propTypes =  true ? {
  /**
   * A React reference to DOM element that need to transition:
   * https://stackoverflow.com/a/51127130/4671932
   *
   *   - When `nodeRef` prop is used, `node` is not passed to callback functions
   *      (e.g. `onEnter`) because user already has direct access to the node.
   *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
   *     `nodeRef` need to be provided to `Transition` with changed `key` prop
   *     (see
   *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
   */
  nodeRef: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.shape({
    current: typeof Element === 'undefined' ? prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.any : function (propValue, key, componentName, location, propFullName, secret) {
      var value = propValue[key];
      return prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.instanceOf(value && 'ownerDocument' in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location, propFullName, secret);
    }
  }),

  /**
   * A `function` child can be used instead of a React element. This function is
   * called with the current transition status (`'entering'`, `'entered'`,
   * `'exiting'`, `'exited'`), which can be used to apply context
   * specific props to a component.
   *
   * ```jsx
   * <Transition in={this.state.in} timeout={150}>
   *   {state => (
   *     <MyComponent className={`fade fade-${state}`} />
   *   )}
   * </Transition>
   * ```
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func.isRequired, prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.element.isRequired]).isRequired,

  /**
   * Show the component; triggers the enter or exit states
   */
  in: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * By default the child component is mounted immediately along with
   * the parent `Transition` component. If you want to "lazy mount" the component on the
   * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
   * mounted, even on "exited", unless you also specify `unmountOnExit`.
   */
  mountOnEnter: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * By default the child component stays mounted after it reaches the `'exited'` state.
   * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
   */
  unmountOnExit: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * By default the child component does not perform the enter transition when
   * it first mounts, regardless of the value of `in`. If you want this
   * behavior, set both `appear` and `in` to `true`.
   *
   * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
   * > only adds an additional enter transition. However, in the
   * > `<CSSTransition>` component that first enter transition does result in
   * > additional `.appear-*` classes, that way you can choose to style it
   * > differently.
   */
  appear: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * Enable or disable enter transitions.
   */
  enter: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * Enable or disable exit transitions.
   */
  exit: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.bool,

  /**
   * The duration of the transition, in milliseconds.
   * Required unless `addEndListener` is provided.
   *
   * You may specify a single timeout for all transitions:
   *
   * ```jsx
   * timeout={500}
   * ```
   *
   * or individually:
   *
   * ```jsx
   * timeout={{
   *  appear: 500,
   *  enter: 300,
   *  exit: 500,
   * }}
   * ```
   *
   * - `appear` defaults to the value of `enter`
   * - `enter` defaults to `0`
   * - `exit` defaults to `0`
   *
   * @type {number | { enter?: number, exit?: number, appear?: number }}
   */
  timeout: function timeout(props) {
    var pt = _utils_PropTypes__WEBPACK_IMPORTED_MODULE_6__["timeoutsShape"];
    if (!props.addEndListener) pt = pt.isRequired;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    return pt.apply(void 0, [props].concat(args));
  },

  /**
   * Add a custom transition end trigger. Called with the transitioning
   * DOM node and a `done` callback. Allows for more fine grained transition end
   * logic. Timeouts are still used as a fallback if provided.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * ```jsx
   * addEndListener={(node, done) => {
   *   // use the css transitionend event to mark the finish of a transition
   *   node.addEventListener('transitionend', done, false);
   * }}
   * ```
   */
  addEndListener: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired before the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEnter: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired after the "entering" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool)
   */
  onEntering: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired after the "entered" status is applied. An extra parameter
   * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement, isAppearing: bool) -> void
   */
  onEntered: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired before the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExit: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired after the "exiting" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed.
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExiting: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func,

  /**
   * Callback fired after the "exited" status is applied.
   *
   * **Note**: when `nodeRef` prop is passed, `node` is not passed
   *
   * @type Function(node: HtmlElement) -> void
   */
  onExited: prop_types__WEBPACK_IMPORTED_MODULE_2___default.a.func
} : undefined; // Name the function so it is clearer in the documentation

function noop() {}

Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop,
  onEntering: noop,
  onEntered: noop,
  onExit: noop,
  onExiting: noop,
  onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
/* harmony default export */ __webpack_exports__["default"] = (Transition);

/***/ }),

/***/ "./node_modules/react-transition-group/esm/TransitionGroup.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/TransitionGroup.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");
/* harmony import */ var _babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inheritsLoose */ "./node_modules/@babel/runtime/helpers/esm/inheritsLoose.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _TransitionGroupContext__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TransitionGroupContext */ "./node_modules/react-transition-group/esm/TransitionGroupContext.js");
/* harmony import */ var _utils_ChildMapping__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/ChildMapping */ "./node_modules/react-transition-group/esm/utils/ChildMapping.js");









var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (k) {
    return obj[k];
  });
};

var defaultProps = {
  component: 'div',
  childFactory: function childFactory(child) {
    return child;
  }
};
/**
 * The `<TransitionGroup>` component manages a set of transition components
 * (`<Transition>` and `<CSSTransition>`) in a list. Like with the transition
 * components, `<TransitionGroup>` is a state machine for managing the mounting
 * and unmounting of components over time.
 *
 * Consider the example below. As items are removed or added to the TodoList the
 * `in` prop is toggled automatically by the `<TransitionGroup>`.
 *
 * Note that `<TransitionGroup>`  does not define any animation behavior!
 * Exactly _how_ a list item animates is up to the individual transition
 * component. This means you can mix and match animations across different list
 * items.
 */

var TransitionGroup = /*#__PURE__*/function (_React$Component) {
  Object(_babel_runtime_helpers_esm_inheritsLoose__WEBPACK_IMPORTED_MODULE_3__["default"])(TransitionGroup, _React$Component);

  function TransitionGroup(props, context) {
    var _this;

    _this = _React$Component.call(this, props, context) || this;

    var handleExited = _this.handleExited.bind(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_2__["default"])(_this)); // Initial children should all be entering, dependent on appear


    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited: handleExited,
      firstRender: true
    };
    return _this;
  }

  var _proto = TransitionGroup.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  TransitionGroup.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children,
        handleExited = _ref.handleExited,
        firstRender = _ref.firstRender;
    return {
      children: firstRender ? Object(_utils_ChildMapping__WEBPACK_IMPORTED_MODULE_7__["getInitialChildMapping"])(nextProps, handleExited) : Object(_utils_ChildMapping__WEBPACK_IMPORTED_MODULE_7__["getNextChildMapping"])(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  } // node is `undefined` when user provided `nodeRef` prop
  ;

  _proto.handleExited = function handleExited(child, node) {
    var currentChildMapping = Object(_utils_ChildMapping__WEBPACK_IMPORTED_MODULE_7__["getChildMapping"])(this.props.children);
    if (child.key in currentChildMapping) return;

    if (child.props.onExited) {
      child.props.onExited(node);
    }

    if (this.mounted) {
      this.setState(function (state) {
        var children = Object(_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, state.children);

        delete children[child.key];
        return {
          children: children
        };
      });
    }
  };

  _proto.render = function render() {
    var _this$props = this.props,
        Component = _this$props.component,
        childFactory = _this$props.childFactory,
        props = Object(_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(_this$props, ["component", "childFactory"]);

    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory);
    delete props.appear;
    delete props.enter;
    delete props.exit;

    if (Component === null) {
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_TransitionGroupContext__WEBPACK_IMPORTED_MODULE_6__["default"].Provider, {
        value: contextValue
      }, children);
    }

    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(_TransitionGroupContext__WEBPACK_IMPORTED_MODULE_6__["default"].Provider, {
      value: contextValue
    }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_5___default.a.createElement(Component, props, children));
  };

  return TransitionGroup;
}(react__WEBPACK_IMPORTED_MODULE_5___default.a.Component);

TransitionGroup.propTypes =  true ? {
  /**
   * `<TransitionGroup>` renders a `<div>` by default. You can change this
   * behavior by providing a `component` prop.
   * If you use React v16+ and would like to avoid a wrapping `<div>` element
   * you can pass in `component={null}`. This is useful if the wrapping div
   * borks your css styles.
   */
  component: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.any,

  /**
   * A set of `<Transition>` components, that are toggled `in` and out as they
   * leave. the `<TransitionGroup>` will inject specific transition props, so
   * remember to spread them through if you are wrapping the `<Transition>` as
   * with our `<Fade>` example.
   *
   * While this component is meant for multiple `Transition` or `CSSTransition`
   * children, sometimes you may want to have a single transition child with
   * content that you want to be transitioned out and in when you change it
   * (e.g. routes, images etc.) In that case you can change the `key` prop of
   * the transition child as you change its content, this will cause
   * `TransitionGroup` to transition the child out and back in.
   */
  children: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.node,

  /**
   * A convenience prop that enables or disables appear animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  appear: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * A convenience prop that enables or disables enter animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  enter: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * A convenience prop that enables or disables exit animations
   * for all children. Note that specifying this will override any defaults set
   * on individual children Transitions.
   */
  exit: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,

  /**
   * You may need to apply reactive updates to a child as it is exiting.
   * This is generally done by using `cloneElement` however in the case of an exiting
   * child the element has already been removed and not accessible to the consumer.
   *
   * If you do need to update a child as it leaves you can provide a `childFactory`
   * to wrap every child, even the ones that are leaving.
   *
   * @type Function(child: ReactElement) -> ReactElement
   */
  childFactory: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.func
} : undefined;
TransitionGroup.defaultProps = defaultProps;
/* harmony default export */ __webpack_exports__["default"] = (TransitionGroup);

/***/ }),

/***/ "./node_modules/react-transition-group/esm/TransitionGroupContext.js":
/*!***************************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/TransitionGroupContext.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/* harmony default export */ __webpack_exports__["default"] = (react__WEBPACK_IMPORTED_MODULE_0___default.a.createContext(null));

/***/ }),

/***/ "./node_modules/react-transition-group/esm/config.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-transition-group/esm/config.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  disabled: false
});

/***/ }),

/***/ "./node_modules/react-transition-group/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/react-transition-group/esm/index.js ***!
  \**********************************************************/
/*! exports provided: CSSTransition, ReplaceTransition, SwitchTransition, TransitionGroup, Transition, config */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CSSTransition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CSSTransition */ "./node_modules/react-transition-group/esm/CSSTransition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSTransition", function() { return _CSSTransition__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _ReplaceTransition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReplaceTransition */ "./node_modules/react-transition-group/esm/ReplaceTransition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ReplaceTransition", function() { return _ReplaceTransition__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _SwitchTransition__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SwitchTransition */ "./node_modules/react-transition-group/esm/SwitchTransition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SwitchTransition", function() { return _SwitchTransition__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _TransitionGroup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TransitionGroup */ "./node_modules/react-transition-group/esm/TransitionGroup.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransitionGroup", function() { return _TransitionGroup__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _Transition__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Transition */ "./node_modules/react-transition-group/esm/Transition.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transition", function() { return _Transition__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./config */ "./node_modules/react-transition-group/esm/config.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _config__WEBPACK_IMPORTED_MODULE_5__["default"]; });








/***/ }),

/***/ "./node_modules/react-transition-group/esm/utils/ChildMapping.js":
/*!***********************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/utils/ChildMapping.js ***!
  \***********************************************************************/
/*! exports provided: getChildMapping, mergeChildMappings, getInitialChildMapping, getNextChildMapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getChildMapping", function() { return getChildMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mergeChildMappings", function() { return mergeChildMappings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getInitialChildMapping", function() { return getInitialChildMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNextChildMapping", function() { return getNextChildMapping; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Given `this.props.children`, return an object mapping key to child.
 *
 * @param {*} children `this.props.children`
 * @return {object} Mapping of key to child
 */

function getChildMapping(children, mapFn) {
  var mapper = function mapper(child) {
    return mapFn && Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(child) ? mapFn(child) : child;
  };

  var result = Object.create(null);
  if (children) react__WEBPACK_IMPORTED_MODULE_0__["Children"].map(children, function (c) {
    return c;
  }).forEach(function (child) {
    // run the map function here instead so that the key is the computed one
    result[child.key] = mapper(child);
  });
  return result;
}
/**
 * When you're adding or removing children some may be added or removed in the
 * same render pass. We want to show *both* since we want to simultaneously
 * animate elements in and out. This function takes a previous set of keys
 * and a new set of keys and merges them with its best guess of the correct
 * ordering. In the future we may expose some of the utilities in
 * ReactMultiChild to make this easy, but for now React itself does not
 * directly have this concept of the union of prevChildren and nextChildren
 * so we implement it here.
 *
 * @param {object} prev prev children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @param {object} next next children as returned from
 * `ReactTransitionChildMapping.getChildMapping()`.
 * @return {object} a key set that contains all keys in `prev` and all keys
 * in `next` in a reasonable order.
 */

function mergeChildMappings(prev, next) {
  prev = prev || {};
  next = next || {};

  function getValueForKey(key) {
    return key in next ? next[key] : prev[key];
  } // For each key of `next`, the list of keys to insert before that key in
  // the combined list


  var nextKeysPending = Object.create(null);
  var pendingKeys = [];

  for (var prevKey in prev) {
    if (prevKey in next) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }

  var i;
  var childMapping = {};

  for (var nextKey in next) {
    if (nextKeysPending[nextKey]) {
      for (i = 0; i < nextKeysPending[nextKey].length; i++) {
        var pendingNextKey = nextKeysPending[nextKey][i];
        childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
      }
    }

    childMapping[nextKey] = getValueForKey(nextKey);
  } // Finally, add the keys which didn't appear before any key in `next`


  for (i = 0; i < pendingKeys.length; i++) {
    childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
  }

  return childMapping;
}

function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}

function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function (child) {
    return Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, 'appear', props),
      enter: getProp(child, 'enter', props),
      exit: getProp(child, 'exit', props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function (key) {
    var child = children[key];
    if (!Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(child)) return;
    var hasPrev = (key in prevChildMapping);
    var hasNext = (key in nextChildMapping);
    var prevChild = prevChildMapping[key];
    var isLeaving = Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(prevChild) && !prevChild.props.in; // item is new (entering)

    if (hasNext && (!hasPrev || isLeaving)) {
      // console.log('entering', key)
      children[key] = Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      // item is old (exiting)
      // console.log('leaving', key)
      children[key] = Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, {
        in: false
      });
    } else if (hasNext && hasPrev && Object(react__WEBPACK_IMPORTED_MODULE_0__["isValidElement"])(prevChild)) {
      // item hasn't changed transition states
      // copy over the last transition props;
      // console.log('unchanged', key)
      children[key] = Object(react__WEBPACK_IMPORTED_MODULE_0__["cloneElement"])(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, 'exit', nextProps),
        enter: getProp(child, 'enter', nextProps)
      });
    }
  });
  return children;
}

/***/ }),

/***/ "./node_modules/react-transition-group/esm/utils/PropTypes.js":
/*!********************************************************************!*\
  !*** ./node_modules/react-transition-group/esm/utils/PropTypes.js ***!
  \********************************************************************/
/*! exports provided: timeoutsShape, classNamesShape */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeoutsShape", function() { return timeoutsShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "classNamesShape", function() { return classNamesShape; });
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_0__);

var timeoutsShape =  true ? prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
  enter: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,
  exit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number,
  appear: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.number
}).isRequired]) : undefined;
var classNamesShape =  true ? prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string, prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
  enter: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  exit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  active: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
}), prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.shape({
  enter: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  enterDone: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  enterActive: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  exit: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  exitDone: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string,
  exitActive: prop_types__WEBPACK_IMPORTED_MODULE_0___default.a.string
})]) : undefined;

/***/ }),

/***/ "./node_modules/react/index.js":
/*!*******************************************************************************************!*\
  !*** delegated ./node_modules/react/index.js from dll-reference dll_5030f387d328e4415785 ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = (__webpack_require__(/*! dll-reference dll_5030f387d328e4415785 */ "dll-reference dll_5030f387d328e4415785"))("./node_modules/react/index.js");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}


/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./public/images/circle-accent-1.svg":
/*!*******************************************!*\
  !*** ./public/images/circle-accent-1.svg ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function CircleAccent1 (props) {
    return React.createElement("svg",props,[React.createElement("circle",{"cx":"69.5","cy":"203.5","r":"203","stroke":"#4D55BC","key":0}),React.createElement("circle",{"opacity":"0.9","cx":"56.5","cy":"216.5","r":"190","stroke":"#4D55BC","key":1}),React.createElement("circle",{"opacity":"0.8","cx":"39.5","cy":"237.5","r":"181","stroke":"#4D55BC","key":2}),React.createElement("circle",{"opacity":"0.7","cx":"27","cy":"256","r":"167.5","stroke":"#4D55BC","key":3}),React.createElement("circle",{"opacity":"0.6","cx":"10","cy":"269","r":"155.5","stroke":"#4D55BC","key":4}),React.createElement("circle",{"opacity":"0.5","cx":"-7.5","cy":"286.5","r":"138","stroke":"#4D55BC","key":5}),React.createElement("circle",{"opacity":"0.4","cx":"-24","cy":"303","r":"121.5","stroke":"#4D55BC","key":6})]);
}

CircleAccent1.defaultProps = {"id":"accent-circle","width":"273","height":"283","viewBox":"0 0 273 283","fill":"none"};

module.exports = CircleAccent1;

CircleAccent1.default = CircleAccent1;


/***/ }),

/***/ "./public/images/default-avatar.svg":
/*!******************************************!*\
  !*** ./public/images/default-avatar.svg ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function DefaultAvatar (props) {
    return React.createElement("svg",props,[React.createElement("mask",{"id":"mask0","maskType":"alpha","maskUnits":"userSpaceOnUse","x":"0","y":"0","width":"90","height":"90","key":0},React.createElement("circle",{"cx":"45","cy":"45","r":"45","fill":"#7176B8"})),React.createElement("g",{"mask":"url(#mask0)","key":1},[React.createElement("circle",{"cx":"45","cy":"45","r":"45","fill":"#7176B8","key":0}),React.createElement("circle",{"cx":"45","cy":"31","r":"19","fill":"#505593","key":1}),React.createElement("circle",{"cx":"44.5","cy":"82.5","r":"34.5","fill":"#505593","key":2})])]);
}

DefaultAvatar.defaultProps = {"width":"90","height":"90","viewBox":"0 0 90 90","fill":"none"};

module.exports = DefaultAvatar;

DefaultAvatar.default = DefaultAvatar;


/***/ }),

/***/ "./public/images/icon-business-development.svg":
/*!*****************************************************!*\
  !*** ./public/images/icon-business-development.svg ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconBusinessDevelopment (props) {
    return React.createElement("svg",props,[React.createElement("path",{"d":"M44.0833 21.0833H40.2117C40.227 20.7642 40.25 20.446 40.25 20.125C40.25 11.7568 34.9763 4.17163 27.1227 1.24967C27.1074 1.24392 27.0921 1.24008 27.0767 1.23529C27.0729 1.23433 27.07 1.23146 27.0662 1.2305C27.0614 1.22858 27.0566 1.22858 27.0518 1.22763C24.8256 0.414958 22.4969 0 20.125 0C18.5246 0 16.9759 0.207958 15.4828 0.562542C15.3075 0.581708 15.1359 0.627708 14.9711 0.694792C6.36717 2.97946 0 10.8119 0 20.125C0 20.2103 0.0105417 20.2946 0.0115 20.3799C0.014375 20.4298 0.0115 20.4805 0.0182083 20.5285C0.112125 25.1668 1.79592 29.6412 4.80796 33.1631C4.80892 33.1641 4.81083 33.166 4.81179 33.167C4.81371 33.1689 4.81562 33.1708 4.81754 33.1737C8.64896 37.6711 14.2274 40.25 20.125 40.25H37.5389L42.7282 45.4384C43.0943 45.8055 43.585 46 44.0833 46C44.3296 46 44.5798 45.9521 44.8165 45.8543C45.5333 45.5572 46 44.8586 46 44.0833V23C46 21.942 45.1413 21.0833 44.0833 21.0833ZM25.1064 13.1608L27.6077 5.66375C32.9427 8.43908 36.4167 14.0195 36.4167 20.125C36.4167 20.4451 36.4071 20.7652 36.3889 21.0833H31.487C30.9216 19.9851 30.0782 19.0507 29.0135 18.3808L26.3963 16.7574C25.186 15.9984 24.656 14.5178 25.1064 13.1608ZM13.9073 5.07246L14.5216 7.52962C14.836 8.78504 14.3012 10.0759 13.1905 10.7429C11.6438 11.6715 10.5503 13.1464 10.1133 14.8963L9.6945 16.5734C9.34183 17.985 8.027 18.905 6.59142 18.7728C5.72125 18.6904 4.80317 18.606 3.91575 18.5275C4.50992 12.4382 8.47071 7.32646 13.9073 5.07246ZM18.2083 36.3036C15.0305 35.927 12.052 34.6112 9.61496 32.545L10.8598 31.9968C12.5034 31.2666 14.3884 31.2532 16.0387 31.9595L17.7809 32.7022C17.918 32.7625 18.0665 32.8085 18.2083 32.8622V36.3036ZM18.2083 23V28.7184L17.5452 28.4357C14.9222 27.3115 11.9188 27.3326 9.31308 28.4903L7.80563 29.1544C7.49896 29.2895 7.17504 29.4314 6.85975 29.5694C5.33887 27.4409 4.37 24.9713 4.00679 22.3838C4.75046 22.4509 5.5085 22.5208 6.22917 22.5898C6.44863 22.61 6.66712 22.6205 6.88371 22.6205C9.96283 22.6205 12.651 20.5524 13.4128 17.503L13.8316 15.8259C14.0204 15.0698 14.4929 14.4315 15.1627 14.03C17.7292 12.49 18.9664 9.50379 18.24 6.601L17.6027 4.04992C18.4268 3.92054 19.2654 3.83333 20.125 3.83333C21.4446 3.83333 22.746 4.00296 24.0168 4.31442L21.4686 11.9504C20.4595 14.9912 21.6488 18.3032 24.3666 20.01L26.0973 21.0833H20.125C19.067 21.0833 18.2083 21.942 18.2083 23ZM42.1667 39.4555L39.6884 36.9782C39.329 36.6189 38.8412 36.4167 38.3333 36.4167H22.0417V31.4563C22.0417 31.4535 22.0417 31.4506 22.0417 31.4467V24.9167H30.1837C30.1846 24.9167 30.1856 24.9167 30.1865 24.9167C30.1875 24.9167 30.1894 24.9167 30.1904 24.9167H38.1033H42.1667V39.4555Z","key":0}),React.createElement("path",{"d":"M26.8333 28.75H25.875C24.817 28.75 23.9583 29.6087 23.9583 30.6667C23.9583 31.7247 24.817 32.5833 25.875 32.5833H26.8333C27.8913 32.5833 28.75 31.7247 28.75 30.6667C28.75 29.6087 27.8913 28.75 26.8333 28.75Z","key":1}),React.createElement("path",{"d":"M32.5833 28.75H31.625C30.567 28.75 29.7083 29.6087 29.7083 30.6667C29.7083 31.7247 30.567 32.5833 31.625 32.5833H32.5833C33.6413 32.5833 34.5 31.7247 34.5 30.6667C34.5 29.6087 33.6413 28.75 32.5833 28.75Z","key":2}),React.createElement("path",{"d":"M38.3333 28.75H37.375C36.317 28.75 35.4583 29.6087 35.4583 30.6667C35.4583 31.7247 36.317 32.5833 37.375 32.5833H38.3333C39.3913 32.5833 40.25 31.7247 40.25 30.6667C40.25 29.6087 39.3913 28.75 38.3333 28.75Z","key":3})]);
}

IconBusinessDevelopment.defaultProps = {"width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconBusinessDevelopment;

IconBusinessDevelopment.default = IconBusinessDevelopment;


/***/ }),

/***/ "./public/images/icon-content-writer.svg":
/*!***********************************************!*\
  !*** ./public/images/icon-content-writer.svg ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconContentWriter (props) {
    return React.createElement("svg",props,[React.createElement("path",{"d":"M44.0833 9.58333H38.3333V1.91667C38.3333 0.858667 37.4747 0 36.4167 0H5.75C2.57887 0 0 2.57887 0 5.75V40.25C0 43.4211 2.57887 46 5.75 46H40.25C43.4211 46 46 43.4211 46 40.25V11.5C46 10.442 45.1413 9.58333 44.0833 9.58333ZM5.75 42.1667C4.69296 42.1667 3.83333 41.307 3.83333 40.25V5.75C3.83333 4.69296 4.69296 3.83333 5.75 3.83333H34.5V11.5V40.25C34.5 40.9227 34.6227 41.5658 34.8354 42.1667H5.75ZM42.1667 40.25C42.1667 41.307 41.307 42.1667 40.25 42.1667C39.193 42.1667 38.3333 41.307 38.3333 40.25V13.4167H42.1667V40.25Z","key":0}),React.createElement("path",{"d":"M28.75 9.58337H9.58332C8.52532 9.58337 7.66666 10.442 7.66666 11.5C7.66666 12.558 8.52532 13.4167 9.58332 13.4167H28.75C29.808 13.4167 30.6667 12.558 30.6667 11.5C30.6667 10.442 29.808 9.58337 28.75 9.58337Z","key":1}),React.createElement("path",{"d":"M24.9167 21.0834H9.58332C8.52532 21.0834 7.66666 21.942 7.66666 23C7.66666 24.058 8.52532 24.9167 9.58332 24.9167H24.9167C25.9747 24.9167 26.8333 24.058 26.8333 23C26.8333 21.942 25.9747 21.0834 24.9167 21.0834Z","key":2}),React.createElement("path",{"d":"M23 26.8334H9.58332C8.52532 26.8334 7.66666 27.692 7.66666 28.75C7.66666 29.808 8.52532 30.6667 9.58332 30.6667H23C24.058 30.6667 24.9167 29.808 24.9167 28.75C24.9167 27.692 24.058 26.8334 23 26.8334Z","key":3}),React.createElement("path",{"d":"M21.0833 32.5834H9.58332C8.52532 32.5834 7.66666 33.442 7.66666 34.5C7.66666 35.558 8.52532 36.4167 9.58332 36.4167H21.0833C22.1413 36.4167 23 35.558 23 34.5C23 33.442 22.1413 32.5834 21.0833 32.5834Z","key":4})]);
}

IconContentWriter.defaultProps = {"width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconContentWriter;

IconContentWriter.default = IconContentWriter;


/***/ }),

/***/ "./public/images/icon-customer-relationship.svg":
/*!******************************************************!*\
  !*** ./public/images/icon-customer-relationship.svg ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconCustomerRelationship (props) {
    return React.createElement("svg",props,React.createElement("path",{"d":"M36.8958 15.3333H36.4167V13.4167C36.4167 6.01833 30.3983 0 23 0C15.6017 0 9.58333 6.01833 9.58333 13.4167V15.3333H9.10417C4.08442 15.3333 0 19.4177 0 24.4375C0 29.4572 4.08442 33.5417 9.10417 33.5417H14.375C15.433 33.5417 16.2917 32.683 16.2917 31.625V17.25C16.2917 16.192 15.433 15.3333 14.375 15.3333H13.4167V13.4167C13.4167 8.13242 17.7157 3.83333 23 3.83333C28.2843 3.83333 32.5833 8.13242 32.5833 13.4167V15.3333H31.625C30.567 15.3333 29.7083 16.192 29.7083 17.25V31.625C29.7083 32.683 30.567 33.5417 31.625 33.5417H32.5833V40.25C32.5833 41.307 31.7237 42.1667 30.6667 42.1667H29.7083V41.2083C29.7083 40.1503 28.8497 39.2917 27.7917 39.2917H21.0833C20.0253 39.2917 19.1667 40.1503 19.1667 41.2083V44.0833C19.1667 45.1413 20.0253 46 21.0833 46H27.7917H30.6667C33.8378 46 36.4167 43.4211 36.4167 40.25V33.5417H36.8958C41.9156 33.5417 46 29.4572 46 24.4375C46 19.4177 41.9156 15.3333 36.8958 15.3333ZM12.4583 23H11.5C10.442 23 9.58333 23.8587 9.58333 24.9167C9.58333 25.9747 10.442 26.8333 11.5 26.8333H12.4583V29.7083H9.10417C6.1985 29.7083 3.83333 27.3441 3.83333 24.4375C3.83333 21.5309 6.1985 19.1667 9.10417 19.1667H12.4583V23ZM36.8958 29.7083H33.5417V26.8333H34.5C35.558 26.8333 36.4167 25.9747 36.4167 24.9167C36.4167 23.8587 35.558 23 34.5 23H33.5417V19.1667H36.8958C39.8015 19.1667 42.1667 21.5309 42.1667 24.4375C42.1667 27.3441 39.8015 29.7083 36.8958 29.7083Z"}));
}

IconCustomerRelationship.defaultProps = {"width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconCustomerRelationship;

IconCustomerRelationship.default = IconCustomerRelationship;


/***/ }),

/***/ "./public/images/icon-game-development.svg":
/*!*************************************************!*\
  !*** ./public/images/icon-game-development.svg ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconGameDevelopment (props) {
    return React.createElement("svg",props,[React.createElement("path",{"d":"M18.6051 10.1449C17.8574 9.39662 16.6426 9.39662 15.8949 10.1449L14.375 11.6647L12.8551 10.1449C12.1074 9.39662 10.8926 9.39662 10.1449 10.1449C9.39662 10.8935 9.39662 12.1064 10.1449 12.8551L11.6647 14.375L10.1449 15.8949C9.39662 16.6435 9.39662 17.8564 10.1449 18.6051C10.5187 18.98 11.0091 19.1667 11.5 19.1667C11.9909 19.1667 12.4813 18.98 12.8551 18.6051L14.375 17.0853L15.8949 18.6051C16.2687 18.98 16.7591 19.1667 17.25 19.1667C17.7409 19.1667 18.2313 18.98 18.6051 18.6051C19.3534 17.8564 19.3534 16.6435 18.6051 15.8949L17.0853 14.375L18.6051 12.8551C19.3534 12.1064 19.3534 10.8935 18.6051 10.1449Z","key":0}),React.createElement("path",{"d":"M31.625 24.9167C27.926 24.9167 24.9167 27.9269 24.9167 31.625C24.9167 35.3231 27.926 38.3334 31.625 38.3334C35.324 38.3334 38.3333 35.3231 38.3333 31.625C38.3333 27.9269 35.324 24.9167 31.625 24.9167ZM31.625 34.5C30.0401 34.5 28.75 33.2099 28.75 31.625C28.75 30.0401 30.0401 28.75 31.625 28.75C33.2099 28.75 34.5 30.0401 34.5 31.625C34.5 33.2099 33.2099 34.5 31.625 34.5Z","key":1}),React.createElement("path",{"d":"M45.4385 0.561523C44.6907 -0.186707 43.476 -0.186707 42.7282 0.561523L36.7643 6.52537C35.0405 5.50948 32.8402 5.51229 31.1182 6.6606L28.6419 8.31242L24.54 4.21096C24.5278 4.19832 24.5124 4.1899 24.4997 4.1782C21.7913 1.48429 18.1999 0 14.375 0C10.5332 0 6.92405 1.49693 4.21377 4.21096C1.49693 6.92405 0 10.5332 0 14.375C0 18.2168 1.49693 21.8259 4.21096 24.5362C6.9423 27.2751 10.5847 28.7608 14.3549 28.7608C15.0058 28.7608 15.6609 28.699 16.3155 28.6091L17.3792 29.6737C16.7652 34.1214 18.2504 38.5855 21.4619 41.7872C24.1741 44.5031 27.7832 46 31.625 46C35.4668 46 39.0759 44.5031 41.7862 41.789C44.5031 39.0759 46 35.4668 46 31.625C46 27.7992 44.5148 24.2054 41.819 21.4965C41.8082 21.4848 41.8007 21.4713 41.789 21.461L37.8149 17.4868L39.4873 14.8064C40.5799 13.0564 40.5373 10.9057 39.4929 9.21647L45.4385 3.27087C46.1867 2.52311 46.1867 1.31022 45.4385 0.561523ZM39.075 39.0778C37.0877 41.0694 34.4415 42.1667 31.625 42.1667C28.8085 42.1667 26.1623 41.0694 24.1712 39.075C21.6285 36.5393 20.5583 32.9301 21.3084 29.4191C21.3093 29.414 21.3093 29.4093 21.3103 29.4046C21.3285 29.3162 21.3346 29.2273 21.3402 29.137C21.3421 29.1 21.3505 29.0616 21.3505 29.0251C21.3505 28.954 21.3393 28.8834 21.3313 28.8122C21.3257 28.7594 21.3267 28.706 21.3164 28.6541C21.3075 28.6091 21.2892 28.5661 21.2771 28.5221C21.2569 28.4482 21.2406 28.3724 21.2115 28.3017C21.1938 28.2563 21.1666 28.2161 21.1446 28.1721C21.1109 28.1042 21.0805 28.035 21.0393 27.9718C21.0174 27.9381 20.9883 27.9096 20.9645 27.8778C20.9125 27.808 20.8611 27.7379 20.7998 27.6756C20.796 27.6719 20.7941 27.6672 20.7899 27.6635L18.3365 25.2091C18.3319 25.204 18.3263 25.2012 18.3225 25.1965C18.2687 25.1436 18.2074 25.0996 18.147 25.0538C18.1059 25.022 18.0684 24.9855 18.0254 24.9578C17.9762 24.926 17.922 24.9031 17.87 24.8764C17.8125 24.8455 17.7568 24.8104 17.6973 24.7861C17.5893 24.7421 17.4751 24.7098 17.359 24.6855C17.3553 24.6846 17.3515 24.6827 17.3469 24.6818C17.2584 24.6644 17.1667 24.6607 17.0755 24.656C17.0432 24.6542 17.0104 24.6476 16.9777 24.6476C16.9215 24.6476 16.8649 24.6588 16.8073 24.6635C16.7371 24.6705 16.6665 24.6733 16.5972 24.6864C16.5916 24.6878 16.5851 24.6878 16.579 24.6888C13.0657 25.4389 9.45886 24.3715 6.92031 21.8241C4.93064 19.8377 3.83333 17.1915 3.83333 14.375C3.83333 11.5585 4.93064 8.91231 6.92499 6.92218C8.91231 4.93064 11.5585 3.83333 14.375 3.83333C17.1915 3.83333 19.8377 4.93064 21.825 6.92218C21.833 6.92967 21.8423 6.93528 21.8507 6.94324L27.0219 12.1144C27.0392 12.1326 27.0575 12.1509 27.0757 12.1677L34.0283 19.1208C34.0456 19.1381 34.0629 19.1559 34.0812 19.1732L39.054 24.146C39.0628 24.1549 39.0685 24.1652 39.0769 24.175C41.0694 26.1623 42.1667 28.8085 42.1667 31.625C42.1667 34.4415 41.0694 37.0877 39.075 39.0778ZM31.4055 11.0775L33.2445 9.85052C33.829 9.4598 34.617 9.53748 35.1153 10.0349L36.0255 10.945C36.5154 11.4359 36.6015 12.1893 36.2346 12.7775L35.033 14.7049L31.4055 11.0775Z","key":2}),React.createElement("path",{"d":"M26.2718 24.3551C27.02 23.6064 27.02 22.3935 26.2718 21.6448L24.3551 19.7282C23.6074 18.9799 22.3926 18.9799 21.6449 19.7282C20.8966 20.4769 20.8966 21.6898 21.6449 22.4385L23.5615 24.3551C23.9354 24.7299 24.4258 24.9166 24.9167 24.9166C25.4075 24.9166 25.8979 24.7299 26.2718 24.3551Z","key":3})]);
}

IconGameDevelopment.defaultProps = {"width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconGameDevelopment;

IconGameDevelopment.default = IconGameDevelopment;


/***/ }),

/***/ "./public/images/icon-play.svg":
/*!*************************************!*\
  !*** ./public/images/icon-play.svg ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconPlay (props) {
    return React.createElement("svg",props,[React.createElement("circle",{"cx":"23","cy":"23","r":"23","key":0}),React.createElement("path",{"d":"M32 21.2679C33.3333 22.0377 33.3333 23.9623 32 24.7321L20 31.6603C18.6667 32.4301 17 31.4678 17 29.9282L17 16.0718C17 14.5322 18.6667 13.5699 20 14.3397L32 21.2679Z","fill":"white","key":1})]);
}

IconPlay.defaultProps = {"className":"icon","width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconPlay;

IconPlay.default = IconPlay;


/***/ }),

/***/ "./public/images/icon-product-advertisement.svg":
/*!******************************************************!*\
  !*** ./public/images/icon-product-advertisement.svg ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconProductAdvertisement (props) {
    return React.createElement("svg",props,React.createElement("path",{"d":"M45.441 23.5616L43.5244 21.645L29.16 7.28056C29.158 7.27865 29.1561 7.27673 29.1533 7.27386L24.3578 2.47837L22.4411 0.561708C21.6936 -0.186748 20.4784 -0.186748 19.7309 0.561708C18.9825 1.31016 18.9825 2.52341 19.7309 3.27187L20.5695 4.11041L3.48724 31.441L3.27449 31.2283C2.52699 30.4798 1.31183 30.4798 0.564333 31.2283C-0.184123 31.9767 -0.184123 33.19 0.564333 33.9384L2.48099 35.8551L10.1476 43.5218L12.0643 45.4384C12.4381 45.8131 12.9287 46 13.4194 46C13.91 46 14.4007 45.8131 14.7745 45.4384C15.5229 44.69 15.5229 43.4767 14.7745 42.7283L14.5617 42.5155L16.8818 41.0656C17.9302 43.4048 20.2772 45.0417 23.0027 45.0417C26.7018 45.0417 29.711 42.0325 29.711 38.3334C29.711 36.7099 29.1283 35.2082 28.1384 34.0295L41.8923 25.4333L42.7309 26.2718C43.1046 26.6465 43.5953 26.8334 44.086 26.8334C44.5766 26.8334 45.0673 26.6465 45.441 26.2718C46.1895 25.5233 46.1895 24.3101 45.441 23.5616ZM23.0027 41.2083C21.6428 41.2083 20.5014 40.2596 20.2034 38.9888L24.8178 36.1052C25.4733 36.6429 25.8777 37.4613 25.8777 38.3334C25.8777 39.9184 24.5878 41.2083 23.0027 41.2083ZM23.0257 32.7041L17.2144 36.3343C17.2096 36.3372 17.2067 36.341 17.2019 36.3439L11.7797 39.7325L6.26928 34.2221L23.3515 6.89148L25.3286 8.86852L16.6164 21.9363C16.0289 22.817 16.2675 24.0073 17.1482 24.5938C17.4741 24.8132 17.844 24.9167 18.2091 24.9167C18.8282 24.9167 19.4367 24.6168 19.8057 24.0628L28.0924 11.6333L39.1103 22.6512L23.0257 32.7041Z"}));
}

IconProductAdvertisement.defaultProps = {"width":"47","height":"46","viewBox":"0 0 47 46","fill":"none"};

module.exports = IconProductAdvertisement;

IconProductAdvertisement.default = IconProductAdvertisement;


/***/ }),

/***/ "./public/images/icon-travel-guidance.svg":
/*!************************************************!*\
  !*** ./public/images/icon-travel-guidance.svg ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function IconTravelGuidance (props) {
    return React.createElement("svg",props,React.createElement("path",{"d":"M1.91667 46H44.0833C45.1413 46 46 45.1413 46 44.0833V32.6849C46 29.597 44.7927 26.699 42.6009 24.5245C40.4082 22.3482 37.5215 21.205 34.4088 21.1877C29.1304 21.2289 26.3659 21.2195 24.9167 21.1956V1.91667C24.9167 0.858663 24.058 0 23 0H1.91667C0.858663 0 0 0.858663 0 1.91667V44.0833C0 45.1413 0.858663 46 1.91667 46ZM3.83333 38.3333H7.66667V42.1667H3.83333V38.3333ZM21.0833 38.3333V42.1667H11.5V38.3333H21.0833ZM34.5 38.3333V42.1667H24.9167V38.3333H34.5ZM38.3333 42.1667V38.3333H42.1667V42.1667H38.3333ZM21.0833 3.83333V7.66667H17.25C16.192 7.66667 15.3333 8.52533 15.3333 9.58333C15.3333 10.6413 16.192 11.5 17.25 11.5H21.0833V15.3333H17.25C16.192 15.3333 15.3333 16.192 15.3333 17.25C15.3333 18.308 16.192 19.1667 17.25 19.1667H21.0833V22.9223C21.0707 23.2003 21.118 23.4829 21.2289 23.7496C21.804 25.1216 21.8068 25.1216 34.4387 25.022C36.4972 25.0355 38.4396 25.7964 39.9 27.2465C41.3618 28.6953 42.1667 30.6264 42.1667 32.6849V34.5H3.83333V3.83333H21.0833Z"}));
}

IconTravelGuidance.defaultProps = {"width":"46","height":"46","viewBox":"0 0 46 46","fill":"none"};

module.exports = IconTravelGuidance;

IconTravelGuidance.default = IconTravelGuidance;


/***/ }),

/***/ "./public/images/logo_jcpro.svg":
/*!**************************************!*\
  !*** ./public/images/logo_jcpro.svg ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var React = __webpack_require__(/*! react */ "./node_modules/react/index.js");

function LogoJcpro (props) {
    return React.createElement("svg",props,[React.createElement("rect",{"width":"93","height":"61","fill":"url(#pattern0)","key":0}),React.createElement("defs",{"key":1},[React.createElement("pattern",{"id":"pattern0","patternContentUnits":"objectBoundingBox","width":"1","height":"1","key":0},React.createElement("use",{"xlinkHref":"#image0_265:25","transform":"translate(0 -0.262295) scale(0.000282167 0.000430189)"})),React.createElement("image",{"id":"image0_265:25","width":"3544","height":"3544","xlinkHref":"data:image/png;base64,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HfVvuZPRg0QBBpjdfQAAAAAAAAAAAAAAAABQM9cBAAAAAAAAAAAAAAAAAHDBYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAAAAACDJYAcAAAAAAAAAAAAAAABAksEOAAAAAAAAAAAAAAAAgCSDHQAAAAAAAAAAAAAAAABJBjsAAAAAAAAAAAAAAAAAkgx2AAAAAAAAAAAAAAAAACQZ7AAAAAAAAAAAAAAAAABIMtgBAAAAAAAAAAAAAAAAkGSwAwAAAAAAAAAAAPjs24EAAAAAgCB/60EujwAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAA42FEmgAAIABJREFUAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAiL17AdKrLBM8/rznfN3pdC7kwiUJmEEQRMQyhCSEEAiEW4SRcUZGvDA75exa407VWo7Kqow1KXZnanaBCIgWjgGdLWuWcnTUWq3yguMScyWEcFlABC94Q0BEiFyT7vPu+RKuzsggAqfT7+9XvN855/06naeT7q9TdP3rAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAAAAAAAAAQJEEdgAAAAAAAAAAAAAAAAAUSWAHAAAAAAAAv6WqqtKrV/7TwFAM9UanTRkc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AAAAAACglRTsAAAAAAAAAAAAAAAAAGglBTsAAAAAAAAAAAAAAAAAWknBDgAAAAAAAAAAAAAAAIBWUrADAAAAAAAAAAAAAAAAoJUU7AAAAAAAAAAAAAAAAABoJQU7AAAAAAAAAAAAAAAAAFpJwQ4AAAAAAAAAAAAAAACAVlKwAwAAAAAAAAAAAAAAAKCVFOwAAAAAAAAAAAAAAAAAaCUFOwAAAAAAAAAAAAAAAABaScEOAAAAAAAAAAAAAAAAgFZSsAMAAAAAAAAAAAAAAACglRTsAAAAAAAAAAAAAAAAAGglBTsAAAAAAAAAAAAAAAAAWknBDgAAAAAAAAAAAAAAAIBWUrADAAAAAAAAAAAAAAAAoJUU7AAAAAAAAAAAAAAAAABoJQU7AAAAAAAAAAAAAAAAAFpJwQ4AAAAAAAAAAAAAAACAVlKwAwAAAAAAAAAAAAAAAKCVFOwAAAAAAAAAAAAAAAAAaCUFOwAAAAAAAAAAAAAAAABaScEOAAAAAAAAAAAAAAAAgFZSsAMAAAAAAAAAAAAAAACglRTsAAAAAAAAAAAAAAAAAGglBTsAAAAAAAAAAAAAAAAAWknBDgAAAAAAAAAAAAAAAIBWUrADAAAAAAAAAAAAAAAAoJUU7AAAAAAAAAAAAAAAAABoJQU7AAAAAAAAAAAAAAAAAFpJwQ4AAAAAAAAAAAAAAACAVlKwAwAAAAAAAAAAAAAAAKCVFOwAAAAAAAAAAAAAAAAAaCUFOwAAAAAAAAAAAAAAAABaScEOAAAAAAAAAAAAAAAAgFZSsAMAAAAAAAAAAAAAAACglRTsAAAAAAAAAAAAAAAAAGglBTsAAAAAAAAAAAAAAAAAWknBDgAAAAAAAAAAAAAAAIBWUrADAAAAAAAAAAAAAAAAoJUU7AAAAAAAAAAAAAAAAABoJQU7AAAAAAAAAAAAAAAAAFpJwQ4AAAAAAAAAAAAAAACAVlKwAwAAAAAAAAAAAAAAAKCVFOwAAAAAAAAAAAAAAAAAaCUFOwAAAAAAAAAAAAAAAABaScEOAAAAAAAAAAAAAAAAgFZSsAMAAAAAAAAAAAAAAACglRTsAAAAAAAAAAAAAAAAAGglBTsAAAAAAAAAAAAAAAAAWknBDgAAAAAAAAAAAAAAAIBWUrADAAAAAAAAAAAAAAAAoJUU7AAAAAAAAAAAAAAAAABoJQU7AAAA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AAAAAAAAAKCTBOwAAAAAAAAAAAAAAAAA6CQBOwAAAAAAAAAAAAAAAAA6ScAOAAAAAAAAAAAAAAAAgE4SsAMAAAAAAAAAAAAAAACgkwTsAAAAAAAAAAAAAAAAAOgkATsAAAAAAAAAAAAAAAAAOknADgAAAAAAAAAAAAAAAIBOErADAAAAAAAAAAAAAAAAoJME7AAAAAAAAAAAAAAAAADoJAE7AAAAAAAAAAAAAAAAADpJwA4AAAAAAAAAAAAAAACAThKwAwAAAAAAAAAAAAAAAKCTBOwAAAAAAAAAAAAAAAAA6CQBOwAAAAAAAAAAAAAAAAA6ScAOAAAAAAAAAAAAAAAAgE4SsAMAAAAAAAAAAAAAAACgkwTsAAAAAAAAAAAAAAAAAOgkATsAAAAAAAAAAAAAAAAAOknADgAAAAAAAAAAAAAAAIBOErADAAAAAAAAAAAAAAAAoJME7AAAAAAAAAAAAAAAAADoJAE7AAAAAAAAAAAAAAAAADpJwA4AAAAAAAAAAAAAAACAThKwAwAAAAAAAAAAAAAAAKCTBOwAAAAAAAAAAAAAAAAA6CQBOwAAAAAAAAAAAAAAAAA6ScAOAAAAAAAAAAAAAAAAgE4SsAMAAAAAAAAAAAAAAACgkwTsAAAAAAAAAAAAAAAAAOgkATsAAAAAAAAAAAAAAAAAOknADgAAAAAAAAAAAAAAAIBOErADAAAAAAAAAAAAAAAAoJME7AAAAAAAAAAAAAAAAADoJAE7AAAAAAAAAAAAAAAAADpJwA4AAAAAAAAAAAAAAACAThKwAwAAAAAAAAAAAAAAAKCTBOwAAAAAAAAAAAAAAAAA6CQBOwAAAAAAAAAAAAAAAAA6ScAOAAAAAAAAAAAAAAAAgE4SsAMAAAAAAAAAAAAAAACgkwTsAAAAAAAAAAAAAAAAAOgkATsAAAAAAAAAAAAAAAAAOknADgAAAAAAAAAAAAAAAIBOErADAAAAAAAAAAAAAAAAoJME7AAAAAAAAAAAAAAAAADoJAE7AAAAAAAAAAAAAAAAADpJwA4AAAAAAAAAAAAAAACAThKwAwAAAAAAAAAAAAAAAKCTBOwAAAAAAAAAAAAAAAAA6CQBOwAAAAAAAAAAAAAAAAA6ScAOAAAAAAAAAAAAAAAAgE4SsAMAAAAAAAAAAAAAAACgkwTsAAAAAAAAAAAAAAAAAOgkATsA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AAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAAAAAAAAAAAQCcp2AEAAAAAAAAAAAAAAADQSQp2AAAAAAAAAAAAAAAAAHSSgh0AAAAAAAAAAAAAAAAAnaRgBwAAAAAAAAAAAAAAAEAnKdgBAAAAAAAAAAAAAAAA0EkKdgAAAAAAAAAAAAAAAAB0koIdAAAAAAAAAAAAAAAAAJ2kYAcAAAAAAAAAAAAAAABAJynYAQAAAAAAAAAAAAAAANBJCnYAAAAAAAAAAAAAAAAAdJKCHQAAAAAAAAAAAAAAAACdpGAHAAAAAAD/P/t2IAAAAAAgyN96kMsjAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAAB7w4VcAAAgAElEQVRgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAAAAAAAAAAAAAABgSbADAAAAAAAAAAAAAAAAYEmwAwAAAAAAAAAAAAAAAGBJsAMAAABi3w4EAAAAAAT5Ww9yeQQAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AAAAAAAAAAAAAAAAAS4IdAAAAAAAAAAAAAAAAAEuCHQAAAAAAAAAAAAAAAABLgh0AQO3bgQAAAACAIH/rQS6PAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7AAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWBLsAAAAAAAAAAAAAAAAAFgS7PPMMWwAAAAjSURBVAAAAAAAAAAAAAAAAABYEuwAAAAAAAAAAAAAAAAAWApwoNoZJZvJqgAAAABJRU5ErkJggg==","key":1})])]);
}

LogoJcpro.defaultProps = {"width":"93","height":"61","viewBox":"0 0 93 61","fill":"none"};

module.exports = LogoJcpro;

LogoJcpro.default = LogoJcpro;


/***/ }),

/***/ "./src/configs/axios/errorHandler.js":
/*!*******************************************!*\
  !*** ./src/configs/axios/errorHandler.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return errorHandler; });
/* harmony import */ var react_toastify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-toastify */ "./node_modules/react-toastify/dist/react-toastify.esm.js");

function errorHandler(error) {
  if (error) {
    var message;

    if (error.response) {
      if (error.response.status === 500) message = "Something went terribly wrong";else message = error.response.data.message;
      if (typeof message === "string") react_toastify__WEBPACK_IMPORTED_MODULE_0__["toast"].error(message);
      return Promise.reject(error);
    }
  }
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/configs/axios/index.js":
/*!************************************!*\
  !*** ./src/configs/axios/index.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ "./node_modules/axios/index.js");
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _errorHandler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errorHandler */ "./src/configs/axios/errorHandler.js");


var instance = axios__WEBPACK_IMPORTED_MODULE_0___default.a.create({
  baseURL: "".concat("https://api.bwamicro.com")
});
instance.interceptors.response.use(function (response) {
  return response.data;
}, _errorHandler__WEBPACK_IMPORTED_MODULE_1__["default"]);
/* harmony default export */ __webpack_exports__["default"] = (instance);

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/constants/api/courses.js":
/*!**************************************!*\
  !*** ./src/constants/api/courses.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var src_configs_axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/configs/axios */ "./src/configs/axios/index.js");

/* harmony default export */ __webpack_exports__["default"] = ({
  all: function all() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      params: {
        status: "published"
      }
    };
    return src_configs_axios__WEBPACK_IMPORTED_MODULE_0__["default"].get("/courses", options).then(function (res) {
      return res.data;
    });
  },
  details: function details(id) {
    return src_configs_axios__WEBPACK_IMPORTED_MODULE_0__["default"].get("/courses/".concat(id)).then(function (res) {
      return res.data;
    });
  }
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/helpers/formatThousand.js":
/*!***************************************!*\
  !*** ./src/helpers/formatThousand.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony default export */ __webpack_exports__["default"] = (function () {
  var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var thousand = new Intl.NumberFormat();
  return thousand.format(number);
});

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/pages/index.js":
/*!****************************!*\
  !*** ./src/pages/index.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "./node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/head */ "./node_modules/next/dist/next-server/lib/head.js");
/* harmony import */ var next_head__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_head__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var src_configs_axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! src/configs/axios */ "./src/configs/axios/index.js");
/* harmony import */ var public_images_circle_accent_1_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! public/images/circle-accent-1.svg */ "./public/images/circle-accent-1.svg");
/* harmony import */ var public_images_circle_accent_1_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(public_images_circle_accent_1_svg__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var src_parts_Header__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! src/parts/Header */ "./src/parts/Header.js");
/* harmony import */ var src_parts_Hero__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! src/parts/Hero */ "./src/parts/Hero.js");
/* harmony import */ var src_parts_Clients__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! src/parts/Clients */ "./src/parts/Clients.js");
/* harmony import */ var src_parts_ListCourses__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! src/parts/ListCourses */ "./src/parts/ListCourses/index.js");
/* harmony import */ var src_parts_ListCategories__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! src/parts/ListCategories */ "./src/parts/ListCategories/index.js");
/* harmony import */ var src_parts_Footer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! src/parts/Footer */ "./src/parts/Footer.js");
/* harmony import */ var src_constants_api_courses__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! src/constants/api/courses */ "./src/constants/api/courses.js");


var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\pages\\index.js";

var __jsx = react__WEBPACK_IMPORTED_MODULE_2___default.a.createElement;











function Home(_ref) {
  var data = _ref.data;
  return __jsx(react__WEBPACK_IMPORTED_MODULE_2___default.a.Fragment, null, __jsx(next_head__WEBPACK_IMPORTED_MODULE_3___default.a, {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 7
    }
  }, __jsx("title", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 9
    }
  }, "ETNIPRO INDONESIA"), __jsx("link", {
    rel: "icon",
    href: "/favicon.ico",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 9
    }
  })), __jsx("main", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 7
    }
  }, __jsx("section", {
    className: "header-clipping pt-10 min-h-screen md:min-h-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 9
    }
  }, __jsx("div", {
    className: "sunshine max-w-full",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 11
    }
  }), __jsx(public_images_circle_accent_1_svg__WEBPACK_IMPORTED_MODULE_5___default.a, {
    className: "absolute left-0 bottom-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 11
    }
  }), __jsx("div", {
    className: "container mx-auto px-4",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 11
    }
  }, __jsx(src_parts_Header__WEBPACK_IMPORTED_MODULE_6__["default"], {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 13
    }
  }), __jsx(src_parts_Hero__WEBPACK_IMPORTED_MODULE_7__["default"], {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 13
    }
  }))), __jsx("section", {
    className: "container px-4 mx-auto md:pt-24",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 33,
      columnNumber: 9
    }
  }, __jsx(src_parts_Clients__WEBPACK_IMPORTED_MODULE_8__["default"], {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 11
    }
  })), __jsx("section", {
    className: "container px-4 mx-auto md:pt-24",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 9
    }
  }, __jsx(src_parts_ListCourses__WEBPACK_IMPORTED_MODULE_9__["default"], {
    data: data,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 11
    }
  })), __jsx("section", {
    className: "container px-4 mx-auto md:pt-24",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 39,
      columnNumber: 9
    }
  }, __jsx(src_parts_ListCategories__WEBPACK_IMPORTED_MODULE_10__["default"], {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 40,
      columnNumber: 11
    }
  })), __jsx("section", {
    className: "mt-24 bg-indigo-1000 py-12",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 9
    }
  }, __jsx(src_parts_Footer__WEBPACK_IMPORTED_MODULE_11__["default"], {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 11
    }
  }))));
}

_c = Home;
Home.getInitialProps = /*#__PURE__*/Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])( /*#__PURE__*/_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee() {
  var data;
  return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.prev = 0;
          _context.next = 3;
          return src_constants_api_courses__WEBPACK_IMPORTED_MODULE_12__["default"].all();

        case 3:
          data = _context.sent;
          return _context.abrupt("return", {
            data: data.data
          });

        case 7:
          _context.prev = 7;
          _context.t0 = _context["catch"](0);
          return _context.abrupt("return", _context.t0);

        case 10:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[0, 7]]);
}));
/* harmony default export */ __webpack_exports__["default"] = (Home);

var _c;

$RefreshReg$(_c, "Home");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/Clients.js":
/*!******************************!*\
  !*** ./src/parts/Clients.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Clients; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\Clients.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function Clients() {
  return __jsx("div", {
    className: "flex flex-wrap justify-center items-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 5,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "w-full sm:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 6,
      columnNumber: 7
    }
  }, __jsx("img", {
    src: "/images/logo-amazon.svg",
    alt: "logo amazon",
    className: "mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 7,
      columnNumber: 9
    }
  })), __jsx("div", {
    className: "w-full sm:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }
  }, __jsx("img", {
    src: "/images/logo-microsoft.svg",
    alt: "logo microsoft",
    className: "mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 9
    }
  })), __jsx("div", {
    className: "w-full sm:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 7
    }
  }, __jsx("img", {
    src: "/images/logo-tesla.svg",
    alt: "logo tesla",
    className: "mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 9
    }
  })), __jsx("div", {
    className: "w-full sm:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 7
    }
  }, __jsx("img", {
    src: "/images/logo-google.svg",
    alt: "logo google",
    className: "mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 9
    }
  })), __jsx("div", {
    className: "w-full sm:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 34,
      columnNumber: 7
    }
  }, __jsx("img", {
    src: "/images/logo-facebook.svg",
    alt: "logo facebook",
    className: "mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 9
    }
  })));
}
_c = Clients;

var _c;

$RefreshReg$(_c, "Clients");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/Footer.js":
/*!*****************************!*\
  !*** ./src/parts/Footer.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Footer; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\Footer.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;


function Footer() {
  function submit() {}

  return __jsx("footer", {
    className: "container px-4 mx-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "flex flex-wrap justify-between",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }
  }, __jsx("div", {
    className: "w-full md:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 9
    }
  }, __jsx("h6", {
    className: "text-white",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 11
    }
  }, "Company"), __jsx("ul", {
    className: "mt-4",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 11
    }
  }, __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 17
    }
  }, "API Developer"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 23,
      columnNumber: 17
    }
  }, "Career"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 28,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 29,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 30,
      columnNumber: 17
    }
  }, "Our Story"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 35,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 17
    }
  }, "New Soon"))))), __jsx("div", {
    className: "w-full md:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 9
    }
  }, __jsx("h6", {
    className: "text-white",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 11
    }
  }, "Student"), __jsx("ul", {
    className: "mt-4",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 11
    }
  }, __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 47,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 48,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 49,
      columnNumber: 17
    }
  }, "Get Scholarship"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 54,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 55,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 56,
      columnNumber: 17
    }
  }, "Our Pathskills"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 61,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 62,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 63,
      columnNumber: 17
    }
  }, "All Features"))), __jsx("li", {
    className: "mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 13
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 15
    }
  }, __jsx("a", {
    className: "text-indigo-500 hover:text-teal-500 hover:underline",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 17
    }
  }, "Refund Policy"))))), __jsx("div", {
    className: "w-full md:w-1/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 77,
      columnNumber: 9
    }
  }, __jsx("h6", {
    className: "text-white",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 78,
      columnNumber: 11
    }
  }, "Touch Us"), __jsx("p", {
    className: "mt-4 text-indigo-500 leading-loose",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 79,
      columnNumber: 11
    }
  }, "Jepara", __jsx("br", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 80,
      columnNumber: 19
    }
  }), "l. Pakis H. Rahayu No.51", __jsx("br", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 81,
      columnNumber: 37
    }
  }), "RT.03/RW.02, Potroyudan V, Potroyudan ", __jsx("br", {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 82,
      columnNumber: 51
    }
  }), "+21 2020 5555")), __jsx("div", {
    className: "w-full md:w-2/6 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 86,
      columnNumber: 9
    }
  }, __jsx("h6", {
    className: "text-white",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 87,
      columnNumber: 11
    }
  }, "Promotions"), __jsx("p", {
    className: "mt-4 text-indigo-500",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 88,
      columnNumber: 11
    }
  }, "Submit your email for new updates"), __jsx("form", {
    onSubmit: submit,
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 91,
      columnNumber: 11
    }
  }, __jsx("input", {
    type: "text",
    className: "bg-white focus:outline-none border-0 px-6 py-3 mt-6 md:w-1/2",
    placeholder: "Your email addres",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 92,
      columnNumber: 13
    }
  }), __jsx("button", {
    className: "bg-orange-500 hover:bg-orange-400 transition-all duration-200 focus:outline-none shadow-inner text-white px-4 md:px-6 py-3",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 97,
      columnNumber: 13
    }
  }, "Daftar Now")))), __jsx("div", {
    className: "border-t pt-8 mt-8 border-gray-800 text-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 103,
      columnNumber: 7
    }
  }, __jsx("p", {
    className: "text-indigo-500",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 104,
      columnNumber: 9
    }
  }, "2020 Copyright Micro by  Etnicode. All Rights Reserved")));
}
_c = Footer;

var _c;

$RefreshReg$(_c, "Footer");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/Header.js":
/*!*****************************!*\
  !*** ./src/parts/Header.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Header; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/router */ "./node_modules/next/dist/client/router.js");
/* harmony import */ var next_router__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_router__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var public_images_logo_jcpro_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! public/images/logo_jcpro.svg */ "./public/images/logo_jcpro.svg");
/* harmony import */ var public_images_logo_jcpro_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(public_images_logo_jcpro_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var public_images_default_avatar_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! public/images/default-avatar.svg */ "./public/images/default-avatar.svg");
/* harmony import */ var public_images_default_avatar_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(public_images_default_avatar_svg__WEBPACK_IMPORTED_MODULE_5__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\Header.js",
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;






function Header(_ref) {
  _s();

  var _User$name;

  var onLight = _ref.onLight;

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(function () {
    return null;
  }),
      User = _useState[0],
      setUser = _useState[1];

  var _useState2 = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(false),
      ToggleMenu = _useState2[0],
      setToggleMenu = _useState2[1];

  Object(react__WEBPACK_IMPORTED_MODULE_0__["useEffect"])(function () {
    var _decodeURIComponent$s, _decodeURIComponent, _decodeURIComponent$s2, _decodeURIComponent$s3, _decodeURIComponent$s4;

    var userCookies = (_decodeURIComponent$s = (_decodeURIComponent = decodeURIComponent(window.document.cookie)) === null || _decodeURIComponent === void 0 ? void 0 : (_decodeURIComponent$s2 = _decodeURIComponent.split(";")) === null || _decodeURIComponent$s2 === void 0 ? void 0 : (_decodeURIComponent$s3 = _decodeURIComponent$s2.find) === null || _decodeURIComponent$s3 === void 0 ? void 0 : (_decodeURIComponent$s4 = _decodeURIComponent$s3.call(_decodeURIComponent$s2, function (item) {
      return item.indexOf("BWAMICRO:user") > -1;
    })) === null || _decodeURIComponent$s4 === void 0 ? void 0 : _decodeURIComponent$s4.split("=")[1]) !== null && _decodeURIComponent$s !== void 0 ? _decodeURIComponent$s : null;
    setUser(userCookies ? JSON.parse(userCookies) : null);
  }, []);
  var linkColor = onLight ? "text-gray-900" : "text-white";
  var router = Object(next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"])();
  var linkCTA = router.pathname.indexOf("/login") > -1 ? "".concat("http://localhost:3030", "/register") : "".concat("http://localhost:3030", "/login");
  var textCTA = router.pathname.indexOf("/login") > -1 ? "Daftar" : "Masuk";
  return __jsx("header", {
    className: ["flex justify-between items-center", ToggleMenu ? "fixed w-full -mx-4 px-4" : ""].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 36,
      columnNumber: 5
    }
  }, __jsx("div", {
    style: {
      height: 54,
      zIndex: 50
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 42,
      columnNumber: 7
    }
  }, __jsx(public_images_logo_jcpro_svg__WEBPACK_IMPORTED_MODULE_4___default.a, {
    className: "on-dark",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 9
    }
  })), __jsx("div", {
    className: "flex md:hidden",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 45,
      columnNumber: 7
    }
  }, __jsx("button", {
    onClick: function onClick() {
      return setToggleMenu(function (prev) {
        return !prev;
      });
    },
    className: ["toggle z-50", ToggleMenu ? "active" : ""].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 46,
      columnNumber: 9
    }
  })), __jsx("ul", {
    className: ["transition-all duration-200 items-center fixed inset-0 bg-indigo-1000 pt-24 md:pt-0 md:bg-transparent md:relative md:flex md:opacity-100 md:visible", ToggleMenu ? "opacity-100 visible z-20" : "opacity-0 invisible"].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 7
    }
  }, __jsx("li", {
    className: "my-4 md:my-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 57,
      columnNumber: 9
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
    href: "/",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 58,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: [linkColor, "text-white hover:text-teal-500 text-lg px-6 py-3 font-medium"].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 59,
      columnNumber: 13
    }
  }, "Home"))), __jsx("li", {
    className: "my-4 md:my-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 69,
      columnNumber: 9
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
    href: "/",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 70,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: [linkColor, "text-white hover:text-teal-500 text-lg px-6 py-3 font-medium"].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 71,
      columnNumber: 13
    }
  }, "Pricing"))), __jsx("li", {
    className: "my-4 md:my-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 81,
      columnNumber: 9
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
    href: "/",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 82,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: [linkColor, "text-white hover:text-teal-500 text-lg px-6 py-3 font-medium"].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 83,
      columnNumber: 13
    }
  }, "Feature"))), __jsx("li", {
    className: "my-4 md:my-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 93,
      columnNumber: 9
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_3___default.a, {
    href: "/",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: [linkColor, "text-white hover:text-teal-500 text-lg px-6 py-3 font-medium"].join(" "),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 95,
      columnNumber: 13
    }
  }, "Story"))), __jsx("li", {
    className: "mt-8 md:mt-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 105,
      columnNumber: 9
    }
  }, User ? __jsx("a", {
    target: "_blank",
    rel: "noopener noereferrer",
    href: linkCTA,
    className: "hover:bg-indigo-800 transition-all duration-200 text-white hover:text-teal-500 text-lg px-6 py-3 font-medium ml-6 inline-flex items-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 107,
      columnNumber: 13
    }
  }, __jsx("span", {
    className: "rounded-full overflow-hidden mr-3 border-2 border-orange-500",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 113,
      columnNumber: 15
    }
  }, (User === null || User === void 0 ? void 0 : User.thumbnail) ? __jsx("img", {
    src: User === null || User === void 0 ? void 0 : User.thumbnail,
    alt: (_User$name = User === null || User === void 0 ? void 0 : User.name) !== null && _User$name !== void 0 ? _User$name : "Username",
    className: "object-cover w-8 h-8 inline-block",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 115,
      columnNumber: 19
    }
  }) : __jsx(public_images_default_avatar_svg__WEBPACK_IMPORTED_MODULE_5___default.a, {
    className: "fill-indigo-500 w-8 h-8 inline-block",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 121,
      columnNumber: 19
    }
  })), "Hi, ", User.name) : __jsx("a", {
    target: "_blank",
    rel: "noopener noereferrer",
    href: linkCTA,
    className: "bg-indigo-700 hover:bg-indigo-800 transition-all duration-200 text-white hover:text-teal-500 text-lg px-6 py-3 font-medium ml-6",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 127,
      columnNumber: 13
    }
  }, textCTA))));
}

_s(Header, "4FHLO0m37XCxshKutfeFjaZxeOw=", false, function () {
  return [next_router__WEBPACK_IMPORTED_MODULE_2__["useRouter"]];
});

_c = Header;
Header.propTypes = {
  onLight: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool
};

var _c;

$RefreshReg$(_c, "Header");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/Hero.js":
/*!***************************!*\
  !*** ./src/parts/Hero.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Hero; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\Hero.js",
    _s = $RefreshSig$();

var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;

function Hero() {
  _s();

  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_0__["useState"])(function () {
    return "";
  }),
      state = _useState[0],
      setstate = _useState[1];

  function submit() {
    window.open("".concat("http://localhost:3030", "/register?email=").concat(state));
  }

  return __jsx("div", {
    className: "flex justify-between items-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "w-full md:w-1/2 mt-8 md:mt-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 7
    }
  }, __jsx("h1", {
    className: "text-5xl text-white mb-5 font-semibold",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 9
    }
  }, __jsx("span", {
    className: "text-teal-400",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 15,
      columnNumber: 11
    }
  }, "The New"), " Way to", __jsx("br", {
    className: "hidden md:block",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 11
    }
  }), " Achieve Good", " ", __jsx("span", {
    className: "text-teal-400",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 11
    }
  }, "Skills")), __jsx("p", {
    className: "text-white font-light text-lg mb-8",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 9
    }
  }, "We provide tons of pathskill that you", " ", __jsx("br", {
    className: "hidden md:block",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 21,
      columnNumber: 11
    }
  }), " can choose and focus on"), __jsx("form", {
    onSubmit: submit,
    className: "flex",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 24,
      columnNumber: 9
    }
  }, __jsx("input", {
    type: "text",
    onChange: function onChange(event) {
      return setstate(event.target.value);
    },
    className: "bg-white focus:outline-none border-0 px-4 md:px-6 py-3 w-full md:w-1/2",
    value: state,
    placeholder: "Your email addres",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 11
    }
  }), __jsx("button", {
    className: "bg-orange-500 hover:bg-orange-400 transition-all duration-200 focus:outline-none shadow-inner text-white px-4 md:px-6 py-3 whitespace-no-wrap",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 32,
      columnNumber: 11
    }
  }, "Daftar Now"))), __jsx("div", {
    className: "hidden w-1/2 md:flex justify-end pt-24 pr-16",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 37,
      columnNumber: 7
    }
  }, __jsx("div", {
    className: "relative",
    style: {
      width: 369,
      height: 440
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 38,
      columnNumber: 9
    }
  }, __jsx("div", {
    className: "absolute border-indigo-700 border-2 -mt-12 -mr-6 right-0",
    style: {
      width: 324,
      height: 374
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 39,
      columnNumber: 11
    }
  }), __jsx("div", {
    className: "absolute w-full h-full -mb-8 -ml-8",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 43,
      columnNumber: 11
    }
  }, __jsx("img", {
    src: "/images/img-hero-mbak-alyssa-cakep.jpg",
    alt: "Mbak Alyssa Cakep euy",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 44,
      columnNumber: 13
    }
  })), __jsx("div", {
    className: "absolute z-10 bg-white py-3 px-4 mt-24",
    style: {
      transform: "translateX(-50%)",
      width: 290
    },
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 49,
      columnNumber: 11
    }
  }, __jsx("p", {
    className: "text-gray-900 mb-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 53,
      columnNumber: 13
    }
  }, "Metode belajar yang santai seperti nonton drakor di Netflix"), __jsx("span", {
    className: "text-gray-600",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 56,
      columnNumber: 13
    }
  }, "Alyssa, Apps Developer")))));
}

_s(Hero, "dXh3ia0XnMndFhKrb8bKhKUZyMg=");

_c = Hero;

var _c;

$RefreshReg$(_c, "Hero");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/ListCategories/RenderItem.js":
/*!************************************************!*\
  !*** ./src/parts/ListCategories/RenderItem.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderItem; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var src_helpers_formatThousand__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! src/helpers/formatThousand */ "./src/helpers/formatThousand.js");
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\ListCategories\\RenderItem.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;



function RenderItem(_ref) {
  var item = _ref.item;
  return __jsx("div", {
    className: "w-3/6 md:w-1/6 px-4 h-100 mb-8 md:mb-0",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "card relative transition-all duration-300",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }
  }, item.imageName, __jsx("div", {
    className: "card-meta mt-10",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 9
    }
  }, __jsx("h4", {
    className: "text-lg transition-all duration-200 w-1/2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 11
    }
  }, item.name), __jsx("h5", {
    className: "text-sm transition-all mt-2 duration-500",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 16,
      columnNumber: 11
    }
  }, Object(src_helpers_formatThousand__WEBPACK_IMPORTED_MODULE_2__["default"])(item.total)), __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "#",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: "link-wrapped",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 20,
      columnNumber: 13
    }
  })))));
}
_c = RenderItem;

var _c;

$RefreshReg$(_c, "RenderItem");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/ListCategories/index.js":
/*!*******************************************!*\
  !*** ./src/parts/ListCategories/index.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return index; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _RenderItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./RenderItem */ "./src/parts/ListCategories/RenderItem.js");
/* harmony import */ var public_images_icon_business_development_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! public/images/icon-business-development.svg */ "./public/images/icon-business-development.svg");
/* harmony import */ var public_images_icon_business_development_svg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_business_development_svg__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var public_images_icon_content_writer_svg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! public/images/icon-content-writer.svg */ "./public/images/icon-content-writer.svg");
/* harmony import */ var public_images_icon_content_writer_svg__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_content_writer_svg__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var public_images_icon_product_advertisement_svg__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! public/images/icon-product-advertisement.svg */ "./public/images/icon-product-advertisement.svg");
/* harmony import */ var public_images_icon_product_advertisement_svg__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_product_advertisement_svg__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var public_images_icon_customer_relationship_svg__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! public/images/icon-customer-relationship.svg */ "./public/images/icon-customer-relationship.svg");
/* harmony import */ var public_images_icon_customer_relationship_svg__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_customer_relationship_svg__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var public_images_icon_game_development_svg__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! public/images/icon-game-development.svg */ "./public/images/icon-game-development.svg");
/* harmony import */ var public_images_icon_game_development_svg__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_game_development_svg__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var public_images_icon_travel_guidance_svg__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! public/images/icon-travel-guidance.svg */ "./public/images/icon-travel-guidance.svg");
/* harmony import */ var public_images_icon_travel_guidance_svg__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_travel_guidance_svg__WEBPACK_IMPORTED_MODULE_7__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\ListCategories\\index.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;








function index() {
  var _this = this;

  var data = [{
    imageName: __jsx(public_images_icon_business_development_svg__WEBPACK_IMPORTED_MODULE_2___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 15,
        columnNumber: 18
      }
    }),
    name: "Business Development",
    total: 12493
  }, {
    imageName: __jsx(public_images_icon_content_writer_svg__WEBPACK_IMPORTED_MODULE_3___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 20,
        columnNumber: 18
      }
    }),
    name: "Content Writer",
    total: 839
  }, {
    imageName: __jsx(public_images_icon_product_advertisement_svg__WEBPACK_IMPORTED_MODULE_4___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 25,
        columnNumber: 18
      }
    }),
    name: "Product Advertisement",
    total: 478
  }, {
    imageName: __jsx(public_images_icon_customer_relationship_svg__WEBPACK_IMPORTED_MODULE_5___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 30,
        columnNumber: 18
      }
    }),
    name: "Customer Relationship",
    total: 553
  }, {
    imageName: __jsx(public_images_icon_game_development_svg__WEBPACK_IMPORTED_MODULE_6___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 35,
        columnNumber: 18
      }
    }),
    name: "Game Development",
    total: 7309
  }, {
    imageName: __jsx(public_images_icon_travel_guidance_svg__WEBPACK_IMPORTED_MODULE_7___default.a, {
      __self: this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 40,
        columnNumber: 18
      }
    }),
    name: "Travel Guidance",
    total: 73
  }];
  return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, __jsx("div", {
    className: "flex justify-between items-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 48,
      columnNumber: 7
    }
  }, __jsx("div", {
    className: "w-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 49,
      columnNumber: 9
    }
  }, __jsx("h2", {
    className: "text-lg text-gray-600",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 50,
      columnNumber: 11
    }
  }, "Category"), __jsx("h3", {
    className: "text-xl text-gray-900",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 51,
      columnNumber: 11
    }
  }, "Explore & ", __jsx("span", {
    className: "text-teal-400",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 52,
      columnNumber: 23
    }
  }, "Learn")))), __jsx("div", {
    className: "flex flex-wrap justify-start items-center -mx-4 mt-6",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 56,
      columnNumber: 7
    }
  }, (data === null || data === void 0 ? void 0 : data.length) > 0 ? data.map(function (item, index) {
    return __jsx(_RenderItem__WEBPACK_IMPORTED_MODULE_1__["default"], {
      item: item,
      key: index,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 59,
        columnNumber: 20
      }
    });
  }) : __jsx("div", {
    className: "w-full text-center-py-12",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 62,
      columnNumber: 11
    }
  }, "No Item Found")));
}

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/ListCourses/RenderItem.js":
/*!*********************************************!*\
  !*** ./src/parts/ListCourses/RenderItem.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderItem; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var public_images_icon_play_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! public/images/icon-play.svg */ "./public/images/icon-play.svg");
/* harmony import */ var public_images_icon_play_svg__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(public_images_icon_play_svg__WEBPACK_IMPORTED_MODULE_2__);
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\ListCourses\\RenderItem.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;



function RenderItem(_ref) {
  var _item$thumbnail, _item$name, _item$name2, _item$level;

  var item = _ref.item;
  return __jsx("div", {
    className: "w-full md:w-1/4 px-4 mb-6",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 9,
      columnNumber: 5
    }
  }, __jsx("div", {
    className: "item relative",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }
  }, __jsx("figure", {
    className: "item-image",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 9
    }
  }, __jsx(public_images_icon_play_svg__WEBPACK_IMPORTED_MODULE_2___default.a, {
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 11
    }
  }), __jsx("img", {
    src: (_item$thumbnail = item === null || item === void 0 ? void 0 : item.thumbnail) !== null && _item$thumbnail !== void 0 ? _item$thumbnail : "",
    alt: (_item$name = item === null || item === void 0 ? void 0 : item.name) !== null && _item$name !== void 0 ? _item$name : "some information",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 11
    }
  })), __jsx("div", {
    className: "item-meta mt-2",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 9
    }
  }, __jsx("h4", {
    className: "text-lg text-gray-900",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 11
    }
  }, (_item$name2 = item === null || item === void 0 ? void 0 : item.name) !== null && _item$name2 !== void 0 ? _item$name2 : "Course name"), __jsx("h5", {
    className: "text-sm text-gray-600",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 22,
      columnNumber: 11
    }
  }, (_item$level = item === null || item === void 0 ? void 0 : item.level) !== null && _item$level !== void 0 ? _item$level : "Course level")), __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "/courses/[id]",
    as: "/courses/".concat(item.id),
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 26,
      columnNumber: 9
    }
  }, __jsx("a", {
    className: "link-wrapped",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 27,
      columnNumber: 11
    }
  }))));
}
_c = RenderItem;

var _c;

$RefreshReg$(_c, "RenderItem");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "./src/parts/ListCourses/index.js":
/*!****************************************!*\
  !*** ./src/parts/ListCourses/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListCourses; });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/link */ "./node_modules/next/link.js");
/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _RenderItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RenderItem */ "./src/parts/ListCourses/RenderItem.js");
var _jsxFileName = "D:\\Skripsi\\micro services\\FRONTEND\\frontpage\\src\\parts\\ListCourses\\index.js";
var __jsx = react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement;



function ListCourses(_ref) {
  var _this = this;

  var data = _ref.data;
  return __jsx(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, __jsx("div", {
    className: "flex justify-between items-center",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 10,
      columnNumber: 7
    }
  }, __jsx("div", {
    className: "w-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 11,
      columnNumber: 9
    }
  }, __jsx("h2", {
    className: "text-lg text-gray-600",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 12,
      columnNumber: 11
    }
  }, "New Classes"), __jsx("h3", {
    className: "text-xl text-gray-900",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 13,
      columnNumber: 11
    }
  }, "Summer ", __jsx("span", {
    className: "text-teal-400",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 14,
      columnNumber: 20
    }
  }, "Productive"))), __jsx("div", {
    className: "w-auto",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 17,
      columnNumber: 9
    }
  }, __jsx(next_link__WEBPACK_IMPORTED_MODULE_1___default.a, {
    href: "/courses",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 18,
      columnNumber: 11
    }
  }, __jsx("a", {
    className: "text-gray-600 hover:underline text-sm",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 19,
      columnNumber: 13
    }
  }, "View All Course")))), __jsx("div", {
    className: "flex flex-wrap justify-start items-center -mx-4 mt-6",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 25,
      columnNumber: 7
    }
  }, (data === null || data === void 0 ? void 0 : data.length) > 0 ? data.map(function (item, index) {
    return __jsx(_RenderItem__WEBPACK_IMPORTED_MODULE_2__["default"], {
      item: item,
      key: index,
      __self: _this,
      __source: {
        fileName: _jsxFileName,
        lineNumber: 28,
        columnNumber: 20
      }
    });
  }) : __jsx("div", {
    className: "w-full text-center-py-12",
    __self: this,
    __source: {
      fileName: _jsxFileName,
      lineNumber: 31,
      columnNumber: 11
    }
  }, "No Item Found")));
}
_c = ListCourses;

var _c;

$RefreshReg$(_c, "ListCourses");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports_1 = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports_1, module.i);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports_1)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports_1;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports_1)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ "./node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ 1:
/*!**************************************************************************************************************************************************!*\
  !*** multi next-client-pages-loader?page=%2F&absolutePagePath=D%3A%5CSkripsi%5Cmicro%20services%5CFRONTEND%5Cfrontpage%5Csrc%5Cpages%5Cindex.js ***!
  \**************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! next-client-pages-loader?page=%2F&absolutePagePath=D%3A%5CSkripsi%5Cmicro%20services%5CFRONTEND%5Cfrontpage%5Csrc%5Cpages%5Cindex.js! */"./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F&absolutePagePath=D%3A%5CSkripsi%5Cmicro%20services%5CFRONTEND%5Cfrontpage%5Csrc%5Cpages%5Cindex.js!./");


/***/ }),

/***/ "dll-reference dll_5030f387d328e4415785":
/*!*******************************************!*\
  !*** external "dll_5030f387d328e4415785" ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = dll_5030f387d328e4415785;

/***/ })

},[[1,"static/runtime/webpack.js"]]]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheUxpa2VUb0FycmF5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL25vbkl0ZXJhYmxlU3ByZWFkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kb20taGVscGVycy9lc20vYWRkQ2xhc3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RvbS1oZWxwZXJzL2VzbS9oYXNDbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tLWhlbHBlcnMvZXNtL3JlbW92ZUNsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uYXRpdmUtdXJsL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2RlbGVnYXRlZCAuL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMgZnJvbSBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QuYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtY2xpZW50LXBhZ2VzLWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi4vLi4vY2xpZW50L2xpbmsudHN4Iiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvcm91dGVyLnRzIiwid2VicGFjazovLy8uLi8uLi9jbGllbnQvd2l0aC1yb3V0ZXIudHN4Iiwid2VicGFjazovLy8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvYW1wLWNvbnRleHQudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9hbXAudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9oZWFkLW1hbmFnZXItY29udGV4dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL2hlYWQudHN4Iiwid2VicGFjazovLy8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvbWl0dC50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci1jb250ZXh0LnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlci50cyIsIndlYnBhY2s6Ly8vLi4vLi4vLi4vLi4vLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci91dGlscy9pcy1keW5hbWljLnRzIiwid2VicGFjazovLy8uLi8uLi8uLi8uLi8uLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3V0aWxzL3JvdXRlLW1hdGNoZXIudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvdXRpbHMvcm91dGUtcmVnZXgudHMiLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi9zaWRlLWVmZmVjdC50c3giLCJ3ZWJwYWNrOi8vLy4uLy4uLy4uL25leHQtc2VydmVyL2xpYi91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMtZXhhY3QvYnVpbGQvaGVscGVycy9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzLWV4YWN0L2J1aWxkL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyBmcm9tIGRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMgZnJvbSBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2VuY29kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwid2VicGFjazovLy9kZWxlZ2F0ZWQgLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfNTAzMGYzODdkMzI4ZTQ0MTU3ODUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRvYXN0aWZ5L2Rpc3QvcmVhY3QtdG9hc3RpZnkuZXNtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9DU1NUcmFuc2l0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9SZXBsYWNlVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vU3dpdGNoVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC9lc20vVHJhbnNpdGlvbkdyb3VwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9UcmFuc2l0aW9uR3JvdXBDb250ZXh0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC10cmFuc2l0aW9uLWdyb3VwL2VzbS91dGlscy9DaGlsZE1hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvZXNtL3V0aWxzL1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vZGVsZWdhdGVkIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIGZyb20gZGxsLXJlZmVyZW5jZSBkbGxfNTAzMGYzODdkMzI4ZTQ0MTU3ODUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2NpcmNsZS1hY2NlbnQtMS5zdmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9kZWZhdWx0LWF2YXRhci5zdmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9pY29uLWJ1c2luZXNzLWRldmVsb3BtZW50LnN2ZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ljb24tY29udGVudC13cml0ZXIuc3ZnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvaWNvbi1jdXN0b21lci1yZWxhdGlvbnNoaXAuc3ZnIiwid2VicGFjazovLy8uL3B1YmxpYy9pbWFnZXMvaWNvbi1nYW1lLWRldmVsb3BtZW50LnN2ZyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvaW1hZ2VzL2ljb24tcGxheS5zdmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9pY29uLXByb2R1Y3QtYWR2ZXJ0aXNlbWVudC5zdmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9pY29uLXRyYXZlbC1ndWlkYW5jZS5zdmciLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2ltYWdlcy9sb2dvX2pjcHJvLnN2ZyIsIndlYnBhY2s6Ly8vLi9zcmMvY29uZmlncy9heGlvcy9lcnJvckhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbmZpZ3MvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnN0YW50cy9hcGkvY291cnNlcy5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvaGVscGVycy9mb3JtYXRUaG91c2FuZC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhcnRzL0NsaWVudHMuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3BhcnRzL0Zvb3Rlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFydHMvSGVhZGVyLmpzIiwid2VicGFjazovLy8uL3NyYy9wYXJ0cy9IZXJvLmpzIiwid2VicGFjazovLy8uL3NyYy9wYXJ0cy9MaXN0Q2F0ZWdvcmllcy9SZW5kZXJJdGVtLmpzIiwid2VicGFjazovLy8uL3NyYy9wYXJ0cy9MaXN0Q2F0ZWdvcmllcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFydHMvTGlzdENvdXJzZXMvUmVuZGVySXRlbS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvcGFydHMvTGlzdENvdXJzZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1XCIiXSwibmFtZXMiOlsidXJsIiwib3JpZ2luIiwibGFzdEhyZWYiLCJsYXN0QXMiLCJsYXN0UmVzdWx0IiwiaHJlZiIsImFzIiwicmVzdWx0IiwiZm9ybWF0RnVuYyIsImxpc3RlbmVycyIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwid2luZG93IiwicHJlZmV0Y2hlZCIsIm9ic2VydmVyIiwiZW50cmllcyIsImVudHJ5IiwiY2IiLCJyb290TWFyZ2luIiwibGlzdGVuVG9JbnRlcnNlY3Rpb25zIiwiZ2V0T2JzZXJ2ZXIiLCJjb25zb2xlIiwiY29uc3RydWN0b3IiLCJwIiwibWVtb2l6ZWRGb3JtYXRVcmwiLCJmb3JtYXRVcmwiLCJhc0hyZWYiLCJlIiwibm9kZU5hbWUiLCJ0YXJnZXQiLCJpc0xvY2FsIiwic2Nyb2xsIiwiUm91dGVyIiwic2hhbGxvdyIsInN1Y2Nlc3MiLCJkb2N1bWVudCIsInByb3BzIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJnZXRQYXRocyIsInJlc29sdmVkSHJlZiIsInBhcnNlZEFzIiwiaGFuZGxlUmVmIiwicmVmIiwiaXNQcmVmZXRjaGVkIiwicHJlZmV0Y2giLCJwYXRocyIsImVyciIsInJlbmRlciIsImNoaWxkcmVuIiwiY2hpbGQiLCJDaGlsZHJlbiIsImVsIiwib25Nb3VzZUVudGVyIiwicHJpb3JpdHkiLCJvbkNsaWNrIiwicHJvY2VzcyIsIlJlYWN0IiwiQ29tcG9uZW50Iiwid2FybiIsIlByb3BUeXBlcyIsInJlcXVpcmUiLCJleGFjdCIsIkxpbmsiLCJyZXBsYWNlIiwicGFzc0hyZWYiLCJ2YWx1ZSIsInNpbmdsZXRvblJvdXRlciIsInJvdXRlciIsInJlYWR5Q2FsbGJhY2tzIiwicmVhZHkiLCJ1cmxQcm9wZXJ0eUZpZWxkcyIsInJvdXRlckV2ZW50cyIsImNvcmVNZXRob2RGaWVsZHMiLCJPYmplY3QiLCJnZXQiLCJmaWVsZCIsImdldFJvdXRlciIsImV2ZW50IiwiZXZlbnRGaWVsZCIsIl9zaW5nbGV0b25Sb3V0ZXIiLCJtZXNzYWdlIiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlciIsIl9yb3V0ZXIiLCJpbnN0YW5jZSIsIkNvbXBvc2VkQ29tcG9uZW50IiwiZ2V0SW5pdGlhbFByb3BzIiwiV2l0aFJvdXRlcldyYXBwZXIiLCJuYW1lIiwiQW1wU3RhdGVDb250ZXh0IiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSIsImlzSW5BbXBNb2RlIiwiSGVhZE1hbmFnZXJDb250ZXh0IiwiaW5BbXBNb2RlIiwiaGVhZCIsImxpc3QiLCJmcmFnbWVudExpc3QiLCJNRVRBVFlQRVMiLCJrZXlzIiwidGFncyIsIm1ldGFUeXBlcyIsIm1ldGFDYXRlZ29yaWVzIiwiaCIsInVuaXF1ZSIsImtleSIsImkiLCJsZW4iLCJtZXRhdHlwZSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsImhlYWRFbGVtZW50cyIsImhlYWRFbGVtZW50Q2hpbGRyZW4iLCJoZWFkRWxlbWVudCIsImRlZmF1bHRIZWFkIiwiYyIsIkVmZmVjdCIsImFtcFN0YXRlIiwidXBkYXRlSGVhZCIsIkhlYWQiLCJhbGwiLCJvbiIsIm9mZiIsImVtaXQiLCJoYW5kbGVyIiwiYmFzZVBhdGgiLCJwYXRoIiwicHJlcGFyZVJvdXRlIiwidG9Sb3V0ZSIsImF0dGVtcHRzIiwiaXNTZXJ2ZXJSZW5kZXIiLCJwYXRobmFtZSIsImFkZEJhc2VQYXRoIiwiX19ORVhUX0RBVEFfXyIsImJ1aWxkSWQiLCJkZWxCYXNlUGF0aCIsInF1ZXJ5IiwiY3JlZGVudGlhbHMiLCJyZXMiLCJnZXRSZXNwb25zZSIsImRhdGEiLCJyb3V0ZSIsImFzUGF0aCIsImNvbXBvbmVudHMiLCJzZGMiLCJzdWIiLCJjbGMiLCJwYWdlTG9hZGVyIiwiX2JwcyIsImV2ZW50cyIsIl93cmFwQXBwIiwiaXNTc3IiLCJpc0ZhbGxiYWNrIiwiUHJvbWlzZSIsImZldGNoTmV4dERhdGEiLCJfX05fU1NHIiwiaW5pdGlhbFByb3BzIiwiX19OX1NTUCIsInVwZGF0ZSIsIm1vZCIsIm5ld0RhdGEiLCJyZWxvYWQiLCJiYWNrIiwicHVzaCIsIm9wdGlvbnMiLCJjaGFuZ2UiLCJTVCIsInBlcmZvcm1hbmNlIiwicmVzb2x2ZSIsIm1ldGhvZCIsInJvdXRlUmVnZXgiLCJyb3V0ZU1hdGNoIiwibWlzc2luZ1BhcmFtcyIsInBhcmFtIiwicmVqZWN0IiwiYXNQYXRobmFtZSIsInJvdXRlSW5mbyIsImVycm9yIiwiYXBwQ29tcCIsImNoYW5nZVN0YXRlIiwiZ2V0Um91dGVJbmZvIiwiY2FjaGVkUm91dGVJbmZvIiwiaGFuZGxlRXJyb3IiLCJwYWdlIiwiZ2lwRXJyIiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwic2V0IiwiYmVmb3JlUG9wU3RhdGUiLCJvbmx5QUhhc2hDaGFuZ2UiLCJuZXdIYXNoIiwib2xkVXJsTm9IYXNoIiwib2xkSGFzaCIsInNjcm9sbFRvSGFzaCIsImhhc2giLCJpZEVsIiwibmFtZUVsIiwidXJsSXNOZXciLCJjYW5jZWxsZWQiLCJjYW5jZWwiLCJjb21wb25lbnRSZXN1bHQiLCJfZ2V0RGF0YSIsImZuIiwiQXBwVHJlZSIsImN0eCIsImFib3J0Q29tcG9uZW50TG9hZCIsIm5vdGlmeSIsIlRFU1RfUk9VVEUiLCJyZSIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsInBhcmFtcyIsInNsdWdOYW1lIiwiZyIsImdyb3VwcyIsIm0iLCJzdHIiLCJlc2NhcGVkUm91dGUiLCJlc2NhcGVSZWdleCIsIm5vcm1hbGl6ZWRSb3V0ZSIsImdyb3VwSW5kZXgiLCJwYXJhbWV0ZXJpemVkUm91dGUiLCJpc09wdGlvbmFsIiwiJDEiLCJpc0NhdGNoQWxsIiwicG9zIiwicmVwZWF0IiwibmFtZWRSZWdleCIsIm5hbWVkUGFyYW1ldGVyaXplZFJvdXRlIiwiaXNTZXJ2ZXIiLCJtb3VudGVkSW5zdGFuY2VzIiwic3RhdGUiLCJjb21wb25lbnQiLCJlbWl0Q2hhbmdlIiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJyZWNvcmRlZFN0YXRlIiwidXNlZCIsInByb3RvY29sIiwiaG9zdG5hbWUiLCJwb3J0IiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJBcHAiLCJnZXREaXNwbGF5TmFtZSIsImxvYWRHZXRJbml0aWFsUHJvcHMiLCJwYWdlUHJvcHMiLCJpc1Jlc1NlbnQiLCJ1cmxPYmplY3RLZXlzIiwiU1AiLCJlcnJvckhhbmRsZXIiLCJyZXNwb25zZSIsInN0YXR1cyIsInRvYXN0IiwiYXhpb3MiLCJjcmVhdGUiLCJiYXNlVVJMIiwiaW50ZXJjZXB0b3JzIiwidXNlIiwidGhlbiIsImRldGFpbHMiLCJpZCIsIm51bWJlciIsInRob3VzYW5kIiwiSW50bCIsIk51bWJlckZvcm1hdCIsImZvcm1hdCIsIkhvbWUiLCJjb3Vyc2VzIiwiQ2xpZW50cyIsIkZvb3RlciIsInN1Ym1pdCIsIkhlYWRlciIsIm9uTGlnaHQiLCJ1c2VTdGF0ZSIsIlVzZXIiLCJzZXRVc2VyIiwiVG9nZ2xlTWVudSIsInNldFRvZ2dsZU1lbnUiLCJ1c2VFZmZlY3QiLCJ1c2VyQ29va2llcyIsImNvb2tpZSIsInNwbGl0IiwiZmluZCIsIml0ZW0iLCJpbmRleE9mIiwiSlNPTiIsInBhcnNlIiwibGlua0NvbG9yIiwidXNlUm91dGVyIiwibGlua0NUQSIsInRleHRDVEEiLCJqb2luIiwiaGVpZ2h0IiwiekluZGV4IiwicHJldiIsInRodW1ibmFpbCIsInByb3BUeXBlcyIsImJvb2wiLCJIZXJvIiwic2V0c3RhdGUiLCJvcGVuIiwid2lkdGgiLCJ0cmFuc2Zvcm0iLCJSZW5kZXJJdGVtIiwiaW1hZ2VOYW1lIiwiZm9ybWF0VGhvdXNhbmQiLCJ0b3RhbCIsImluZGV4IiwibGVuZ3RoIiwibWFwIiwibGV2ZWwiLCJMaXN0Q291cnNlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM5V1AsaUJBQWlCLG1CQUFPLENBQUMsbUVBQW9COzs7Ozs7Ozs7Ozs7QUNBN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxvR0FBb0csbUJBQW1CLEVBQUUsbUJBQW1CLDhIQUE4SDs7QUFFMVE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLHNGQUFlOztBQUVyQzs7QUFFQSxXQUFXLG1CQUFPLENBQUMsNENBQUs7O0FBRXhCOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLCtGQUF5Qjs7QUFFdEQ7O0FBRUEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLDJDQUEyQyxrQkFBa0Isa0NBQWtDLHFFQUFxRSxFQUFFLEVBQUUsT0FBTyxrQkFBa0IsRUFBRSxZQUFZOztBQUUvTTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3REFBd0Q7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQywrQkFBK0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7OztBQ3hEQSw4Szs7Ozs7Ozs7Ozs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxrREFBVTtBQUNoQyxhQUFhLG1CQUFPLENBQUMsZ0ZBQWU7O0FBRXBDLDJCQUEyQixtQkFBTyxDQUFDLHlGQUE0QjtBQUMvRCxxQkFBcUIsbUJBQU8sQ0FBQyxxRUFBa0I7O0FBRS9DO0FBQ0E7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw2QkFBNkI7QUFDN0IsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVUsS0FBcUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixTQUFNO0FBQzdJO0FBQ0E7O0FBRUEsbUJBQW1CLGdDQUFnQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0NBQWdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDREQUFjO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVywyREFBYSxDQUFDLGlFQUFVLGtCQUFrQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx3REFBTSxDQUFDLDJEQUFhLGlDQUFpQztBQUMzRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNB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LE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLFdBQVc7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyxrQkFBa0I7QUFDbkQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUEsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZUFERixFQUVFO0FBQUksYUFBUyxFQUFDLE1BQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUksYUFBUyxFQUFDLE1BQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFLE1BQUMsZ0RBQUQ7QUFBTSxRQUFJLEVBQUMsRUFBWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0U7QUFBRyxhQUFTLEVBQUMscURBQWI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxxQkFERixDQURGLENBREYsRUFRRTtBQUFJLGFBQVMsRUFBQyxNQUFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLGdEQUFEO0FBQU0sUUFBSSxFQUFDLEVBQVg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUcsYUFBUyxFQUFDLHFEQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FERixDQURGLENBUkYsRUFlRTtBQUFJLGFBQVMsRUFBQyxNQUFkO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLGdEQUFEO0FBQU0sUUFBSSxFQUFDLEVBQVg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUcsYUFBUyxFQUFDLHFEQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUJBREYsQ0FERixDQWZGLEVBc0JFO0FBQUksYUFBUyxFQUFDLE1BQWQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFLE1BQUMsZ0RBQUQ7QUFBTSxRQUFJLEVBQUMsRUFBWDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEtBQ0U7QUFBRyxhQUFTLEVBQUMscURBQWI7QUFBQTtBQUFBO0FBQUE7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O0FBQUE7QUFBQSxrQkFEVCxDQUZGLENBREYsRUFPRTtBQUFLLGFBQVMsRUFBQyxRQUFmO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsS0FDRSxNQUFDLGdEQUFEO0FBQU0sUUFBSSxFQUFDLFVBQVg7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNFO0FBQUcsYUFBUyxFQUFDLHVDQUFiO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBREYsQ0FERixDQVBGLENBREYsRUFnQkU7QUFBSyxhQUFTLEVBQUMsc0RBQWY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxLQUNHLENBQUFBLElBQUksU0FBSixJQUFBQSxJQUFJLFdBQUosWUFBQUEsSUFBSSxDQUFFdUssTUFBTixJQUFlLENBQWYsR0FDQ3ZLLElBQUksQ0FBQ3dLLEdBQUwsQ0FBUyxVQUFDMUIsSUFBRCxFQUFPd0IsS0FBUCxFQUFpQjtBQUN4QixXQUFPLE1BQUMsbURBQUQ7QUFBWSxVQUFJLEVBQUV4QixJQUFsQjtBQUF3QixTQUFHLEVBQUV3QixLQUE3QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BQVA7QUFDRCxHQUZELENBREQsR0FLQztBQUFLLGFBQVMsRUFBQywwQkFBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHFCQU5KLENBaEJGLENBREY7QUE0QkQ7S0E3QnVCSSxXOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNOeEIsMEMiLCJmaWxlIjoic3RhdGljXFxkZXZlbG9wbWVudFxccGFnZXNcXGluZGV4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9hcnJheUxpa2VUb0FycmF5OyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRoSG9sZXM7IiwidmFyIGFycmF5TGlrZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9hcnJheUxpa2VUb0FycmF5XCIpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FycmF5V2l0aG91dEhvbGVzOyIsImZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZDsiLCJmdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvcjsiLCJmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjazsiLCJ2YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKFwiLi9zZXRQcm90b3R5cGVPZlwiKTtcblxudmFyIGlzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IHJlcXVpcmUoXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdFwiKTtcblxuZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IFJlZmxlY3QuY29uc3RydWN0O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBfY29uc3RydWN0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NvbnN0cnVjdDsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzOyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59IiwiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2dldFByb3RvdHlwZU9mOyIsInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mXCIpO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuXG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH1cbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2luaGVyaXRzOyIsImZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7XG4gIHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7XG4gICAgXCJkZWZhdWx0XCI6IG9ialxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7IiwiZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuXG4gIHRyeSB7XG4gICAgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3Q7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjtcbiAgdmFyIF9hcnIgPSBbXTtcbiAgdmFyIF9uID0gdHJ1ZTtcbiAgdmFyIF9kID0gZmFsc2U7XG4gIHZhciBfZSA9IHVuZGVmaW5lZDtcblxuICB0cnkge1xuICAgIGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHtcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XG5cbiAgICAgIGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhaztcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIF9kID0gdHJ1ZTtcbiAgICBfZSA9IGVycjtcbiAgfSBmaW5hbGx5IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAoX2QpIHRocm93IF9lO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBfYXJyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXlMaW1pdDsiLCJmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9ub25JdGVyYWJsZVJlc3Q7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7IiwidmFyIF90eXBlb2YgPSByZXF1aXJlKFwiLi4vaGVscGVycy90eXBlb2ZcIik7XG5cbnZhciBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQgPSByZXF1aXJlKFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIik7XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfVxuXG4gIHJldHVybiBhc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm47IiwiZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG5cbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2Y7IiwidmFyIGFycmF5V2l0aEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRoSG9sZXNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXlMaW1pdCA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheUxpbWl0XCIpO1xuXG52YXIgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIG5vbkl0ZXJhYmxlUmVzdCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlUmVzdFwiKTtcblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfc2xpY2VkVG9BcnJheTsiLCJ2YXIgYXJyYXlXaXRob3V0SG9sZXMgPSByZXF1aXJlKFwiLi9hcnJheVdpdGhvdXRIb2xlc1wiKTtcblxudmFyIGl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2l0ZXJhYmxlVG9BcnJheVwiKTtcblxudmFyIHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5ID0gcmVxdWlyZShcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXlcIik7XG5cbnZhciBub25JdGVyYWJsZVNwcmVhZCA9IHJlcXVpcmUoXCIuL25vbkl0ZXJhYmxlU3ByZWFkXCIpO1xuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdG9Db25zdW1hYmxlQXJyYXk7IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mOyIsInZhciBhcnJheUxpa2VUb0FycmF5ID0gcmVxdWlyZShcIi4vYXJyYXlMaWtlVG9BcnJheVwiKTtcblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXk7IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwicmVnZW5lcmF0b3ItcnVudGltZVwiKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJztcbiAgICAgIGlmIChjb25maWcudGltZW91dEVycm9yTWVzc2FnZSkge1xuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IodGltZW91dEVycm9yTWVzc2FnZSwgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oZnVsbFBhdGgpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9ICEhY29uZmlnLndpdGhDcmVkZW50aWFscztcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGF4aW9zO1xuXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBheGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsID0gcmVxdWlyZSgnLi9DYW5jZWwnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxUb2tlbmAgaXMgYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVxdWVzdCBjYW5jZWxsYXRpb24gb2YgYW4gb3BlcmF0aW9uLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZXhlY3V0b3IgVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBDYW5jZWxUb2tlbihleGVjdXRvcikge1xuICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xuICB9XG5cbiAgdmFyIHJlc29sdmVQcm9taXNlO1xuICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiBwcm9taXNlRXhlY3V0b3IocmVzb2x2ZSkge1xuICAgIHJlc29sdmVQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG5cbiAgdmFyIHRva2VuID0gdGhpcztcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcbiAgICBpZiAodG9rZW4ucmVhc29uKSB7XG4gICAgICAvLyBDYW5jZWxsYXRpb24gaGFzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xuICAgIHJlc29sdmVQcm9taXNlKHRva2VuLnJlYXNvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxuICogY2FuY2VscyB0aGUgYENhbmNlbFRva2VuYC5cbiAqL1xuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xuICB2YXIgY2FuY2VsO1xuICB2YXIgdG9rZW4gPSBuZXcgQ2FuY2VsVG9rZW4oZnVuY3Rpb24gZXhlY3V0b3IoYykge1xuICAgIGNhbmNlbCA9IGM7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHRva2VuOiB0b2tlbixcbiAgICBjYW5jZWw6IGNhbmNlbFxuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxUb2tlbjtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9tZXJnZUNvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gYXJndW1lbnRzWzFdIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBhcmd1bWVudHNbMF07XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICB9XG5cbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcblxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxuICBpZiAoY29uZmlnLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSBjb25maWcubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gdGhpcy5kZWZhdWx0cy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XG4gIH1cblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuQXhpb3MucHJvdG90eXBlLmdldFVyaSA9IGZ1bmN0aW9uIGdldFVyaShjb25maWcpIHtcbiAgY29uZmlnID0gbWVyZ2VDb25maWcodGhpcy5kZWZhdWx0cywgY29uZmlnKTtcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFw/LywgJycpO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWRcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cblxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgZXJyb3IuaXNBeGlvc0Vycm9yID0gdHJ1ZTtcblxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ3BhcmFtcycsICdkYXRhJ107XG4gIHZhciBtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyA9IFsnaGVhZGVycycsICdhdXRoJywgJ3Byb3h5J107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd1cmwnLCAndHJhbnNmb3JtUmVxdWVzdCcsICd0cmFuc2Zvcm1SZXNwb25zZScsICdwYXJhbXNTZXJpYWxpemVyJyxcbiAgICAndGltZW91dCcsICd3aXRoQ3JlZGVudGlhbHMnLCAnYWRhcHRlcicsICdyZXNwb25zZVR5cGUnLCAneHNyZkNvb2tpZU5hbWUnLFxuICAgICd4c3JmSGVhZGVyTmFtZScsICdvblVwbG9hZFByb2dyZXNzJywgJ29uRG93bmxvYWRQcm9ncmVzcycsXG4gICAgJ21heENvbnRlbnRMZW5ndGgnLCAndmFsaWRhdGVTdGF0dXMnLCAnbWF4UmVkaXJlY3RzJywgJ2h0dHBBZ2VudCcsXG4gICAgJ2h0dHBzQWdlbnQnLCAnY2FuY2VsVG9rZW4nLCAnc29ja2V0UGF0aCdcbiAgXTtcblxuICB1dGlscy5mb3JFYWNoKHZhbHVlRnJvbUNvbmZpZzJLZXlzLCBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZzJbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcyW3Byb3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cywgZnVuY3Rpb24gbWVyZ2VEZWVwUHJvcGVydGllcyhwcm9wKSB7XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSB1dGlscy5kZWVwTWVyZ2UoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnMltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzJbcHJvcF07XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdChjb25maWcxW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gdXRpbHMuZGVlcE1lcmdlKGNvbmZpZzFbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZzFbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcxW3Byb3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkZWZhdWx0VG9Db25maWcyS2V5cywgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnW3Byb3BdID0gY29uZmlnMltwcm9wXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcxW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnW3Byb3BdID0gY29uZmlnMVtwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzIpXG4gICAgLmZpbHRlcihmdW5jdGlvbiBmaWx0ZXJBeGlvc0tleXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXhpb3NLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG4gICAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChvdGhlcktleXMsIGZ1bmN0aW9uIG90aGVyS2V5c0RlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICh0eXBlb2YgY29uZmlnMltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzJbcHJvcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnMVtwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzFbcHJvcF07XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY29uZmlnO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi9jcmVhdGVFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIHV0aWxzLmZvckVhY2goZm5zLCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICBkYXRhID0gZm4oZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IFt2YWxdO1xuICAgICAgfVxuXG4gICAgICB1dGlscy5mb3JFYWNoKHZhbCwgZnVuY3Rpb24gcGFyc2VWYWx1ZSh2KSB7XG4gICAgICAgIGlmICh1dGlscy5pc0RhdGUodikpIHtcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzT2JqZWN0KHYpKSB7XG4gICAgICAgICAgdiA9IEpTT04uc3RyaW5naWZ5KHYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goZW5jb2RlKGtleSkgKyAnPScgKyBlbmNvZGUodikpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFydHMuam9pbignJicpO1xuICB9XG5cbiAgaWYgKHNlcmlhbGl6ZWRQYXJhbXMpIHtcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XG4gICAgaWYgKGhhc2htYXJrSW5kZXggIT09IC0xKSB7XG4gICAgICB1cmwgPSB1cmwuc2xpY2UoMCwgaGFzaG1hcmtJbmRleCk7XG4gICAgfVxuXG4gICAgdXJsICs9ICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBzZXJpYWxpemVkUGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIHVybDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUobmFtZSwgdmFsdWUsIGV4cGlyZXMsIHBhdGgsIGRvbWFpbiwgc2VjdXJlKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xuICAgICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2V4cGlyZXM9JyArIG5ldyBEYXRlKGV4cGlyZXMpLnRvR01UU3RyaW5nKCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3BhdGg9JyArIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh1dGlscy5pc1N0cmluZyhkb21haW4pKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdzZWN1cmUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBjb29raWUuam9pbignOyAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgICB2YXIgbWF0Y2ggPSBkb2N1bWVudC5jb29raWUubWF0Y2gobmV3IFJlZ0V4cCgnKF58O1xcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xuICAgICAgICAgIHJldHVybiAobWF0Y2ggPyBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbM10pIDogbnVsbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgICAgIHRoaXMud3JpdGUobmFtZSwgJycsIERhdGUubm93KCkgLSA4NjQwMDAwMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3cml0ZTogZnVuY3Rpb24gd3JpdGUoKSB7fSxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgaGF2ZSBmdWxsIHN1cHBvcnQgb2YgdGhlIEFQSXMgbmVlZGVkIHRvIHRlc3RcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcbiAgICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgICB9XG5cbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG5cbiAgICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGhyZWY6IHVybFBhcnNpbmdOb2RlLmhyZWYsXG4gICAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICAgIHNlYXJjaDogdXJsUGFyc2luZ05vZGUuc2VhcmNoID8gdXJsUGFyc2luZ05vZGUuc2VhcmNoLnJlcGxhY2UoL15cXD8vLCAnJykgOiAnJyxcbiAgICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxuICAgICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xuICAgICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAgIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgfSkoKVxuKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxuLy8gYy5mLiBodHRwczovL25vZGVqcy5vcmcvYXBpL2h0dHAuaHRtbCNodHRwX21lc3NhZ2VfaGVhZGVyc1xudmFyIGlnbm9yZUR1cGxpY2F0ZU9mID0gW1xuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxuICAnZXhwaXJlcycsICdmcm9tJywgJ2hvc3QnLCAnaWYtbW9kaWZpZWQtc2luY2UnLCAnaWYtdW5tb2RpZmllZC1zaW5jZScsXG4gICdsYXN0LW1vZGlmaWVkJywgJ2xvY2F0aW9uJywgJ21heC1mb3J3YXJkcycsICdwcm94eS1hdXRob3JpemF0aW9uJyxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcbl07XG5cbi8qKlxuICogUGFyc2UgaGVhZGVycyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIGBgYFxuICogRGF0ZTogV2VkLCAyNyBBdWcgMjAxNCAwODo1ODo0OSBHTVRcbiAqIENvbnRlbnQtVHlwZTogYXBwbGljYXRpb24vanNvblxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxuICogVHJhbnNmZXItRW5jb2Rpbmc6IGNodW5rZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXJzIEhlYWRlcnMgbmVlZGluZyB0byBiZSBwYXJzZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IEhlYWRlcnMgcGFyc2VkIGludG8gYW4gb2JqZWN0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2VIZWFkZXJzKGhlYWRlcnMpIHtcbiAgdmFyIHBhcnNlZCA9IHt9O1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuICB2YXIgaTtcblxuICBpZiAoIWhlYWRlcnMpIHsgcmV0dXJuIHBhcnNlZDsgfVxuXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxuJyksIGZ1bmN0aW9uIHBhcnNlcihsaW5lKSB7XG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xuICAgIGtleSA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoMCwgaSkpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cihpICsgMSkpO1xuXG4gICAgaWYgKGtleSkge1xuICAgICAgaWYgKHBhcnNlZFtrZXldICYmIGlnbm9yZUR1cGxpY2F0ZU9mLmluZGV4T2Yoa2V5KSA+PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChrZXkgPT09ICdzZXQtY29va2llJykge1xuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJzZWRba2V5XSA9IHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gKyAnLCAnICsgdmFsIDogdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHBhcnNlZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKiBuYXRpdmVzY3JpcHRcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnTmF0aXZlU2NyaXB0JyBvciAnTlMnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgKG5hdmlnYXRvci5wcm9kdWN0ID09PSAnUmVhY3ROYXRpdmUnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOUycpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXG4gICk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFuIEFycmF5IG9yIGFuIE9iamVjdCBpbnZva2luZyBhIGZ1bmN0aW9uIGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgYG9iamAgaXMgYW4gQXJyYXkgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBpbmRleCwgYW5kIGNvbXBsZXRlIGFycmF5IGZvciBlYWNoIGl0ZW0uXG4gKlxuICogSWYgJ29iaicgaXMgYW4gT2JqZWN0IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwga2V5LCBhbmQgY29tcGxldGUgb2JqZWN0IGZvciBlYWNoIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEFycmF5fSBvYmogVGhlIG9iamVjdCB0byBpdGVyYXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgY2FsbGJhY2sgdG8gaW52b2tlIGZvciBlYWNoIGl0ZW1cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaChvYmosIGZuKSB7XG4gIC8vIERvbid0IGJvdGhlciBpZiBubyB2YWx1ZSBwcm92aWRlZFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRm9yY2UgYW4gYXJyYXkgaWYgbm90IGFscmVhZHkgc29tZXRoaW5nIGl0ZXJhYmxlXG4gIGlmICh0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIG9iaiA9IFtvYmpdO1xuICB9XG5cbiAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBhcnJheSB2YWx1ZXNcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2ldLCBpLCBvYmopO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgb2JqZWN0IGtleXNcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgICBmbi5jYWxsKG51bGwsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjZXB0cyB2YXJhcmdzIGV4cGVjdGluZyBlYWNoIGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdCwgdGhlblxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXG4gKlxuICogV2hlbiBtdWx0aXBsZSBvYmplY3RzIGNvbnRhaW4gdGhlIHNhbWUga2V5IHRoZSBsYXRlciBvYmplY3QgaW5cbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiB2YXIgcmVzdWx0ID0gbWVyZ2Uoe2ZvbzogMTIzfSwge2ZvbzogNDU2fSk7XG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBlcXVhbCB0byBtZXJnZSB3aXRoIHRoZSBkaWZmZXJlbmNlIGJlaW5nIHRoYXQgbm8gcmVmZXJlbmNlXG4gKiB0byBvcmlnaW5hbCBvYmplY3RzIGlzIGtlcHQuXG4gKlxuICogQHNlZSBtZXJnZVxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZGVlcE1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHRba2V5XSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gZGVlcE1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGRlZXBNZXJnZTogZGVlcE1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbVxufTtcbiIsImZ1bmN0aW9uIHRvVmFsKG1peCkge1xuXHR2YXIgaywgeSwgc3RyPScnO1xuXG5cdGlmICh0eXBlb2YgbWl4ID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbWl4ID09PSAnbnVtYmVyJykge1xuXHRcdHN0ciArPSBtaXg7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG1peCA9PT0gJ29iamVjdCcpIHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShtaXgpKSB7XG5cdFx0XHRmb3IgKGs9MDsgayA8IG1peC5sZW5ndGg7IGsrKykge1xuXHRcdFx0XHRpZiAobWl4W2tdKSB7XG5cdFx0XHRcdFx0aWYgKHkgPSB0b1ZhbChtaXhba10pKSB7XG5cdFx0XHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRcdFx0c3RyICs9IHk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoayBpbiBtaXgpIHtcblx0XHRcdFx0aWYgKG1peFtrXSkge1xuXHRcdFx0XHRcdHN0ciAmJiAoc3RyICs9ICcgJyk7XG5cdFx0XHRcdFx0c3RyICs9IGs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG5cdHZhciBpPTAsIHRtcCwgeCwgc3RyPScnO1xuXHR3aGlsZSAoaSA8IGFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRpZiAodG1wID0gYXJndW1lbnRzW2krK10pIHtcblx0XHRcdGlmICh4ID0gdG9WYWwodG1wKSkge1xuXHRcdFx0XHRzdHIgJiYgKHN0ciArPSAnICcpO1xuXHRcdFx0XHRzdHIgKz0geFxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRyZXR1cm4gc3RyO1xufVxuIiwiaW1wb3J0IGhhc0NsYXNzIGZyb20gJy4vaGFzQ2xhc3MnO1xuLyoqXG4gKiBBZGRzIGEgQ1NTIGNsYXNzIHRvIGEgZ2l2ZW4gZWxlbWVudC5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWRkQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7XG4gIGlmIChlbGVtZW50LmNsYXNzTGlzdCkgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSk7ZWxzZSBpZiAoIWhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkpIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lICsgXCIgXCIgKyBjbGFzc05hbWU7ZWxzZSBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJykgKyBcIiBcIiArIGNsYXNzTmFtZSk7XG59IiwiLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBlbGVtZW50IGhhcyBhIENTUyBjbGFzcy5cbiAqIFxuICogQHBhcmFtIGVsZW1lbnQgdGhlIGVsZW1lbnRcbiAqIEBwYXJhbSBjbGFzc05hbWUgdGhlIENTUyBjbGFzcyBuYW1lXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGhhc0NsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHJldHVybiAhIWNsYXNzTmFtZSAmJiBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpO1xuICByZXR1cm4gKFwiIFwiICsgKGVsZW1lbnQuY2xhc3NOYW1lLmJhc2VWYWwgfHwgZWxlbWVudC5jbGFzc05hbWUpICsgXCIgXCIpLmluZGV4T2YoXCIgXCIgKyBjbGFzc05hbWUgKyBcIiBcIikgIT09IC0xO1xufSIsImZ1bmN0aW9uIHJlcGxhY2VDbGFzc05hbWUob3JpZ0NsYXNzLCBjbGFzc1RvUmVtb3ZlKSB7XG4gIHJldHVybiBvcmlnQ2xhc3MucmVwbGFjZShuZXcgUmVnRXhwKFwiKF58XFxcXHMpXCIgKyBjbGFzc1RvUmVtb3ZlICsgXCIoPzpcXFxcc3wkKVwiLCAnZycpLCAnJDEnKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuLyoqXG4gKiBSZW1vdmVzIGEgQ1NTIGNsYXNzIGZyb20gYSBnaXZlbiBlbGVtZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCB0aGUgZWxlbWVudFxuICogQHBhcmFtIGNsYXNzTmFtZSB0aGUgQ1NTIGNsYXNzIG5hbWVcbiAqL1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsZW1lbnQsIGNsYXNzTmFtZSkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QpIHtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC5jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgZWxlbWVudC5jbGFzc05hbWUgPSByZXBsYWNlQ2xhc3NOYW1lKGVsZW1lbnQuY2xhc3NOYW1lLCBjbGFzc05hbWUpO1xuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHJlcGxhY2VDbGFzc05hbWUoZWxlbWVudC5jbGFzc05hbWUgJiYgZWxlbWVudC5jbGFzc05hbWUuYmFzZVZhbCB8fCAnJywgY2xhc3NOYW1lKSk7XG4gIH1cbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cblxudmFyIEVSUk9SX01FU1NBR0UgPSAnRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnO1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBmdW5jVHlwZSA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZCh0aGF0KSB7XG4gICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEVSUk9SX01FU1NBR0UgKyB0YXJnZXQpO1xuICAgIH1cbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgIHZhciBib3VuZDtcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGF0LFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcbiAgICB2YXIgYm91bmRBcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgIH1cblxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgIGlmICh0YXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XG4gICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBib3VuZDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4vaW1wbGVtZW50YXRpb24nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCBpbXBsZW1lbnRhdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGJpbmQgPSByZXF1aXJlKCdmdW5jdGlvbi1iaW5kJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIiwidmFyIGUsdD0oZT1yZXF1aXJlKFwicXVlcnlzdHJpbmdcIikpJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmXCJkZWZhdWx0XCJpbiBlP2UuZGVmYXVsdDplLHI9L2h0dHBzP3xmdHB8Z29waGVyfGZpbGUvO2Z1bmN0aW9uIG8oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWcoZSkpO3ZhciBvPWZ1bmN0aW9uKGUsdCxyKXt2YXIgbz1lLmF1dGgsYT1lLmhvc3RuYW1lLHM9ZS5wcm90b2NvbHx8XCJcIixjPWUucGF0aG5hbWV8fFwiXCIsaD1lLmhhc2h8fFwiXCIscD1lLnF1ZXJ5fHxcIlwiLG49ITE7bz1vP2VuY29kZVVSSUNvbXBvbmVudChvKS5yZXBsYWNlKC8lM0EvaSxcIjpcIikrXCJAXCI6XCJcIixlLmhvc3Q/bj1vK2UuaG9zdDphJiYobj1vKyh+YS5pbmRleE9mKFwiOlwiKT9cIltcIithK1wiXVwiOmEpLGUucG9ydCYmKG4rPVwiOlwiK2UucG9ydCkpLHAmJlwib2JqZWN0XCI9PXR5cGVvZiBwJiYocD10LmVuY29kZShwKSk7dmFyIGw9ZS5zZWFyY2h8fHAmJlwiP1wiK3B8fFwiXCI7cmV0dXJuIHMmJlwiOlwiIT09cy5zdWJzdHIoLTEpJiYocys9XCI6XCIpLGUuc2xhc2hlc3x8KCFzfHxyLnRlc3QocykpJiYhMSE9PW4/KG49XCIvL1wiKyhufHxcIlwiKSxjJiZcIi9cIiE9PWNbMF0mJihjPVwiL1wiK2MpKTpufHwobj1cIlwiKSxoJiZcIiNcIiE9PWhbMF0mJihoPVwiI1wiK2gpLGwmJlwiP1wiIT09bFswXSYmKGw9XCI/XCIrbCkse3Byb3RvY29sOnMsaG9zdDpuLHBhdGhuYW1lOmM9Yy5yZXBsYWNlKC9bPyNdL2csZW5jb2RlVVJJQ29tcG9uZW50KSxzZWFyY2g6bD1sLnJlcGxhY2UoXCIjXCIsXCIlMjNcIiksaGFzaDpofX0oZSx0LHIpO3JldHVyblwiXCIrby5wcm90b2NvbCtvLmhvc3Qrby5wYXRobmFtZStvLnNlYXJjaCtvLmhhc2h9dmFyIGE9XCJodHRwOi8vXCIscz1cIncud1wiLGM9YStzLGg9L14oW2EtejAtOS4rLV0qOlxcL1xcL1xcLykoW2EtejAtOS4rLV06XFwvKik/L2kscD0vaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS87ZnVuY3Rpb24gbihlLHQpe3ZhciByPVwic3RyaW5nXCI9PXR5cGVvZiBlP2coZSk6ZTtlPVwib2JqZWN0XCI9PXR5cGVvZiBlP28oZSk6ZTt2YXIgcz1nKHQpLG49XCJcIjtyLnByb3RvY29sJiYhci5zbGFzaGVzJiYobj1yLnByb3RvY29sLGU9ZS5yZXBsYWNlKHIucHJvdG9jb2wsXCJcIiksbis9XCIvXCI9PT10WzBdfHxcIi9cIj09PWVbMF0/XCIvXCI6XCJcIiksbiYmcy5wcm90b2NvbCYmKG49XCJcIixzLnNsYXNoZXN8fChuPXMucHJvdG9jb2wsdD10LnJlcGxhY2Uocy5wcm90b2NvbCxcIlwiKSkpO3ZhciBsPWUubWF0Y2goaCk7bCYmIXMucHJvdG9jb2wmJihlPWUuc3Vic3RyKChuPWxbMV0rKGxbMl18fFwiXCIpKS5sZW5ndGgpLC9eXFwvXFwvW14vXS8udGVzdCh0KSYmKG49bi5zbGljZSgwLC0xKSkpO3ZhciBpPW5ldyBVUkwoZSxjK1wiL1wiKSxmPW5ldyBVUkwodCxpKS50b1N0cmluZygpLnJlcGxhY2UoYyxcIlwiKSx1PXMucHJvdG9jb2x8fHIucHJvdG9jb2w7cmV0dXJuIHUrPXIuc2xhc2hlc3x8cy5zbGFzaGVzP1wiLy9cIjpcIlwiLCFuJiZ1P2Y9Zi5yZXBsYWNlKGEsdSk6biYmKGY9Zi5yZXBsYWNlKGEsXCJcIikpLHAudGVzdChmKXx8fnQuaW5kZXhPZihcIi5cIil8fFwiL1wiPT09ZS5zbGljZSgtMSl8fFwiL1wiPT09dC5zbGljZSgtMSl8fFwiL1wiIT09Zi5zbGljZSgtMSl8fChmPWYuc2xpY2UoMCwtMSkpLG4mJihmPW4rKFwiL1wiPT09ZlswXT9mLnN1YnN0cigxKTpmKSksZn1mdW5jdGlvbiBsKCl7fWwucGFyc2U9ZyxsLmZvcm1hdD1vLGwucmVzb2x2ZT1uLGwucmVzb2x2ZU9iamVjdD1uO3ZhciBpPS9eaHR0cHM/fGZ0cHxnb3BoZXJ8ZmlsZS8sZj0vXiguKj8pKFsjP10uKikvLHU9L14oW2EtejAtOS4rLV0qOikoXFwvezAsM30pKC4qKS9pLG09L14oW2EtejAtOS4rLV0qOik/XFwvXFwvXFwvKi9pLHY9L14oW2EtejAtOS4rLV0qOikoXFwvezAsMn0pXFxbKC4qKVxcXSQvaTtmdW5jdGlvbiBkKGUpe3RyeXtyZXR1cm4gZGVjb2RlVVJJKGUpfWNhdGNoKHQpe3JldHVybiBlfX1mdW5jdGlvbiBnKGUscixhKXtpZih2b2lkIDA9PT1yJiYocj0hMSksdm9pZCAwPT09YSYmKGE9ITEpLGUmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlIGluc3RhbmNlb2YgbClyZXR1cm4gZTt2YXIgaD0oZT1lLnRyaW0oKSkubWF0Y2goZik7ZT1oP2QoaFsxXSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKStoWzJdOmQoZSkucmVwbGFjZSgvXFxcXC9nLFwiL1wiKSx2LnRlc3QoZSkmJlwiL1wiIT09ZS5zbGljZSgtMSkmJihlKz1cIi9cIik7dmFyIHA9IS8oXmphdmFzY3JpcHQpLy50ZXN0KGUpJiZlLm1hdGNoKHUpLG49bS50ZXN0KGUpLGc9XCJcIjtwJiYoaS50ZXN0KHBbMV0pfHwoZz1wWzFdLnRvTG93ZXJDYXNlKCksZT1cIlwiK3BbMl0rcFszXSkscFsyXXx8KG49ITEsaS50ZXN0KHBbMV0pPyhnPXBbMV0sZT1cIlwiK3BbM10pOmU9XCIvL1wiK3BbM10pLDMhPT1wWzJdLmxlbmd0aCYmMSE9PXBbMl0ubGVuZ3RofHwoZz1wWzFdLGU9XCIvXCIrcFszXSkpO3ZhciBiLHk9KGg/aFsxXTplKS5tYXRjaCgvKDpbMC05XSspLyksaj1cIlwiO3kmJnlbMV0mJjM9PT15WzFdLmxlbmd0aCYmKGU9ZS5yZXBsYWNlKGo9eVsxXSxqK1wiMDBcIikpO3ZhciB3PW5ldyBsLHg9XCJcIixVPVwiXCI7dHJ5e2I9bmV3IFVSTChlKX1jYXRjaCh0KXt4PXQsZ3x8YXx8IS9eXFwvXFwvLy50ZXN0KGUpfHwvXlxcL1xcLy4rW0AuXS8udGVzdChlKXx8KFU9XCIvXCIsZT1lLnN1YnN0cigxKSk7dHJ5e2I9bmV3IFVSTChlLGMpfWNhdGNoKGUpe3JldHVybiB3LnByb3RvY29sPWcsdy5ocmVmPWcsd319dy5zbGFzaGVzPW4mJiFVLHcuaG9zdD1iLmhvc3Q9PT1zP1wiXCI6Yi5ob3N0LHcuaG9zdG5hbWU9Yi5ob3N0bmFtZT09PXM/XCJcIjpiLmhvc3RuYW1lLnJlcGxhY2UoLyhcXFt8XFxdKS9nLFwiXCIpLHcucHJvdG9jb2w9eD9nfHxudWxsOmIucHJvdG9jb2wsdy5zZWFyY2g9Yi5zZWFyY2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpLHcuaGFzaD1iLmhhc2gucmVwbGFjZSgvXFxcXC9nLFwiJTVDXCIpO3ZhciBSPWUuc3BsaXQoXCIjXCIpOyF3LnNlYXJjaCYmflJbMF0uaW5kZXhPZihcIj9cIikmJih3LnNlYXJjaD1cIj9cIiksdy5oYXNofHxcIlwiIT09UlsxXXx8KHcuaGFzaD1cIiNcIiksdy5xdWVyeT1yP3QuZGVjb2RlKGIuc2VhcmNoLnN1YnN0cigxKSk6dy5zZWFyY2guc3Vic3RyKDEpLHcucGF0aG5hbWU9VStkKGIucGF0aG5hbWUpLnJlcGxhY2UoL1wiL2csXCIlMjJcIiksXCJhYm91dDpcIj09PXcucHJvdG9jb2wmJlwiYmxhbmtcIj09PXcucGF0aG5hbWUmJih3LnByb3RvY29sPVwiXCIsdy5wYXRobmFtZT1cIlwiKSx4JiZcIi9cIiE9PWVbMF0mJih3LnBhdGhuYW1lPXcucGF0aG5hbWUuc3Vic3RyKDEpKSxnJiYhaS50ZXN0KGcpJiZcIi9cIiE9PWUuc2xpY2UoLTEpJiZcIi9cIj09PXcucGF0aG5hbWUmJih3LnBhdGhuYW1lPVwiXCIpLHcucGF0aD13LnBhdGhuYW1lK3cuc2VhcmNoLHcuYXV0aD1bYi51c2VybmFtZSxiLnBhc3N3b3JkXS5tYXAoZGVjb2RlVVJJQ29tcG9uZW50KS5maWx0ZXIoQm9vbGVhbikuam9pbihcIjpcIiksdy5wb3J0PWIucG9ydCxqJiYody5ob3N0PXcuaG9zdC5yZXBsYWNlKGorXCIwMFwiLGopLHcucG9ydD13LnBvcnQuc2xpY2UoMCwtMikpLHcuaHJlZj1VP1wiXCIrdy5wYXRobmFtZSt3LnNlYXJjaCt3Lmhhc2g6byh3KTt2YXIgTz0vXihmaWxlKS8udGVzdCh3LmhyZWYpP1tcImhvc3RcIixcImhvc3RuYW1lXCJdOltdO3JldHVybiBPYmplY3Qua2V5cyh3KS5mb3JFYWNoKGZ1bmN0aW9uKGUpe35PLmluZGV4T2YoZSl8fCh3W2VdPXdbZV18fG51bGwpfSksd31leHBvcnRzLnBhcnNlPWcsZXhwb3J0cy5mb3JtYXQ9byxleHBvcnRzLnJlc29sdmU9bixleHBvcnRzLnJlc29sdmVPYmplY3Q9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZyhuKGUsdCkpfSxleHBvcnRzLlVybD1sO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1XCIpKShcIi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvb2JqZWN0LWFzc2lnbi5qc1wiKTsiLCJcInVzZSBzdHJpY3RcIjt2YXIgYXNzaWduPU9iamVjdC5hc3NpZ24uYmluZChPYmplY3QpO2Z1bmN0aW9uIGcoKXtyZXR1cm4gYXNzaWduO31PYmplY3QuZGVmaW5lUHJvcGVydGllcyhnKCkse2ltcGxlbWVudGF0aW9uOntnZXQ6Z30sc2hpbTp7dmFsdWU6Z30sZ2V0UG9seWZpbGw6e3ZhbHVlOmd9fSk7bW9kdWxlLmV4cG9ydHM9ZygpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCJEOlxcXFxTa3JpcHNpXFxcXG1pY3JvIHNlcnZpY2VzXFxcXEZST05URU5EXFxcXGZyb250cGFnZVxcXFxzcmNcXFxccGFnZXNcXFxcaW5kZXguanNcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICIsImRlY2xhcmUgY29uc3QgX19ORVhUX0RBVEFfXzogYW55XG5cbmltcG9ydCBSZWFjdCwgeyBDaGlsZHJlbiwgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBwYXJzZSwgcmVzb2x2ZSwgVXJsT2JqZWN0IH0gZnJvbSAndXJsJ1xuaW1wb3J0IHsgUHJlZmV0Y2hPcHRpb25zIH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3JvdXRlci9yb3V0ZXInXG5pbXBvcnQge1xuICBleGVjT25jZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldExvY2F0aW9uT3JpZ2luLFxufSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvdXRpbHMnXG5pbXBvcnQgUm91dGVyIGZyb20gJy4vcm91dGVyJ1xuaW1wb3J0IHsgYWRkQmFzZVBhdGggfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcblxuZnVuY3Rpb24gaXNMb2NhbChocmVmOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3QgdXJsID0gcGFyc2UoaHJlZiwgZmFsc2UsIHRydWUpXG4gIGNvbnN0IG9yaWdpbiA9IHBhcnNlKGdldExvY2F0aW9uT3JpZ2luKCksIGZhbHNlLCB0cnVlKVxuXG4gIHJldHVybiAoXG4gICAgIXVybC5ob3N0IHx8ICh1cmwucHJvdG9jb2wgPT09IG9yaWdpbi5wcm90b2NvbCAmJiB1cmwuaG9zdCA9PT0gb3JpZ2luLmhvc3QpXG4gIClcbn1cblxudHlwZSBVcmwgPSBzdHJpbmcgfCBVcmxPYmplY3RcbnR5cGUgRm9ybWF0UmVzdWx0ID0geyBocmVmOiBzdHJpbmc7IGFzPzogc3RyaW5nIH1cblxuZnVuY3Rpb24gbWVtb2l6ZWRGb3JtYXRVcmwoZm9ybWF0RnVuYzogKGhyZWY6IFVybCwgYXM/OiBVcmwpID0+IEZvcm1hdFJlc3VsdCkge1xuICBsZXQgbGFzdEhyZWY6IG51bGwgfCBVcmwgPSBudWxsXG4gIGxldCBsYXN0QXM6IHVuZGVmaW5lZCB8IG51bGwgfCBVcmwgPSBudWxsXG4gIGxldCBsYXN0UmVzdWx0OiBudWxsIHwgRm9ybWF0UmVzdWx0ID0gbnVsbFxuICByZXR1cm4gKGhyZWY6IFVybCwgYXM/OiBVcmwpID0+IHtcbiAgICBpZiAobGFzdFJlc3VsdCAmJiBocmVmID09PSBsYXN0SHJlZiAmJiBhcyA9PT0gbGFzdEFzKSB7XG4gICAgICByZXR1cm4gbGFzdFJlc3VsdFxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGZvcm1hdEZ1bmMoaHJlZiwgYXMpXG4gICAgbGFzdEhyZWYgPSBocmVmXG4gICAgbGFzdEFzID0gYXNcbiAgICBsYXN0UmVzdWx0ID0gcmVzdWx0XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFVybCh1cmw6IFVybCk6IHN0cmluZyB7XG4gIHJldHVybiB1cmwgJiYgdHlwZW9mIHVybCA9PT0gJ29iamVjdCcgPyBmb3JtYXRXaXRoVmFsaWRhdGlvbih1cmwpIDogdXJsXG59XG5cbmV4cG9ydCB0eXBlIExpbmtQcm9wcyA9IHtcbiAgaHJlZjogVXJsXG4gIGFzPzogVXJsXG4gIHJlcGxhY2U/OiBib29sZWFuXG4gIHNjcm9sbD86IGJvb2xlYW5cbiAgc2hhbGxvdz86IGJvb2xlYW5cbiAgcGFzc0hyZWY/OiBib29sZWFuXG4gIHByZWZldGNoPzogYm9vbGVhblxufVxuXG5sZXQgb2JzZXJ2ZXI6IEludGVyc2VjdGlvbk9ic2VydmVyXG5jb25zdCBsaXN0ZW5lcnMgPSBuZXcgTWFwPEVsZW1lbnQsICgpID0+IHZvaWQ+KClcbmNvbnN0IEludGVyc2VjdGlvbk9ic2VydmVyID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgOiBudWxsXG5jb25zdCBwcmVmZXRjaGVkOiB7IFtjYWNoZUtleTogc3RyaW5nXTogYm9vbGVhbiB9ID0ge31cblxuZnVuY3Rpb24gZ2V0T2JzZXJ2ZXIoKTogSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgfCB1bmRlZmluZWQge1xuICAvLyBSZXR1cm4gc2hhcmVkIGluc3RhbmNlIG9mIEludGVyc2VjdGlvbk9ic2VydmVyIGlmIGFscmVhZHkgY3JlYXRlZFxuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gb2JzZXJ2ZXJcbiAgfVxuXG4gIC8vIE9ubHkgY3JlYXRlIHNoYXJlZCBJbnRlcnNlY3Rpb25PYnNlcnZlciBpZiBzdXBwb3J0ZWQgaW4gYnJvd3NlclxuICBpZiAoIUludGVyc2VjdGlvbk9ic2VydmVyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG5cbiAgcmV0dXJuIChvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihcbiAgICAoZW50cmllcykgPT4ge1xuICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoIWxpc3RlbmVycy5oYXMoZW50cnkudGFyZ2V0KSkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2IgPSBsaXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkhXG4gICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZyB8fCBlbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyA+IDApIHtcbiAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUoZW50cnkudGFyZ2V0KVxuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHsgcm9vdE1hcmdpbjogJzIwMHB4JyB9XG4gICkpXG59XG5cbmNvbnN0IGxpc3RlblRvSW50ZXJzZWN0aW9ucyA9IChlbDogRWxlbWVudCwgY2I6ICgpID0+IHZvaWQpID0+IHtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBnZXRPYnNlcnZlcigpXG4gIGlmICghb2JzZXJ2ZXIpIHtcbiAgICByZXR1cm4gKCkgPT4ge31cbiAgfVxuXG4gIG9ic2VydmVyLm9ic2VydmUoZWwpXG4gIGxpc3RlbmVycy5zZXQoZWwsIGNiKVxuICByZXR1cm4gKCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBvYnNlcnZlci51bm9ic2VydmUoZWwpXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICB9XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShlbClcbiAgfVxufVxuXG5jbGFzcyBMaW5rIGV4dGVuZHMgQ29tcG9uZW50PExpbmtQcm9wcz4ge1xuICBwOiBib29sZWFuXG5cbiAgY29uc3RydWN0b3IocHJvcHM6IExpbmtQcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAocHJvcHMucHJlZmV0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdOZXh0LmpzIGF1dG8tcHJlZmV0Y2hlcyBhdXRvbWF0aWNhbGx5IGJhc2VkIG9uIHZpZXdwb3J0LiBUaGUgcHJlZmV0Y2ggYXR0cmlidXRlIGlzIG5vIGxvbmdlciBuZWVkZWQuIE1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3ByZWZldGNoLXRydWUtZGVwcmVjYXRlZCdcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnAgPSBwcm9wcy5wcmVmZXRjaCAhPT0gZmFsc2VcbiAgfVxuXG4gIGNsZWFuVXBMaXN0ZW5lcnMgPSAoKSA9PiB7fVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCk6IHZvaWQge1xuICAgIHRoaXMuY2xlYW5VcExpc3RlbmVycygpXG4gIH1cblxuICBnZXRQYXRocygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gd2luZG93LmxvY2F0aW9uXG4gICAgY29uc3QgeyBocmVmOiBwYXJzZWRIcmVmLCBhczogcGFyc2VkQXMgfSA9IHRoaXMuZm9ybWF0VXJscyhcbiAgICAgIHRoaXMucHJvcHMuaHJlZixcbiAgICAgIHRoaXMucHJvcHMuYXNcbiAgICApXG4gICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gcmVzb2x2ZShwYXRobmFtZSwgcGFyc2VkSHJlZilcbiAgICByZXR1cm4gW3Jlc29sdmVkSHJlZiwgcGFyc2VkQXMgPyByZXNvbHZlKHBhdGhuYW1lLCBwYXJzZWRBcykgOiByZXNvbHZlZEhyZWZdXG4gIH1cblxuICBoYW5kbGVSZWYocmVmOiBFbGVtZW50KTogdm9pZCB7XG4gICAgaWYgKHRoaXMucCAmJiBJbnRlcnNlY3Rpb25PYnNlcnZlciAmJiByZWYgJiYgcmVmLnRhZ05hbWUpIHtcbiAgICAgIHRoaXMuY2xlYW5VcExpc3RlbmVycygpXG5cbiAgICAgIGNvbnN0IGlzUHJlZmV0Y2hlZCA9XG4gICAgICAgIHByZWZldGNoZWRbXG4gICAgICAgICAgdGhpcy5nZXRQYXRocygpLmpvaW4oXG4gICAgICAgICAgICAvLyBKb2luIG9uIGFuIGludmFsaWQgVVJJIGNoYXJhY3RlclxuICAgICAgICAgICAgJyUnXG4gICAgICAgICAgKVxuICAgICAgICBdXG4gICAgICBpZiAoIWlzUHJlZmV0Y2hlZCkge1xuICAgICAgICB0aGlzLmNsZWFuVXBMaXN0ZW5lcnMgPSBsaXN0ZW5Ub0ludGVyc2VjdGlvbnMocmVmLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcmVmZXRjaCgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlIGZ1bmN0aW9uIGlzIG1lbW9pemVkIHNvIHRoYXQgbm8gZXh0cmEgbGlmZWN5Y2xlcyBhcmUgbmVlZGVkXG4gIC8vIGFzIHBlciBodHRwczovL3JlYWN0anMub3JnL2Jsb2cvMjAxOC8wNi8wNy95b3UtcHJvYmFibHktZG9udC1uZWVkLWRlcml2ZWQtc3RhdGUuaHRtbFxuICBmb3JtYXRVcmxzID0gbWVtb2l6ZWRGb3JtYXRVcmwoKGhyZWYsIGFzSHJlZikgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICBocmVmOiBhZGRCYXNlUGF0aChmb3JtYXRVcmwoaHJlZikpLFxuICAgICAgYXM6IGFzSHJlZiA/IGFkZEJhc2VQYXRoKGZvcm1hdFVybChhc0hyZWYpKSA6IGFzSHJlZixcbiAgICB9XG4gIH0pXG5cbiAgbGlua0NsaWNrZWQgPSAoZTogUmVhY3QuTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHsgbm9kZU5hbWUsIHRhcmdldCB9ID0gZS5jdXJyZW50VGFyZ2V0IGFzIEhUTUxBbmNob3JFbGVtZW50XG4gICAgaWYgKFxuICAgICAgbm9kZU5hbWUgPT09ICdBJyAmJlxuICAgICAgKCh0YXJnZXQgJiYgdGFyZ2V0ICE9PSAnX3NlbGYnKSB8fFxuICAgICAgICBlLm1ldGFLZXkgfHxcbiAgICAgICAgZS5jdHJsS2V5IHx8XG4gICAgICAgIGUuc2hpZnRLZXkgfHxcbiAgICAgICAgKGUubmF0aXZlRXZlbnQgJiYgZS5uYXRpdmVFdmVudC53aGljaCA9PT0gMikpXG4gICAgKSB7XG4gICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIG5ldyB0YWIgLyBuZXcgd2luZG93IGJlaGF2aW9yXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgeyBocmVmLCBhcyB9ID0gdGhpcy5mb3JtYXRVcmxzKHRoaXMucHJvcHMuaHJlZiwgdGhpcy5wcm9wcy5hcylcblxuICAgIGlmICghaXNMb2NhbChocmVmKSkge1xuICAgICAgLy8gaWdub3JlIGNsaWNrIGlmIGl0J3Mgb3V0c2lkZSBvdXIgc2NvcGUgKGUuZy4gaHR0cHM6Ly9nb29nbGUuY29tKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgeyBwYXRobmFtZSB9ID0gd2luZG93LmxvY2F0aW9uXG4gICAgaHJlZiA9IHJlc29sdmUocGF0aG5hbWUsIGhyZWYpXG4gICAgYXMgPSBhcyA/IHJlc29sdmUocGF0aG5hbWUsIGFzKSA6IGhyZWZcblxuICAgIGUucHJldmVudERlZmF1bHQoKVxuXG4gICAgLy8gIGF2b2lkIHNjcm9sbCBmb3IgdXJscyB3aXRoIGFuY2hvciByZWZzXG4gICAgbGV0IHsgc2Nyb2xsIH0gPSB0aGlzLnByb3BzXG4gICAgaWYgKHNjcm9sbCA9PSBudWxsKSB7XG4gICAgICBzY3JvbGwgPSBhcy5pbmRleE9mKCcjJykgPCAwXG4gICAgfVxuXG4gICAgLy8gcmVwbGFjZSBzdGF0ZSBpbnN0ZWFkIG9mIHB1c2ggaWYgcHJvcCBpcyBwcmVzZW50XG4gICAgUm91dGVyW3RoaXMucHJvcHMucmVwbGFjZSA/ICdyZXBsYWNlJyA6ICdwdXNoJ10oaHJlZiwgYXMsIHtcbiAgICAgIHNoYWxsb3c6IHRoaXMucHJvcHMuc2hhbGxvdyxcbiAgICB9KS50aGVuKChzdWNjZXNzOiBib29sZWFuKSA9PiB7XG4gICAgICBpZiAoIXN1Y2Nlc3MpIHJldHVyblxuICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHByZWZldGNoKG9wdGlvbnM/OiBQcmVmZXRjaE9wdGlvbnMpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucCB8fCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgcmV0dXJuXG4gICAgLy8gUHJlZmV0Y2ggdGhlIEpTT04gcGFnZSBpZiBhc2tlZCAob25seSBpbiB0aGUgY2xpZW50KVxuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5nZXRQYXRocygpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFJvdXRlci5wcmVmZXRjaChwYXRoc1svKiBocmVmICovIDBdLCBwYXRoc1svKiBhc1BhdGggKi8gMV0sIG9wdGlvbnMpLmNhdGNoKFxuICAgICAgKGVycikgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgICAgICB0aHJvdyBlcnJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbiAgICBwcmVmZXRjaGVkW1xuICAgICAgcGF0aHMuam9pbihcbiAgICAgICAgLy8gSm9pbiBvbiBhbiBpbnZhbGlkIFVSSSBjaGFyYWN0ZXJcbiAgICAgICAgJyUnXG4gICAgICApXG4gICAgXSA9IHRydWVcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgaHJlZiwgYXMgfSA9IHRoaXMuZm9ybWF0VXJscyh0aGlzLnByb3BzLmhyZWYsIHRoaXMucHJvcHMuYXMpXG4gICAgLy8gRGVwcmVjYXRlZC4gV2FybmluZyBzaG93biBieSBwcm9wVHlwZSBjaGVjay4gSWYgdGhlIGNoaWxkcmVuIHByb3ZpZGVkIGlzIGEgc3RyaW5nICg8TGluaz5leGFtcGxlPC9MaW5rPikgd2Ugd3JhcCBpdCBpbiBhbiA8YT4gdGFnXG4gICAgaWYgKHR5cGVvZiBjaGlsZHJlbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNoaWxkcmVuID0gPGE+e2NoaWxkcmVufTwvYT5cbiAgICB9XG5cbiAgICAvLyBUaGlzIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBjaGlsZCwgaWYgbXVsdGlwbGUgYXJlIHByb3ZpZGVkIGl0IHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICBjb25zdCBjaGlsZDogYW55ID0gQ2hpbGRyZW4ub25seShjaGlsZHJlbilcbiAgICBjb25zdCBwcm9wczoge1xuICAgICAgb25Nb3VzZUVudGVyOiBSZWFjdC5Nb3VzZUV2ZW50SGFuZGxlclxuICAgICAgb25DbGljazogUmVhY3QuTW91c2VFdmVudEhhbmRsZXJcbiAgICAgIGhyZWY/OiBzdHJpbmdcbiAgICAgIHJlZj86IGFueVxuICAgIH0gPSB7XG4gICAgICByZWY6IChlbDogYW55KSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlUmVmKGVsKVxuXG4gICAgICAgIGlmIChjaGlsZCAmJiB0eXBlb2YgY2hpbGQgPT09ICdvYmplY3QnICYmIGNoaWxkLnJlZikge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQucmVmID09PSAnZnVuY3Rpb24nKSBjaGlsZC5yZWYoZWwpXG4gICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNoaWxkLnJlZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlZi5jdXJyZW50ID0gZWxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbk1vdXNlRW50ZXI6IChlOiBSZWFjdC5Nb3VzZUV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2hpbGQucHJvcHMub25Nb3VzZUVudGVyKGUpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVmZXRjaCh7IHByaW9yaXR5OiB0cnVlIH0pXG4gICAgICB9LFxuICAgICAgb25DbGljazogKGU6IFJlYWN0Lk1vdXNlRXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKVxuICAgICAgICB9XG4gICAgICAgIGlmICghZS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgdGhpcy5saW5rQ2xpY2tlZChlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH1cblxuICAgIC8vIElmIGNoaWxkIGlzIGFuIDxhPiB0YWcgYW5kIGRvZXNuJ3QgaGF2ZSBhIGhyZWYgYXR0cmlidXRlLCBvciBpZiB0aGUgJ3Bhc3NIcmVmJyBwcm9wZXJ0eSBpc1xuICAgIC8vIGRlZmluZWQsIHdlIHNwZWNpZnkgdGhlIGN1cnJlbnQgJ2hyZWYnLCBzbyB0aGF0IHJlcGV0aXRpb24gaXMgbm90IG5lZWRlZCBieSB0aGUgdXNlclxuICAgIGlmIChcbiAgICAgIHRoaXMucHJvcHMucGFzc0hyZWYgfHxcbiAgICAgIChjaGlsZC50eXBlID09PSAnYScgJiYgISgnaHJlZicgaW4gY2hpbGQucHJvcHMpKVxuICAgICkge1xuICAgICAgcHJvcHMuaHJlZiA9IGFzIHx8IGhyZWZcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIGVuZGluZyBzbGFzaCB0byB0aGUgcGF0aHMuIFNvLCB3ZSBjYW4gc2VydmUgdGhlXG4gICAgLy8gXCI8cGFnZT4vaW5kZXguaHRtbFwiIGRpcmVjdGx5LlxuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4uL25leHQtc2VydmVyL2xpYi9yb3V0ZXIvcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgIC5yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydFxuICAgICAgaWYgKFxuICAgICAgICBwcm9wcy5ocmVmICYmXG4gICAgICAgIHR5cGVvZiBfX05FWFRfREFUQV9fICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBfX05FWFRfREFUQV9fLm5leHRFeHBvcnRcbiAgICAgICkge1xuICAgICAgICBwcm9wcy5ocmVmID0gcmV3cml0ZVVybEZvck5leHRFeHBvcnQocHJvcHMuaHJlZilcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcylcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgY29uc3Qgd2FybiA9IGV4ZWNPbmNlKGNvbnNvbGUuZXJyb3IpXG5cbiAgLy8gVGhpcyBtb2R1bGUgZ2V0cyByZW1vdmVkIGJ5IHdlYnBhY2suSWdub3JlUGx1Z2luXG4gIGNvbnN0IFByb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMnKVxuICBjb25zdCBleGFjdCA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMtZXhhY3QnKVxuICAvLyBAdHMtaWdub3JlIHRoZSBwcm9wZXJ0eSBpcyBzdXBwb3J0ZWQsIHdoZW4gZGVjbGFyaW5nIGl0IG9uIHRoZSBjbGFzcyBpdCBvdXRwdXRzIGFuIGV4dHJhIGJpdCBvZiBjb2RlIHdoaWNoIGlzIG5vdCBuZWVkZWQuXG4gIExpbmsucHJvcFR5cGVzID0gZXhhY3Qoe1xuICAgIGhyZWY6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICAgIGFzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgcHJlZmV0Y2g6IFByb3BUeXBlcy5ib29sLFxuICAgIHJlcGxhY2U6IFByb3BUeXBlcy5ib29sLFxuICAgIHNoYWxsb3c6IFByb3BUeXBlcy5ib29sLFxuICAgIHBhc3NIcmVmOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBzY3JvbGw6IFByb3BUeXBlcy5ib29sLFxuICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtcbiAgICAgIFByb3BUeXBlcy5lbGVtZW50LFxuICAgICAgKHByb3BzOiBhbnksIHByb3BOYW1lOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wTmFtZV1cblxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICBgV2FybmluZzogWW91J3JlIHVzaW5nIGEgc3RyaW5nIGRpcmVjdGx5IGluc2lkZSA8TGluaz4uIFRoaXMgdXNhZ2UgaGFzIGJlZW4gZGVwcmVjYXRlZC4gUGxlYXNlIGFkZCBhbiA8YT4gdGFnIGFzIGNoaWxkIG9mIDxMaW5rPmBcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfSxcbiAgICBdKS5pc1JlcXVpcmVkLFxuICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBMaW5rXG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgUm91dGVyLCB7IE5leHRSb3V0ZXIgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IFJvdXRlckNvbnRleHQgfSBmcm9tICcuLi9uZXh0LXNlcnZlci9saWIvcm91dGVyLWNvbnRleHQnXG5cbnR5cGUgQ2xhc3NBcmd1bWVudHM8VD4gPSBUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBpbmZlciBVKSA9PiBhbnkgPyBVIDogYW55XG5cbnR5cGUgUm91dGVyQXJncyA9IENsYXNzQXJndW1lbnRzPHR5cGVvZiBSb3V0ZXI+XG5cbnR5cGUgU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBSb3V0ZXIgfCBudWxsXG4gIHJlYWR5Q2FsbGJhY2tzOiBBcnJheTwoKSA9PiBhbnk+XG4gIHJlYWR5KGNiOiAoKSA9PiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCB7IFJvdXRlciwgTmV4dFJvdXRlciB9XG5cbmV4cG9ydCB0eXBlIFNpbmdsZXRvblJvdXRlciA9IFNpbmdsZXRvblJvdXRlckJhc2UgJiBOZXh0Um91dGVyXG5cbmNvbnN0IHNpbmdsZXRvblJvdXRlcjogU2luZ2xldG9uUm91dGVyQmFzZSA9IHtcbiAgcm91dGVyOiBudWxsLCAvLyBob2xkcyB0aGUgYWN0dWFsIHJvdXRlciBpbnN0YW5jZVxuICByZWFkeUNhbGxiYWNrczogW10sXG4gIHJlYWR5KGNiOiAoKSA9PiB2b2lkKSB7XG4gICAgaWYgKHRoaXMucm91dGVyKSByZXR1cm4gY2IoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5yZWFkeUNhbGxiYWNrcy5wdXNoKGNiKVxuICAgIH1cbiAgfSxcbn1cblxuLy8gQ3JlYXRlIHB1YmxpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIG9mIHRoZSByb3V0ZXIgaW4gdGhlIHNpbmdsZXRvblJvdXRlclxuY29uc3QgdXJsUHJvcGVydHlGaWVsZHMgPSBbXG4gICdwYXRobmFtZScsXG4gICdyb3V0ZScsXG4gICdxdWVyeScsXG4gICdhc1BhdGgnLFxuICAnY29tcG9uZW50cycsXG4gICdpc0ZhbGxiYWNrJyxcbiAgJ2Jhc2VQYXRoJyxcbl1cbmNvbnN0IHJvdXRlckV2ZW50cyA9IFtcbiAgJ3JvdXRlQ2hhbmdlU3RhcnQnLFxuICAnYmVmb3JlSGlzdG9yeUNoYW5nZScsXG4gICdyb3V0ZUNoYW5nZUNvbXBsZXRlJyxcbiAgJ3JvdXRlQ2hhbmdlRXJyb3InLFxuICAnaGFzaENoYW5nZVN0YXJ0JyxcbiAgJ2hhc2hDaGFuZ2VDb21wbGV0ZScsXG5dXG5jb25zdCBjb3JlTWV0aG9kRmllbGRzID0gW1xuICAncHVzaCcsXG4gICdyZXBsYWNlJyxcbiAgJ3JlbG9hZCcsXG4gICdiYWNrJyxcbiAgJ3ByZWZldGNoJyxcbiAgJ2JlZm9yZVBvcFN0YXRlJyxcbl1cblxuLy8gRXZlbnRzIGlzIGEgc3RhdGljIHByb3BlcnR5IG9uIHRoZSByb3V0ZXIsIHRoZSByb3V0ZXIgZG9lc24ndCBoYXZlIHRvIGJlIGluaXRpYWxpemVkIHRvIHVzZSBpdFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHNpbmdsZXRvblJvdXRlciwgJ2V2ZW50cycsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBSb3V0ZXIuZXZlbnRzXG4gIH0sXG59KVxuXG51cmxQcm9wZXJ0eUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBIZXJlIHdlIG5lZWQgdG8gdXNlIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBiZWNhdXNlLCB3ZSBuZWVkIHRvIHJldHVyblxuICAvLyB0aGUgcHJvcGVydHkgYXNzaWduZWQgdG8gdGhlIGFjdHVhbCByb3V0ZXJcbiAgLy8gVGhlIHZhbHVlIG1pZ2h0IGdldCBjaGFuZ2VkIGFzIHdlIGNoYW5nZSByb3V0ZXMgYW5kIHRoaXMgaXMgdGhlXG4gIC8vIHByb3BlciB3YXkgdG8gYWNjZXNzIGl0XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzaW5nbGV0b25Sb3V0ZXIsIGZpZWxkLCB7XG4gICAgZ2V0KCkge1xuICAgICAgY29uc3Qgcm91dGVyID0gZ2V0Um91dGVyKCkgYXMgYW55XG4gICAgICByZXR1cm4gcm91dGVyW2ZpZWxkXSBhcyBzdHJpbmdcbiAgICB9LFxuICB9KVxufSlcblxuY29yZU1ldGhvZEZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAvLyBXZSBkb24ndCByZWFsbHkga25vdyB0aGUgdHlwZXMgaGVyZSwgc28gd2UgYWRkIHRoZW0gbGF0ZXIgaW5zdGVhZFxuICA7KHNpbmdsZXRvblJvdXRlciBhcyBhbnkpW2ZpZWxkXSA9ICguLi5hcmdzOiBhbnlbXSkgPT4ge1xuICAgIGNvbnN0IHJvdXRlciA9IGdldFJvdXRlcigpIGFzIGFueVxuICAgIHJldHVybiByb3V0ZXJbZmllbGRdKC4uLmFyZ3MpXG4gIH1cbn0pXG5cbnJvdXRlckV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHkoKCkgPT4ge1xuICAgIFJvdXRlci5ldmVudHMub24oZXZlbnQsICguLi5hcmdzKSA9PiB7XG4gICAgICBjb25zdCBldmVudEZpZWxkID0gYG9uJHtldmVudC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke2V2ZW50LnN1YnN0cmluZyhcbiAgICAgICAgMVxuICAgICAgKX1gXG4gICAgICBjb25zdCBfc2luZ2xldG9uUm91dGVyID0gc2luZ2xldG9uUm91dGVyIGFzIGFueVxuICAgICAgaWYgKF9zaW5nbGV0b25Sb3V0ZXJbZXZlbnRGaWVsZF0pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBfc2luZ2xldG9uUm91dGVyW2V2ZW50RmllbGRdKC4uLmFyZ3MpXG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3Igd2hlbiBydW5uaW5nIHRoZSBSb3V0ZXIgZXZlbnQ6ICR7ZXZlbnRGaWVsZH1gKVxuICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1jb25zb2xlXG4gICAgICAgICAgY29uc29sZS5lcnJvcihgJHtlcnIubWVzc2FnZX1cXG4ke2Vyci5zdGFja31gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIGdldFJvdXRlcigpOiBSb3V0ZXIge1xuICBpZiAoIXNpbmdsZXRvblJvdXRlci5yb3V0ZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICdObyByb3V0ZXIgaW5zdGFuY2UgZm91bmQuXFxuJyArXG4gICAgICAnWW91IHNob3VsZCBvbmx5IHVzZSBcIm5leHQvcm91dGVyXCIgaW5zaWRlIHRoZSBjbGllbnQgc2lkZSBvZiB5b3VyIGFwcC5cXG4nXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gIH1cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gRXhwb3J0IHRoZSBzaW5nbGV0b25Sb3V0ZXIgYW5kIHRoaXMgaXMgdGhlIHB1YmxpYyBBUEkuXG5leHBvcnQgZGVmYXVsdCBzaW5nbGV0b25Sb3V0ZXIgYXMgU2luZ2xldG9uUm91dGVyXG5cbi8vIFJlZXhwb3J0IHRoZSB3aXRoUm91dGUgSE9DXG5leHBvcnQgeyBkZWZhdWx0IGFzIHdpdGhSb3V0ZXIgfSBmcm9tICcuL3dpdGgtcm91dGVyJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUm91dGVyKCk6IE5leHRSb3V0ZXIge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChSb3V0ZXJDb250ZXh0KVxufVxuXG4vLyBJTlRFUk5BTCBBUElTXG4vLyAtLS0tLS0tLS0tLS0tXG4vLyAoZG8gbm90IHVzZSBmb2xsb3dpbmcgZXhwb3J0cyBpbnNpZGUgdGhlIGFwcClcblxuLy8gQ3JlYXRlIGEgcm91dGVyIGFuZCBhc3NpZ24gaXQgYXMgdGhlIHNpbmdsZXRvbiBpbnN0YW5jZS5cbi8vIFRoaXMgaXMgdXNlZCBpbiBjbGllbnQgc2lkZSB3aGVuIHdlIGFyZSBpbml0aWxpemluZyB0aGUgYXBwLlxuLy8gVGhpcyBzaG91bGQgKipub3QqKiB1c2UgaW5zaWRlIHRoZSBzZXJ2ZXIuXG5leHBvcnQgY29uc3QgY3JlYXRlUm91dGVyID0gKC4uLmFyZ3M6IFJvdXRlckFyZ3MpOiBSb3V0ZXIgPT4ge1xuICBzaW5nbGV0b25Sb3V0ZXIucm91dGVyID0gbmV3IFJvdXRlciguLi5hcmdzKVxuICBzaW5nbGV0b25Sb3V0ZXIucmVhZHlDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IGNiKCkpXG4gIHNpbmdsZXRvblJvdXRlci5yZWFkeUNhbGxiYWNrcyA9IFtdXG5cbiAgcmV0dXJuIHNpbmdsZXRvblJvdXRlci5yb3V0ZXJcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGNyZWF0ZSB0aGUgYHdpdGhSb3V0ZXJgIHJvdXRlciBpbnN0YW5jZVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQdWJsaWNSb3V0ZXJJbnN0YW5jZShyb3V0ZXI6IFJvdXRlcik6IE5leHRSb3V0ZXIge1xuICBjb25zdCBfcm91dGVyID0gcm91dGVyIGFzIGFueVxuICBjb25zdCBpbnN0YW5jZSA9IHt9IGFzIGFueVxuXG4gIGZvciAoY29uc3QgcHJvcGVydHkgb2YgdXJsUHJvcGVydHlGaWVsZHMpIHtcbiAgICBpZiAodHlwZW9mIF9yb3V0ZXJbcHJvcGVydHldID09PSAnb2JqZWN0Jykge1xuICAgICAgaW5zdGFuY2VbcHJvcGVydHldID0gT2JqZWN0LmFzc2lnbih7fSwgX3JvdXRlcltwcm9wZXJ0eV0pIC8vIG1ha2VzIHN1cmUgcXVlcnkgaXMgbm90IHN0YXRlZnVsXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGluc3RhbmNlW3Byb3BlcnR5XSA9IF9yb3V0ZXJbcHJvcGVydHldXG4gIH1cblxuICAvLyBFdmVudHMgaXMgYSBzdGF0aWMgcHJvcGVydHkgb24gdGhlIHJvdXRlciwgdGhlIHJvdXRlciBkb2Vzbid0IGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gdXNlIGl0XG4gIGluc3RhbmNlLmV2ZW50cyA9IFJvdXRlci5ldmVudHNcblxuICBjb3JlTWV0aG9kRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgaW5zdGFuY2VbZmllbGRdID0gKC4uLmFyZ3M6IGFueVtdKSA9PiB7XG4gICAgICByZXR1cm4gX3JvdXRlcltmaWVsZF0oLi4uYXJncylcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGluc3RhbmNlXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBOZXh0Q29tcG9uZW50VHlwZSwgTmV4dFBhZ2VDb250ZXh0IH0gZnJvbSAnLi4vbmV4dC1zZXJ2ZXIvbGliL3V0aWxzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciwgdXNlUm91dGVyIH0gZnJvbSAnLi9yb3V0ZXInXG5cbmV4cG9ydCB0eXBlIFdpdGhSb3V0ZXJQcm9wcyA9IHtcbiAgcm91dGVyOiBOZXh0Um91dGVyXG59XG5cbmV4cG9ydCB0eXBlIEV4Y2x1ZGVSb3V0ZXJQcm9wczxQPiA9IFBpY2s8XG4gIFAsXG4gIEV4Y2x1ZGU8a2V5b2YgUCwga2V5b2YgV2l0aFJvdXRlclByb3BzPlxuPlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB3aXRoUm91dGVyPFxuICBQIGV4dGVuZHMgV2l0aFJvdXRlclByb3BzLFxuICBDID0gTmV4dFBhZ2VDb250ZXh0XG4+KFxuICBDb21wb3NlZENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8QywgYW55LCBQPlxuKTogUmVhY3QuQ29tcG9uZW50VHlwZTxFeGNsdWRlUm91dGVyUHJvcHM8UD4+IHtcbiAgZnVuY3Rpb24gV2l0aFJvdXRlcldyYXBwZXIocHJvcHM6IGFueSkge1xuICAgIHJldHVybiA8Q29tcG9zZWRDb21wb25lbnQgcm91dGVyPXt1c2VSb3V0ZXIoKX0gey4uLnByb3BzfSAvPlxuICB9XG5cbiAgV2l0aFJvdXRlcldyYXBwZXIuZ2V0SW5pdGlhbFByb3BzID0gQ29tcG9zZWRDb21wb25lbnQuZ2V0SW5pdGlhbFByb3BzXG4gIC8vIFRoaXMgaXMgbmVlZGVkIHRvIGFsbG93IGNoZWNraW5nIGZvciBjdXN0b20gZ2V0SW5pdGlhbFByb3BzIGluIF9hcHBcbiAgOyhXaXRoUm91dGVyV3JhcHBlciBhcyBhbnkpLm9yaWdHZXRJbml0aWFsUHJvcHMgPSAoQ29tcG9zZWRDb21wb25lbnQgYXMgYW55KS5vcmlnR2V0SW5pdGlhbFByb3BzXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY29uc3QgbmFtZSA9XG4gICAgICBDb21wb3NlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb3NlZENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xuICAgIFdpdGhSb3V0ZXJXcmFwcGVyLmRpc3BsYXlOYW1lID0gYHdpdGhSb3V0ZXIoJHtuYW1lfSlgXG4gIH1cblxuICByZXR1cm4gV2l0aFJvdXRlcldyYXBwZXJcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcblxuZXhwb3J0IGNvbnN0IEFtcFN0YXRlQ29udGV4dDogUmVhY3QuQ29udGV4dDxhbnk+ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7fSlcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgQW1wU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0FtcFN0YXRlQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB7IEFtcFN0YXRlQ29udGV4dCB9IGZyb20gJy4vYW1wLWNvbnRleHQnXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luQW1wTW9kZSh7XG4gIGFtcEZpcnN0ID0gZmFsc2UsXG4gIGh5YnJpZCA9IGZhbHNlLFxuICBoYXNRdWVyeSA9IGZhbHNlLFxufSA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiBhbXBGaXJzdCB8fCAoaHlicmlkICYmIGhhc1F1ZXJ5KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlQW1wKCk6IGJvb2xlYW4ge1xuICAvLyBEb24ndCBhc3NpZ24gdGhlIGNvbnRleHQgdmFsdWUgdG8gYSB2YXJpYWJsZSB0byBzYXZlIGJ5dGVzXG4gIHJldHVybiBpc0luQW1wTW9kZShSZWFjdC51c2VDb250ZXh0KEFtcFN0YXRlQ29udGV4dCkpXG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnXG5cbmV4cG9ydCBjb25zdCBIZWFkTWFuYWdlckNvbnRleHQ6IFJlYWN0LkNvbnRleHQ8YW55PiA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbClcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgSGVhZE1hbmFnZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ0hlYWRNYW5hZ2VyQ29udGV4dCdcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCB3aXRoU2lkZUVmZmVjdCBmcm9tICcuL3NpZGUtZWZmZWN0J1xuaW1wb3J0IHsgQW1wU3RhdGVDb250ZXh0IH0gZnJvbSAnLi9hbXAtY29udGV4dCdcbmltcG9ydCB7IEhlYWRNYW5hZ2VyQ29udGV4dCB9IGZyb20gJy4vaGVhZC1tYW5hZ2VyLWNvbnRleHQnXG5pbXBvcnQgeyBpc0luQW1wTW9kZSB9IGZyb20gJy4vYW1wJ1xuXG50eXBlIFdpdGhJbkFtcE1vZGUgPSB7XG4gIGluQW1wTW9kZT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRIZWFkKGluQW1wTW9kZSA9IGZhbHNlKTogSlNYLkVsZW1lbnRbXSB7XG4gIGNvbnN0IGhlYWQgPSBbPG1ldGEgY2hhclNldD1cInV0Zi04XCIgLz5dXG4gIGlmICghaW5BbXBNb2RlKSB7XG4gICAgaGVhZC5wdXNoKDxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGhcIiAvPilcbiAgfVxuICByZXR1cm4gaGVhZFxufVxuXG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KFxuICBsaXN0OiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4sXG4gIGNoaWxkOiBSZWFjdC5SZWFjdENoaWxkXG4pOiBBcnJheTxSZWFjdC5SZWFjdEVsZW1lbnQ8YW55Pj4ge1xuICAvLyBSZWFjdCBjaGlsZHJlbiBjYW4gYmUgXCJzdHJpbmdcIiBvciBcIm51bWJlclwiIGluIHRoaXMgY2FzZSB3ZSBpZ25vcmUgdGhlbSBmb3IgYmFja3dhcmRzIGNvbXBhdFxuICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICAvLyBBZGRzIHN1cHBvcnQgZm9yIFJlYWN0LkZyYWdtZW50XG4gIGlmIChjaGlsZC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdChcbiAgICAgIFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZShcbiAgICAgICAgKFxuICAgICAgICAgIGZyYWdtZW50TGlzdDogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+LFxuICAgICAgICAgIGZyYWdtZW50Q2hpbGQ6IFJlYWN0LlJlYWN0Q2hpbGRcbiAgICAgICAgKTogQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+ID0+IHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgIHR5cGVvZiBmcmFnbWVudENoaWxkID09PSAnbnVtYmVyJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYWdtZW50TGlzdFxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKVxuICAgICAgICB9LFxuICAgICAgICBbXVxuICAgICAgKVxuICAgIClcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoY2hpbGQpXG59XG5cbmNvbnN0IE1FVEFUWVBFUyA9IFsnbmFtZScsICdodHRwRXF1aXYnLCAnY2hhclNldCcsICdpdGVtUHJvcCddXG5cbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qL1xuZnVuY3Rpb24gdW5pcXVlKCkge1xuICBjb25zdCBrZXlzID0gbmV3IFNldCgpXG4gIGNvbnN0IHRhZ3MgPSBuZXcgU2V0KClcbiAgY29uc3QgbWV0YVR5cGVzID0gbmV3IFNldCgpXG4gIGNvbnN0IG1ldGFDYXRlZ29yaWVzOiB7IFttZXRhdHlwZTogc3RyaW5nXTogU2V0PHN0cmluZz4gfSA9IHt9XG5cbiAgcmV0dXJuIChoOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgIGxldCB1bmlxdWUgPSB0cnVlXG5cbiAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSAnbnVtYmVyJyAmJiBoLmtleS5pbmRleE9mKCckJykgPiAwKSB7XG4gICAgICBjb25zdCBrZXkgPSBoLmtleS5zbGljZShoLmtleS5pbmRleE9mKCckJykgKyAxKVxuICAgICAgaWYgKGtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgdW5pcXVlID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGtleXMuYWRkKGtleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZGVmYXVsdC1jYXNlXG4gICAgc3dpdGNoIChoLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIGNhc2UgJ2Jhc2UnOlxuICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFncy5hZGQoaC50eXBlKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdtZXRhJzpcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1FVEFUWVBFUy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGNvbnN0IG1ldGF0eXBlID0gTUVUQVRZUEVTW2ldXG4gICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWVcblxuICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gJ2NoYXJTZXQnKSB7XG4gICAgICAgICAgICBpZiAobWV0YVR5cGVzLmhhcyhtZXRhdHlwZSkpIHtcbiAgICAgICAgICAgICAgdW5pcXVlID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3J5ID0gaC5wcm9wc1ttZXRhdHlwZV1cbiAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpXG4gICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgIHVuaXF1ZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYXRlZ29yaWVzLmFkZChjYXRlZ29yeSlcbiAgICAgICAgICAgICAgbWV0YUNhdGVnb3JpZXNbbWV0YXR5cGVdID0gY2F0ZWdvcmllc1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cblxuICAgIHJldHVybiB1bmlxdWVcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZEVsZW1lbnRzIExpc3Qgb2YgbXVsdGlwbGUgPEhlYWQ+IGluc3RhbmNlc1xuICovXG5mdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKFxuICBoZWFkRWxlbWVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgcHJvcHM6IFdpdGhJbkFtcE1vZGVcbikge1xuICByZXR1cm4gaGVhZEVsZW1lbnRzXG4gICAgLnJlZHVjZShcbiAgICAgIChsaXN0OiBSZWFjdC5SZWFjdENoaWxkW10sIGhlYWRFbGVtZW50OiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PikgPT4ge1xuICAgICAgICBjb25zdCBoZWFkRWxlbWVudENoaWxkcmVuID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShcbiAgICAgICAgICBoZWFkRWxlbWVudC5wcm9wcy5jaGlsZHJlblxuICAgICAgICApXG4gICAgICAgIHJldHVybiBsaXN0LmNvbmNhdChoZWFkRWxlbWVudENoaWxkcmVuKVxuICAgICAgfSxcbiAgICAgIFtdXG4gICAgKVxuICAgIC5yZWR1Y2Uob25seVJlYWN0RWxlbWVudCwgW10pXG4gICAgLnJldmVyc2UoKVxuICAgIC5jb25jYXQoZGVmYXVsdEhlYWQocHJvcHMuaW5BbXBNb2RlKSlcbiAgICAuZmlsdGVyKHVuaXF1ZSgpKVxuICAgIC5yZXZlcnNlKClcbiAgICAubWFwKChjOiBSZWFjdC5SZWFjdEVsZW1lbnQ8YW55PiwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSBjLmtleSB8fCBpXG4gICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGMsIHsga2V5IH0pXG4gICAgfSlcbn1cblxuY29uc3QgRWZmZWN0ID0gd2l0aFNpZGVFZmZlY3QoKVxuXG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGluamVjdHMgZWxlbWVudHMgdG8gYDxoZWFkPmAgb2YgeW91ciBwYWdlLlxuICogVG8gYXZvaWQgZHVwbGljYXRlZCBgdGFnc2AgaW4gYDxoZWFkPmAgeW91IGNhbiB1c2UgdGhlIGBrZXlgIHByb3BlcnR5LCB3aGljaCB3aWxsIG1ha2Ugc3VyZSBldmVyeSB0YWcgaXMgb25seSByZW5kZXJlZCBvbmNlLlxuICovXG5mdW5jdGlvbiBIZWFkKHsgY2hpbGRyZW4gfTogeyBjaGlsZHJlbjogUmVhY3QuUmVhY3ROb2RlIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8QW1wU3RhdGVDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgeyhhbXBTdGF0ZSkgPT4gKFxuICAgICAgICA8SGVhZE1hbmFnZXJDb250ZXh0LkNvbnN1bWVyPlxuICAgICAgICAgIHsodXBkYXRlSGVhZCkgPT4gKFxuICAgICAgICAgICAgPEVmZmVjdFxuICAgICAgICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZT17cmVkdWNlQ29tcG9uZW50c31cbiAgICAgICAgICAgICAgaGFuZGxlU3RhdGVDaGFuZ2U9e3VwZGF0ZUhlYWR9XG4gICAgICAgICAgICAgIGluQW1wTW9kZT17aXNJbkFtcE1vZGUoYW1wU3RhdGUpfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgICAgICA8L0VmZmVjdD5cbiAgICAgICAgICApfVxuICAgICAgICA8L0hlYWRNYW5hZ2VyQ29udGV4dC5Db25zdW1lcj5cbiAgICAgICl9XG4gICAgPC9BbXBTdGF0ZUNvbnRleHQuQ29uc3VtZXI+XG4gIClcbn1cblxuSGVhZC5yZXdpbmQgPSBFZmZlY3QucmV3aW5kXG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRcbiIsIi8qXG5NSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIEphc29uIE1pbGxlciAoaHR0cHM6Ly9qYXNvbmZvcm1hdC5jb20vKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG4vLyBUaGlzIGZpbGUgaXMgYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9taXR0L2Jsb2IvdjEuMS4zL3NyYy9pbmRleC5qc1xuLy8gSXQncyBiZWVuIGVkaXRlZCBmb3IgdGhlIG5lZWRzIG9mIHRoaXMgc2NyaXB0XG4vLyBTZWUgdGhlIExJQ0VOU0UgYXQgdGhlIHRvcCBvZiB0aGUgZmlsZVxuXG50eXBlIEhhbmRsZXIgPSAoLi4uZXZ0czogYW55W10pID0+IHZvaWRcblxuZXhwb3J0IHR5cGUgTWl0dEVtaXR0ZXIgPSB7XG4gIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgb2ZmKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcik6IHZvaWRcbiAgZW1pdCh0eXBlOiBzdHJpbmcsIC4uLmV2dHM6IGFueVtdKTogdm9pZFxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtaXR0KCk6IE1pdHRFbWl0dGVyIHtcbiAgY29uc3QgYWxsOiB7IFtzOiBzdHJpbmddOiBIYW5kbGVyW10gfSA9IE9iamVjdC5jcmVhdGUobnVsbClcblxuICByZXR1cm4ge1xuICAgIG9uKHR5cGU6IHN0cmluZywgaGFuZGxlcjogSGFuZGxlcikge1xuICAgICAgOyhhbGxbdHlwZV0gfHwgKGFsbFt0eXBlXSA9IFtdKSkucHVzaChoYW5kbGVyKVxuICAgIH0sXG5cbiAgICBvZmYodHlwZTogc3RyaW5nLCBoYW5kbGVyOiBIYW5kbGVyKSB7XG4gICAgICBpZiAoYWxsW3R5cGVdKSB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1iaXR3aXNlXG4gICAgICAgIGFsbFt0eXBlXS5zcGxpY2UoYWxsW3R5cGVdLmluZGV4T2YoaGFuZGxlcikgPj4+IDAsIDEpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGVtaXQodHlwZTogc3RyaW5nLCAuLi5ldnRzOiBhbnlbXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgOyhhbGxbdHlwZV0gfHwgW10pLnNsaWNlKCkubWFwKChoYW5kbGVyOiBIYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoLi4uZXZ0cylcbiAgICAgIH0pXG4gICAgfSxcbiAgfVxufVxuIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcblxuZXhwb3J0IGNvbnN0IFJvdXRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0PE5leHRSb3V0ZXI+KG51bGwgYXMgYW55KVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBSb3V0ZXJDb250ZXh0LmRpc3BsYXlOYW1lID0gJ1JvdXRlckNvbnRleHQnXG59XG4iLCIvKiBnbG9iYWwgX19ORVhUX0RBVEFfXyAqL1xuLy8gdHNsaW50OmRpc2FibGU6bm8tY29uc29sZVxuaW1wb3J0IHsgUGFyc2VkVXJsUXVlcnkgfSBmcm9tICdxdWVyeXN0cmluZydcbmltcG9ydCB7IENvbXBvbmVudFR5cGUgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHBhcnNlLCBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgbWl0dCwgeyBNaXR0RW1pdHRlciB9IGZyb20gJy4uL21pdHQnXG5pbXBvcnQge1xuICBBcHBDb250ZXh0VHlwZSxcbiAgZm9ybWF0V2l0aFZhbGlkYXRpb24sXG4gIGdldFVSTCxcbiAgbG9hZEdldEluaXRpYWxQcm9wcyxcbiAgTmV4dFBhZ2VDb250ZXh0LFxuICBTVCxcbn0gZnJvbSAnLi4vdXRpbHMnXG5pbXBvcnQgeyBpc0R5bmFtaWNSb3V0ZSB9IGZyb20gJy4vdXRpbHMvaXMtZHluYW1pYydcbmltcG9ydCB7IGdldFJvdXRlTWF0Y2hlciB9IGZyb20gJy4vdXRpbHMvcm91dGUtbWF0Y2hlcidcbmltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3V0aWxzL3JvdXRlLXJlZ2V4J1xuXG5jb25zdCBiYXNlUGF0aCA9IChwcm9jZXNzLmVudi5fX05FWFRfUk9VVEVSX0JBU0VQQVRIIGFzIHN0cmluZykgfHwgJydcblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEJhc2VQYXRoKHBhdGg6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoYmFzZVBhdGgpICE9PSAwID8gYmFzZVBhdGggKyBwYXRoIDogcGF0aFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQmFzZVBhdGgocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlUGF0aCkgPT09IDBcbiAgICA/IHBhdGguc3Vic3RyKGJhc2VQYXRoLmxlbmd0aCkgfHwgJy8nXG4gICAgOiBwYXRoXG59XG5cbmZ1bmN0aW9uIHRvUm91dGUocGF0aDogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwvJC8sICcnKSB8fCAnLydcbn1cblxuY29uc3QgcHJlcGFyZVJvdXRlID0gKHBhdGg6IHN0cmluZykgPT5cbiAgdG9Sb3V0ZSghcGF0aCB8fCBwYXRoID09PSAnLycgPyAnL2luZGV4JyA6IHBhdGgpXG5cbnR5cGUgVXJsID0gVXJsT2JqZWN0IHwgc3RyaW5nXG5cbnR5cGUgQ29tcG9uZW50UmVzID0geyBwYWdlOiBDb21wb25lbnRUeXBlOyBtb2Q6IGFueSB9XG5cbmV4cG9ydCB0eXBlIEJhc2VSb3V0ZXIgPSB7XG4gIHJvdXRlOiBzdHJpbmdcbiAgcGF0aG5hbWU6IHN0cmluZ1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgYXNQYXRoOiBzdHJpbmdcbiAgYmFzZVBhdGg6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBOZXh0Um91dGVyID0gQmFzZVJvdXRlciAmXG4gIFBpY2s8XG4gICAgUm91dGVyLFxuICAgIHwgJ3B1c2gnXG4gICAgfCAncmVwbGFjZSdcbiAgICB8ICdyZWxvYWQnXG4gICAgfCAnYmFjaydcbiAgICB8ICdwcmVmZXRjaCdcbiAgICB8ICdiZWZvcmVQb3BTdGF0ZSdcbiAgICB8ICdldmVudHMnXG4gICAgfCAnaXNGYWxsYmFjaydcbiAgPlxuXG5leHBvcnQgdHlwZSBQcmVmZXRjaE9wdGlvbnMgPSB7XG4gIHByaW9yaXR5PzogYm9vbGVhblxufVxuXG50eXBlIFJvdXRlSW5mbyA9IHtcbiAgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlXG4gIF9fTl9TU0c/OiBib29sZWFuXG4gIF9fTl9TU1A/OiBib29sZWFuXG4gIHByb3BzPzogYW55XG4gIGVycj86IEVycm9yXG4gIGVycm9yPzogYW55XG59XG5cbnR5cGUgU3Vic2NyaXB0aW9uID0gKGRhdGE6IFJvdXRlSW5mbywgQXBwPzogQ29tcG9uZW50VHlwZSkgPT4gUHJvbWlzZTx2b2lkPlxuXG50eXBlIEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgPSAoc3RhdGU6IGFueSkgPT4gYm9vbGVhblxuXG50eXBlIENvbXBvbmVudExvYWRDYW5jZWwgPSAoKCkgPT4gdm9pZCkgfCBudWxsXG5cbnR5cGUgSGlzdG9yeU1ldGhvZCA9ICdyZXBsYWNlU3RhdGUnIHwgJ3B1c2hTdGF0ZSdcblxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShcbiAgcGF0aG5hbWU6IHN0cmluZyxcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5IHwgbnVsbCxcbiAgaXNTZXJ2ZXJSZW5kZXI6IGJvb2xlYW4sXG4gIGNiPzogKC4uLmFyZ3M6IGFueSkgPT4gYW55XG4pIHtcbiAgbGV0IGF0dGVtcHRzID0gaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMVxuICBmdW5jdGlvbiBnZXRSZXNwb25zZSgpOiBQcm9taXNlPGFueT4ge1xuICAgIHJldHVybiBmZXRjaChcbiAgICAgIGZvcm1hdFdpdGhWYWxpZGF0aW9uKHtcbiAgICAgICAgcGF0aG5hbWU6IGFkZEJhc2VQYXRoKFxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgX19ORVhUX0RBVEFfX1xuICAgICAgICAgIGAvX25leHQvZGF0YS8ke19fTkVYVF9EQVRBX18uYnVpbGRJZH0ke2RlbEJhc2VQYXRoKHBhdGhuYW1lKX0uanNvbmBcbiAgICAgICAgKSxcbiAgICAgICAgcXVlcnksXG4gICAgICB9KSxcbiAgICAgIHtcbiAgICAgICAgLy8gQ29va2llcyBhcmUgcmVxdWlyZWQgdG8gYmUgcHJlc2VudCBmb3IgTmV4dC5qcycgU1NHIFwiUHJldmlldyBNb2RlXCIuXG4gICAgICAgIC8vIENvb2tpZXMgbWF5IGFsc28gYmUgcmVxdWlyZWQgZm9yIGBnZXRTZXJ2ZXJTaWRlUHJvcHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyA+IGBmZXRjaGAgd29u4oCZdCBzZW5kIGNvb2tpZXMsIHVubGVzcyB5b3Ugc2V0IHRoZSBjcmVkZW50aWFscyBpbml0XG4gICAgICAgIC8vID4gb3B0aW9uLlxuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRmV0Y2hfQVBJL1VzaW5nX0ZldGNoXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gRm9yIG1heGltdW0gYnJvd3NlciBjb21wYXRpYmlsaXR5IHdoZW4gaXQgY29tZXMgdG8gc2VuZGluZyAmXG4gICAgICAgIC8vID4gcmVjZWl2aW5nIGNvb2tpZXMsIGFsd2F5cyBzdXBwbHkgdGhlIGBjcmVkZW50aWFsczogJ3NhbWUtb3JpZ2luJ2BcbiAgICAgICAgLy8gPiBvcHRpb24gaW5zdGVhZCBvZiByZWx5aW5nIG9uIHRoZSBkZWZhdWx0LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ2l0aHViL2ZldGNoI2NhdmVhdHNcbiAgICAgICAgY3JlZGVudGlhbHM6ICdzYW1lLW9yaWdpbicsXG4gICAgICB9XG4gICAgKS50aGVuKChyZXMpID0+IHtcbiAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgIGlmICgtLWF0dGVtcHRzID4gMCAmJiByZXMuc3RhdHVzID49IDUwMCkge1xuICAgICAgICAgIHJldHVybiBnZXRSZXNwb25zZSgpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNgKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcy5qc29uKClcbiAgICB9KVxuICB9XG5cbiAgcmV0dXJuIGdldFJlc3BvbnNlKClcbiAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgcmV0dXJuIGNiID8gY2IoZGF0YSkgOiBkYXRhXG4gICAgfSlcbiAgICAuY2F0Y2goKGVycjogRXJyb3IpID0+IHtcbiAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHRyaWdnZXIgYSBzZXJ2ZXItc2lkZSB0cmFuc2l0aW9uIGlmIHRoaXMgd2FzIGNhdXNlZFxuICAgICAgLy8gb24gYSBjbGllbnQtc2lkZSB0cmFuc2l0aW9uLiBPdGhlcndpc2UsIHdlJ2QgZ2V0IGludG8gYW4gaW5maW5pdGVcbiAgICAgIC8vIGxvb3AuXG4gICAgICBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgIDsoZXJyIGFzIGFueSkuY29kZSA9ICdQQUdFX0xPQURfRVJST1InXG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXIgaW1wbGVtZW50cyBCYXNlUm91dGVyIHtcbiAgcm91dGU6IHN0cmluZ1xuICBwYXRobmFtZTogc3RyaW5nXG4gIHF1ZXJ5OiBQYXJzZWRVcmxRdWVyeVxuICBhc1BhdGg6IHN0cmluZ1xuICBiYXNlUGF0aDogc3RyaW5nXG5cbiAgLyoqXG4gICAqIE1hcCBvZiBhbGwgY29tcG9uZW50cyBsb2FkZWQgaW4gYFJvdXRlcmBcbiAgICovXG4gIGNvbXBvbmVudHM6IHsgW3BhdGhuYW1lOiBzdHJpbmddOiBSb3V0ZUluZm8gfVxuICAvLyBTdGF0aWMgRGF0YSBDYWNoZVxuICBzZGM6IHsgW2FzUGF0aDogc3RyaW5nXTogb2JqZWN0IH0gPSB7fVxuICBzdWI6IFN1YnNjcmlwdGlvblxuICBjbGM6IENvbXBvbmVudExvYWRDYW5jZWxcbiAgcGFnZUxvYWRlcjogYW55XG4gIF9icHM6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2sgfCB1bmRlZmluZWRcbiAgZXZlbnRzOiBNaXR0RW1pdHRlclxuICBfd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gIGlzU3NyOiBib29sZWFuXG4gIGlzRmFsbGJhY2s6IGJvb2xlYW5cblxuICBzdGF0aWMgZXZlbnRzOiBNaXR0RW1pdHRlciA9IG1pdHQoKVxuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHBhdGhuYW1lOiBzdHJpbmcsXG4gICAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5LFxuICAgIGFzOiBzdHJpbmcsXG4gICAge1xuICAgICAgaW5pdGlhbFByb3BzLFxuICAgICAgcGFnZUxvYWRlcixcbiAgICAgIEFwcCxcbiAgICAgIHdyYXBBcHAsXG4gICAgICBDb21wb25lbnQsXG4gICAgICBlcnIsXG4gICAgICBzdWJzY3JpcHRpb24sXG4gICAgICBpc0ZhbGxiYWNrLFxuICAgIH06IHtcbiAgICAgIHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uXG4gICAgICBpbml0aWFsUHJvcHM6IGFueVxuICAgICAgcGFnZUxvYWRlcjogYW55XG4gICAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGVcbiAgICAgIEFwcDogQ29tcG9uZW50VHlwZVxuICAgICAgd3JhcEFwcDogKEFwcDogQ29tcG9uZW50VHlwZSkgPT4gYW55XG4gICAgICBlcnI/OiBFcnJvclxuICAgICAgaXNGYWxsYmFjazogYm9vbGVhblxuICAgIH1cbiAgKSB7XG4gICAgLy8gcmVwcmVzZW50cyB0aGUgY3VycmVudCBjb21wb25lbnQga2V5XG4gICAgdGhpcy5yb3V0ZSA9IHRvUm91dGUocGF0aG5hbWUpXG5cbiAgICAvLyBzZXQgdXAgdGhlIGNvbXBvbmVudCBjYWNoZSAoYnkgcm91dGUga2V5cylcbiAgICB0aGlzLmNvbXBvbmVudHMgPSB7fVxuICAgIC8vIFdlIHNob3VsZCBub3Qga2VlcCB0aGUgY2FjaGUsIGlmIHRoZXJlJ3MgYW4gZXJyb3JcbiAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgIC8vIGNvbWUgYWdhaW4gdG8gdGhlIGVycm9yZWQgcGFnZS5cbiAgICBpZiAocGF0aG5hbWUgIT09ICcvX2Vycm9yJykge1xuICAgICAgdGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdID0ge1xuICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIHByb3BzOiBpbml0aWFsUHJvcHMsXG4gICAgICAgIGVycixcbiAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICBfX05fU1NQOiBpbml0aWFsUHJvcHMgJiYgaW5pdGlhbFByb3BzLl9fTl9TU1AsXG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jb21wb25lbnRzWycvX2FwcCddID0geyBDb21wb25lbnQ6IEFwcCB9XG5cbiAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgIC8vIFRPRE86IFNob3VsZCBiZSByZW1vdmUgdGhlIGZvbGxvd2luZyBtYWpvciB2ZXJzaW9uIGFzIGl0IHdhcyBuZXZlciBkb2N1bWVudGVkXG4gICAgdGhpcy5ldmVudHMgPSBSb3V0ZXIuZXZlbnRzXG5cbiAgICB0aGlzLnBhZ2VMb2FkZXIgPSBwYWdlTG9hZGVyXG4gICAgdGhpcy5wYXRobmFtZSA9IHBhdGhuYW1lXG4gICAgdGhpcy5xdWVyeSA9IHF1ZXJ5XG4gICAgLy8gaWYgYXV0byBwcmVyZW5kZXJlZCBhbmQgZHluYW1pYyByb3V0ZSB3YWl0IHRvIHVwZGF0ZSBhc1BhdGhcbiAgICAvLyB1bnRpbCBhZnRlciBtb3VudCB0byBwcmV2ZW50IGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgIHRoaXMuYXNQYXRoID1cbiAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgIGlzRHluYW1pY1JvdXRlKHBhdGhuYW1lKSAmJiBfX05FWFRfREFUQV9fLmF1dG9FeHBvcnQgPyBwYXRobmFtZSA6IGFzXG4gICAgdGhpcy5iYXNlUGF0aCA9IGJhc2VQYXRoXG4gICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb25cbiAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB0aGlzLl93cmFwQXBwID0gd3JhcEFwcFxuICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAvLyBiYWNrIGZyb20gZXh0ZXJuYWwgc2l0ZVxuICAgIHRoaXMuaXNTc3IgPSB0cnVlXG5cbiAgICB0aGlzLmlzRmFsbGJhY2sgPSBpc0ZhbGxiYWNrXG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgaWYgKGFzLnN1YnN0cigwLCAyKSAhPT0gJy8vJykge1xuICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHJlZ2lzdGVyIHRoZSBpbml0aWFsIHJvdXRlIHVwb24gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgdGhpcy5jaGFuZ2VTdGF0ZShcbiAgICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgICBmb3JtYXRXaXRoVmFsaWRhdGlvbih7IHBhdGhuYW1lLCBxdWVyeSB9KSxcbiAgICAgICAgICBhc1xuICAgICAgICApXG4gICAgICB9XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb3BzdGF0ZScsIHRoaXMub25Qb3BTdGF0ZSlcbiAgICB9XG4gIH1cblxuICAvLyBAZGVwcmVjYXRlZCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBldmVuIHRob3VnaCBpdCdzIGEgcHJpdmF0ZSBtZXRob2QuXG4gIHN0YXRpYyBfcmV3cml0ZVVybEZvck5leHRFeHBvcnQodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfRVhQT1JUX1RSQUlMSU5HX1NMQVNIKSB7XG4gICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgIC5yZXdyaXRlVXJsRm9yTmV4dEV4cG9ydFxuICAgICAgcmV0dXJuIHJld3JpdGVVcmxGb3JOZXh0RXhwb3J0KHVybClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHVybFxuICAgIH1cbiAgfVxuXG4gIG9uUG9wU3RhdGUgPSAoZTogUG9wU3RhdGVFdmVudCk6IHZvaWQgPT4ge1xuICAgIGlmICghZS5zdGF0ZSkge1xuICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAvLyAgMS4gV2l0aCBvbGRlciBzYWZhcmkgKDwgOCkgYW5kIG9sZGVyIGNocm9tZSAoPCAzNClcbiAgICAgIC8vICAyLiBXaGVuIHRoZSBVUkwgY2hhbmdlZCB3aXRoICNcbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgYm90aCBjYXNlcywgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZWVkIGFuZCBjaGFuZ2UgdGhlIHJvdXRlLlxuICAgICAgLy8gKGFzIGl0J3MgYWxyZWFkeSBjaGFuZ2VkKVxuICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAvLyBBY3R1YWxseSwgZm9yICgxKSB3ZSBkb24ndCBuZWVkIHRvIG5vdGhpbmcuIEJ1dCBpdCdzIGhhcmQgdG8gZGV0ZWN0IHRoYXQgZXZlbnQuXG4gICAgICAvLyBTbywgZG9pbmcgdGhlIGZvbGxvd2luZyBmb3IgKDEpIGRvZXMgbm8gaGFybS5cbiAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzXG4gICAgICB0aGlzLmNoYW5nZVN0YXRlKFxuICAgICAgICAncmVwbGFjZVN0YXRlJyxcbiAgICAgICAgZm9ybWF0V2l0aFZhbGlkYXRpb24oeyBwYXRobmFtZSwgcXVlcnkgfSksXG4gICAgICAgIGdldFVSTCgpXG4gICAgICApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG9uJ3QgcmUtcmVuZGVyIG9uIGluaXRpYWwgbG9hZCxcbiAgICAvLyBjYW4gYmUgY2F1c2VkIGJ5IG5hdmlnYXRpbmcgYmFjayBmcm9tIGFuIGV4dGVybmFsIHNpdGVcbiAgICBpZiAoXG4gICAgICBlLnN0YXRlICYmXG4gICAgICB0aGlzLmlzU3NyICYmXG4gICAgICBlLnN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCAmJlxuICAgICAgcGFyc2UoZS5zdGF0ZS51cmwpLnBhdGhuYW1lID09PSB0aGlzLnBhdGhuYW1lXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgZG93bnN0cmVhbSBhcHBsaWNhdGlvbiByZXR1cm5zIGZhbHN5LCByZXR1cm4uXG4gICAgLy8gVGhleSB3aWxsIHRoZW4gYmUgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRoZSBldmVudC5cbiAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoZS5zdGF0ZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHsgdXJsLCBhcywgb3B0aW9ucyB9ID0gZS5zdGF0ZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGFzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgJ2Bwb3BzdGF0ZWAgZXZlbnQgdHJpZ2dlcmVkIGJ1dCBgZXZlbnQuc3RhdGVgIGRpZCBub3QgaGF2ZSBgdXJsYCBvciBgYXNgIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL3BvcHN0YXRlLXN0YXRlLWVtcHR5J1xuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgdXBkYXRlKHJvdXRlOiBzdHJpbmcsIG1vZDogYW55KSB7XG4gICAgY29uc3QgQ29tcG9uZW50OiBDb21wb25lbnRUeXBlID0gbW9kLmRlZmF1bHQgfHwgbW9kXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuY29tcG9uZW50c1tyb3V0ZV1cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHVwZGF0ZSB1bmF2YWlsYWJsZSByb3V0ZTogJHtyb3V0ZX1gKVxuICAgIH1cblxuICAgIGNvbnN0IG5ld0RhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhLCB7XG4gICAgICBDb21wb25lbnQsXG4gICAgICBfX05fU1NHOiBtb2QuX19OX1NTRyxcbiAgICAgIF9fTl9TU1A6IG1vZC5fX05fU1NQLFxuICAgIH0pXG4gICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IG5ld0RhdGFcblxuICAgIC8vIHBhZ2VzL19hcHAuanMgdXBkYXRlZFxuICAgIGlmIChyb3V0ZSA9PT0gJy9fYXBwJykge1xuICAgICAgdGhpcy5ub3RpZnkodGhpcy5jb21wb25lbnRzW3RoaXMucm91dGVdKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHJvdXRlID09PSB0aGlzLnJvdXRlKSB7XG4gICAgICB0aGlzLm5vdGlmeShuZXdEYXRhKVxuICAgIH1cbiAgfVxuXG4gIHJlbG9hZCgpOiB2b2lkIHtcbiAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBHbyBiYWNrIGluIGhpc3RvcnlcbiAgICovXG4gIGJhY2soKSB7XG4gICAgd2luZG93Lmhpc3RvcnkuYmFjaygpXG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybXMgYSBgcHVzaFN0YXRlYCB3aXRoIGFyZ3VtZW50c1xuICAgKiBAcGFyYW0gdXJsIG9mIHRoZSByb3V0ZVxuICAgKiBAcGFyYW0gYXMgbWFza3MgYHVybGAgZm9yIHRoZSBicm93c2VyXG4gICAqIEBwYXJhbSBvcHRpb25zIG9iamVjdCB5b3UgY2FuIGRlZmluZSBgc2hhbGxvd2AgYW5kIG90aGVyIG9wdGlvbnNcbiAgICovXG4gIHB1c2godXJsOiBVcmwsIGFzOiBVcmwgPSB1cmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZSgncHVzaFN0YXRlJywgdXJsLCBhcywgb3B0aW9ucylcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi9cbiAgcmVwbGFjZSh1cmw6IFVybCwgYXM6IFVybCA9IHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbmdlKCdyZXBsYWNlU3RhdGUnLCB1cmwsIGFzLCBvcHRpb25zKVxuICB9XG5cbiAgY2hhbmdlKFxuICAgIG1ldGhvZDogSGlzdG9yeU1ldGhvZCxcbiAgICBfdXJsOiBVcmwsXG4gICAgX2FzOiBVcmwsXG4gICAgb3B0aW9uczogYW55XG4gICk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAoIW9wdGlvbnMuX2gpIHtcbiAgICAgICAgdGhpcy5pc1NzciA9IGZhbHNlXG4gICAgICB9XG4gICAgICAvLyBtYXJraW5nIHJvdXRlIGNoYW5nZXMgYXMgYSBuYXZpZ2F0aW9uIHN0YXJ0IGVudHJ5XG4gICAgICBpZiAoU1QpIHtcbiAgICAgICAgcGVyZm9ybWFuY2UubWFyaygncm91dGVDaGFuZ2UnKVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB1cmwgYW5kIGFzIHByb3ZpZGVkIGFzIGFuIG9iamVjdCByZXByZXNlbnRhdGlvbixcbiAgICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgICBsZXQgdXJsID0gdHlwZW9mIF91cmwgPT09ICdvYmplY3QnID8gZm9ybWF0V2l0aFZhbGlkYXRpb24oX3VybCkgOiBfdXJsXG4gICAgICBsZXQgYXMgPSB0eXBlb2YgX2FzID09PSAnb2JqZWN0JyA/IGZvcm1hdFdpdGhWYWxpZGF0aW9uKF9hcykgOiBfYXNcblxuICAgICAgdXJsID0gYWRkQmFzZVBhdGgodXJsKVxuICAgICAgYXMgPSBhZGRCYXNlUGF0aChhcylcblxuICAgICAgLy8gQWRkIHRoZSBlbmRpbmcgc2xhc2ggdG8gdGhlIHBhdGhzLiBTbywgd2UgY2FuIHNlcnZlIHRoZVxuICAgICAgLy8gXCI8cGFnZT4vaW5kZXguaHRtbFwiIGRpcmVjdGx5IGZvciB0aGUgU1NSIHBhZ2UuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0VYUE9SVF9UUkFJTElOR19TTEFTSCkge1xuICAgICAgICBjb25zdCByZXdyaXRlVXJsRm9yTmV4dEV4cG9ydCA9IHJlcXVpcmUoJy4vcmV3cml0ZS11cmwtZm9yLWV4cG9ydCcpXG4gICAgICAgICAgLnJld3JpdGVVcmxGb3JOZXh0RXhwb3J0XG4gICAgICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBpcyB0ZW1wb3JhcmlseSBnbG9iYWwgKGF0dGFjaGVkIHRvIHdpbmRvdylcbiAgICAgICAgaWYgKF9fTkVYVF9EQVRBX18ubmV4dEV4cG9ydCkge1xuICAgICAgICAgIGFzID0gcmV3cml0ZVVybEZvck5leHRFeHBvcnQoYXMpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5hYm9ydENvbXBvbmVudExvYWQoYXMpXG5cbiAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAvLyBXZSBzaG91bGQgbm90IHByb2NlZWQuIFdlIHNob3VsZCBvbmx5IGNoYW5nZSB0aGUgc3RhdGUuXG5cbiAgICAgIC8vIFdBUk5JTkc6IGBfaGAgaXMgYW4gaW50ZXJuYWwgb3B0aW9uIGZvciBoYW5kaW5nIE5leHQuanMgY2xpZW50LXNpZGVcbiAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgIC8vIGFueSB0aW1lIHdpdGhvdXQgbm90aWNlLlxuICAgICAgaWYgKCFvcHRpb25zLl9oICYmIHRoaXMub25seUFIYXNoQ2hhbmdlKGFzKSkge1xuICAgICAgICB0aGlzLmFzUGF0aCA9IGFzXG4gICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnaGFzaENoYW5nZVN0YXJ0JywgYXMpXG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuICAgICAgICB0aGlzLnNjcm9sbFRvSGFzaChhcylcbiAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KCdoYXNoQ2hhbmdlQ29tcGxldGUnLCBhcylcbiAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSlcbiAgICAgIH1cblxuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcXVlcnksIHByb3RvY29sIH0gPSBwYXJzZSh1cmwsIHRydWUpXG5cbiAgICAgIGlmICghcGF0aG5hbWUgfHwgcHJvdG9jb2wpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW52YWxpZCBocmVmIHBhc3NlZCB0byByb3V0ZXI6ICR7dXJsfSBodHRwczovL2Vyci5zaC92ZXJjZWwvbmV4dC5qcy9pbnZhbGlkLWhyZWYtcGFzc2VkYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZShmYWxzZSlcbiAgICAgIH1cblxuICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgIC8vIChub3QgbG9jYXRpb24ucmVsb2FkKCkgYnV0IHJlbG9hZCBnZXRJbml0aWFsUHJvcHMgYW5kIG90aGVyIE5leHQuanMgc3R1ZmZzKVxuICAgICAgLy8gV2UgYWxzbyBuZWVkIHRvIHNldCB0aGUgbWV0aG9kID0gcmVwbGFjZVN0YXRlIGFsd2F5c1xuICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgIC8vIFdlIHNob3VsZCBjb21wYXJlIHRoZSBuZXcgYXNQYXRoIHRvIHRoZSBjdXJyZW50IGFzUGF0aCwgbm90IHRoZSB1cmxcbiAgICAgIGlmICghdGhpcy51cmxJc05ldyhhcykpIHtcbiAgICAgICAgbWV0aG9kID0gJ3JlcGxhY2VTdGF0ZSdcbiAgICAgIH1cblxuICAgICAgY29uc3Qgcm91dGUgPSB0b1JvdXRlKHBhdGhuYW1lKVxuICAgICAgY29uc3QgeyBzaGFsbG93ID0gZmFsc2UgfSA9IG9wdGlvbnNcblxuICAgICAgaWYgKGlzRHluYW1pY1JvdXRlKHJvdXRlKSkge1xuICAgICAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSBwYXJzZShhcylcbiAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9IGdldFJvdXRlUmVnZXgocm91dGUpXG4gICAgICAgIGNvbnN0IHJvdXRlTWF0Y2ggPSBnZXRSb3V0ZU1hdGNoZXIocm91dGVSZWdleCkoYXNQYXRobmFtZSlcbiAgICAgICAgaWYgKCFyb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgY29uc3QgbWlzc2luZ1BhcmFtcyA9IE9iamVjdC5rZXlzKHJvdXRlUmVnZXguZ3JvdXBzKS5maWx0ZXIoXG4gICAgICAgICAgICAocGFyYW0pID0+ICFxdWVyeVtwYXJhbV1cbiAgICAgICAgICApXG5cbiAgICAgICAgICBpZiAobWlzc2luZ1BhcmFtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgYE1pc21hdGNoaW5nIFxcYGFzXFxgIGFuZCBcXGBocmVmXFxgIGZhaWxlZCB0byBtYW51YWxseSBwcm92aWRlIGAgK1xuICAgICAgICAgICAgICAgICAgYHRoZSBwYXJhbXM6ICR7bWlzc2luZ1BhcmFtcy5qb2luKFxuICAgICAgICAgICAgICAgICAgICAnLCAnXG4gICAgICAgICAgICAgICAgICApfSBpbiB0aGUgXFxgaHJlZlxcYCdzIFxcYHF1ZXJ5XFxgYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZWplY3QoXG4gICAgICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVGhlIHByb3ZpZGVkIFxcYGFzXFxgIHZhbHVlICgke2FzUGF0aG5hbWV9KSBpcyBpbmNvbXBhdGlibGUgd2l0aCB0aGUgXFxgaHJlZlxcYCB2YWx1ZSAoJHtyb3V0ZX0pLiBgICtcbiAgICAgICAgICAgICAgICAgIGBSZWFkIG1vcmU6IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2luY29tcGF0aWJsZS1ocmVmLWFzYFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE1lcmdlIHBhcmFtcyBpbnRvIGBxdWVyeWAsIG92ZXJ3cml0aW5nIGFueSBzcGVjaWZpZWQgaW4gc2VhcmNoXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihxdWVyeSwgcm91dGVNYXRjaClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlU3RhcnQnLCBhcylcblxuICAgICAgLy8gSWYgc2hhbGxvdyBpcyB0cnVlIGFuZCB0aGUgcm91dGUgZXhpc3RzIGluIHRoZSByb3V0ZXIgY2FjaGUgd2UgcmV1c2UgdGhlIHByZXZpb3VzIHJlc3VsdFxuICAgICAgdGhpcy5nZXRSb3V0ZUluZm8ocm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHNoYWxsb3cpLnRoZW4oXG4gICAgICAgIChyb3V0ZUluZm8pID0+IHtcbiAgICAgICAgICBjb25zdCB7IGVycm9yIH0gPSByb3V0ZUluZm9cblxuICAgICAgICAgIGlmIChlcnJvciAmJiBlcnJvci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGZhbHNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgnYmVmb3JlSGlzdG9yeUNoYW5nZScsIGFzKVxuICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zKVxuXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IGFwcENvbXA6IGFueSA9IHRoaXMuY29tcG9uZW50c1snL19hcHAnXS5Db21wb25lbnRcbiAgICAgICAgICAgIDsod2luZG93IGFzIGFueSkubmV4dC5pc1ByZXJlbmRlcmVkID1cbiAgICAgICAgICAgICAgYXBwQ29tcC5nZXRJbml0aWFsUHJvcHMgPT09IGFwcENvbXAub3JpZ0dldEluaXRpYWxQcm9wcyAmJlxuICAgICAgICAgICAgICAhKHJvdXRlSW5mby5Db21wb25lbnQgYXMgYW55KS5nZXRJbml0aWFsUHJvcHNcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnNldChyb3V0ZSwgcGF0aG5hbWUsIHF1ZXJ5LCBhcywgcm91dGVJbmZvKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoJ3JvdXRlQ2hhbmdlRXJyb3InLCBlcnJvciwgYXMpXG4gICAgICAgICAgICAgIHRocm93IGVycm9yXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VDb21wbGV0ZScsIGFzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSlcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICByZWplY3RcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgY2hhbmdlU3RhdGUoXG4gICAgbWV0aG9kOiBIaXN0b3J5TWV0aG9kLFxuICAgIHVybDogc3RyaW5nLFxuICAgIGFzOiBzdHJpbmcsXG4gICAgb3B0aW9ucyA9IHt9XG4gICk6IHZvaWQge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBXYXJuaW5nOiB3aW5kb3cuaGlzdG9yeSBpcyBub3QgYXZhaWxhYmxlLmApXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdy5oaXN0b3J5W21ldGhvZF0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYFdhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LiR7bWV0aG9kfSBpcyBub3QgYXZhaWxhYmxlYClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1ldGhvZCAhPT0gJ3B1c2hTdGF0ZScgfHwgZ2V0VVJMKCkgIT09IGFzKSB7XG4gICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKFxuICAgICAgICB7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGFzLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE1vc3QgYnJvd3NlcnMgY3VycmVudGx5IGlnbm9yZXMgdGhpcyBwYXJhbWV0ZXIsIGFsdGhvdWdoIHRoZXkgbWF5IHVzZSBpdCBpbiB0aGUgZnV0dXJlLlxuICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IaXN0b3J5L3JlcGxhY2VTdGF0ZVxuICAgICAgICAnJyxcbiAgICAgICAgYXNcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICBnZXRSb3V0ZUluZm8oXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBzaGFsbG93OiBib29sZWFuID0gZmFsc2VcbiAgKTogUHJvbWlzZTxSb3V0ZUluZm8+IHtcbiAgICBjb25zdCBjYWNoZWRSb3V0ZUluZm8gPSB0aGlzLmNvbXBvbmVudHNbcm91dGVdXG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHNoYWxsb3cgcm91dGUgdHJhbnNpdGlvbiBwb3NzaWJsZVxuICAgIC8vIElmIHRoZSByb3V0ZSBpcyBhbHJlYWR5IHJlbmRlcmVkIG9uIHRoZSBzY3JlZW4uXG4gICAgaWYgKHNoYWxsb3cgJiYgY2FjaGVkUm91dGVJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNhY2hlZFJvdXRlSW5mbylcbiAgICB9XG5cbiAgICBjb25zdCBoYW5kbGVFcnJvciA9IChcbiAgICAgIGVycjogRXJyb3IgJiB7IGNvZGU6IGFueTsgY2FuY2VsbGVkOiBib29sZWFuIH0sXG4gICAgICBsb2FkRXJyb3JGYWlsPzogYm9vbGVhblxuICAgICkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChlcnIuY29kZSA9PT0gJ1BBR0VfTE9BRF9FUlJPUicgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgLy8gIDEuIFBhZ2UgZG9lc24ndCBleGlzdHNcbiAgICAgICAgICAvLyAgMi4gUGFnZSBkb2VzIGV4aXN0IGluIGEgZGlmZmVyZW50IHpvbmVcbiAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuXG4gICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBhc1xuXG4gICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgLy8gU28sIHdlIG5lZWQgdG8gbWFyayBpdCBhcyBhIGNhbmNlbGxlZCBlcnJvciBhbmQgc3RvcCB0aGUgcm91dGluZyBsb2dpYy5cbiAgICAgICAgICBlcnIuY2FuY2VsbGVkID0gdHJ1ZVxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVE9ETzogZml4IHRoZSBjb250cm9sIGZsb3cgaGVyZVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHsgZXJyb3I6IGVyciB9KVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVyci5jYW5jZWxsZWQpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIFRPRE86IGZpeCB0aGUgY29udHJvbCBmbG93IGhlcmVcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7IGVycm9yOiBlcnIgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoXG4gICAgICAgICAgdGhpcy5mZXRjaENvbXBvbmVudCgnL19lcnJvcicpXG4gICAgICAgICAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsgcGFnZTogQ29tcG9uZW50IH0gPSByZXNcbiAgICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvOiBSb3V0ZUluZm8gPSB7IENvbXBvbmVudCwgZXJyIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgIH0gYXMgYW55KS50aGVuKFxuICAgICAgICAgICAgICAgICAgKHByb3BzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5lcnJvciA9IGVyclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJvdXRlSW5mbylcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAoZ2lwRXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgJ0Vycm9yIGluIGVycm9yIHBhZ2UgYGdldEluaXRpYWxQcm9wc2A6ICcsXG4gICAgICAgICAgICAgICAgICAgICAgZ2lwRXJyXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLmVycm9yID0gZXJyXG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm91dGVJbmZvKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfSkgYXMgUHJvbWlzZTxSb3V0ZUluZm8+XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IGhhbmRsZUVycm9yKGVyciwgdHJ1ZSkpXG4gICAgICAgIClcbiAgICAgIH0pIGFzIFByb21pc2U8Um91dGVJbmZvPlxuICAgIH1cblxuICAgIHJldHVybiAobmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKGNhY2hlZFJvdXRlSW5mbykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShjYWNoZWRSb3V0ZUluZm8pXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZmV0Y2hDb21wb25lbnQocm91dGUpLnRoZW4oXG4gICAgICAgIChyZXMpID0+XG4gICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICBDb21wb25lbnQ6IHJlcy5wYWdlLFxuICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgX19OX1NTUDogcmVzLm1vZC5fX05fU1NQLFxuICAgICAgICAgIH0pLFxuICAgICAgICByZWplY3RcbiAgICAgIClcbiAgICB9KSBhcyBQcm9taXNlPFJvdXRlSW5mbz4pXG4gICAgICAudGhlbigocm91dGVJbmZvOiBSb3V0ZUluZm8pID0+IHtcbiAgICAgICAgY29uc3QgeyBDb21wb25lbnQsIF9fTl9TU0csIF9fTl9TU1AgfSA9IHJvdXRlSW5mb1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoJ3JlYWN0LWlzJylcbiAgICAgICAgICBpZiAoIWlzVmFsaWRFbGVtZW50VHlwZShDb21wb25lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJHtwYXRobmFtZX1cImBcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0RGF0YTxSb3V0ZUluZm8+KCgpID0+XG4gICAgICAgICAgX19OX1NTR1xuICAgICAgICAgICAgPyB0aGlzLl9nZXRTdGF0aWNEYXRhKGFzKVxuICAgICAgICAgICAgOiBfX05fU1NQXG4gICAgICAgICAgICA/IHRoaXMuX2dldFNlcnZlckRhdGEoYXMpXG4gICAgICAgICAgICA6IHRoaXMuZ2V0SW5pdGlhbFByb3BzKFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICBhc1BhdGg6IGFzLFxuICAgICAgICAgICAgICAgIH0gYXMgYW55XG4gICAgICAgICAgICAgIClcbiAgICAgICAgKS50aGVuKChwcm9wcykgPT4ge1xuICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHByb3BzXG4gICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mb1xuICAgICAgICAgIHJldHVybiByb3V0ZUluZm9cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goaGFuZGxlRXJyb3IpXG4gIH1cblxuICBzZXQoXG4gICAgcm91dGU6IHN0cmluZyxcbiAgICBwYXRobmFtZTogc3RyaW5nLFxuICAgIHF1ZXJ5OiBhbnksXG4gICAgYXM6IHN0cmluZyxcbiAgICBkYXRhOiBSb3V0ZUluZm9cbiAgKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdGhpcy5pc0ZhbGxiYWNrID0gZmFsc2VcblxuICAgIHRoaXMucm91dGUgPSByb3V0ZVxuICAgIHRoaXMucGF0aG5hbWUgPSBwYXRobmFtZVxuICAgIHRoaXMucXVlcnkgPSBxdWVyeVxuICAgIHRoaXMuYXNQYXRoID0gYXNcbiAgICByZXR1cm4gdGhpcy5ub3RpZnkoZGF0YSlcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB0byBleGVjdXRlIGJlZm9yZSByZXBsYWNpbmcgcm91dGVyIHN0YXRlXG4gICAqIEBwYXJhbSBjYiBjYWxsYmFjayB0byBiZSBleGVjdXRlZFxuICAgKi9cbiAgYmVmb3JlUG9wU3RhdGUoY2I6IEJlZm9yZVBvcFN0YXRlQ2FsbGJhY2spIHtcbiAgICB0aGlzLl9icHMgPSBjYlxuICB9XG5cbiAgb25seUFIYXNoQ2hhbmdlKGFzOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoIXRoaXMuYXNQYXRoKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KCcjJylcbiAgICBjb25zdCBbbmV3VXJsTm9IYXNoLCBuZXdIYXNoXSA9IGFzLnNwbGl0KCcjJylcblxuICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICBpZiAobmV3SGFzaCAmJiBvbGRVcmxOb0hhc2ggPT09IG5ld1VybE5vSGFzaCAmJiBvbGRIYXNoID09PSBuZXdIYXNoKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSB1cmxzIGFyZSBjaGFuZ2UsIHRoZXJlJ3MgbW9yZSB0aGFuIGEgaGFzaCBjaGFuZ2VcbiAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBoYXNoIGhhcyBjaGFuZ2VkLCB0aGVuIGl0J3MgYSBoYXNoIG9ubHkgY2hhbmdlLlxuICAgIC8vIFRoaXMgY2hlY2sgaXMgbmVjZXNzYXJ5IHRvIGhhbmRsZSBib3RoIHRoZSBlbnRlciBhbmRcbiAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgIC8vIGFuZCBpcyB0cmVhdGVkIGFzIGEgbmV4dCByZWxvYWQuXG4gICAgcmV0dXJuIG9sZEhhc2ggIT09IG5ld0hhc2hcbiAgfVxuXG4gIHNjcm9sbFRvSGFzaChhczogc3RyaW5nKTogdm9pZCB7XG4gICAgY29uc3QgWywgaGFzaF0gPSBhcy5zcGxpdCgnIycpXG4gICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlXG4gICAgaWYgKGhhc2ggPT09ICcnKSB7XG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZpcnN0IHdlIGNoZWNrIGlmIHRoZSBlbGVtZW50IGJ5IGlkIGlzIGZvdW5kXG4gICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGhhc2gpXG4gICAgaWYgKGlkRWwpIHtcbiAgICAgIGlkRWwuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gZWxlbWVudCB3aXRoIHRoZSBpZCwgd2UgY2hlY2sgdGhlIGBuYW1lYCBwcm9wZXJ0eVxuICAgIC8vIFRvIG1pcnJvciBicm93c2Vyc1xuICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2gpWzBdXG4gICAgaWYgKG5hbWVFbCkge1xuICAgICAgbmFtZUVsLnNjcm9sbEludG9WaWV3KClcbiAgICB9XG4gIH1cblxuICB1cmxJc05ldyhhc1BhdGg6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLmFzUGF0aCAhPT0gYXNQYXRoXG4gIH1cblxuICAvKipcbiAgICogUHJlZmV0Y2ggcGFnZSBjb2RlLCB5b3UgbWF5IHdhaXQgZm9yIHRoZSBkYXRhIGR1cmluZyBwYWdlIHJlbmRlcmluZy5cbiAgICogVGhpcyBmZWF0dXJlIG9ubHkgd29ya3MgaW4gcHJvZHVjdGlvbiFcbiAgICogQHBhcmFtIHVybCB0aGUgaHJlZiBvZiBwcmVmZXRjaGVkIHBhZ2VcbiAgICogQHBhcmFtIGFzUGF0aCB0aGUgYXMgcGF0aCBvZiB0aGUgcHJlZmV0Y2hlZCBwYWdlXG4gICAqL1xuICBwcmVmZXRjaChcbiAgICB1cmw6IHN0cmluZyxcbiAgICBhc1BhdGg6IHN0cmluZyA9IHVybCxcbiAgICBvcHRpb25zOiBQcmVmZXRjaE9wdGlvbnMgPSB7fVxuICApOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgeyBwYXRobmFtZSwgcHJvdG9jb2wgfSA9IHBhcnNlKHVybClcblxuICAgICAgaWYgKCFwYXRobmFtZSB8fCBwcm90b2NvbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBJbnZhbGlkIGhyZWYgcGFzc2VkIHRvIHJvdXRlcjogJHt1cmx9IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2ludmFsaWQtaHJlZi1wYXNzZWRgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBQcmVmZXRjaCBpcyBub3Qgc3VwcG9ydGVkIGluIGRldmVsb3BtZW50IG1vZGUgYmVjYXVzZSBpdCB3b3VsZCB0cmlnZ2VyIG9uLWRlbWFuZC1lbnRyaWVzXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHJvdXRlID0gZGVsQmFzZVBhdGgodG9Sb3V0ZShwYXRobmFtZSkpXG4gICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgIHRoaXMucGFnZUxvYWRlci5wcmVmZXRjaERhdGEodXJsLCBkZWxCYXNlUGF0aChhc1BhdGgpKSxcbiAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyAnbG9hZFBhZ2UnIDogJ3ByZWZldGNoJ10ocm91dGUpLFxuICAgICAgXSkudGhlbigoKSA9PiByZXNvbHZlKCksIHJlamVjdClcbiAgICB9KVxuICB9XG5cbiAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGU6IHN0cmluZyk6IFByb21pc2U8Q29tcG9uZW50UmVzPiB7XG4gICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlXG4gICAgY29uc3QgY2FuY2VsID0gKHRoaXMuY2xjID0gKCkgPT4ge1xuICAgICAgY2FuY2VsbGVkID0gdHJ1ZVxuICAgIH0pXG4gICAgcm91dGUgPSBkZWxCYXNlUGF0aChyb3V0ZSlcblxuICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSlcblxuICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgIGNvbnN0IGVycm9yOiBhbnkgPSBuZXcgRXJyb3IoXG4gICAgICAgIGBBYm9ydCBmZXRjaGluZyBjb21wb25lbnQgZm9yIHJvdXRlOiBcIiR7cm91dGV9XCJgXG4gICAgICApXG4gICAgICBlcnJvci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cblxuICAgIGlmIChjYW5jZWwgPT09IHRoaXMuY2xjKSB7XG4gICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcG9uZW50UmVzdWx0XG4gIH1cblxuICBfZ2V0RGF0YTxUPihmbjogKCkgPT4gUHJvbWlzZTxUPik6IFByb21pc2U8VD4ge1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZVxuICAgIGNvbnN0IGNhbmNlbCA9ICgpID0+IHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWVcbiAgICB9XG4gICAgdGhpcy5jbGMgPSBjYW5jZWxcbiAgICByZXR1cm4gZm4oKS50aGVuKChkYXRhKSA9PiB7XG4gICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICB0aGlzLmNsYyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICBjb25zdCBlcnI6IGFueSA9IG5ldyBFcnJvcignTG9hZGluZyBpbml0aWFsIHByb3BzIGNhbmNlbGxlZCcpXG4gICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlXG4gICAgICAgIHRocm93IGVyclxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YVxuICAgIH0pXG4gIH1cblxuICBfZ2V0U3RhdGljRGF0YSA9IChhc1BhdGg6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gICAgY29uc3QgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUocGFyc2UoYXNQYXRoKS5wYXRobmFtZSEpXG5cbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJiB0aGlzLnNkY1twYXRobmFtZV1cbiAgICAgID8gUHJvbWlzZS5yZXNvbHZlKHRoaXMuc2RjW3BhdGhuYW1lXSlcbiAgICAgIDogZmV0Y2hOZXh0RGF0YShcbiAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHRoaXMuaXNTc3IsXG4gICAgICAgICAgKGRhdGEpID0+ICh0aGlzLnNkY1twYXRobmFtZV0gPSBkYXRhKVxuICAgICAgICApXG4gIH1cblxuICBfZ2V0U2VydmVyRGF0YSA9IChhc1BhdGg6IHN0cmluZyk6IFByb21pc2U8b2JqZWN0PiA9PiB7XG4gICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZShhc1BhdGgsIHRydWUpXG4gICAgcGF0aG5hbWUgPSBwcmVwYXJlUm91dGUocGF0aG5hbWUhKVxuICAgIHJldHVybiBmZXRjaE5leHREYXRhKHBhdGhuYW1lLCBxdWVyeSwgdGhpcy5pc1NzcilcbiAgfVxuXG4gIGdldEluaXRpYWxQcm9wcyhcbiAgICBDb21wb25lbnQ6IENvbXBvbmVudFR5cGUsXG4gICAgY3R4OiBOZXh0UGFnZUNvbnRleHRcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICBjb25zdCB7IENvbXBvbmVudDogQXBwIH0gPSB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ11cbiAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApXG4gICAgY3R4LkFwcFRyZWUgPSBBcHBUcmVlXG4gICAgcmV0dXJuIGxvYWRHZXRJbml0aWFsUHJvcHM8QXBwQ29udGV4dFR5cGU8Um91dGVyPj4oQXBwLCB7XG4gICAgICBBcHBUcmVlLFxuICAgICAgQ29tcG9uZW50LFxuICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgY3R4LFxuICAgIH0pXG4gIH1cblxuICBhYm9ydENvbXBvbmVudExvYWQoYXM6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNsYykge1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcignUm91dGUgQ2FuY2VsbGVkJylcbiAgICAgIDsoZSBhcyBhbnkpLmNhbmNlbGxlZCA9IHRydWVcbiAgICAgIFJvdXRlci5ldmVudHMuZW1pdCgncm91dGVDaGFuZ2VFcnJvcicsIGUsIGFzKVxuICAgICAgdGhpcy5jbGMoKVxuICAgICAgdGhpcy5jbGMgPSBudWxsXG4gICAgfVxuICB9XG5cbiAgbm90aWZ5KGRhdGE6IFJvdXRlSW5mbyk6IFByb21pc2U8dm9pZD4ge1xuICAgIHJldHVybiB0aGlzLnN1YihkYXRhLCB0aGlzLmNvbXBvbmVudHNbJy9fYXBwJ10uQ29tcG9uZW50KVxuICB9XG59XG4iLCIvLyBJZGVudGlmeSAvW3BhcmFtXS8gaW4gcm91dGUgc3RyaW5nXG5jb25zdCBURVNUX1JPVVRFID0gL1xcL1xcW1teL10rP1xcXSg/PVxcL3wkKS9cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRHluYW1pY1JvdXRlKHJvdXRlOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIFRFU1RfUk9VVEUudGVzdChyb3V0ZSlcbn1cbiIsImltcG9ydCB7IGdldFJvdXRlUmVnZXggfSBmcm9tICcuL3JvdXRlLXJlZ2V4J1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Um91dGVNYXRjaGVyKHJvdXRlUmVnZXg6IFJldHVyblR5cGU8dHlwZW9mIGdldFJvdXRlUmVnZXg+KSB7XG4gIGNvbnN0IHsgcmUsIGdyb3VwcyB9ID0gcm91dGVSZWdleFxuICByZXR1cm4gKHBhdGhuYW1lOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgY29uc3Qgcm91dGVNYXRjaCA9IHJlLmV4ZWMocGF0aG5hbWUhKVxuICAgIGlmICghcm91dGVNYXRjaCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgZGVjb2RlID0gKHBhcmFtOiBzdHJpbmcpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFyYW0pXG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIGNvbnN0IGVycjogRXJyb3IgJiB7IGNvZGU/OiBzdHJpbmcgfSA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnZmFpbGVkIHRvIGRlY29kZSBwYXJhbSdcbiAgICAgICAgKVxuICAgICAgICBlcnIuY29kZSA9ICdERUNPREVfRkFJTEVEJ1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFyYW1zOiB7IFtwYXJhbU5hbWU6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdIH0gPSB7fVxuXG4gICAgT2JqZWN0LmtleXMoZ3JvdXBzKS5mb3JFYWNoKChzbHVnTmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICBjb25zdCBnID0gZ3JvdXBzW3NsdWdOYW1lXVxuICAgICAgY29uc3QgbSA9IHJvdXRlTWF0Y2hbZy5wb3NdXG4gICAgICBpZiAobSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtc1tzbHVnTmFtZV0gPSB+bS5pbmRleE9mKCcvJylcbiAgICAgICAgICA/IG0uc3BsaXQoJy8nKS5tYXAoKGVudHJ5KSA9PiBkZWNvZGUoZW50cnkpKVxuICAgICAgICAgIDogZy5yZXBlYXRcbiAgICAgICAgICA/IFtkZWNvZGUobSldXG4gICAgICAgICAgOiBkZWNvZGUobSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBwYXJhbXNcbiAgfVxufVxuIiwiLy8gdGhpcyBpc24ndCBpbXBvcnRpbmcgdGhlIGVzY2FwZS1zdHJpbmctcmVnZXggbW9kdWxlXG4vLyB0byByZWR1Y2UgYnl0ZXNcbmZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cjogc3RyaW5nKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW3xcXFxce30oKVtcXF1eJCsqPy4tXS9nLCAnXFxcXCQmJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvdXRlUmVnZXgoXG4gIG5vcm1hbGl6ZWRSb3V0ZTogc3RyaW5nXG4pOiB7XG4gIHJlOiBSZWdFeHBcbiAgbmFtZWRSZWdleD86IHN0cmluZ1xuICBncm91cHM6IHsgW2dyb3VwTmFtZTogc3RyaW5nXTogeyBwb3M6IG51bWJlcjsgcmVwZWF0OiBib29sZWFuIH0gfVxufSB7XG4gIC8vIEVzY2FwZSBhbGwgY2hhcmFjdGVycyB0aGF0IGNvdWxkIGJlIGNvbnNpZGVyZWQgUmVnRXhcbiAgY29uc3QgZXNjYXBlZFJvdXRlID0gZXNjYXBlUmVnZXgobm9ybWFsaXplZFJvdXRlLnJlcGxhY2UoL1xcLyQvLCAnJykgfHwgJy8nKVxuXG4gIGNvbnN0IGdyb3VwczogeyBbZ3JvdXBOYW1lOiBzdHJpbmddOiB7IHBvczogbnVtYmVyOyByZXBlYXQ6IGJvb2xlYW4gfSB9ID0ge31cbiAgbGV0IGdyb3VwSW5kZXggPSAxXG5cbiAgY29uc3QgcGFyYW1ldGVyaXplZFJvdXRlID0gZXNjYXBlZFJvdXRlLnJlcGxhY2UoXG4gICAgL1xcL1xcXFxcXFsoW14vXSs/KVxcXFxcXF0oPz1cXC98JCkvZyxcbiAgICAoXywgJDEpID0+IHtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSAvXlxcXFxcXFsuKlxcXFxcXF0kLy50ZXN0KCQxKVxuICAgICAgaWYgKGlzT3B0aW9uYWwpIHtcbiAgICAgICAgJDEgPSAkMS5zbGljZSgyLCAtMilcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlzQ2F0Y2hBbGwgPSAvXihcXFxcXFwuKXszfS8udGVzdCgkMSlcbiAgICAgIGlmIChpc0NhdGNoQWxsKSB7XG4gICAgICAgICQxID0gJDEuc2xpY2UoNilcbiAgICAgIH1cbiAgICAgIGdyb3Vwc1tcbiAgICAgICAgJDFcbiAgICAgICAgICAvLyBVbi1lc2NhcGUga2V5XG4gICAgICAgICAgLnJlcGxhY2UoL1xcXFwoW3xcXFxce30oKVtcXF1eJCsqPy4tXSkvZywgJyQxJylcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgXSA9IHsgcG9zOiBncm91cEluZGV4KyssIHJlcGVhdDogaXNDYXRjaEFsbCB9XG4gICAgICByZXR1cm4gaXNDYXRjaEFsbCA/IChpc09wdGlvbmFsID8gJyg/Oi8oLis/KSk/JyA6ICcvKC4rPyknKSA6ICcvKFteL10rPyknXG4gICAgfVxuICApXG5cbiAgbGV0IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlOiBzdHJpbmcgfCB1bmRlZmluZWRcblxuICAvLyBkZWFkIGNvZGUgZWxpbWluYXRlIGZvciBicm93c2VyIHNpbmNlIGl0J3Mgb25seSBuZWVkZWRcbiAgLy8gd2hpbGUgZ2VuZXJhdGluZyByb3V0ZXMtbWFuaWZlc3RcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgbmFtZWRQYXJhbWV0ZXJpemVkUm91dGUgPSBlc2NhcGVkUm91dGUucmVwbGFjZShcbiAgICAgIC9cXC9cXFxcXFxbKFteL10rPylcXFxcXFxdKD89XFwvfCQpL2csXG4gICAgICAoXywgJDEpID0+IHtcbiAgICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IC9eKFxcXFxcXC4pezN9Ly50ZXN0KCQxKVxuICAgICAgICBjb25zdCBrZXkgPSAkMVxuICAgICAgICAgIC8vIFVuLWVzY2FwZSBrZXlcbiAgICAgICAgICAucmVwbGFjZSgvXFxcXChbfFxcXFx7fSgpW1xcXV4kKyo/Li1dKS9nLCAnJDEnKVxuICAgICAgICAgIC5yZXBsYWNlKC9eXFwuezN9LywgJycpXG5cbiAgICAgICAgcmV0dXJuIGlzQ2F0Y2hBbGxcbiAgICAgICAgICA/IGAvKD88JHtlc2NhcGVSZWdleChrZXkpfT4uKz8pYFxuICAgICAgICAgIDogYC8oPzwke2VzY2FwZVJlZ2V4KGtleSl9PlteL10rPylgXG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZTogbmV3IFJlZ0V4cCgnXicgKyBwYXJhbWV0ZXJpemVkUm91dGUgKyAnKD86Lyk/JCcsICdpJyksXG4gICAgZ3JvdXBzLFxuICAgIG5hbWVkUmVnZXg6IG5hbWVkUGFyYW1ldGVyaXplZFJvdXRlXG4gICAgICA/IGBeJHtuYW1lZFBhcmFtZXRlcml6ZWRSb3V0ZX0oPzovKT8kYFxuICAgICAgOiB1bmRlZmluZWQsXG4gIH1cbn1cbiIsImltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcblxuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuXG50eXBlIFN0YXRlID0gQXJyYXk8UmVhY3QuUmVhY3RFbGVtZW50PGFueT4+IHwgdW5kZWZpbmVkXG5cbnR5cGUgU2lkZUVmZmVjdFByb3BzID0ge1xuICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogPFQ+KFxuICAgIGNvbXBvbmVudHM6IEFycmF5PFJlYWN0LlJlYWN0RWxlbWVudDxhbnk+PixcbiAgICBwcm9wczogVFxuICApID0+IFN0YXRlXG4gIGhhbmRsZVN0YXRlQ2hhbmdlPzogKHN0YXRlOiBTdGF0ZSkgPT4gdm9pZFxuICBpbkFtcE1vZGU/OiBib29sZWFuXG59XG5cbmV4cG9ydCBkZWZhdWx0ICgpID0+IHtcbiAgY29uc3QgbW91bnRlZEluc3RhbmNlczogU2V0PGFueT4gPSBuZXcgU2V0KClcbiAgbGV0IHN0YXRlOiBTdGF0ZVxuXG4gIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoY29tcG9uZW50OiBSZWFjdC5Db21wb25lbnQ8U2lkZUVmZmVjdFByb3BzPik6IHZvaWQge1xuICAgIHN0YXRlID0gY29tcG9uZW50LnByb3BzLnJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKFxuICAgICAgWy4uLm1vdW50ZWRJbnN0YW5jZXNdLFxuICAgICAgY29tcG9uZW50LnByb3BzXG4gICAgKVxuICAgIGlmIChjb21wb25lbnQucHJvcHMuaGFuZGxlU3RhdGVDaGFuZ2UpIHtcbiAgICAgIGNvbXBvbmVudC5wcm9wcy5oYW5kbGVTdGF0ZUNoYW5nZShzdGF0ZSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY2xhc3MgZXh0ZW5kcyBDb21wb25lbnQ8U2lkZUVmZmVjdFByb3BzPiB7XG4gICAgLy8gVXNlZCB3aGVuIHNlcnZlciByZW5kZXJpbmdcbiAgICBzdGF0aWMgcmV3aW5kKCkge1xuICAgICAgY29uc3QgcmVjb3JkZWRTdGF0ZSA9IHN0YXRlXG4gICAgICBzdGF0ZSA9IHVuZGVmaW5lZFxuICAgICAgbW91bnRlZEluc3RhbmNlcy5jbGVhcigpXG4gICAgICByZXR1cm4gcmVjb3JkZWRTdGF0ZVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHByb3BzOiBhbnkpIHtcbiAgICAgIHN1cGVyKHByb3BzKVxuICAgICAgaWYgKGlzU2VydmVyKSB7XG4gICAgICAgIG1vdW50ZWRJbnN0YW5jZXMuYWRkKHRoaXMpXG4gICAgICAgIGVtaXRDaGFuZ2UodGhpcylcbiAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBtb3VudGVkSW5zdGFuY2VzLmFkZCh0aGlzKVxuICAgICAgZW1pdENoYW5nZSh0aGlzKVxuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICBlbWl0Q2hhbmdlKHRoaXMpXG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgbW91bnRlZEluc3RhbmNlcy5kZWxldGUodGhpcylcbiAgICAgIGVtaXRDaGFuZ2UodGhpcylcbiAgICB9XG5cbiAgICByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgSW5jb21pbmdNZXNzYWdlLCBTZXJ2ZXJSZXNwb25zZSB9IGZyb20gJ2h0dHAnXG5pbXBvcnQgeyBQYXJzZWRVcmxRdWVyeSB9IGZyb20gJ3F1ZXJ5c3RyaW5nJ1xuaW1wb3J0IHsgQ29tcG9uZW50VHlwZSB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgZm9ybWF0LCBVUkxGb3JtYXRPcHRpb25zLCBVcmxPYmplY3QgfSBmcm9tICd1cmwnXG5pbXBvcnQgeyBNYW5pZmVzdEl0ZW0gfSBmcm9tICcuLi9zZXJ2ZXIvbG9hZC1jb21wb25lbnRzJ1xuaW1wb3J0IHsgTmV4dFJvdXRlciB9IGZyb20gJy4vcm91dGVyL3JvdXRlcidcbmltcG9ydCB7IEVudiB9IGZyb20gJy4uLy4uL2xpYi9sb2FkLWVudi1jb25maWcnXG5cbi8qKlxuICogVHlwZXMgdXNlZCBieSBib3RoIG5leHQgYW5kIG5leHQtc2VydmVyXG4gKi9cblxuZXhwb3J0IHR5cGUgTmV4dENvbXBvbmVudFR5cGU8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCA9IE5leHRQYWdlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+ID0gQ29tcG9uZW50VHlwZTxQPiAmIHtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGluaXRpYWwgcGFnZSBsb2FkIGRhdGEgcG9wdWxhdGlvbi4gRGF0YSByZXR1cm5lZCBmcm9tIGBnZXRJbml0aWFsUHJvcHNgIGlzIHNlcmlhbGl6ZWQgd2hlbiBzZXJ2ZXIgcmVuZGVyZWQuXG4gICAqIE1ha2Ugc3VyZSB0byByZXR1cm4gcGxhaW4gYE9iamVjdGAgd2l0aG91dCB1c2luZyBgRGF0ZWAsIGBNYXBgLCBgU2V0YC5cbiAgICogQHBhcmFtIGN0eCBDb250ZXh0IG9mIGBwYWdlYFxuICAgKi9cbiAgZ2V0SW5pdGlhbFByb3BzPyhjb250ZXh0OiBDKTogSVAgfCBQcm9taXNlPElQPlxufVxuXG5leHBvcnQgdHlwZSBEb2N1bWVudFR5cGUgPSBOZXh0Q29tcG9uZW50VHlwZTxcbiAgRG9jdW1lbnRDb250ZXh0LFxuICBEb2N1bWVudEluaXRpYWxQcm9wcyxcbiAgRG9jdW1lbnRQcm9wc1xuPiAmIHtcbiAgcmVuZGVyRG9jdW1lbnQoXG4gICAgRG9jdW1lbnQ6IERvY3VtZW50VHlwZSxcbiAgICBwcm9wczogRG9jdW1lbnRQcm9wc1xuICApOiBSZWFjdC5SZWFjdEVsZW1lbnRcbn1cblxuZXhwb3J0IHR5cGUgQXBwVHlwZSA9IE5leHRDb21wb25lbnRUeXBlPFxuICBBcHBDb250ZXh0VHlwZSxcbiAgQXBwSW5pdGlhbFByb3BzLFxuICBBcHBQcm9wc1R5cGVcbj5cblxuZXhwb3J0IHR5cGUgQXBwVHJlZVR5cGUgPSBDb21wb25lbnRUeXBlPFxuICBBcHBJbml0aWFsUHJvcHMgJiB7IFtuYW1lOiBzdHJpbmddOiBhbnkgfVxuPlxuXG5leHBvcnQgdHlwZSBFbmhhbmNlcjxDPiA9IChDb21wb25lbnQ6IEMpID0+IENcblxuZXhwb3J0IHR5cGUgQ29tcG9uZW50c0VuaGFuY2VyID1cbiAgfCB7XG4gICAgICBlbmhhbmNlQXBwPzogRW5oYW5jZXI8QXBwVHlwZT5cbiAgICAgIGVuaGFuY2VDb21wb25lbnQ/OiBFbmhhbmNlcjxOZXh0Q29tcG9uZW50VHlwZT5cbiAgICB9XG4gIHwgRW5oYW5jZXI8TmV4dENvbXBvbmVudFR5cGU+XG5cbmV4cG9ydCB0eXBlIFJlbmRlclBhZ2VSZXN1bHQgPSB7XG4gIGh0bWw6IHN0cmluZ1xuICBoZWFkPzogQXJyYXk8SlNYLkVsZW1lbnQgfCBudWxsPlxufVxuXG5leHBvcnQgdHlwZSBSZW5kZXJQYWdlID0gKFxuICBvcHRpb25zPzogQ29tcG9uZW50c0VuaGFuY2VyXG4pID0+IFJlbmRlclBhZ2VSZXN1bHQgfCBQcm9taXNlPFJlbmRlclBhZ2VSZXN1bHQ+XG5cbmV4cG9ydCB0eXBlIEJhc2VDb250ZXh0ID0ge1xuICByZXM/OiBTZXJ2ZXJSZXNwb25zZVxuICBbazogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB0eXBlIE5FWFRfREFUQSA9IHtcbiAgcHJvcHM6IGFueVxuICBwYWdlOiBzdHJpbmdcbiAgcXVlcnk6IFBhcnNlZFVybFF1ZXJ5XG4gIGJ1aWxkSWQ6IHN0cmluZ1xuICBhc3NldFByZWZpeD86IHN0cmluZ1xuICBydW50aW1lQ29uZmlnPzogeyBba2V5OiBzdHJpbmddOiBhbnkgfVxuICBuZXh0RXhwb3J0PzogYm9vbGVhblxuICBhdXRvRXhwb3J0PzogYm9vbGVhblxuICBpc0ZhbGxiYWNrPzogYm9vbGVhblxuICBkeW5hbWljSWRzPzogc3RyaW5nW11cbiAgZXJyPzogRXJyb3IgJiB7IHN0YXR1c0NvZGU/OiBudW1iZXIgfVxuICBnc3A/OiBib29sZWFuXG4gIGdzc3A/OiBib29sZWFuXG4gIGN1c3RvbVNlcnZlcj86IGJvb2xlYW5cbiAgZ2lwPzogYm9vbGVhblxuICBhcHBHaXA/OiBib29sZWFuXG59XG5cbi8qKlxuICogYE5leHRgIGNvbnRleHRcbiAqL1xuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIGludGVyZmFjZS1uYW1lXG5leHBvcnQgaW50ZXJmYWNlIE5leHRQYWdlQ29udGV4dCB7XG4gIC8qKlxuICAgKiBFcnJvciBvYmplY3QgaWYgZW5jb3VudGVyZWQgZHVyaW5nIHJlbmRlcmluZ1xuICAgKi9cbiAgZXJyPzogKEVycm9yICYgeyBzdGF0dXNDb2RlPzogbnVtYmVyIH0pIHwgbnVsbFxuICAvKipcbiAgICogYEhUVFBgIHJlcXVlc3Qgb2JqZWN0LlxuICAgKi9cbiAgcmVxPzogSW5jb21pbmdNZXNzYWdlXG4gIC8qKlxuICAgKiBgSFRUUGAgcmVzcG9uc2Ugb2JqZWN0LlxuICAgKi9cbiAgcmVzPzogU2VydmVyUmVzcG9uc2VcbiAgLyoqXG4gICAqIFBhdGggc2VjdGlvbiBvZiBgVVJMYC5cbiAgICovXG4gIHBhdGhuYW1lOiBzdHJpbmdcbiAgLyoqXG4gICAqIFF1ZXJ5IHN0cmluZyBzZWN0aW9uIG9mIGBVUkxgIHBhcnNlZCBhcyBhbiBvYmplY3QuXG4gICAqL1xuICBxdWVyeTogUGFyc2VkVXJsUXVlcnlcbiAgLyoqXG4gICAqIGBTdHJpbmdgIG9mIHRoZSBhY3R1YWwgcGF0aCBpbmNsdWRpbmcgcXVlcnkuXG4gICAqL1xuICBhc1BhdGg/OiBzdHJpbmdcbiAgLyoqXG4gICAqIGBDb21wb25lbnRgIHRoZSB0cmVlIG9mIHRoZSBBcHAgdG8gdXNlIGlmIG5lZWRpbmcgdG8gcmVuZGVyIHNlcGFyYXRlbHlcbiAgICovXG4gIEFwcFRyZWU6IEFwcFRyZWVUeXBlXG59XG5cbmV4cG9ydCB0eXBlIEFwcENvbnRleHRUeXBlPFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcj4gPSB7XG4gIENvbXBvbmVudDogTmV4dENvbXBvbmVudFR5cGU8TmV4dFBhZ2VDb250ZXh0PlxuICBBcHBUcmVlOiBBcHBUcmVlVHlwZVxuICBjdHg6IE5leHRQYWdlQ29udGV4dFxuICByb3V0ZXI6IFJcbn1cblxuZXhwb3J0IHR5cGUgQXBwSW5pdGlhbFByb3BzID0ge1xuICBwYWdlUHJvcHM6IGFueVxufVxuXG5leHBvcnQgdHlwZSBBcHBQcm9wc1R5cGU8XG4gIFIgZXh0ZW5kcyBOZXh0Um91dGVyID0gTmV4dFJvdXRlcixcbiAgUCA9IHt9XG4+ID0gQXBwSW5pdGlhbFByb3BzICYge1xuICBDb21wb25lbnQ6IE5leHRDb21wb25lbnRUeXBlPE5leHRQYWdlQ29udGV4dCwgYW55LCBQPlxuICByb3V0ZXI6IFJcbiAgX19OX1NTRz86IGJvb2xlYW5cbiAgX19OX1NTUD86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRG9jdW1lbnRDb250ZXh0ID0gTmV4dFBhZ2VDb250ZXh0ICYge1xuICByZW5kZXJQYWdlOiBSZW5kZXJQYWdlXG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50SW5pdGlhbFByb3BzID0gUmVuZGVyUGFnZVJlc3VsdCAmIHtcbiAgc3R5bGVzPzogUmVhY3QuUmVhY3RFbGVtZW50W10gfCBSZWFjdC5SZWFjdEZyYWdtZW50XG59XG5cbmV4cG9ydCB0eXBlIERvY3VtZW50UHJvcHMgPSBEb2N1bWVudEluaXRpYWxQcm9wcyAmIHtcbiAgX19ORVhUX0RBVEFfXzogTkVYVF9EQVRBXG4gIGRhbmdlcm91c0FzUGF0aDogc3RyaW5nXG4gIGFtcFBhdGg6IHN0cmluZ1xuICBpbkFtcE1vZGU6IGJvb2xlYW5cbiAgaHlicmlkQW1wOiBib29sZWFuXG4gIHN0YXRpY01hcmt1cDogYm9vbGVhblxuICBpc0RldmVsb3BtZW50OiBib29sZWFuXG4gIGRldkZpbGVzOiBzdHJpbmdbXVxuICBmaWxlczogc3RyaW5nW11cbiAgbG93UHJpb3JpdHlGaWxlczogc3RyaW5nW11cbiAgcG9seWZpbGxGaWxlczogc3RyaW5nW11cbiAgZHluYW1pY0ltcG9ydHM6IE1hbmlmZXN0SXRlbVtdXG4gIGFzc2V0UHJlZml4Pzogc3RyaW5nXG4gIGNhbm9uaWNhbEJhc2U6IHN0cmluZ1xuICBodG1sUHJvcHM6IGFueVxuICBib2R5VGFnczogYW55W11cbiAgaGVhZFRhZ3M6IGFueVtdXG4gIHVuc3RhYmxlX3J1bnRpbWVKUz86IGZhbHNlXG59XG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXF1ZXN0XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmV4dEFwaVJlcXVlc3QgZXh0ZW5kcyBJbmNvbWluZ01lc3NhZ2Uge1xuICAvKipcbiAgICogT2JqZWN0IG9mIGBxdWVyeWAgdmFsdWVzIGZyb20gdXJsXG4gICAqL1xuICBxdWVyeToge1xuICAgIFtrZXk6IHN0cmluZ106IHN0cmluZyB8IHN0cmluZ1tdXG4gIH1cbiAgLyoqXG4gICAqIE9iamVjdCBvZiBgY29va2llc2AgZnJvbSBoZWFkZXJcbiAgICovXG4gIGNvb2tpZXM6IHtcbiAgICBba2V5OiBzdHJpbmddOiBzdHJpbmdcbiAgfVxuXG4gIGJvZHk6IGFueVxuXG4gIGVudjogRW52XG59XG5cbi8qKlxuICogU2VuZCBib2R5IG9mIHJlc3BvbnNlXG4gKi9cbnR5cGUgU2VuZDxUPiA9IChib2R5OiBUKSA9PiB2b2lkXG5cbi8qKlxuICogTmV4dCBgQVBJYCByb3V0ZSByZXNwb25zZVxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpUmVzcG9uc2U8VCA9IGFueT4gPSBTZXJ2ZXJSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqIFNlbmQgZGF0YSBgYW55YCBkYXRhIGluIHJlc3BvbnNlXG4gICAqL1xuICBzZW5kOiBTZW5kPFQ+XG4gIC8qKlxuICAgKiBTZW5kIGRhdGEgYGpzb25gIGRhdGEgaW4gcmVzcG9uc2VcbiAgICovXG4gIGpzb246IFNlbmQ8VD5cbiAgc3RhdHVzOiAoc3RhdHVzQ29kZTogbnVtYmVyKSA9PiBOZXh0QXBpUmVzcG9uc2U8VD5cblxuICAvKipcbiAgICogU2V0IHByZXZpZXcgZGF0YSBmb3IgTmV4dC5qcycgcHJlcmVuZGVyIG1vZGVcbiAgICovXG4gIHNldFByZXZpZXdEYXRhOiAoXG4gICAgZGF0YTogb2JqZWN0IHwgc3RyaW5nLFxuICAgIG9wdGlvbnM/OiB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpZmllcyB0aGUgbnVtYmVyIChpbiBzZWNvbmRzKSBmb3IgdGhlIHByZXZpZXcgc2Vzc2lvbiB0byBsYXN0IGZvci5cbiAgICAgICAqIFRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gYW4gaW50ZWdlciBieSByb3VuZGluZyBkb3duLlxuICAgICAgICogQnkgZGVmYXVsdCwgbm8gbWF4aW11bSBhZ2UgaXMgc2V0IGFuZCB0aGUgcHJldmlldyBzZXNzaW9uIGZpbmlzaGVzXG4gICAgICAgKiB3aGVuIHRoZSBjbGllbnQgc2h1dHMgZG93biAoYnJvd3NlciBpcyBjbG9zZWQpLlxuICAgICAgICovXG4gICAgICBtYXhBZ2U/OiBudW1iZXJcbiAgICB9XG4gICkgPT4gTmV4dEFwaVJlc3BvbnNlPFQ+XG4gIGNsZWFyUHJldmlld0RhdGE6ICgpID0+IE5leHRBcGlSZXNwb25zZTxUPlxufVxuXG4vKipcbiAqIE5leHQgYEFQSWAgcm91dGUgaGFuZGxlclxuICovXG5leHBvcnQgdHlwZSBOZXh0QXBpSGFuZGxlcjxUID0gYW55PiA9IChcbiAgcmVxOiBOZXh0QXBpUmVxdWVzdCxcbiAgcmVzOiBOZXh0QXBpUmVzcG9uc2U8VD5cbikgPT4gdm9pZCB8IFByb21pc2U8dm9pZD5cblxuLyoqXG4gKiBVdGlsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXhlY09uY2U8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gUmV0dXJuVHlwZTxUPj4oXG4gIGZuOiBUXG4pOiBUIHtcbiAgbGV0IHVzZWQgPSBmYWxzZVxuICBsZXQgcmVzdWx0OiBSZXR1cm5UeXBlPFQ+XG5cbiAgcmV0dXJuICgoLi4uYXJnczogYW55W10pID0+IHtcbiAgICBpZiAoIXVzZWQpIHtcbiAgICAgIHVzZWQgPSB0cnVlXG4gICAgICByZXN1bHQgPSBmbiguLi5hcmdzKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0pIGFzIFRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBjb25zdCB7IHByb3RvY29sLCBob3N0bmFtZSwgcG9ydCB9ID0gd2luZG93LmxvY2F0aW9uXG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9JHtwb3J0ID8gJzonICsgcG9ydCA6ICcnfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgY29uc3QgeyBocmVmIH0gPSB3aW5kb3cubG9jYXRpb25cbiAgY29uc3Qgb3JpZ2luID0gZ2V0TG9jYXRpb25PcmlnaW4oKVxuICByZXR1cm4gaHJlZi5zdWJzdHJpbmcob3JpZ2luLmxlbmd0aClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lPFA+KENvbXBvbmVudDogQ29tcG9uZW50VHlwZTxQPikge1xuICByZXR1cm4gdHlwZW9mIENvbXBvbmVudCA9PT0gJ3N0cmluZydcbiAgICA/IENvbXBvbmVudFxuICAgIDogQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdVbmtub3duJ1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZXNTZW50KHJlczogU2VydmVyUmVzcG9uc2UpIHtcbiAgcmV0dXJuIHJlcy5maW5pc2hlZCB8fCByZXMuaGVhZGVyc1NlbnRcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRHZXRJbml0aWFsUHJvcHM8XG4gIEMgZXh0ZW5kcyBCYXNlQ29udGV4dCxcbiAgSVAgPSB7fSxcbiAgUCA9IHt9XG4+KEFwcDogTmV4dENvbXBvbmVudFR5cGU8QywgSVAsIFA+LCBjdHg6IEMpOiBQcm9taXNlPElQPiB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKEFwcC5wcm90b3R5cGU/LmdldEluaXRpYWxQcm9wcykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGBcIiR7Z2V0RGlzcGxheU5hbWUoXG4gICAgICAgIEFwcFxuICAgICAgKX0uZ2V0SW5pdGlhbFByb3BzKClcIiBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAtIHZpc2l0IGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2dldC1pbml0aWFsLXByb3BzLWFzLWFuLWluc3RhbmNlLW1ldGhvZCBmb3IgbW9yZSBpbmZvcm1hdGlvbi5gXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gIH1cbiAgLy8gd2hlbiBjYWxsZWQgZnJvbSBfYXBwIGBjdHhgIGlzIG5lc3RlZCBpbiBgY3R4YFxuICBjb25zdCByZXMgPSBjdHgucmVzIHx8IChjdHguY3R4ICYmIGN0eC5jdHgucmVzKVxuXG4gIGlmICghQXBwLmdldEluaXRpYWxQcm9wcykge1xuICAgIGlmIChjdHguY3R4ICYmIGN0eC5Db21wb25lbnQpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgcGFnZVByb3BzIGRlZmF1bHRcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhZ2VQcm9wczogYXdhaXQgbG9hZEdldEluaXRpYWxQcm9wcyhjdHguQ29tcG9uZW50LCBjdHguY3R4KSxcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9IGFzIElQXG4gIH1cblxuICBjb25zdCBwcm9wcyA9IGF3YWl0IEFwcC5nZXRJbml0aWFsUHJvcHMoY3R4KVxuXG4gIGlmIChyZXMgJiYgaXNSZXNTZW50KHJlcykpIHtcbiAgICByZXR1cm4gcHJvcHNcbiAgfVxuXG4gIGlmICghcHJvcHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYFwiJHtnZXREaXNwbGF5TmFtZShcbiAgICAgIEFwcFxuICAgICl9LmdldEluaXRpYWxQcm9wcygpXCIgc2hvdWxkIHJlc29sdmUgdG8gYW4gb2JqZWN0LiBCdXQgZm91bmQgXCIke3Byb3BzfVwiIGluc3RlYWQuYFxuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcHMpLmxlbmd0aCA9PT0gMCAmJiAhY3R4LmN0eCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgJHtnZXREaXNwbGF5TmFtZShcbiAgICAgICAgICBBcHBcbiAgICAgICAgKX0gcmV0dXJuZWQgYW4gZW1wdHkgb2JqZWN0IGZyb20gXFxgZ2V0SW5pdGlhbFByb3BzXFxgLiBUaGlzIGRlLW9wdGltaXplcyBhbmQgcHJldmVudHMgYXV0b21hdGljIHN0YXRpYyBvcHRpbWl6YXRpb24uIGh0dHBzOi8vZXJyLnNoL3ZlcmNlbC9uZXh0LmpzL2VtcHR5LW9iamVjdC1nZXRJbml0aWFsUHJvcHNgXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBjb25zdCB1cmxPYmplY3RLZXlzID0gW1xuICAnYXV0aCcsXG4gICdoYXNoJyxcbiAgJ2hvc3QnLFxuICAnaG9zdG5hbWUnLFxuICAnaHJlZicsXG4gICdwYXRoJyxcbiAgJ3BhdGhuYW1lJyxcbiAgJ3BvcnQnLFxuICAncHJvdG9jb2wnLFxuICAncXVlcnknLFxuICAnc2VhcmNoJyxcbiAgJ3NsYXNoZXMnLFxuXVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0V2l0aFZhbGlkYXRpb24oXG4gIHVybDogVXJsT2JqZWN0LFxuICBvcHRpb25zPzogVVJMRm9ybWF0T3B0aW9uc1xuKTogc3RyaW5nIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgaWYgKHVybCAhPT0gbnVsbCAmJiB0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgT2JqZWN0LmtleXModXJsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgaWYgKHVybE9iamVjdEtleXMuaW5kZXhPZihrZXkpID09PSAtMSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBVbmtub3duIGtleSBwYXNzZWQgdmlhIHVybE9iamVjdCBpbnRvIHVybC5mb3JtYXQ6ICR7a2V5fWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZvcm1hdCh1cmwgYXMgVVJMLCBvcHRpb25zKVxufVxuXG5leHBvcnQgY29uc3QgU1AgPSB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnXG5leHBvcnQgY29uc3QgU1QgPVxuICBTUCAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJ1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gaXNQbGFpbk9iamVjdDtcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICByZXR1cm4geCAmJiAodHlwZW9mIHggPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHgpKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoeCk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzUGxhaW5PYmplY3QuanMubWFwIiwiT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGZvcmJpZEV4dHJhUHJvcHM7XG5cbnZhciBfb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LmFzc2lnbicpO1xuXG52YXIgX29iamVjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vYmplY3QpO1xuXG52YXIgX2hhcyA9IHJlcXVpcmUoJ2hhcycpO1xuXG52YXIgX2hhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oYXMpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNQbGFpbk9iamVjdCcpO1xuXG52YXIgX2lzUGxhaW5PYmplY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaXNQbGFpbk9iamVjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxudmFyIHplcm9XaWR0aFNwYWNlID0gJ1xcdTIwMEInO1xudmFyIHNwZWNpYWxQcm9wZXJ0eSA9ICdwcm9wLXR5cGVzLWV4YWN0OiAnICsgemVyb1dpZHRoU3BhY2U7XG52YXIgc2VtYXBob3JlID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJyA/IFN5bWJvbFsnZm9yJ10oc3BlY2lhbFByb3BlcnR5KSA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovc3BlY2lhbFByb3BlcnR5O1xuXG5mdW5jdGlvbiBicmFuZChmbikge1xuICByZXR1cm4gKDAsIF9vYmplY3QyWydkZWZhdWx0J10pKGZuLCBfZGVmaW5lUHJvcGVydHkoe30sIHNwZWNpYWxQcm9wZXJ0eSwgc2VtYXBob3JlKSk7XG59XG5cbmZ1bmN0aW9uIGlzQnJhbmRlZCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJiYgdmFsdWVbc3BlY2lhbFByb3BlcnR5XSA9PT0gc2VtYXBob3JlO1xufVxuXG5mdW5jdGlvbiBmb3JiaWRFeHRyYVByb3BzKHByb3BUeXBlcykge1xuICBpZiAoISgwLCBfaXNQbGFpbk9iamVjdDJbJ2RlZmF1bHQnXSkocHJvcFR5cGVzKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2dpdmVuIHByb3BUeXBlcyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICB9XG4gIGlmICgoMCwgX2hhczJbJ2RlZmF1bHQnXSkocHJvcFR5cGVzLCBzcGVjaWFsUHJvcGVydHkpICYmICFpc0JyYW5kZWQocHJvcFR5cGVzW3NwZWNpYWxQcm9wZXJ0eV0pKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQWdhaW5zdCBhbGwgb2RkcywgeW91IGNyZWF0ZWQgYSBwcm9wVHlwZSBmb3IgYSBwcm9wIHRoYXQgdXNlcyBib3RoIHRoZSB6ZXJvLXdpZHRoIHNwYWNlIGFuZCBvdXIgY3VzdG9tIHN0cmluZyAtIHdoaWNoLCBzYWRseSwgY29uZmxpY3RzIHdpdGggYHByb3AtdHlwZXMtZXhhY3RgJyk7XG4gIH1cblxuICByZXR1cm4gKDAsIF9vYmplY3QyWydkZWZhdWx0J10pKHt9LCBwcm9wVHlwZXMsIF9kZWZpbmVQcm9wZXJ0eSh7fSwgc3BlY2lhbFByb3BlcnR5LCBicmFuZChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZm9yYmlkVW5rbm93blByb3BzKHByb3BzLCBfLCBjb21wb25lbnROYW1lKSB7XG4gICAgICB2YXIgdW5rbm93blByb3BzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICByZXR1cm4gISgwLCBfaGFzMlsnZGVmYXVsdCddKShwcm9wVHlwZXMsIHByb3ApO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoU3RyaW5nKGNvbXBvbmVudE5hbWUpICsgJzogdW5rbm93biBwcm9wcyBmb3VuZDogJyArIFN0cmluZyh1bmtub3duUHJvcHMuam9pbignLCAnKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcmJpZFVua25vd25Qcm9wcztcbiAgfSgpKSkpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1XCIpKShcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanNcIik7IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbnZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSk7XG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwoKSB7XG4gIHJldHVybiBudWxsO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgZWxlbWVudFR5cGU6IGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICcgKyBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlcikgKyAnIGF0IGluZGV4ICcgKyBpICsgJy4nXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoUmVhY3RJcy5pc0VsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gKF9fd2VicGFja19yZXF1aXJlX18oLyohIGRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1ICovIFwiZGxsLXJlZmVyZW5jZSBkbGxfNTAzMGYzODdkMzI4ZTQ0MTU3ODVcIikpKFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanNcIik7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1XCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qc1wiKTsiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIiwiaW1wb3J0IHsgaXNWYWxpZEVsZW1lbnQsIGNyZWF0ZUVsZW1lbnQsIHVzZVJlZiwgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyLCBjbG9uZUVsZW1lbnQsIHVzZVN0YXRlLCBDaGlsZHJlbiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbmltcG9ydCBjeCBmcm9tICdjbHN4JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyByZW5kZXIgfSBmcm9tICdyZWFjdC1kb20nO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuXG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIHZhciBzb3VyY2VLZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgdmFyIGtleSwgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gaXNOdW0odikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdudW1iZXInICYmICFpc05hTih2KTtcbn1cbmZ1bmN0aW9uIGlzQm9vbCh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Jvb2xlYW4nO1xufVxuZnVuY3Rpb24gaXNTdHIodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnO1xufVxuZnVuY3Rpb24gaXNGbih2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gJ2Z1bmN0aW9uJztcbn1cbmZ1bmN0aW9uIHBhcnNlQ2xhc3NOYW1lKHYpIHtcbiAgcmV0dXJuIGlzU3RyKHYpIHx8IGlzRm4odikgPyB2IDogbnVsbDtcbn1cbmZ1bmN0aW9uIG9iamVjdFZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzVG9hc3RJZCh0b2FzdElkKSB7XG4gIHJldHVybiB0b2FzdElkID09PSAwIHx8IHRvYXN0SWQ7XG59XG5mdW5jdGlvbiBnZXRBdXRvQ2xvc2VEZWxheSh0b2FzdEF1dG9DbG9zZSwgY29udGFpbmVyQXV0b0Nsb3NlKSB7XG4gIHJldHVybiB0b2FzdEF1dG9DbG9zZSA9PT0gZmFsc2UgfHwgaXNOdW0odG9hc3RBdXRvQ2xvc2UpICYmIHRvYXN0QXV0b0Nsb3NlID4gMCA/IHRvYXN0QXV0b0Nsb3NlIDogY29udGFpbmVyQXV0b0Nsb3NlO1xufVxudmFyIGNhblVzZURvbSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5mdW5jdGlvbiBjYW5CZVJlbmRlcmVkKGNvbnRlbnQpIHtcbiAgcmV0dXJuIGlzVmFsaWRFbGVtZW50KGNvbnRlbnQpIHx8IGlzU3RyKGNvbnRlbnQpIHx8IGlzRm4oY29udGVudCkgfHwgaXNOdW0oY29udGVudCk7XG59XG5cbnZhciBQT1NJVElPTiA9IHtcbiAgVE9QX0xFRlQ6ICd0b3AtbGVmdCcsXG4gIFRPUF9SSUdIVDogJ3RvcC1yaWdodCcsXG4gIFRPUF9DRU5URVI6ICd0b3AtY2VudGVyJyxcbiAgQk9UVE9NX0xFRlQ6ICdib3R0b20tbGVmdCcsXG4gIEJPVFRPTV9SSUdIVDogJ2JvdHRvbS1yaWdodCcsXG4gIEJPVFRPTV9DRU5URVI6ICdib3R0b20tY2VudGVyJ1xufTtcbnZhciBUWVBFID0ge1xuICBJTkZPOiAnaW5mbycsXG4gIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbiAgV0FSTklORzogJ3dhcm5pbmcnLFxuICBFUlJPUjogJ2Vycm9yJyxcbiAgREVGQVVMVDogJ2RlZmF1bHQnLFxuICBEQVJLOiAnZGFyaydcbn07XG5cbi8qKlxyXG4gKiBVc2VkIHRvIGNvbGxhcHNlIHRvYXN0IGFmdGVyIGV4aXQgYW5pbWF0aW9uXHJcbiAqL1xuZnVuY3Rpb24gY29sbGFwc2VUb2FzdChub2RlLCBkb25lLCBkdXJhdGlvblxuLyogQ09MTEFQU0VfRFVSQVRJT04gKi9cbikge1xuICBpZiAoZHVyYXRpb24gPT09IHZvaWQgMCkge1xuICAgIGR1cmF0aW9uID0gMzAwO1xuICB9XG5cbiAgdmFyIGhlaWdodCA9IG5vZGUuc2Nyb2xsSGVpZ2h0O1xuICB2YXIgc3R5bGUgPSBub2RlLnN0eWxlO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIHN0eWxlLm1pbkhlaWdodCA9ICdpbml0aWFsJztcbiAgICBzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIHN0eWxlLnRyYW5zaXRpb24gPSBcImFsbCBcIiArIGR1cmF0aW9uICsgXCJtc1wiO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZS5oZWlnaHQgPSAnMCc7XG4gICAgICBzdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb25lKCk7XG4gICAgICB9LCBkdXJhdGlvbik7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjc3NUcmFuc2l0aW9uKF9yZWYpIHtcbiAgdmFyIGVudGVyID0gX3JlZi5lbnRlcixcbiAgICAgIGV4aXQgPSBfcmVmLmV4aXQsXG4gICAgICBfcmVmJGR1cmF0aW9uID0gX3JlZi5kdXJhdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX3JlZiRkdXJhdGlvbiA9PT0gdm9pZCAwID8gNzUwIDogX3JlZiRkdXJhdGlvbixcbiAgICAgIF9yZWYkYXBwZW5kUG9zaXRpb24gPSBfcmVmLmFwcGVuZFBvc2l0aW9uLFxuICAgICAgYXBwZW5kUG9zaXRpb24gPSBfcmVmJGFwcGVuZFBvc2l0aW9uID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkYXBwZW5kUG9zaXRpb24sXG4gICAgICBfcmVmJGNvbGxhcHNlID0gX3JlZi5jb2xsYXBzZSxcbiAgICAgIGNvbGxhcHNlID0gX3JlZiRjb2xsYXBzZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9yZWYkY29sbGFwc2UsXG4gICAgICBfcmVmJGNvbGxhcHNlRHVyYXRpb24gPSBfcmVmLmNvbGxhcHNlRHVyYXRpb24sXG4gICAgICBjb2xsYXBzZUR1cmF0aW9uID0gX3JlZiRjb2xsYXBzZUR1cmF0aW9uID09PSB2b2lkIDAgPyAzMDAgOiBfcmVmJGNvbGxhcHNlRHVyYXRpb247XG4gIHZhciBlbnRlckR1cmF0aW9uLCBleGl0RHVyYXRpb247XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoZHVyYXRpb24pICYmIGR1cmF0aW9uLmxlbmd0aCA9PT0gMikge1xuICAgIGVudGVyRHVyYXRpb24gPSBkdXJhdGlvblswXTtcbiAgICBleGl0RHVyYXRpb24gPSBkdXJhdGlvblsxXTtcbiAgfSBlbHNlIHtcbiAgICBlbnRlckR1cmF0aW9uID0gZXhpdER1cmF0aW9uID0gZHVyYXRpb247XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gVG9hc3RUcmFuc2l0aW9uKF9yZWYyKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gX3JlZjIuY2hpbGRyZW4sXG4gICAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICAgIHByZXZlbnRFeGl0VHJhbnNpdGlvbiA9IF9yZWYyLnByZXZlbnRFeGl0VHJhbnNpdGlvbixcbiAgICAgICAgZG9uZSA9IF9yZWYyLmRvbmUsXG4gICAgICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjIsIFtcImNoaWxkcmVuXCIsIFwicG9zaXRpb25cIiwgXCJwcmV2ZW50RXhpdFRyYW5zaXRpb25cIiwgXCJkb25lXCJdKTtcblxuICAgIHZhciBlbnRlckNsYXNzTmFtZSA9IGFwcGVuZFBvc2l0aW9uID8gZW50ZXIgKyBcIi0tXCIgKyBwb3NpdGlvbiA6IGVudGVyO1xuICAgIHZhciBleGl0Q2xhc3NOYW1lID0gYXBwZW5kUG9zaXRpb24gPyBleGl0ICsgXCItLVwiICsgcG9zaXRpb24gOiBleGl0O1xuXG4gICAgdmFyIG9uRW50ZXIgPSBmdW5jdGlvbiBvbkVudGVyKCkge1xuICAgICAgdmFyIG5vZGUgPSBwcm9wcy5ub2RlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChlbnRlckNsYXNzTmFtZSk7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uRmlsbE1vZGUgPSAnZm9yd2FyZHMnO1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbkR1cmF0aW9uID0gZW50ZXJEdXJhdGlvbiArIFwibXNcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIG9uRW50ZXJlZCA9IGZ1bmN0aW9uIG9uRW50ZXJlZCgpIHtcbiAgICAgIHZhciBub2RlID0gcHJvcHMubm9kZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoZW50ZXJDbGFzc05hbWUpO1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdhbmltYXRpb25GaWxsTW9kZScpO1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KCdhbmltYXRpb25EdXJhdGlvbicpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb25FeGl0ZWQgPSBmdW5jdGlvbiBvbkV4aXRlZCgpIHtcbiAgICAgIHZhciBub2RlID0gcHJvcHMubm9kZVJlZi5jdXJyZW50O1xuXG4gICAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIG9uRXhpdGVkKTtcbiAgICAgICAgY29sbGFwc2UgPyBjb2xsYXBzZVRvYXN0KG5vZGUsIGRvbmUsIGNvbGxhcHNlRHVyYXRpb24pIDogZG9uZSgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgb25FeGl0ID0gZnVuY3Rpb24gb25FeGl0KCkge1xuICAgICAgdmFyIG5vZGUgPSBwcm9wcy5ub2RlUmVmLmN1cnJlbnQ7XG5cbiAgICAgIGlmIChub2RlKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChleGl0Q2xhc3NOYW1lKTtcbiAgICAgICAgbm9kZS5zdHlsZS5hbmltYXRpb25GaWxsTW9kZSA9ICdmb3J3YXJkcyc7XG4gICAgICAgIG5vZGUuc3R5bGUuYW5pbWF0aW9uRHVyYXRpb24gPSBleGl0RHVyYXRpb24gKyBcIm1zXCI7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgb25FeGl0ZWQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uLCBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgdGltZW91dDogcHJldmVudEV4aXRUcmFuc2l0aW9uID8gY29sbGFwc2UgPyBjb2xsYXBzZUR1cmF0aW9uIDogNTBcbiAgICAgIC8qIERFQk9VTkNFX0RVUkFUSU9OICovXG4gICAgICA6IHtcbiAgICAgICAgZW50ZXI6IGVudGVyRHVyYXRpb24sXG4gICAgICAgIGV4aXQ6IGNvbGxhcHNlID8gZXhpdER1cmF0aW9uICsgY29sbGFwc2VEdXJhdGlvbiA6IGV4aXREdXJhdGlvbiArIDUwXG4gICAgICAgIC8qIERFQk9VTkNFX0RVUkFUSU9OICovXG5cbiAgICAgIH0sXG4gICAgICBvbkVudGVyOiBvbkVudGVyLFxuICAgICAgb25FbnRlcmVkOiBvbkVudGVyZWQsXG4gICAgICBvbkV4aXQ6IHByZXZlbnRFeGl0VHJhbnNpdGlvbiA/IG9uRXhpdGVkIDogb25FeGl0LFxuICAgICAgdW5tb3VudE9uRXhpdDogdHJ1ZVxuICAgIH0pLCBjaGlsZHJlbik7XG4gIH07XG59XG5cbnZhciBldmVudE1hbmFnZXIgPSB7XG4gIGxpc3Q6IC8qI19fUFVSRV9fKi9uZXcgTWFwKCksXG4gIGVtaXRRdWV1ZTogLyojX19QVVJFX18qL25ldyBNYXAoKSxcbiAgb246IGZ1bmN0aW9uIG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIHRoaXMubGlzdC5oYXMoZXZlbnQpIHx8IHRoaXMubGlzdC5zZXQoZXZlbnQsIFtdKTtcbiAgICB0aGlzLmxpc3QuZ2V0KGV2ZW50KS5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgb2ZmOiBmdW5jdGlvbiBvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB2YXIgY2IgPSB0aGlzLmxpc3QuZ2V0KGV2ZW50KS5maWx0ZXIoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgIHJldHVybiBjYiAhPT0gY2FsbGJhY2s7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubGlzdC5zZXQoZXZlbnQsIGNiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGlzdFtcImRlbGV0ZVwiXShldmVudCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGNhbmNlbEVtaXQ6IGZ1bmN0aW9uIGNhbmNlbEVtaXQoZXZlbnQpIHtcbiAgICB2YXIgdGltZXJzID0gdGhpcy5lbWl0UXVldWUuZ2V0KGV2ZW50KTtcblxuICAgIGlmICh0aW1lcnMpIHtcbiAgICAgIHRpbWVycy5mb3JFYWNoKGZ1bmN0aW9uICh0aW1lcikge1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0UXVldWVbXCJkZWxldGVcIl0oZXZlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEVucXVldWUgdGhlIGV2ZW50IGF0IHRoZSBlbmQgb2YgdGhlIGNhbGwgc3RhY2tcclxuICAgKiBEb2luZyBzbyBsZXQgdGhlIHVzZXIgY2FsbCB0b2FzdCBhcyBmb2xsb3c6XHJcbiAgICogdG9hc3QoJzEnKVxyXG4gICAqIHRvYXN0KCcyJylcclxuICAgKiB0b2FzdCgnMycpXHJcbiAgICogV2l0aG91dCBzZXRUaW1lbW91dCB0aGUgY29kZSBhYm92ZSB3aWxsIG5vdCB3b3JrXHJcbiAgICovXG4gIGVtaXQ6IGZ1bmN0aW9uIGVtaXQoZXZlbnQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5saXN0LmhhcyhldmVudCkgJiYgdGhpcy5saXN0LmdldChldmVudCkuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJncyk7XG4gICAgICB9LCAwKTtcbiAgICAgIF90aGlzLmVtaXRRdWV1ZS5oYXMoZXZlbnQpIHx8IF90aGlzLmVtaXRRdWV1ZS5zZXQoZXZlbnQsIFtdKTtcblxuICAgICAgX3RoaXMuZW1pdFF1ZXVlLmdldChldmVudCkucHVzaCh0aW1lcik7XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBgdXNlS2VlcGVyYCBpcyBhIGhlbHBlciBhcm91bmQgYHVzZVJlZmAuXHJcbiAqXHJcbiAqIFlvdSBkb24ndCBuZWVkIHRvIGFjY2VzcyB0aGUgYC5jdXJyZW50YHByb3BlcnR5IHRvIGdldCB0aGUgdmFsdWVcclxuICogSWYgcmVmcmVzaCBpcyBzZXQgdG8gdHJ1ZS4gVGhlIHJlZiB3aWxsIGJlIHVwZGF0ZWQgZXZlcnkgcmVuZGVyXHJcbiAqL1xuXG5mdW5jdGlvbiB1c2VLZWVwZXIoYXJnLCByZWZyZXNoKSB7XG4gIGlmIChyZWZyZXNoID09PSB2b2lkIDApIHtcbiAgICByZWZyZXNoID0gZmFsc2U7XG4gIH1cblxuICB2YXIgcmVmID0gdXNlUmVmKGFyZyk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHJlZnJlc2gpIHJlZi5jdXJyZW50ID0gYXJnO1xuICB9KTtcbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiByZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgJ0FERCc6XG4gICAgICByZXR1cm4gW10uY29uY2F0KHN0YXRlLCBbYWN0aW9uLnRvYXN0SWRdKS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAhPT0gYWN0aW9uLnN0YWxlSWQ7XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ1JFTU9WRSc6XG4gICAgICByZXR1cm4gaGFzVG9hc3RJZChhY3Rpb24udG9hc3RJZCkgPyBzdGF0ZS5maWx0ZXIoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiBpZCAhPT0gYWN0aW9uLnRvYXN0SWQ7XG4gICAgICB9KSA6IFtdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVzZVRvYXN0Q29udGFpbmVyKHByb3BzKSB7XG4gIHZhciBfdXNlUmVkdWNlciA9IHVzZVJlZHVjZXIoZnVuY3Rpb24gKHgpIHtcbiAgICByZXR1cm4geCArIDE7XG4gIH0sIDApLFxuICAgICAgZm9yY2VVcGRhdGUgPSBfdXNlUmVkdWNlclsxXTtcblxuICB2YXIgX3VzZVJlZHVjZXIyID0gdXNlUmVkdWNlcihyZWR1Y2VyLCBbXSksXG4gICAgICB0b2FzdCA9IF91c2VSZWR1Y2VyMlswXSxcbiAgICAgIGRpc3BhdGNoID0gX3VzZVJlZHVjZXIyWzFdO1xuXG4gIHZhciBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciB0b2FzdENvdW50ID0gdXNlS2VlcGVyKDApO1xuICB2YXIgcXVldWUgPSB1c2VLZWVwZXIoW10pO1xuICB2YXIgY29sbGVjdGlvbiA9IHVzZUtlZXBlcih7fSk7XG4gIHZhciBpbnN0YW5jZSA9IHVzZUtlZXBlcih7XG4gICAgdG9hc3RLZXk6IDEsXG4gICAgZGlzcGxheWVkVG9hc3Q6IDAsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIGNvbnRhaW5lcklkOiBudWxsLFxuICAgIGlzVG9hc3RBY3RpdmU6IGlzVG9hc3RBY3RpdmUsXG4gICAgZ2V0VG9hc3Q6IGZ1bmN0aW9uIGdldFRvYXN0KGlkKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbltpZF0gfHwgbnVsbDtcbiAgICB9XG4gIH0pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLmNvbnRhaW5lcklkID0gcHJvcHMuY29udGFpbmVySWQ7XG4gICAgZXZlbnRNYW5hZ2VyLmNhbmNlbEVtaXQoM1xuICAgIC8qIFdpbGxVbm1vdW50ICovXG4gICAgKS5vbigwXG4gICAgLyogU2hvdyAqL1xuICAgICwgYnVpbGRUb2FzdCkub24oMVxuICAgIC8qIENsZWFyICovXG4gICAgLCBmdW5jdGlvbiAodG9hc3RJZCkge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lclJlZi5jdXJyZW50ICYmIHJlbW92ZVRvYXN0KHRvYXN0SWQpO1xuICAgIH0pLm9uKDVcbiAgICAvKiBDbGVhcldhaXRpbmdRdWV1ZSAqL1xuICAgICwgY2xlYXJXYWl0aW5nUXVldWUpLmVtaXQoMlxuICAgIC8qIERpZE1vdW50ICovXG4gICAgLCBpbnN0YW5jZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBldmVudE1hbmFnZXIuZW1pdCgzXG4gICAgICAvKiBXaWxsVW5tb3VudCAqL1xuICAgICAgLCBpbnN0YW5jZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGluc3RhbmNlLmlzVG9hc3RBY3RpdmUgPSBpc1RvYXN0QWN0aXZlO1xuICAgIGluc3RhbmNlLmRpc3BsYXllZFRvYXN0ID0gdG9hc3QubGVuZ3RoO1xuICAgIGV2ZW50TWFuYWdlci5lbWl0KDRcbiAgICAvKiBDaGFuZ2UgKi9cbiAgICAsIHRvYXN0Lmxlbmd0aCwgcHJvcHMuY29udGFpbmVySWQpO1xuICB9LCBbdG9hc3RdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICB9KTtcblxuICBmdW5jdGlvbiBpc1RvYXN0QWN0aXZlKGlkKSB7XG4gICAgcmV0dXJuIHRvYXN0LmluZGV4T2YoaWQpICE9PSAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FpdGluZ1F1ZXVlKF9yZWYpIHtcbiAgICB2YXIgY29udGFpbmVySWQgPSBfcmVmLmNvbnRhaW5lcklkO1xuICAgIHZhciBfaW5zdGFuY2UkcHJvcHMgPSBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgbGltaXQgPSBfaW5zdGFuY2UkcHJvcHMubGltaXQsXG4gICAgICAgIGVuYWJsZU11bHRpQ29udGFpbmVyID0gX2luc3RhbmNlJHByb3BzLmVuYWJsZU11bHRpQ29udGFpbmVyO1xuXG4gICAgaWYgKGxpbWl0ICYmICghY29udGFpbmVySWQgfHwgaW5zdGFuY2UuY29udGFpbmVySWQgPT09IGNvbnRhaW5lcklkICYmIGVuYWJsZU11bHRpQ29udGFpbmVyKSkge1xuICAgICAgdG9hc3RDb3VudCAtPSBxdWV1ZS5sZW5ndGg7XG4gICAgICBxdWV1ZSA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVRvYXN0KHRvYXN0SWQpIHtcbiAgICB2YXIgcXVldWVMZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgdG9hc3RDb3VudCA9IGhhc1RvYXN0SWQodG9hc3RJZCkgPyB0b2FzdENvdW50IC0gMSA6IHRvYXN0Q291bnQgLSBpbnN0YW5jZS5kaXNwbGF5ZWRUb2FzdDtcbiAgICBpZiAodG9hc3RDb3VudCA8IDApIHRvYXN0Q291bnQgPSAwO1xuXG4gICAgaWYgKHF1ZXVlTGVuID4gMCkge1xuICAgICAgdmFyIGZyZWVTbG90ID0gaGFzVG9hc3RJZCh0b2FzdElkKSA/IDEgOiBpbnN0YW5jZS5wcm9wcy5saW1pdDtcblxuICAgICAgaWYgKHF1ZXVlTGVuID09PSAxIHx8IGZyZWVTbG90ID09PSAxKSB7XG4gICAgICAgIGluc3RhbmNlLmRpc3BsYXllZFRvYXN0Kys7XG4gICAgICAgIGRlcXVldWVUb2FzdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRvRGVxdWV1ZSA9IGZyZWVTbG90ID4gcXVldWVMZW4gPyBxdWV1ZUxlbiA6IGZyZWVTbG90O1xuICAgICAgICBpbnN0YW5jZS5kaXNwbGF5ZWRUb2FzdCA9IHRvRGVxdWV1ZTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvRGVxdWV1ZTsgaSsrKSB7XG4gICAgICAgICAgZGVxdWV1ZVRvYXN0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNwYXRjaCh7XG4gICAgICB0eXBlOiAnUkVNT1ZFJyxcbiAgICAgIHRvYXN0SWQ6IHRvYXN0SWRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlcXVldWVUb2FzdCgpIHtcbiAgICB2YXIgX3F1ZXVlJHNoaWZ0ID0gcXVldWUuc2hpZnQoKSxcbiAgICAgICAgdG9hc3RDb250ZW50ID0gX3F1ZXVlJHNoaWZ0LnRvYXN0Q29udGVudCxcbiAgICAgICAgdG9hc3RQcm9wcyA9IF9xdWV1ZSRzaGlmdC50b2FzdFByb3BzLFxuICAgICAgICBzdGFsZUlkID0gX3F1ZXVlJHNoaWZ0LnN0YWxlSWQ7IC8vIGVuc3VyZSB0aGF0IGV4aXQgdHJhbnNpdGlvbiBoYXMgYmVlbiBjb21wbGV0ZWQsIGhlbmNlIHRoZSB0aW1lb3V0XG5cblxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgYXBwZW5kVG9hc3QodG9hc3RDb250ZW50LCB0b2FzdFByb3BzLCBzdGFsZUlkKTtcbiAgICB9LCA1MDApO1xuICB9XG4gIC8qKlxyXG4gICAqIGNoZWNrIGlmIGEgY29udGFpbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBkb21cclxuICAgKiBjaGVjayBmb3IgbXVsdGktY29udGFpbmVyLCBidWlsZCBvbmx5IGlmIGFzc29jaWF0ZWRcclxuICAgKiBjaGVjayBmb3IgZHVwbGljYXRlIHRvYXN0SWQgaWYgbm8gdXBkYXRlXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBpc05vdFZhbGlkKF9yZWYyKSB7XG4gICAgdmFyIGNvbnRhaW5lcklkID0gX3JlZjIuY29udGFpbmVySWQsXG4gICAgICAgIHRvYXN0SWQgPSBfcmVmMi50b2FzdElkLFxuICAgICAgICB1cGRhdGVJZCA9IF9yZWYyLnVwZGF0ZUlkO1xuICAgIHJldHVybiAhY29udGFpbmVyUmVmLmN1cnJlbnQgfHwgaW5zdGFuY2UucHJvcHMuZW5hYmxlTXVsdGlDb250YWluZXIgJiYgY29udGFpbmVySWQgIT09IGluc3RhbmNlLnByb3BzLmNvbnRhaW5lcklkIHx8IGluc3RhbmNlLmlzVG9hc3RBY3RpdmUodG9hc3RJZCkgJiYgdXBkYXRlSWQgPT0gbnVsbCA/IHRydWUgOiBmYWxzZTtcbiAgfSAvLyB0aGlzIGZ1bmN0aW9uIGFuZCBhbGwgdGhlIGZ1bmN0aW9uIGNhbGxlZCBpbnNpZGUgbmVlZHMgdG8gcmVseSBvbiByZWYoYHVzZUtlZXBlcmApXG5cblxuICBmdW5jdGlvbiBidWlsZFRvYXN0KGNvbnRlbnQsIF9yZWYzKSB7XG4gICAgdmFyIGRlbGF5ID0gX3JlZjMuZGVsYXksXG4gICAgICAgIHN0YWxlSWQgPSBfcmVmMy5zdGFsZUlkLFxuICAgICAgICBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3JlZjMsIFtcImRlbGF5XCIsIFwic3RhbGVJZFwiXSk7XG5cbiAgICBpZiAoIWNhbkJlUmVuZGVyZWQoY29udGVudCkgfHwgaXNOb3RWYWxpZChvcHRpb25zKSkgcmV0dXJuO1xuICAgIHZhciB0b2FzdElkID0gb3B0aW9ucy50b2FzdElkLFxuICAgICAgICB1cGRhdGVJZCA9IG9wdGlvbnMudXBkYXRlSWQ7XG4gICAgdmFyIHByb3BzID0gaW5zdGFuY2UucHJvcHMsXG4gICAgICAgIGlzVG9hc3RBY3RpdmUgPSBpbnN0YW5jZS5pc1RvYXN0QWN0aXZlO1xuXG4gICAgdmFyIGNsb3NlVG9hc3QgPSBmdW5jdGlvbiBjbG9zZVRvYXN0KCkge1xuICAgICAgcmV0dXJuIHJlbW92ZVRvYXN0KHRvYXN0SWQpO1xuICAgIH07XG5cbiAgICB2YXIgaXNOb3RBblVwZGF0ZSA9ICFpc1RvYXN0QWN0aXZlKHRvYXN0SWQpO1xuICAgIGlmIChpc05vdEFuVXBkYXRlKSB0b2FzdENvdW50Kys7XG4gICAgdmFyIHRvYXN0UHJvcHMgPSB7XG4gICAgICB0b2FzdElkOiB0b2FzdElkLFxuICAgICAgdXBkYXRlSWQ6IHVwZGF0ZUlkLFxuICAgICAga2V5OiBvcHRpb25zLmtleSB8fCBpbnN0YW5jZS50b2FzdEtleSsrLFxuICAgICAgdHlwZTogb3B0aW9ucy50eXBlLFxuICAgICAgY2xvc2VUb2FzdDogY2xvc2VUb2FzdCxcbiAgICAgIGNsb3NlQnV0dG9uOiBvcHRpb25zLmNsb3NlQnV0dG9uLFxuICAgICAgcnRsOiBwcm9wcy5ydGwsXG4gICAgICBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbiB8fCBwcm9wcy5wb3NpdGlvbixcbiAgICAgIHRyYW5zaXRpb246IG9wdGlvbnMudHJhbnNpdGlvbiB8fCBwcm9wcy50cmFuc2l0aW9uLFxuICAgICAgY2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZShvcHRpb25zLmNsYXNzTmFtZSB8fCBwcm9wcy50b2FzdENsYXNzTmFtZSksXG4gICAgICBib2R5Q2xhc3NOYW1lOiBwYXJzZUNsYXNzTmFtZShvcHRpb25zLmJvZHlDbGFzc05hbWUgfHwgcHJvcHMuYm9keUNsYXNzTmFtZSksXG4gICAgICBzdHlsZTogb3B0aW9ucy5zdHlsZSB8fCBwcm9wcy50b2FzdFN0eWxlLFxuICAgICAgYm9keVN0eWxlOiBvcHRpb25zLmJvZHlTdHlsZSB8fCBwcm9wcy5ib2R5U3R5bGUsXG4gICAgICBvbkNsaWNrOiBvcHRpb25zLm9uQ2xpY2sgfHwgcHJvcHMub25DbGljayxcbiAgICAgIHBhdXNlT25Ib3ZlcjogaXNCb29sKG9wdGlvbnMucGF1c2VPbkhvdmVyKSA/IG9wdGlvbnMucGF1c2VPbkhvdmVyIDogcHJvcHMucGF1c2VPbkhvdmVyLFxuICAgICAgcGF1c2VPbkZvY3VzTG9zczogaXNCb29sKG9wdGlvbnMucGF1c2VPbkZvY3VzTG9zcykgPyBvcHRpb25zLnBhdXNlT25Gb2N1c0xvc3MgOiBwcm9wcy5wYXVzZU9uRm9jdXNMb3NzLFxuICAgICAgZHJhZ2dhYmxlOiBpc0Jvb2wob3B0aW9ucy5kcmFnZ2FibGUpID8gb3B0aW9ucy5kcmFnZ2FibGUgOiBwcm9wcy5kcmFnZ2FibGUsXG4gICAgICBkcmFnZ2FibGVQZXJjZW50OiBpc051bShvcHRpb25zLmRyYWdnYWJsZVBlcmNlbnQpID8gb3B0aW9ucy5kcmFnZ2FibGVQZXJjZW50IDogcHJvcHMuZHJhZ2dhYmxlUGVyY2VudCxcbiAgICAgIGNsb3NlT25DbGljazogaXNCb29sKG9wdGlvbnMuY2xvc2VPbkNsaWNrKSA/IG9wdGlvbnMuY2xvc2VPbkNsaWNrIDogcHJvcHMuY2xvc2VPbkNsaWNrLFxuICAgICAgcHJvZ3Jlc3NDbGFzc05hbWU6IHBhcnNlQ2xhc3NOYW1lKG9wdGlvbnMucHJvZ3Jlc3NDbGFzc05hbWUgfHwgcHJvcHMucHJvZ3Jlc3NDbGFzc05hbWUpLFxuICAgICAgcHJvZ3Jlc3NTdHlsZTogb3B0aW9ucy5wcm9ncmVzc1N0eWxlIHx8IHByb3BzLnByb2dyZXNzU3R5bGUsXG4gICAgICBhdXRvQ2xvc2U6IGdldEF1dG9DbG9zZURlbGF5KG9wdGlvbnMuYXV0b0Nsb3NlLCBwcm9wcy5hdXRvQ2xvc2UpLFxuICAgICAgaGlkZVByb2dyZXNzQmFyOiBpc0Jvb2wob3B0aW9ucy5oaWRlUHJvZ3Jlc3NCYXIpID8gb3B0aW9ucy5oaWRlUHJvZ3Jlc3NCYXIgOiBwcm9wcy5oaWRlUHJvZ3Jlc3NCYXIsXG4gICAgICBwcm9ncmVzczogb3B0aW9ucy5wcm9ncmVzcyxcbiAgICAgIHJvbGU6IGlzU3RyKG9wdGlvbnMucm9sZSkgPyBvcHRpb25zLnJvbGUgOiBwcm9wcy5yb2xlLFxuICAgICAgZGVsZXRlVG9hc3Q6IGZ1bmN0aW9uIGRlbGV0ZVRvYXN0KCkge1xuICAgICAgICByZW1vdmVGcm9tQ29sbGVjdGlvbih0b2FzdElkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0ZuKG9wdGlvbnMub25PcGVuKSkgdG9hc3RQcm9wcy5vbk9wZW4gPSBvcHRpb25zLm9uT3BlbjtcbiAgICBpZiAoaXNGbihvcHRpb25zLm9uQ2xvc2UpKSB0b2FzdFByb3BzLm9uQ2xvc2UgPSBvcHRpb25zLm9uQ2xvc2U7XG4gICAgdmFyIGNsb3NlQnV0dG9uID0gcHJvcHMuY2xvc2VCdXR0b247XG5cbiAgICBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbiA9PT0gZmFsc2UgfHwgY2FuQmVSZW5kZXJlZChvcHRpb25zLmNsb3NlQnV0dG9uKSkge1xuICAgICAgY2xvc2VCdXR0b24gPSBvcHRpb25zLmNsb3NlQnV0dG9uO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5jbG9zZUJ1dHRvbiA9PT0gdHJ1ZSkge1xuICAgICAgY2xvc2VCdXR0b24gPSBjYW5CZVJlbmRlcmVkKHByb3BzLmNsb3NlQnV0dG9uKSA/IHByb3BzLmNsb3NlQnV0dG9uIDogdHJ1ZTtcbiAgICB9XG5cbiAgICB0b2FzdFByb3BzLmNsb3NlQnV0dG9uID0gY2xvc2VCdXR0b247XG4gICAgdmFyIHRvYXN0Q29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY29udGVudCkgJiYgIWlzU3RyKGNvbnRlbnQudHlwZSkpIHtcbiAgICAgIHRvYXN0Q29udGVudCA9IGNsb25lRWxlbWVudChjb250ZW50LCB7XG4gICAgICAgIGNsb3NlVG9hc3Q6IGNsb3NlVG9hc3QsXG4gICAgICAgIHRvYXN0UHJvcHM6IHRvYXN0UHJvcHNcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNGbihjb250ZW50KSkge1xuICAgICAgdG9hc3RDb250ZW50ID0gY29udGVudCh7XG4gICAgICAgIGNsb3NlVG9hc3Q6IGNsb3NlVG9hc3QsXG4gICAgICAgIHRvYXN0UHJvcHM6IHRvYXN0UHJvcHNcbiAgICAgIH0pO1xuICAgIH0gLy8gbm90IGhhbmRsaW5nIGxpbWl0ICsgZGVsYXkgYnkgZGVzaWduLiBXYWl0aW5nIGZvciB1c2VyIGZlZWRiYWNrIGZpcnN0XG5cblxuICAgIGlmIChwcm9wcy5saW1pdCAmJiBwcm9wcy5saW1pdCA+IDAgJiYgdG9hc3RDb3VudCA+IHByb3BzLmxpbWl0ICYmIGlzTm90QW5VcGRhdGUpIHtcbiAgICAgIHF1ZXVlLnB1c2goe1xuICAgICAgICB0b2FzdENvbnRlbnQ6IHRvYXN0Q29udGVudCxcbiAgICAgICAgdG9hc3RQcm9wczogdG9hc3RQcm9wcyxcbiAgICAgICAgc3RhbGVJZDogc3RhbGVJZFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc051bShkZWxheSkgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYXBwZW5kVG9hc3QodG9hc3RDb250ZW50LCB0b2FzdFByb3BzLCBzdGFsZUlkKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kVG9hc3QodG9hc3RDb250ZW50LCB0b2FzdFByb3BzLCBzdGFsZUlkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRUb2FzdChjb250ZW50LCB0b2FzdFByb3BzLCBzdGFsZUlkKSB7XG4gICAgdmFyIHRvYXN0SWQgPSB0b2FzdFByb3BzLnRvYXN0SWQ7XG4gICAgY29sbGVjdGlvblt0b2FzdElkXSA9IHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICBwcm9wczogdG9hc3RQcm9wc1xuICAgIH07XG4gICAgZGlzcGF0Y2goe1xuICAgICAgdHlwZTogJ0FERCcsXG4gICAgICB0b2FzdElkOiB0b2FzdElkLFxuICAgICAgc3RhbGVJZDogc3RhbGVJZFxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUNvbGxlY3Rpb24odG9hc3RJZCkge1xuICAgIGRlbGV0ZSBjb2xsZWN0aW9uW3RvYXN0SWRdO1xuICAgIGZvcmNlVXBkYXRlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUb2FzdFRvUmVuZGVyKGNiKSB7XG4gICAgdmFyIHRvYXN0VG9SZW5kZXIgPSB7fTtcbiAgICB2YXIgdG9hc3RMaXN0ID0gcHJvcHMubmV3ZXN0T25Ub3AgPyBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKS5yZXZlcnNlKCkgOiBPYmplY3Qua2V5cyhjb2xsZWN0aW9uKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9hc3RMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgX3RvYXN0ID0gY29sbGVjdGlvblt0b2FzdExpc3RbaV1dO1xuICAgICAgdmFyIHBvc2l0aW9uID0gX3RvYXN0LnByb3BzLnBvc2l0aW9uO1xuICAgICAgdG9hc3RUb1JlbmRlcltwb3NpdGlvbl0gfHwgKHRvYXN0VG9SZW5kZXJbcG9zaXRpb25dID0gW10pO1xuICAgICAgdG9hc3RUb1JlbmRlcltwb3NpdGlvbl0ucHVzaChfdG9hc3QpO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0b2FzdFRvUmVuZGVyKS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBjYihwLCB0b2FzdFRvUmVuZGVyW3BdKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0VG9hc3RUb1JlbmRlcjogZ2V0VG9hc3RUb1JlbmRlcixcbiAgICBjb2xsZWN0aW9uOiBjb2xsZWN0aW9uLFxuICAgIGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmLFxuICAgIGlzVG9hc3RBY3RpdmU6IGlzVG9hc3RBY3RpdmVcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0WChlKSB7XG4gIHJldHVybiBlLnRhcmdldFRvdWNoZXMgJiYgZS50YXJnZXRUb3VjaGVzLmxlbmd0aCA+PSAxID8gZS50YXJnZXRUb3VjaGVzWzBdLmNsaWVudFggOiBlLmNsaWVudFg7XG59XG5cbmZ1bmN0aW9uIGdldFkoZSkge1xuICByZXR1cm4gZS50YXJnZXRUb3VjaGVzICYmIGUudGFyZ2V0VG91Y2hlcy5sZW5ndGggPj0gMSA/IGUudGFyZ2V0VG91Y2hlc1swXS5jbGllbnRZIDogZS5jbGllbnRZO1xufVxuXG5mdW5jdGlvbiB1c2VUb2FzdChwcm9wcykge1xuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUodHJ1ZSksXG4gICAgICBpc1J1bm5pbmcgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRJc1J1bm5pbmcgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIF91c2VTdGF0ZTIgPSB1c2VTdGF0ZShmYWxzZSksXG4gICAgICBwcmV2ZW50RXhpdFRyYW5zaXRpb24gPSBfdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0UHJldmVudEV4aXRUcmFuc2l0aW9uID0gX3VzZVN0YXRlMlsxXTtcblxuICB2YXIgdG9hc3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gIHZhciBkcmFnID0gdXNlS2VlcGVyKHtcbiAgICBzdGFydDogMCxcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgZGVsdGFYOiAwLFxuICAgIHJlbW92YWxEaXN0YW5jZTogMCxcbiAgICBjYW5DbG9zZU9uQ2xpY2s6IHRydWUsXG4gICAgY2FuRHJhZzogZmFsc2UsXG4gICAgYm91bmRpbmdSZWN0OiBudWxsXG4gIH0pO1xuICB2YXIgc3luY1Byb3BzID0gdXNlS2VlcGVyKHByb3BzLCB0cnVlKTtcbiAgdmFyIGF1dG9DbG9zZSA9IHByb3BzLmF1dG9DbG9zZSxcbiAgICAgIHBhdXNlT25Ib3ZlciA9IHByb3BzLnBhdXNlT25Ib3ZlcixcbiAgICAgIGNsb3NlVG9hc3QgPSBwcm9wcy5jbG9zZVRvYXN0LFxuICAgICAgb25DbGljayA9IHByb3BzLm9uQ2xpY2ssXG4gICAgICBjbG9zZU9uQ2xpY2sgPSBwcm9wcy5jbG9zZU9uQ2xpY2s7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGlzRm4ocHJvcHMub25PcGVuKSkgcHJvcHMub25PcGVuKGlzVmFsaWRFbGVtZW50KHByb3BzLmNoaWxkcmVuKSAmJiBwcm9wcy5jaGlsZHJlbi5wcm9wcyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpc0ZuKHN5bmNQcm9wcy5vbkNsb3NlKSkgc3luY1Byb3BzLm9uQ2xvc2UoaXNWYWxpZEVsZW1lbnQoc3luY1Byb3BzLmNoaWxkcmVuKSAmJiBzeW5jUHJvcHMuY2hpbGRyZW4ucHJvcHMpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBwcm9wcy5kcmFnZ2FibGUgJiYgYmluZERyYWdFdmVudHMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvcHMuZHJhZ2dhYmxlICYmIHVuYmluZERyYWdFdmVudHMoKTtcbiAgICB9O1xuICB9LCBbcHJvcHMuZHJhZ2dhYmxlXSk7XG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcHJvcHMucGF1c2VPbkZvY3VzTG9zcyAmJiBiaW5kRm9jdXNFdmVudHMoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvcHMucGF1c2VPbkZvY3VzTG9zcyAmJiB1bmJpbmRGb2N1c0V2ZW50cygpO1xuICAgIH07XG4gIH0sIFtwcm9wcy5wYXVzZU9uRm9jdXNMb3NzXSk7XG5cbiAgZnVuY3Rpb24gb25EcmFnU3RhcnQoZSkge1xuICAgIHZhciB0b2FzdCA9IHRvYXN0UmVmLmN1cnJlbnQ7XG4gICAgZHJhZy5jYW5DbG9zZU9uQ2xpY2sgPSB0cnVlO1xuICAgIGRyYWcuY2FuRHJhZyA9IHRydWU7XG4gICAgZHJhZy5ib3VuZGluZ1JlY3QgPSB0b2FzdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB0b2FzdC5zdHlsZS50cmFuc2l0aW9uID0gJyc7XG4gICAgZHJhZy5zdGFydCA9IGRyYWcueCA9IGdldFgoZS5uYXRpdmVFdmVudCk7XG4gICAgZHJhZy5yZW1vdmFsRGlzdGFuY2UgPSB0b2FzdC5vZmZzZXRXaWR0aCAqIChwcm9wcy5kcmFnZ2FibGVQZXJjZW50IC8gMTAwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1RyYW5zaXRpb25FbmQoKSB7XG4gICAgaWYgKGRyYWcuYm91bmRpbmdSZWN0KSB7XG4gICAgICB2YXIgX2RyYWckYm91bmRpbmdSZWN0ID0gZHJhZy5ib3VuZGluZ1JlY3QsXG4gICAgICAgICAgdG9wID0gX2RyYWckYm91bmRpbmdSZWN0LnRvcCxcbiAgICAgICAgICBib3R0b20gPSBfZHJhZyRib3VuZGluZ1JlY3QuYm90dG9tLFxuICAgICAgICAgIGxlZnQgPSBfZHJhZyRib3VuZGluZ1JlY3QubGVmdCxcbiAgICAgICAgICByaWdodCA9IF9kcmFnJGJvdW5kaW5nUmVjdC5yaWdodDtcblxuICAgICAgaWYgKHByb3BzLnBhdXNlT25Ib3ZlciAmJiBkcmFnLnggPj0gbGVmdCAmJiBkcmFnLnggPD0gcmlnaHQgJiYgZHJhZy55ID49IHRvcCAmJiBkcmFnLnkgPD0gYm90dG9tKSB7XG4gICAgICAgIHBhdXNlVG9hc3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBsYXlUb2FzdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYXlUb2FzdCgpIHtcbiAgICBzZXRJc1J1bm5pbmcodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXVzZVRvYXN0KCkge1xuICAgIHNldElzUnVubmluZyhmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBiaW5kRm9jdXNFdmVudHMoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgcGxheVRvYXN0KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHBhdXNlVG9hc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5iaW5kRm9jdXNFdmVudHMoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgcGxheVRvYXN0KTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHBhdXNlVG9hc3QpO1xuICB9XG5cbiAgZnVuY3Rpb24gYmluZERyYWdFdmVudHMoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgb25EcmFnTW92ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uRHJhZ0VuZCk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25EcmFnTW92ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvbkRyYWdFbmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gdW5iaW5kRHJhZ0V2ZW50cygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25EcmFnRW5kKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBvbkRyYWdNb3ZlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uRHJhZ0VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRyYWdNb3ZlKGUpIHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIHRvYXN0ID0gdG9hc3RSZWYuY3VycmVudDtcblxuICAgIGlmIChkcmFnLmNhbkRyYWcpIHtcbiAgICAgIGlmIChpc1J1bm5pbmcpIHBhdXNlVG9hc3QoKTtcbiAgICAgIGRyYWcueCA9IGdldFgoZSk7XG4gICAgICBkcmFnLmRlbHRhWCA9IGRyYWcueCAtIGRyYWcuc3RhcnQ7XG4gICAgICBkcmFnLnkgPSBnZXRZKGUpOyAvLyBwcmV2ZW50IGZhbHNlIHBvc2l0aWYgZHVyaW5nIGEgdG9hc3QgY2xpY2tcblxuICAgICAgaWYgKGRyYWcuc3RhcnQgIT09IGRyYWcueCkgZHJhZy5jYW5DbG9zZU9uQ2xpY2sgPSBmYWxzZTtcbiAgICAgIHRvYXN0LnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlWChcIiArIGRyYWcuZGVsdGFYICsgXCJweClcIjtcbiAgICAgIHRvYXN0LnN0eWxlLm9wYWNpdHkgPSBcIlwiICsgKDEgLSBNYXRoLmFicyhkcmFnLmRlbHRhWCAvIGRyYWcucmVtb3ZhbERpc3RhbmNlKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgIHZhciB0b2FzdCA9IHRvYXN0UmVmLmN1cnJlbnQ7XG5cbiAgICBpZiAoZHJhZy5jYW5EcmFnKSB7XG4gICAgICBkcmFnLmNhbkRyYWcgPSBmYWxzZTtcblxuICAgICAgaWYgKE1hdGguYWJzKGRyYWcuZGVsdGFYKSA+IGRyYWcucmVtb3ZhbERpc3RhbmNlKSB7XG4gICAgICAgIHNldFByZXZlbnRFeGl0VHJhbnNpdGlvbih0cnVlKTtcbiAgICAgICAgcHJvcHMuY2xvc2VUb2FzdCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRvYXN0LnN0eWxlLnRyYW5zaXRpb24gPSAndHJhbnNmb3JtIDAuMnMsIG9wYWNpdHkgMC4ycyc7XG4gICAgICB0b2FzdC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgwKSc7XG4gICAgICB0b2FzdC5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudEhhbmRsZXJzID0ge1xuICAgIG9uTW91c2VEb3duOiBvbkRyYWdTdGFydCxcbiAgICBvblRvdWNoU3RhcnQ6IG9uRHJhZ1N0YXJ0LFxuICAgIG9uTW91c2VVcDogb25EcmFnVHJhbnNpdGlvbkVuZCxcbiAgICBvblRvdWNoRW5kOiBvbkRyYWdUcmFuc2l0aW9uRW5kXG4gIH07XG5cbiAgaWYgKGF1dG9DbG9zZSAmJiBwYXVzZU9uSG92ZXIpIHtcbiAgICBldmVudEhhbmRsZXJzLm9uTW91c2VFbnRlciA9IHBhdXNlVG9hc3Q7XG4gICAgZXZlbnRIYW5kbGVycy5vbk1vdXNlTGVhdmUgPSBwbGF5VG9hc3Q7XG4gIH0gLy8gcHJldmVudCB0b2FzdCBmcm9tIGNsb3Npbmcgd2hlbiB1c2VyIGRyYWdzIHRoZSB0b2FzdFxuXG5cbiAgaWYgKGNsb3NlT25DbGljaykge1xuICAgIGV2ZW50SGFuZGxlcnMub25DbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBvbkNsaWNrICYmIG9uQ2xpY2soZSk7XG4gICAgICBkcmFnLmNhbkNsb3NlT25DbGljayAmJiBjbG9zZVRvYXN0KCk7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGxheVRvYXN0OiBwbGF5VG9hc3QsXG4gICAgcGF1c2VUb2FzdDogcGF1c2VUb2FzdCxcbiAgICBpc1J1bm5pbmc6IGlzUnVubmluZyxcbiAgICBwcmV2ZW50RXhpdFRyYW5zaXRpb246IHByZXZlbnRFeGl0VHJhbnNpdGlvbixcbiAgICB0b2FzdFJlZjogdG9hc3RSZWYsXG4gICAgZXZlbnRIYW5kbGVyczogZXZlbnRIYW5kbGVyc1xuICB9O1xufVxuXG5mdW5jdGlvbiBDbG9zZUJ1dHRvbihfcmVmKSB7XG4gIHZhciBjbG9zZVRvYXN0ID0gX3JlZi5jbG9zZVRvYXN0LFxuICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgIF9yZWYkYXJpYUxhYmVsID0gX3JlZi5hcmlhTGFiZWwsXG4gICAgICBhcmlhTGFiZWwgPSBfcmVmJGFyaWFMYWJlbCA9PT0gdm9pZCAwID8gJ2Nsb3NlJyA6IF9yZWYkYXJpYUxhYmVsO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7XG4gICAgY2xhc3NOYW1lOiBcIlRvYXN0aWZ5XCJcbiAgICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICAgKyBcIl9fY2xvc2UtYnV0dG9uIFwiICsgXCJUb2FzdGlmeVwiXG4gICAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICAgICsgXCJfX2Nsb3NlLWJ1dHRvbi0tXCIgKyB0eXBlLFxuICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgb25DbGljazogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgY2xvc2VUb2FzdChlKTtcbiAgICB9LFxuICAgIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWxcbiAgfSwgY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgXCJhcmlhLWhpZGRlblwiOiBcInRydWVcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAxNCAxNlwiXG4gIH0sIGNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNNy43MSA4LjIzbDMuNzUgMy43NS0xLjQ4IDEuNDgtMy43NS0zLjc1LTMuNzUgMy43NUwxIDExLjk4bDMuNzUtMy43NUwxIDQuNDggMi40OCAzbDMuNzUgMy43NUw5Ljk4IDNsMS40OCAxLjQ4LTMuNzUgMy43NXpcIlxuICB9KSkpO1xufVxuXG5mdW5jdGlvbiBQcm9ncmVzc0JhcihfcmVmKSB7XG4gIHZhciBfcmVmMiwgX2FuaW1hdGlvbkV2ZW50O1xuXG4gIHZhciBkZWxheSA9IF9yZWYuZGVsYXksXG4gICAgICBpc1J1bm5pbmcgPSBfcmVmLmlzUnVubmluZyxcbiAgICAgIGNsb3NlVG9hc3QgPSBfcmVmLmNsb3NlVG9hc3QsXG4gICAgICB0eXBlID0gX3JlZi50eXBlLFxuICAgICAgaGlkZSA9IF9yZWYuaGlkZSxcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgdXNlclN0eWxlID0gX3JlZi5zdHlsZSxcbiAgICAgIGNvbnRyb2xsZWRQcm9ncmVzcyA9IF9yZWYuY29udHJvbGxlZFByb2dyZXNzLFxuICAgICAgcHJvZ3Jlc3MgPSBfcmVmLnByb2dyZXNzLFxuICAgICAgcnRsID0gX3JlZi5ydGwsXG4gICAgICBpc0luID0gX3JlZi5pc0luO1xuXG4gIHZhciBzdHlsZSA9IF9leHRlbmRzKHt9LCB1c2VyU3R5bGUsIHtcbiAgICBhbmltYXRpb25EdXJhdGlvbjogZGVsYXkgKyBcIm1zXCIsXG4gICAgYW5pbWF0aW9uUGxheVN0YXRlOiBpc1J1bm5pbmcgPyAncnVubmluZycgOiAncGF1c2VkJyxcbiAgICBvcGFjaXR5OiBoaWRlID8gMCA6IDFcbiAgfSk7XG5cbiAgaWYgKGNvbnRyb2xsZWRQcm9ncmVzcykgc3R5bGUudHJhbnNmb3JtID0gXCJzY2FsZVgoXCIgKyBwcm9ncmVzcyArIFwiKVwiO1xuICB2YXIgZGVmYXVsdENsYXNzQXJyID0gW1wiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3Byb2dyZXNzLWJhclwiLCBjb250cm9sbGVkUHJvZ3Jlc3MgPyBcIlRvYXN0aWZ5XCJcbiAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICArIFwiX19wcm9ncmVzcy1iYXItLWNvbnRyb2xsZWRcIiA6IFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3Byb2dyZXNzLWJhci0tYW5pbWF0ZWRcIiwgXCJUb2FzdGlmeVwiXG4gIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgKyBcIl9fcHJvZ3Jlc3MtYmFyLS1cIiArIHR5cGUsIChfcmVmMiA9IHt9LCBfcmVmMltcIlRvYXN0aWZ5XCJcbiAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICArIFwiX19wcm9ncmVzcy1iYXItLXJ0bFwiXSA9IHJ0bCwgX3JlZjIpXTtcbiAgdmFyIGNsYXNzTmFtZXMgPSBpc0ZuKGNsYXNzTmFtZSkgPyBjbGFzc05hbWUoe1xuICAgIHJ0bDogcnRsLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgZGVmYXVsdENsYXNzTmFtZTogY3guYXBwbHkodm9pZCAwLCBkZWZhdWx0Q2xhc3NBcnIpXG4gIH0pIDogY3guYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoZGVmYXVsdENsYXNzQXJyLCBbY2xhc3NOYW1lXSkpOyAvLyDwn6eQIGNvbnRyb2xsZWRQcm9ncmVzcyBpcyBkZXJpdmVkIGZyb20gcHJvZ3Jlc3NcbiAgLy8gc28gaWYgY29udHJvbGxlZFByb2dyZXNzIGlzIHNldFxuICAvLyBpdCBtZWFucyB0aGF0IHRoaXMgaXMgYWxzbyB0aGUgY2FzZSBmb3IgcHJvZ3Jlc3NcblxuICB2YXIgYW5pbWF0aW9uRXZlbnQgPSAoX2FuaW1hdGlvbkV2ZW50ID0ge30sIF9hbmltYXRpb25FdmVudFtjb250cm9sbGVkUHJvZ3Jlc3MgJiYgcHJvZ3Jlc3MgPj0gMSA/ICdvblRyYW5zaXRpb25FbmQnIDogJ29uQW5pbWF0aW9uRW5kJ10gPSBjb250cm9sbGVkUHJvZ3Jlc3MgJiYgcHJvZ3Jlc3MgPCAxID8gbnVsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICBpc0luICYmIGNsb3NlVG9hc3QoKTtcbiAgfSwgX2FuaW1hdGlvbkV2ZW50KTtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLFxuICAgIHN0eWxlOiBzdHlsZVxuICB9LCBhbmltYXRpb25FdmVudCkpO1xufVxuUHJvZ3Jlc3NCYXIuZGVmYXVsdFByb3BzID0ge1xuICB0eXBlOiBUWVBFLkRFRkFVTFQsXG4gIGhpZGU6IGZhbHNlXG59O1xuXG52YXIgVG9hc3QgPSBmdW5jdGlvbiBUb2FzdChwcm9wcykge1xuICB2YXIgX3JlZjtcblxuICB2YXIgX3VzZVRvYXN0ID0gdXNlVG9hc3QocHJvcHMpLFxuICAgICAgaXNSdW5uaW5nID0gX3VzZVRvYXN0LmlzUnVubmluZyxcbiAgICAgIHByZXZlbnRFeGl0VHJhbnNpdGlvbiA9IF91c2VUb2FzdC5wcmV2ZW50RXhpdFRyYW5zaXRpb24sXG4gICAgICB0b2FzdFJlZiA9IF91c2VUb2FzdC50b2FzdFJlZixcbiAgICAgIGV2ZW50SGFuZGxlcnMgPSBfdXNlVG9hc3QuZXZlbnRIYW5kbGVycztcblxuICB2YXIgY2xvc2VCdXR0b24gPSBwcm9wcy5jbG9zZUJ1dHRvbixcbiAgICAgIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW4sXG4gICAgICBhdXRvQ2xvc2UgPSBwcm9wcy5hdXRvQ2xvc2UsXG4gICAgICBvbkNsaWNrID0gcHJvcHMub25DbGljayxcbiAgICAgIHR5cGUgPSBwcm9wcy50eXBlLFxuICAgICAgaGlkZVByb2dyZXNzQmFyID0gcHJvcHMuaGlkZVByb2dyZXNzQmFyLFxuICAgICAgY2xvc2VUb2FzdCA9IHByb3BzLmNsb3NlVG9hc3QsXG4gICAgICBUcmFuc2l0aW9uID0gcHJvcHMudHJhbnNpdGlvbixcbiAgICAgIHBvc2l0aW9uID0gcHJvcHMucG9zaXRpb24sXG4gICAgICBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgYm9keUNsYXNzTmFtZSA9IHByb3BzLmJvZHlDbGFzc05hbWUsXG4gICAgICBib2R5U3R5bGUgPSBwcm9wcy5ib2R5U3R5bGUsXG4gICAgICBwcm9ncmVzc0NsYXNzTmFtZSA9IHByb3BzLnByb2dyZXNzQ2xhc3NOYW1lLFxuICAgICAgcHJvZ3Jlc3NTdHlsZSA9IHByb3BzLnByb2dyZXNzU3R5bGUsXG4gICAgICB1cGRhdGVJZCA9IHByb3BzLnVwZGF0ZUlkLFxuICAgICAgcm9sZSA9IHByb3BzLnJvbGUsXG4gICAgICBwcm9ncmVzcyA9IHByb3BzLnByb2dyZXNzLFxuICAgICAgcnRsID0gcHJvcHMucnRsLFxuICAgICAgdG9hc3RJZCA9IHByb3BzLnRvYXN0SWQsXG4gICAgICBkZWxldGVUb2FzdCA9IHByb3BzLmRlbGV0ZVRvYXN0O1xuICB2YXIgZGVmYXVsdENsYXNzQXJyID0gW1wiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3RvYXN0XCIsIFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3RvYXN0LS1cIiArIHR5cGUsIChfcmVmID0ge30sIF9yZWZbXCJUb2FzdGlmeVwiXG4gIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgKyBcIl9fdG9hc3QtLXJ0bFwiXSA9IHJ0bCwgX3JlZildO1xuICB2YXIgY3NzQ2xhc3NlcyA9IGlzRm4oY2xhc3NOYW1lKSA/IGNsYXNzTmFtZSh7XG4gICAgcnRsOiBydGwsXG4gICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgZGVmYXVsdENsYXNzTmFtZTogY3guYXBwbHkodm9pZCAwLCBkZWZhdWx0Q2xhc3NBcnIpXG4gIH0pIDogY3guYXBwbHkodm9pZCAwLCBbXS5jb25jYXQoZGVmYXVsdENsYXNzQXJyLCBbY2xhc3NOYW1lXSkpO1xuICB2YXIgY29udHJvbGxlZFByb2dyZXNzID0gISFwcm9ncmVzcztcblxuICBmdW5jdGlvbiByZW5kZXJDbG9zZUJ1dHRvbihjbG9zZUJ1dHRvbikge1xuICAgIGlmICghY2xvc2VCdXR0b24pIHJldHVybjtcbiAgICB2YXIgcHJvcHMgPSB7XG4gICAgICBjbG9zZVRvYXN0OiBjbG9zZVRvYXN0LFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgaWYgKGlzRm4oY2xvc2VCdXR0b24pKSByZXR1cm4gY2xvc2VCdXR0b24ocHJvcHMpO1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChjbG9zZUJ1dHRvbikpIHJldHVybiBjbG9uZUVsZW1lbnQoY2xvc2VCdXR0b24sIHByb3BzKTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVFbGVtZW50KFRyYW5zaXRpb24sIHtcbiAgICBcImluXCI6IHByb3BzW1wiaW5cIl0sXG4gICAgYXBwZWFyOiB0cnVlLFxuICAgIGRvbmU6IGRlbGV0ZVRvYXN0LFxuICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICBwcmV2ZW50RXhpdFRyYW5zaXRpb246IHByZXZlbnRFeGl0VHJhbnNpdGlvbixcbiAgICBub2RlUmVmOiB0b2FzdFJlZlxuICB9LCBjcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIGlkOiB0b2FzdElkLFxuICAgIG9uQ2xpY2s6IG9uQ2xpY2ssXG4gICAgY2xhc3NOYW1lOiBjc3NDbGFzc2VzIHx8IHVuZGVmaW5lZFxuICB9LCBldmVudEhhbmRsZXJzLCB7XG4gICAgc3R5bGU6IHN0eWxlLFxuICAgIHJlZjogdG9hc3RSZWZcbiAgfSksIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7fSwgcHJvcHNbXCJpblwiXSAmJiB7XG4gICAgcm9sZTogcm9sZVxuICB9LCB7XG4gICAgY2xhc3NOYW1lOiBpc0ZuKGJvZHlDbGFzc05hbWUpID8gYm9keUNsYXNzTmFtZSh7XG4gICAgICB0eXBlOiB0eXBlXG4gICAgfSkgOiBjeChcIlRvYXN0aWZ5XCJcbiAgICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICAgKyBcIl9fdG9hc3QtYm9keVwiLCBib2R5Q2xhc3NOYW1lKSxcbiAgICBzdHlsZTogYm9keVN0eWxlXG4gIH0pLCBjaGlsZHJlbiksIHJlbmRlckNsb3NlQnV0dG9uKGNsb3NlQnV0dG9uKSwgKGF1dG9DbG9zZSB8fCBjb250cm9sbGVkUHJvZ3Jlc3MpICYmIGNyZWF0ZUVsZW1lbnQoUHJvZ3Jlc3NCYXIsIE9iamVjdC5hc3NpZ24oe30sIHVwZGF0ZUlkICYmICFjb250cm9sbGVkUHJvZ3Jlc3MgPyB7XG4gICAga2V5OiBcInBiLVwiICsgdXBkYXRlSWRcbiAgfSA6IHt9LCB7XG4gICAgcnRsOiBydGwsXG4gICAgZGVsYXk6IGF1dG9DbG9zZSxcbiAgICBpc1J1bm5pbmc6IGlzUnVubmluZyxcbiAgICBpc0luOiBwcm9wc1tcImluXCJdLFxuICAgIGNsb3NlVG9hc3Q6IGNsb3NlVG9hc3QsXG4gICAgaGlkZTogaGlkZVByb2dyZXNzQmFyLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgc3R5bGU6IHByb2dyZXNzU3R5bGUsXG4gICAgY2xhc3NOYW1lOiBwcm9ncmVzc0NsYXNzTmFtZSxcbiAgICBjb250cm9sbGVkUHJvZ3Jlc3M6IGNvbnRyb2xsZWRQcm9ncmVzcyxcbiAgICBwcm9ncmVzczogcHJvZ3Jlc3NcbiAgfSkpKSk7XG59O1xuXG52YXIgQm91bmNlID0gLyojX19QVVJFX18qL2Nzc1RyYW5zaXRpb24oe1xuICBlbnRlcjogXCJUb2FzdGlmeVwiXG4gIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgKyBcIl9fYm91bmNlLWVudGVyXCIsXG4gIGV4aXQ6IFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX2JvdW5jZS1leGl0XCIsXG4gIGFwcGVuZFBvc2l0aW9uOiB0cnVlXG59KTtcbnZhciBTbGlkZSA9IC8qI19fUFVSRV9fKi9jc3NUcmFuc2l0aW9uKHtcbiAgZW50ZXI6IFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3NsaWRlLWVudGVyXCIsXG4gIGV4aXQ6IFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX3NsaWRlLWV4aXRcIixcbiAgZHVyYXRpb246IFs0NTAsIDc1MF0sXG4gIGFwcGVuZFBvc2l0aW9uOiB0cnVlXG59KTtcbnZhciBab29tID0gLyojX19QVVJFX18qL2Nzc1RyYW5zaXRpb24oe1xuICBlbnRlcjogXCJUb2FzdGlmeVwiXG4gIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgKyBcIl9fem9vbS1lbnRlclwiLFxuICBleGl0OiBcIlRvYXN0aWZ5XCJcbiAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICArIFwiX196b29tLWV4aXRcIlxufSk7XG52YXIgRmxpcCA9IC8qI19fUFVSRV9fKi9jc3NUcmFuc2l0aW9uKHtcbiAgZW50ZXI6IFwiVG9hc3RpZnlcIlxuICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICsgXCJfX2ZsaXAtZW50ZXJcIixcbiAgZXhpdDogXCJUb2FzdGlmeVwiXG4gIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgKyBcIl9fZmxpcC1leGl0XCJcbn0pO1xuXG52YXIgVG9hc3RQb3NpdGlvbmVyID0gZnVuY3Rpb24gVG9hc3RQb3NpdGlvbmVyKF9yZWYpIHtcbiAgdmFyIGNoaWxkcmVuID0gX3JlZi5jaGlsZHJlbixcbiAgICAgIGNsYXNzTmFtZSA9IF9yZWYuY2xhc3NOYW1lLFxuICAgICAgc3R5bGUgPSBfcmVmLnN0eWxlLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwic3R5bGVcIl0pO1xuXG4gIC8vIE1vbmtleSBwYXRjaCByZWFjdC10cmFuc2l0aW9uLWdyb3VwXG4gIC8vIEFzIGV4aXQgdHJhbnNpdGlvbiBpcyBicm9rZW4gd2l0aCBzdHJpY3QgbW9kZVxuICBkZWxldGUgcmVzdFtcImluXCJdO1xuICByZXR1cm4gY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgc3R5bGU6IHN0eWxlXG4gIH0sIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwgcmVzdCk7XG4gIH0pKTtcbn07XG5cbnZhciBUb2FzdENvbnRhaW5lciA9IGZ1bmN0aW9uIFRvYXN0Q29udGFpbmVyKHByb3BzKSB7XG4gIHZhciBfdXNlVG9hc3RDb250YWluZXIgPSB1c2VUb2FzdENvbnRhaW5lcihwcm9wcyksXG4gICAgICBnZXRUb2FzdFRvUmVuZGVyID0gX3VzZVRvYXN0Q29udGFpbmVyLmdldFRvYXN0VG9SZW5kZXIsXG4gICAgICBjb250YWluZXJSZWYgPSBfdXNlVG9hc3RDb250YWluZXIuY29udGFpbmVyUmVmLFxuICAgICAgaXNUb2FzdEFjdGl2ZSA9IF91c2VUb2FzdENvbnRhaW5lci5pc1RvYXN0QWN0aXZlO1xuXG4gIHZhciBjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBzdHlsZSA9IHByb3BzLnN0eWxlLFxuICAgICAgcnRsID0gcHJvcHMucnRsLFxuICAgICAgY29udGFpbmVySWQgPSBwcm9wcy5jb250YWluZXJJZDtcbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgIHJlZjogY29udGFpbmVyUmVmLFxuICAgIGNsYXNzTmFtZTogXCJUb2FzdGlmeVwiXG4gICAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICAgICxcbiAgICBpZDogY29udGFpbmVySWRcbiAgfSwgZ2V0VG9hc3RUb1JlbmRlcihmdW5jdGlvbiAocG9zaXRpb24sIHRvYXN0TGlzdCkge1xuICAgIHZhciBfY3gsIF9jeDI7XG5cbiAgICB2YXIgc3dhZyA9IHtcbiAgICAgIGNsYXNzTmFtZTogaXNGbihjbGFzc05hbWUpID8gY2xhc3NOYW1lKHtcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICBydGw6IHJ0bCxcbiAgICAgICAgZGVmYXVsdENsYXNzTmFtZTogY3goXCJUb2FzdGlmeVwiXG4gICAgICAgIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgICAgICAgKyBcIl9fdG9hc3QtY29udGFpbmVyXCIsIFwiVG9hc3RpZnlcIlxuICAgICAgICAvKiBDU1NfTkFNRVNQQUNFICovXG4gICAgICAgICsgXCJfX3RvYXN0LWNvbnRhaW5lci0tXCIgKyBwb3NpdGlvbiwgKF9jeCA9IHt9LCBfY3hbXCJUb2FzdGlmeVwiXG4gICAgICAgIC8qIENTU19OQU1FU1BBQ0UgKi9cbiAgICAgICAgKyBcIl9fdG9hc3QtY29udGFpbmVyLS1ydGxcIl0gPSBydGwsIF9jeCkpXG4gICAgICB9KSA6IGN4KFwiVG9hc3RpZnlcIlxuICAgICAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICAgICAgKyBcIl9fdG9hc3QtY29udGFpbmVyXCIsIFwiVG9hc3RpZnlcIlxuICAgICAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICAgICAgKyBcIl9fdG9hc3QtY29udGFpbmVyLS1cIiArIHBvc2l0aW9uLCAoX2N4MiA9IHt9LCBfY3gyW1wiVG9hc3RpZnlcIlxuICAgICAgLyogQ1NTX05BTUVTUEFDRSAqL1xuICAgICAgKyBcIl9fdG9hc3QtY29udGFpbmVyLS1ydGxcIl0gPSBydGwsIF9jeDIpLCBwYXJzZUNsYXNzTmFtZShjbGFzc05hbWUpKSxcbiAgICAgIHN0eWxlOiB0b2FzdExpc3QubGVuZ3RoID09PSAwID8gX2V4dGVuZHMoe30sIHN0eWxlLCB7XG4gICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJ1xuICAgICAgfSkgOiBfZXh0ZW5kcyh7fSwgc3R5bGUpXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChUb2FzdFBvc2l0aW9uZXIsIE9iamVjdC5hc3NpZ24oe30sIHN3YWcsIHtcbiAgICAgIGtleTogXCJjb250YWluZXItXCIgKyBwb3NpdGlvblxuICAgIH0pLCB0b2FzdExpc3QubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgY29udGVudCA9IF9yZWYuY29udGVudCxcbiAgICAgICAgICB0b2FzdFByb3BzID0gX3JlZi5wcm9wcztcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFRvYXN0LCBPYmplY3QuYXNzaWduKHt9LCB0b2FzdFByb3BzLCB7XG4gICAgICAgIFwiaW5cIjogaXNUb2FzdEFjdGl2ZSh0b2FzdFByb3BzLnRvYXN0SWQpLFxuICAgICAgICBrZXk6IFwidG9hc3QtXCIgKyB0b2FzdFByb3BzLmtleSxcbiAgICAgICAgY2xvc2VCdXR0b246IHRvYXN0UHJvcHMuY2xvc2VCdXR0b24gPT09IHRydWUgPyBDbG9zZUJ1dHRvbiA6IHRvYXN0UHJvcHMuY2xvc2VCdXR0b25cbiAgICAgIH0pLCBjb250ZW50KTtcbiAgICB9KSk7XG4gIH0pKTtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgVG9hc3RDb250YWluZXIucHJvcFR5cGVzID0ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwb3NpdGlvbjogLyojX19QVVJFX18qL1Byb3BUeXBlcy5vbmVPZiggLyojX19QVVJFX18qL29iamVjdFZhbHVlcyhQT1NJVElPTikpLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhdXRvQ2xvc2U6IC8qI19fUFVSRV9fKi9Qcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLm51bWJlcl0pLFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjbG9zZUJ1dHRvbjogLyojX19QVVJFX18qL1Byb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5ub2RlLCBQcm9wVHlwZXMuYm9vbCwgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICBoaWRlUHJvZ3Jlc3NCYXI6IFByb3BUeXBlcy5ib29sLFxuICAgIHBhdXNlT25Ib3ZlcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xvc2VPbkNsaWNrOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBuZXdlc3RPblRvcDogUHJvcFR5cGVzLmJvb2wsXG4gICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuYW55LFxuICAgIHN0eWxlOiBQcm9wVHlwZXMub2JqZWN0LFxuICAgIHRvYXN0Q2xhc3NOYW1lOiAvKiNfX1BVUkVfXyovUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBib2R5Q2xhc3NOYW1lOiAvKiNfX1BVUkVfXyovUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgICBwcm9ncmVzc0NsYXNzTmFtZTogLyojX19QVVJFX18qL1Byb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gICAgcHJvZ3Jlc3NTdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICB0cmFuc2l0aW9uOiBQcm9wVHlwZXMuZnVuYyxcbiAgICBydGw6IFByb3BUeXBlcy5ib29sLFxuICAgIGRyYWdnYWJsZTogUHJvcFR5cGVzLmJvb2wsXG4gICAgZHJhZ2dhYmxlUGVyY2VudDogUHJvcFR5cGVzLm51bWJlcixcbiAgICBwYXVzZU9uRm9jdXNMb3NzOiBQcm9wVHlwZXMuYm9vbCxcbiAgICBlbmFibGVNdWx0aUNvbnRhaW5lcjogUHJvcFR5cGVzLmJvb2wsXG4gICAgY29udGFpbmVySWQ6IC8qI19fUFVSRV9fKi9Qcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gICAgcm9sZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICBvbkNsaWNrOiBQcm9wVHlwZXMuZnVuY1xuICB9O1xufVxuXG5Ub2FzdENvbnRhaW5lci5kZWZhdWx0UHJvcHMgPSB7XG4gIHBvc2l0aW9uOiBQT1NJVElPTi5UT1BfUklHSFQsXG4gIHRyYW5zaXRpb246IEJvdW5jZSxcbiAgcnRsOiBmYWxzZSxcbiAgYXV0b0Nsb3NlOiA1MDAwLFxuICBoaWRlUHJvZ3Jlc3NCYXI6IGZhbHNlLFxuICBjbG9zZUJ1dHRvbjogQ2xvc2VCdXR0b24sXG4gIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcbiAgcGF1c2VPbkZvY3VzTG9zczogdHJ1ZSxcbiAgY2xvc2VPbkNsaWNrOiB0cnVlLFxuICBuZXdlc3RPblRvcDogZmFsc2UsXG4gIGRyYWdnYWJsZTogdHJ1ZSxcbiAgZHJhZ2dhYmxlUGVyY2VudDogODAsXG4gIHJvbGU6ICdhbGVydCdcbn07XG5cbnZhciBjb250YWluZXJzID0gLyojX19QVVJFX18qL25ldyBNYXAoKTtcbnZhciBsYXRlc3RJbnN0YW5jZTtcbnZhciBjb250YWluZXJEb21Ob2RlO1xudmFyIGNvbnRhaW5lckNvbmZpZztcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGxhenkgPSBmYWxzZTtcbi8qKlxyXG4gKiBDaGVjayB3aGV0aGVyIGFueSBjb250YWluZXIgaXMgY3VycmVudGx5IG1vdW50ZWQgaW4gdGhlIERPTVxyXG4gKi9cblxuZnVuY3Rpb24gaXNBbnlDb250YWluZXJNb3VudGVkKCkge1xuICByZXR1cm4gY29udGFpbmVycy5zaXplID4gMDtcbn1cbi8qKlxyXG4gKiBHZXQgdGhlIGNvbnRhaW5lciBieSBpZC4gUmV0dXJucyB0aGUgbGFzdCBjb250YWluZXIgZGVjbGFyZWQgd2hlbiBubyBpZCBpcyBnaXZlbi5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyKGNvbnRhaW5lcklkKSB7XG4gIGlmICghaXNBbnlDb250YWluZXJNb3VudGVkKCkpIHJldHVybiBudWxsO1xuICByZXR1cm4gY29udGFpbmVycy5nZXQoIWNvbnRhaW5lcklkID8gbGF0ZXN0SW5zdGFuY2UgOiBjb250YWluZXJJZCk7XG59XG4vKipcclxuICogR2V0IHRoZSB0b2FzdCBieSBpZCwgZ2l2ZW4gaXQncyBpbiB0aGUgRE9NLCBvdGhlcndpc2UgcmV0dXJucyBudWxsXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldFRvYXN0KHRvYXN0SWQsIF9yZWYpIHtcbiAgdmFyIGNvbnRhaW5lcklkID0gX3JlZi5jb250YWluZXJJZDtcbiAgdmFyIGNvbnRhaW5lciA9IGdldENvbnRhaW5lcihjb250YWluZXJJZCk7XG4gIGlmICghY29udGFpbmVyKSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIGNvbnRhaW5lci5nZXRUb2FzdCh0b2FzdElkKTtcbn1cbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHJhbmRvbSB0b2FzdElkXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIGdlbmVyYXRlVG9hc3RJZCgpIHtcbiAgcmV0dXJuIChNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KSArIERhdGUubm93KCkudG9TdHJpbmcoMzYpKS5zdWJzdHIoMiwgMTApO1xufVxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgdG9hc3RJZCBvciB1c2UgdGhlIG9uZSBwcm92aWRlZFxyXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRUb2FzdElkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgJiYgKGlzU3RyKG9wdGlvbnMudG9hc3RJZCkgfHwgaXNOdW0ob3B0aW9ucy50b2FzdElkKSkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy50b2FzdElkO1xuICB9XG5cbiAgcmV0dXJuIGdlbmVyYXRlVG9hc3RJZCgpO1xufVxuLyoqXHJcbiAqIElmIHRoZSBjb250YWluZXIgaXMgbm90IG1vdW50ZWQsIHRoZSB0b2FzdCBpcyBlbnF1ZXVlZCBhbmRcclxuICogdGhlIGNvbnRhaW5lciBsYXp5IG1vdW50ZWRcclxuICovXG5cblxuZnVuY3Rpb24gZGlzcGF0Y2hUb2FzdChjb250ZW50LCBvcHRpb25zKSB7XG4gIGlmIChpc0FueUNvbnRhaW5lck1vdW50ZWQoKSkge1xuICAgIGV2ZW50TWFuYWdlci5lbWl0KDBcbiAgICAvKiBTaG93ICovXG4gICAgLCBjb250ZW50LCBvcHRpb25zKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5wdXNoKHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgfSk7XG5cbiAgICBpZiAobGF6eSAmJiBjYW5Vc2VEb20pIHtcbiAgICAgIGxhenkgPSBmYWxzZTtcbiAgICAgIGNvbnRhaW5lckRvbU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29udGFpbmVyRG9tTm9kZSk7XG4gICAgICByZW5kZXIoY3JlYXRlRWxlbWVudChUb2FzdENvbnRhaW5lciwgT2JqZWN0LmFzc2lnbih7fSwgY29udGFpbmVyQ29uZmlnKSksIGNvbnRhaW5lckRvbU5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvcHRpb25zLnRvYXN0SWQ7XG59XG4vKipcclxuICogTWVyZ2UgcHJvdmlkZWQgb3B0aW9ucyB3aXRoIHRoZSBkZWZhdWx0cyBzZXR0aW5ncyBhbmQgZ2VuZXJhdGUgdGhlIHRvYXN0SWRcclxuICovXG5cblxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKHR5cGUsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgdHlwZTogb3B0aW9ucyAmJiBvcHRpb25zLnR5cGUgfHwgdHlwZSxcbiAgICB0b2FzdElkOiBnZXRUb2FzdElkKG9wdGlvbnMpXG4gIH0pO1xufVxuXG52YXIgdG9hc3QgPSBmdW5jdGlvbiB0b2FzdChjb250ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBkaXNwYXRjaFRvYXN0KGNvbnRlbnQsIG1lcmdlT3B0aW9ucyhUWVBFLkRFRkFVTFQsIG9wdGlvbnMpKTtcbn07XG5cbnRvYXN0LnN1Y2Nlc3MgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICByZXR1cm4gZGlzcGF0Y2hUb2FzdChjb250ZW50LCBtZXJnZU9wdGlvbnMoVFlQRS5TVUNDRVNTLCBvcHRpb25zKSk7XG59O1xuXG50b2FzdC5pbmZvID0gZnVuY3Rpb24gKGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGRpc3BhdGNoVG9hc3QoY29udGVudCwgbWVyZ2VPcHRpb25zKFRZUEUuSU5GTywgb3B0aW9ucykpO1xufTtcblxudG9hc3QuZXJyb3IgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICByZXR1cm4gZGlzcGF0Y2hUb2FzdChjb250ZW50LCBtZXJnZU9wdGlvbnMoVFlQRS5FUlJPUiwgb3B0aW9ucykpO1xufTtcblxudG9hc3Qud2FybmluZyA9IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBkaXNwYXRjaFRvYXN0KGNvbnRlbnQsIG1lcmdlT3B0aW9ucyhUWVBFLldBUk5JTkcsIG9wdGlvbnMpKTtcbn07XG5cbnRvYXN0LmRhcmsgPSBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xuICByZXR1cm4gZGlzcGF0Y2hUb2FzdChjb250ZW50LCBtZXJnZU9wdGlvbnMoVFlQRS5EQVJLLCBvcHRpb25zKSk7XG59O1xuLyoqXHJcbiAqIE1heWJlIEkgc2hvdWxkIHJlbW92ZSB3YXJuaW5nIGluIGZhdm9yIG9mIHdhcm4sIEkgZG9uJ3Qga25vd1xyXG4gKi9cblxuXG50b2FzdC53YXJuID0gdG9hc3Qud2FybmluZztcbi8qKlxyXG4gKiBSZW1vdmUgdG9hc3QgcHJvZ3JhbW1hdGljYWx5XHJcbiAqL1xuXG50b2FzdC5kaXNtaXNzID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBpc0FueUNvbnRhaW5lck1vdW50ZWQoKSAmJiBldmVudE1hbmFnZXIuZW1pdCgxXG4gIC8qIENsZWFyICovXG4gICwgaWQpO1xufTtcbi8qKlxyXG4gKiBDbGVhciB3YWl0aW5nIHF1ZXVlIHdoZW4gbGltaXQgaXMgdXNlZFxyXG4gKi9cblxuXG50b2FzdC5jbGVhcldhaXRpbmdRdWV1ZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFyYW1zID0ge307XG4gIH1cblxuICByZXR1cm4gaXNBbnlDb250YWluZXJNb3VudGVkKCkgJiYgZXZlbnRNYW5hZ2VyLmVtaXQoNVxuICAvKiBDbGVhcldhaXRpbmdRdWV1ZSAqL1xuICAsIHBhcmFtcyk7XG59O1xuLyoqXHJcbiAqIHJldHVybiB0cnVlIGlmIG9uZSBjb250YWluZXIgaXMgZGlzcGxheWluZyB0aGUgdG9hc3RcclxuICovXG5cblxudG9hc3QuaXNBY3RpdmUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgdmFyIGlzVG9hc3RBY3RpdmUgPSBmYWxzZTtcbiAgY29udGFpbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICBpZiAoY29udGFpbmVyLmlzVG9hc3RBY3RpdmUgJiYgY29udGFpbmVyLmlzVG9hc3RBY3RpdmUoaWQpKSB7XG4gICAgICBpc1RvYXN0QWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gaXNUb2FzdEFjdGl2ZTtcbn07XG5cbnRvYXN0LnVwZGF0ZSA9IGZ1bmN0aW9uICh0b2FzdElkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICAvLyBpZiB5b3UgY2FsbCB0b2FzdCBhbmQgdG9hc3QudXBkYXRlIGRpcmVjdGx5IG5vdGhpbmcgd2lsbCBiZSBkaXNwbGF5ZWRcbiAgLy8gdGhpcyBpcyB3aHkgSSBkZWZlcmVkIHRoZSB1cGRhdGVcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvYXN0ID0gZ2V0VG9hc3QodG9hc3RJZCwgb3B0aW9ucyk7XG5cbiAgICBpZiAodG9hc3QpIHtcbiAgICAgIHZhciBvbGRPcHRpb25zID0gdG9hc3QucHJvcHMsXG4gICAgICAgICAgb2xkQ29udGVudCA9IHRvYXN0LmNvbnRlbnQ7XG5cbiAgICAgIHZhciBuZXh0T3B0aW9ucyA9IF9leHRlbmRzKHt9LCBvbGRPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgICAgIHRvYXN0SWQ6IG9wdGlvbnMudG9hc3RJZCB8fCB0b2FzdElkLFxuICAgICAgICB1cGRhdGVJZDogZ2VuZXJhdGVUb2FzdElkKClcbiAgICAgIH0pO1xuXG4gICAgICBpZiAobmV4dE9wdGlvbnMudG9hc3RJZCAhPT0gdG9hc3RJZCkgbmV4dE9wdGlvbnMuc3RhbGVJZCA9IHRvYXN0SWQ7XG4gICAgICB2YXIgY29udGVudCA9IHR5cGVvZiBuZXh0T3B0aW9ucy5yZW5kZXIgIT09ICd1bmRlZmluZWQnID8gbmV4dE9wdGlvbnMucmVuZGVyIDogb2xkQ29udGVudDtcbiAgICAgIGRlbGV0ZSBuZXh0T3B0aW9ucy5yZW5kZXI7XG4gICAgICBkaXNwYXRjaFRvYXN0KGNvbnRlbnQsIG5leHRPcHRpb25zKTtcbiAgICB9XG4gIH0sIDApO1xufTtcbi8qKlxyXG4gKiBVc2VkIGZvciBjb250cm9sbGVkIHByb2dyZXNzIGJhci5cclxuICovXG5cblxudG9hc3QuZG9uZSA9IGZ1bmN0aW9uIChpZCkge1xuICB0b2FzdC51cGRhdGUoaWQsIHtcbiAgICBwcm9ncmVzczogMVxuICB9KTtcbn07XG4vKipcclxuICogVHJhY2sgY2hhbmdlcy4gVGhlIGNhbGxiYWNrIGdldCB0aGUgbnVtYmVyIG9mIHRvYXN0IGRpc3BsYXllZFxyXG4gKlxyXG4gKi9cblxuXG50b2FzdC5vbkNoYW5nZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBpZiAoaXNGbihjYWxsYmFjaykpIHtcbiAgICBldmVudE1hbmFnZXIub24oNFxuICAgIC8qIENoYW5nZSAqL1xuICAgICwgY2FsbGJhY2spO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpc0ZuKGNhbGxiYWNrKSAmJiBldmVudE1hbmFnZXIub2ZmKDRcbiAgICAvKiBDaGFuZ2UgKi9cbiAgICAsIGNhbGxiYWNrKTtcbiAgfTtcbn07XG4vKipcclxuICogQ29uZmlndXJlIHRoZSBUb2FzdENvbnRhaW5lciB3aGVuIGxhenkgbW91bnRlZFxyXG4gKi9cblxuXG50b2FzdC5jb25maWd1cmUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIGlmIChjb25maWcgPT09IHZvaWQgMCkge1xuICAgIGNvbmZpZyA9IHt9O1xuICB9XG5cbiAgbGF6eSA9IHRydWU7XG4gIGNvbnRhaW5lckNvbmZpZyA9IGNvbmZpZztcbn07XG5cbnRvYXN0LlBPU0lUSU9OID0gUE9TSVRJT047XG50b2FzdC5UWVBFID0gVFlQRTtcbi8qKlxyXG4gKiBXYWl0IHVudGlsIHRoZSBUb2FzdENvbnRhaW5lciBpcyBtb3VudGVkIHRvIGRpc3BhdGNoIHRoZSB0b2FzdFxyXG4gKiBhbmQgYXR0YWNoIGlzQWN0aXZlIG1ldGhvZFxyXG4gKi9cblxuZXZlbnRNYW5hZ2VyLm9uKDJcbi8qIERpZE1vdW50ICovXG4sIGZ1bmN0aW9uIChjb250YWluZXJJbnN0YW5jZSkge1xuICBsYXRlc3RJbnN0YW5jZSA9IGNvbnRhaW5lckluc3RhbmNlLmNvbnRhaW5lcklkIHx8IGNvbnRhaW5lckluc3RhbmNlO1xuICBjb250YWluZXJzLnNldChsYXRlc3RJbnN0YW5jZSwgY29udGFpbmVySW5zdGFuY2UpO1xuICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgZXZlbnRNYW5hZ2VyLmVtaXQoMFxuICAgIC8qIFNob3cgKi9cbiAgICAsIGl0ZW0uY29udGVudCwgaXRlbS5vcHRpb25zKTtcbiAgfSk7XG4gIHF1ZXVlID0gW107XG59KS5vbigzXG4vKiBXaWxsVW5tb3VudCAqL1xuLCBmdW5jdGlvbiAoY29udGFpbmVySW5zdGFuY2UpIHtcbiAgY29udGFpbmVyc1tcImRlbGV0ZVwiXShjb250YWluZXJJbnN0YW5jZS5jb250YWluZXJJZCB8fCBjb250YWluZXJJbnN0YW5jZSk7XG5cbiAgaWYgKGNvbnRhaW5lcnMuc2l6ZSA9PT0gMCkge1xuICAgIGV2ZW50TWFuYWdlci5vZmYoMFxuICAgIC8qIFNob3cgKi9cbiAgICApLm9mZigxXG4gICAgLyogQ2xlYXIgKi9cbiAgICApLm9mZig1XG4gICAgLyogQ2xlYXJXYWl0aW5nUXVldWUgKi9cbiAgICApO1xuICB9XG5cbiAgaWYgKGNhblVzZURvbSAmJiBjb250YWluZXJEb21Ob2RlKSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChjb250YWluZXJEb21Ob2RlKTtcbiAgfVxufSk7XG5cbmV4cG9ydCB7IEJvdW5jZSwgRmxpcCwgU2xpZGUsIFRvYXN0Q29udGFpbmVyLCBab29tLCBjb2xsYXBzZVRvYXN0LCBjc3NUcmFuc2l0aW9uLCB0b2FzdCwgdXNlVG9hc3QsIHVzZVRvYXN0Q29udGFpbmVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC10b2FzdGlmeS5lc20uanMubWFwXG4iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9pbmhlcml0c0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c0xvb3NlXCI7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGFkZE9uZUNsYXNzIGZyb20gJ2RvbS1oZWxwZXJzL2FkZENsYXNzJztcbmltcG9ydCByZW1vdmVPbmVDbGFzcyBmcm9tICdkb20taGVscGVycy9yZW1vdmVDbGFzcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFRyYW5zaXRpb24gZnJvbSAnLi9UcmFuc2l0aW9uJztcbmltcG9ydCB7IGNsYXNzTmFtZXNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcblxudmFyIF9hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNsYXNzZXMpIHtcbiAgcmV0dXJuIG5vZGUgJiYgY2xhc3NlcyAmJiBjbGFzc2VzLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgIHJldHVybiBhZGRPbmVDbGFzcyhub2RlLCBjKTtcbiAgfSk7XG59O1xuXG52YXIgcmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhub2RlLCBjbGFzc2VzKSB7XG4gIHJldHVybiBub2RlICYmIGNsYXNzZXMgJiYgY2xhc3Nlcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gcmVtb3ZlT25lQ2xhc3Mobm9kZSwgYyk7XG4gIH0pO1xufTtcbi8qKlxuICogQSB0cmFuc2l0aW9uIGNvbXBvbmVudCBpbnNwaXJlZCBieSB0aGUgZXhjZWxsZW50XG4gKiBbbmctYW5pbWF0ZV0oaHR0cHM6Ly9kb2NzLmFuZ3VsYXJqcy5vcmcvYXBpL25nQW5pbWF0ZSkgbGlicmFyeSwgeW91IHNob3VsZFxuICogdXNlIGl0IGlmIHlvdSdyZSB1c2luZyBDU1MgdHJhbnNpdGlvbnMgb3IgYW5pbWF0aW9ucy4gSXQncyBidWlsdCB1cG9uIHRoZVxuICogW2BUcmFuc2l0aW9uYF0oaHR0cHM6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uKVxuICogY29tcG9uZW50LCBzbyBpdCBpbmhlcml0cyBhbGwgb2YgaXRzIHByb3BzLlxuICpcbiAqIGBDU1NUcmFuc2l0aW9uYCBhcHBsaWVzIGEgcGFpciBvZiBjbGFzcyBuYW1lcyBkdXJpbmcgdGhlIGBhcHBlYXJgLCBgZW50ZXJgLFxuICogYW5kIGBleGl0YCBzdGF0ZXMgb2YgdGhlIHRyYW5zaXRpb24uIFRoZSBmaXJzdCBjbGFzcyBpcyBhcHBsaWVkIGFuZCB0aGVuIGFcbiAqIHNlY29uZCBgKi1hY3RpdmVgIGNsYXNzIGluIG9yZGVyIHRvIGFjdGl2YXRlIHRoZSBDU1MgdHJhbnNpdGlvbi4gQWZ0ZXIgdGhlXG4gKiB0cmFuc2l0aW9uLCBtYXRjaGluZyBgKi1kb25lYCBjbGFzcyBuYW1lcyBhcmUgYXBwbGllZCB0byBwZXJzaXN0IHRoZVxuICogdHJhbnNpdGlvbiBzdGF0ZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgW2luUHJvcCwgc2V0SW5Qcm9wXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8ZGl2PlxuICogICAgICAgPENTU1RyYW5zaXRpb24gaW49e2luUHJvcH0gdGltZW91dD17MjAwfSBjbGFzc05hbWVzPVwibXktbm9kZVwiPlxuICogICAgICAgICA8ZGl2PlxuICogICAgICAgICAgIHtcIkknbGwgcmVjZWl2ZSBteS1ub2RlLSogY2xhc3Nlc1wifVxuICogICAgICAgICA8L2Rpdj5cbiAqICAgICAgIDwvQ1NTVHJhbnNpdGlvbj5cbiAqICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIG9uQ2xpY2s9eygpID0+IHNldEluUHJvcCh0cnVlKX0+XG4gKiAgICAgICAgIENsaWNrIHRvIEVudGVyXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICA8L2Rpdj5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFdoZW4gdGhlIGBpbmAgcHJvcCBpcyBzZXQgdG8gYHRydWVgLCB0aGUgY2hpbGQgY29tcG9uZW50IHdpbGwgZmlyc3QgcmVjZWl2ZVxuICogdGhlIGNsYXNzIGBleGFtcGxlLWVudGVyYCwgdGhlbiB0aGUgYGV4YW1wbGUtZW50ZXItYWN0aXZlYCB3aWxsIGJlIGFkZGVkIGluXG4gKiB0aGUgbmV4dCB0aWNrLiBgQ1NTVHJhbnNpdGlvbmAgW2ZvcmNlcyBhXG4gKiByZWZsb3ddKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi81MDA3MzAzZTcyOWE3NGJlNjZhMjFjM2UyMjA1ZTQ5MTY4MjE1MjRiL3NyYy9DU1NUcmFuc2l0aW9uLmpzI0wyMDgtTDIxNSlcbiAqIGJldHdlZW4gYmVmb3JlIGFkZGluZyB0aGUgYGV4YW1wbGUtZW50ZXItYWN0aXZlYC4gVGhpcyBpcyBhbiBpbXBvcnRhbnQgdHJpY2tcbiAqIGJlY2F1c2UgaXQgYWxsb3dzIHVzIHRvIHRyYW5zaXRpb24gYmV0d2VlbiBgZXhhbXBsZS1lbnRlcmAgYW5kXG4gKiBgZXhhbXBsZS1lbnRlci1hY3RpdmVgIGV2ZW4gdGhvdWdoIHRoZXkgd2VyZSBhZGRlZCBpbW1lZGlhdGVseSBvbmUgYWZ0ZXJcbiAqIGFub3RoZXIuIE1vc3Qgbm90YWJseSwgdGhpcyBpcyB3aGF0IG1ha2VzIGl0IHBvc3NpYmxlIGZvciB1cyB0byBhbmltYXRlXG4gKiBfYXBwZWFyYW5jZV8uXG4gKlxuICogYGBgY3NzXG4gKiAubXktbm9kZS1lbnRlciB7XG4gKiAgIG9wYWNpdHk6IDA7XG4gKiB9XG4gKiAubXktbm9kZS1lbnRlci1hY3RpdmUge1xuICogICBvcGFjaXR5OiAxO1xuICogICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xuICogfVxuICogLm15LW5vZGUtZXhpdCB7XG4gKiAgIG9wYWNpdHk6IDE7XG4gKiB9XG4gKiAubXktbm9kZS1leGl0LWFjdGl2ZSB7XG4gKiAgIG9wYWNpdHk6IDA7XG4gKiAgIHRyYW5zaXRpb246IG9wYWNpdHkgMjAwbXM7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBgKi1hY3RpdmVgIGNsYXNzZXMgcmVwcmVzZW50IHdoaWNoIHN0eWxlcyB5b3Ugd2FudCB0byBhbmltYXRlICoqdG8qKiwgc28gaXQnc1xuICogaW1wb3J0YW50IHRvIGFkZCBgdHJhbnNpdGlvbmAgZGVjbGFyYXRpb24gb25seSB0byB0aGVtLCBvdGhlcndpc2UgdHJhbnNpdGlvbnNcbiAqIG1pZ2h0IG5vdCBiZWhhdmUgYXMgaW50ZW5kZWQhIFRoaXMgbWlnaHQgbm90IGJlIG9idmlvdXMgd2hlbiB0aGUgdHJhbnNpdGlvbnNcbiAqIGFyZSBzeW1tZXRyaWNhbCwgaS5lLiB3aGVuIGAqLWVudGVyLWFjdGl2ZWAgaXMgdGhlIHNhbWUgYXMgYCotZXhpdGAsIGxpa2UgaW5cbiAqIHRoZSBleGFtcGxlIGFib3ZlIChtaW51cyBgdHJhbnNpdGlvbmApLCBidXQgaXQgYmVjb21lcyBhcHBhcmVudCBpbiBtb3JlXG4gKiBjb21wbGV4IHRyYW5zaXRpb25zLlxuICpcbiAqICoqTm90ZSoqOiBJZiB5b3UncmUgdXNpbmcgdGhlXG4gKiBbYGFwcGVhcmBdKGh0dHA6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uI1RyYW5zaXRpb24tcHJvcC1hcHBlYXIpXG4gKiBwcm9wLCBtYWtlIHN1cmUgdG8gZGVmaW5lIHN0eWxlcyBmb3IgYC5hcHBlYXItKmAgY2xhc3NlcyBhcyB3ZWxsLlxuICovXG5cblxudmFyIENTU1RyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ1NTVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gQ1NTVHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5hcHBsaWVkQ2xhc3NlcyA9IHtcbiAgICAgIGFwcGVhcjoge30sXG4gICAgICBlbnRlcjoge30sXG4gICAgICBleGl0OiB7fVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkVudGVyID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnRbMF0sXG4gICAgICAgICAgYXBwZWFyaW5nID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50WzFdO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdleGl0Jyk7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsIGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJywgJ2Jhc2UnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXIpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcihtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmluZyA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MiA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDJbMF0sXG4gICAgICAgICAgYXBwZWFyaW5nID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50MlsxXTtcblxuICAgICAgdmFyIHR5cGUgPSBhcHBlYXJpbmcgPyAnYXBwZWFyJyA6ICdlbnRlcic7XG5cbiAgICAgIF90aGlzLmFkZENsYXNzKG5vZGUsIHR5cGUsICdhY3RpdmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FbnRlcmluZyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMub25FbnRlcmVkID0gZnVuY3Rpb24gKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQzID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50M1swXSxcbiAgICAgICAgICBhcHBlYXJpbmcgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQzWzFdO1xuXG4gICAgICB2YXIgdHlwZSA9IGFwcGVhcmluZyA/ICdhcHBlYXInIDogJ2VudGVyJztcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCB0eXBlKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgdHlwZSwgJ2RvbmUnKTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uRW50ZXJlZCkge1xuICAgICAgICBfdGhpcy5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdCA9IGZ1bmN0aW9uIChtYXliZU5vZGUpIHtcbiAgICAgIHZhciBfdGhpcyRyZXNvbHZlQXJndW1lbnQ0ID0gX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyhtYXliZU5vZGUpLFxuICAgICAgICAgIG5vZGUgPSBfdGhpcyRyZXNvbHZlQXJndW1lbnQ0WzBdO1xuXG4gICAgICBfdGhpcy5yZW1vdmVDbGFzc2VzKG5vZGUsICdhcHBlYXInKTtcblxuICAgICAgX3RoaXMucmVtb3ZlQ2xhc3Nlcyhub2RlLCAnZW50ZXInKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnYmFzZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0KSB7XG4gICAgICAgIF90aGlzLnByb3BzLm9uRXhpdChtYXliZU5vZGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vbkV4aXRpbmcgPSBmdW5jdGlvbiAobWF5YmVOb2RlKSB7XG4gICAgICB2YXIgX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NSA9IF90aGlzLnJlc29sdmVBcmd1bWVudHMobWF5YmVOb2RlKSxcbiAgICAgICAgICBub2RlID0gX3RoaXMkcmVzb2x2ZUFyZ3VtZW50NVswXTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnYWN0aXZlJyk7XG5cbiAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkV4aXRpbmcpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0aW5nKG1heWJlTm9kZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLm9uRXhpdGVkID0gZnVuY3Rpb24gKG1heWJlTm9kZSkge1xuICAgICAgdmFyIF90aGlzJHJlc29sdmVBcmd1bWVudDYgPSBfdGhpcy5yZXNvbHZlQXJndW1lbnRzKG1heWJlTm9kZSksXG4gICAgICAgICAgbm9kZSA9IF90aGlzJHJlc29sdmVBcmd1bWVudDZbMF07XG5cbiAgICAgIF90aGlzLnJlbW92ZUNsYXNzZXMobm9kZSwgJ2V4aXQnKTtcblxuICAgICAgX3RoaXMuYWRkQ2xhc3Mobm9kZSwgJ2V4aXQnLCAnZG9uZScpO1xuXG4gICAgICBpZiAoX3RoaXMucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgICAgX3RoaXMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMucmVzb2x2ZUFyZ3VtZW50cyA9IGZ1bmN0aW9uIChtYXliZU5vZGUsIG1heWJlQXBwZWFyaW5nKSB7XG4gICAgICByZXR1cm4gX3RoaXMucHJvcHMubm9kZVJlZiA/IFtfdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQsIG1heWJlTm9kZV0gLy8gaGVyZSBgbWF5YmVOb2RlYCBpcyBhY3R1YWxseSBgYXBwZWFyaW5nYFxuICAgICAgOiBbbWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZ107XG4gICAgfTtcblxuICAgIF90aGlzLmdldENsYXNzTmFtZXMgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgdmFyIGNsYXNzTmFtZXMgPSBfdGhpcy5wcm9wcy5jbGFzc05hbWVzO1xuICAgICAgdmFyIGlzU3RyaW5nQ2xhc3NOYW1lcyA9IHR5cGVvZiBjbGFzc05hbWVzID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBwcmVmaXggPSBpc1N0cmluZ0NsYXNzTmFtZXMgJiYgY2xhc3NOYW1lcyA/IGNsYXNzTmFtZXMgKyBcIi1cIiA6ICcnO1xuICAgICAgdmFyIGJhc2VDbGFzc05hbWUgPSBpc1N0cmluZ0NsYXNzTmFtZXMgPyBcIlwiICsgcHJlZml4ICsgdHlwZSA6IGNsYXNzTmFtZXNbdHlwZV07XG4gICAgICB2YXIgYWN0aXZlQ2xhc3NOYW1lID0gaXNTdHJpbmdDbGFzc05hbWVzID8gYmFzZUNsYXNzTmFtZSArIFwiLWFjdGl2ZVwiIDogY2xhc3NOYW1lc1t0eXBlICsgXCJBY3RpdmVcIl07XG4gICAgICB2YXIgZG9uZUNsYXNzTmFtZSA9IGlzU3RyaW5nQ2xhc3NOYW1lcyA/IGJhc2VDbGFzc05hbWUgKyBcIi1kb25lXCIgOiBjbGFzc05hbWVzW3R5cGUgKyBcIkRvbmVcIl07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlQ2xhc3NOYW1lOiBiYXNlQ2xhc3NOYW1lLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWU6IGFjdGl2ZUNsYXNzTmFtZSxcbiAgICAgICAgZG9uZUNsYXNzTmFtZTogZG9uZUNsYXNzTmFtZVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENTU1RyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIHR5cGUsIHBoYXNlKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3NOYW1lcyh0eXBlKVtwaGFzZSArIFwiQ2xhc3NOYW1lXCJdO1xuXG4gICAgdmFyIF90aGlzJGdldENsYXNzTmFtZXMgPSB0aGlzLmdldENsYXNzTmFtZXMoJ2VudGVyJyksXG4gICAgICAgIGRvbmVDbGFzc05hbWUgPSBfdGhpcyRnZXRDbGFzc05hbWVzLmRvbmVDbGFzc05hbWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2FwcGVhcicgJiYgcGhhc2UgPT09ICdkb25lJyAmJiBkb25lQ2xhc3NOYW1lKSB7XG4gICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyBkb25lQ2xhc3NOYW1lO1xuICAgIH0gLy8gVGhpcyBpcyB0byBmb3JjZSBhIHJlcGFpbnQsXG4gICAgLy8gd2hpY2ggaXMgbmVjZXNzYXJ5IGluIG9yZGVyIHRvIHRyYW5zaXRpb24gc3R5bGVzIHdoZW4gYWRkaW5nIGEgY2xhc3MgbmFtZS5cblxuXG4gICAgaWYgKHBoYXNlID09PSAnYWN0aXZlJykge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgICBub2RlICYmIG5vZGUuc2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgIHRoaXMuYXBwbGllZENsYXNzZXNbdHlwZV1bcGhhc2VdID0gY2xhc3NOYW1lO1xuXG4gICAgICBfYWRkQ2xhc3Mobm9kZSwgY2xhc3NOYW1lKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZUNsYXNzZXMgPSBmdW5jdGlvbiByZW1vdmVDbGFzc2VzKG5vZGUsIHR5cGUpIHtcbiAgICB2YXIgX3RoaXMkYXBwbGllZENsYXNzZXMkID0gdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXSxcbiAgICAgICAgYmFzZUNsYXNzTmFtZSA9IF90aGlzJGFwcGxpZWRDbGFzc2VzJC5iYXNlLFxuICAgICAgICBhY3RpdmVDbGFzc05hbWUgPSBfdGhpcyRhcHBsaWVkQ2xhc3NlcyQuYWN0aXZlLFxuICAgICAgICBkb25lQ2xhc3NOYW1lID0gX3RoaXMkYXBwbGllZENsYXNzZXMkLmRvbmU7XG4gICAgdGhpcy5hcHBsaWVkQ2xhc3Nlc1t0eXBlXSA9IHt9O1xuXG4gICAgaWYgKGJhc2VDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGJhc2VDbGFzc05hbWUpO1xuICAgIH1cblxuICAgIGlmIChhY3RpdmVDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGFjdGl2ZUNsYXNzTmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGRvbmVDbGFzc05hbWUpIHtcbiAgICAgIHJlbW92ZUNsYXNzKG5vZGUsIGRvbmVDbGFzc05hbWUpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIF8gPSBfdGhpcyRwcm9wcy5jbGFzc05hbWVzLFxuICAgICAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF90aGlzJHByb3BzLCBbXCJjbGFzc05hbWVzXCJdKTtcblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICAgIG9uRW50ZXI6IHRoaXMub25FbnRlcixcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5vbkVudGVyZWQsXG4gICAgICBvbkVudGVyaW5nOiB0aGlzLm9uRW50ZXJpbmcsXG4gICAgICBvbkV4aXQ6IHRoaXMub25FeGl0LFxuICAgICAgb25FeGl0aW5nOiB0aGlzLm9uRXhpdGluZyxcbiAgICAgIG9uRXhpdGVkOiB0aGlzLm9uRXhpdGVkXG4gICAgfSkpO1xuICB9O1xuXG4gIHJldHVybiBDU1NUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5DU1NUcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2xhc3NOYW1lczogJydcbn07XG5DU1NUcmFuc2l0aW9uLnByb3BUeXBlcyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IF9leHRlbmRzKHt9LCBUcmFuc2l0aW9uLnByb3BUeXBlcywge1xuICAvKipcbiAgICogVGhlIGFuaW1hdGlvbiBjbGFzc05hbWVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudCBhcyBpdCBhcHBlYXJzLCBlbnRlcnMsXG4gICAqIGV4aXRzIG9yIGhhcyBmaW5pc2hlZCB0aGUgdHJhbnNpdGlvbi4gQSBzaW5nbGUgbmFtZSBjYW4gYmUgcHJvdmlkZWQsIHdoaWNoXG4gICAqIHdpbGwgYmUgc3VmZml4ZWQgZm9yIGVhY2ggc3RhZ2UsIGUuZy4gYGNsYXNzTmFtZXM9XCJmYWRlXCJgIGFwcGxpZXM6XG4gICAqXG4gICAqIC0gYGZhZGUtYXBwZWFyYCwgYGZhZGUtYXBwZWFyLWFjdGl2ZWAsIGBmYWRlLWFwcGVhci1kb25lYFxuICAgKiAtIGBmYWRlLWVudGVyYCwgYGZhZGUtZW50ZXItYWN0aXZlYCwgYGZhZGUtZW50ZXItZG9uZWBcbiAgICogLSBgZmFkZS1leGl0YCwgYGZhZGUtZXhpdC1hY3RpdmVgLCBgZmFkZS1leGl0LWRvbmVgXG4gICAqXG4gICAqIEEgZmV3IGRldGFpbHMgdG8gbm90ZSBhYm91dCBob3cgdGhlc2UgY2xhc3NlcyBhcmUgYXBwbGllZDpcbiAgICpcbiAgICogMS4gVGhleSBhcmUgX2pvaW5lZF8gd2l0aCB0aGUgb25lcyB0aGF0IGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlIGNoaWxkXG4gICAqICAgIGNvbXBvbmVudCwgc28gaWYgeW91IHdhbnQgdG8gYWRkIHNvbWUgYmFzZSBzdHlsZXMsIHlvdSBjYW4gdXNlXG4gICAqICAgIGBjbGFzc05hbWVgIHdpdGhvdXQgd29ycnlpbmcgdGhhdCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4uXG4gICAqXG4gICAqIDIuIElmIHRoZSB0cmFuc2l0aW9uIGNvbXBvbmVudCBtb3VudHMgd2l0aCBgaW49e2ZhbHNlfWAsIG5vIGNsYXNzZXMgYXJlXG4gICAqICAgIGFwcGxpZWQgeWV0LiBZb3UgbWlnaHQgYmUgZXhwZWN0aW5nIGAqLWV4aXQtZG9uZWAsIGJ1dCBpZiB5b3UgdGhpbmtcbiAgICogICAgYWJvdXQgaXQsIGEgY29tcG9uZW50IGNhbm5vdCBmaW5pc2ggZXhpdGluZyBpZiBpdCBoYXNuJ3QgZW50ZXJlZCB5ZXQuXG4gICAqXG4gICAqIDIuIGBmYWRlLWFwcGVhci1kb25lYCBhbmQgYGZhZGUtZW50ZXItZG9uZWAgd2lsbCBfYm90aF8gYmUgYXBwbGllZC4gVGhpc1xuICAgKiAgICBhbGxvd3MgeW91IHRvIGRlZmluZSBkaWZmZXJlbnQgYmVoYXZpb3IgZm9yIHdoZW4gYXBwZWFyaW5nIGlzIGRvbmUgYW5kXG4gICAqICAgIHdoZW4gcmVndWxhciBlbnRlcmluZyBpcyBkb25lLCB1c2luZyBzZWxlY3RvcnMgbGlrZVxuICAgKiAgICBgLmZhZGUtZW50ZXItZG9uZTpub3QoLmZhZGUtYXBwZWFyLWRvbmUpYC4gRm9yIGV4YW1wbGUsIHlvdSBjb3VsZCBhcHBseVxuICAgKiAgICBhbiBlcGljIGVudHJhbmNlIGFuaW1hdGlvbiB3aGVuIGVsZW1lbnQgZmlyc3QgYXBwZWFycyBpbiB0aGUgRE9NIHVzaW5nXG4gICAqICAgIFtBbmltYXRlLmNzc10oaHR0cHM6Ly9kYW5lZGVuLmdpdGh1Yi5pby9hbmltYXRlLmNzcy8pLiBPdGhlcndpc2UgeW91IGNhblxuICAgKiAgICBzaW1wbHkgdXNlIGBmYWRlLWVudGVyLWRvbmVgIGZvciBkZWZpbmluZyBib3RoIGNhc2VzLlxuICAgKlxuICAgKiBFYWNoIGluZGl2aWR1YWwgY2xhc3NOYW1lcyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgaW5kZXBlbmRlbnRseSBsaWtlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjbGFzc05hbWVzPXt7XG4gICAqICBhcHBlYXI6ICdteS1hcHBlYXInLFxuICAgKiAgYXBwZWFyQWN0aXZlOiAnbXktYWN0aXZlLWFwcGVhcicsXG4gICAqICBhcHBlYXJEb25lOiAnbXktZG9uZS1hcHBlYXInLFxuICAgKiAgZW50ZXI6ICdteS1lbnRlcicsXG4gICAqICBlbnRlckFjdGl2ZTogJ215LWFjdGl2ZS1lbnRlcicsXG4gICAqICBlbnRlckRvbmU6ICdteS1kb25lLWVudGVyJyxcbiAgICogIGV4aXQ6ICdteS1leGl0JyxcbiAgICogIGV4aXRBY3RpdmU6ICdteS1hY3RpdmUtZXhpdCcsXG4gICAqICBleGl0RG9uZTogJ215LWRvbmUtZXhpdCcsXG4gICAqIH19XG4gICAqIGBgYFxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBzZXQgdGhlc2UgY2xhc3NlcyB1c2luZyBDU1MgTW9kdWxlczpcbiAgICpcbiAgICogYGBganNcbiAgICogaW1wb3J0IHN0eWxlcyBmcm9tICcuL3N0eWxlcy5jc3MnO1xuICAgKiBgYGBcbiAgICpcbiAgICogeW91IG1pZ2h0IHdhbnQgdG8gdXNlIGNhbWVsQ2FzZSBpbiB5b3VyIENTUyBmaWxlLCB0aGF0IHdheSBjb3VsZCBzaW1wbHlcbiAgICogc3ByZWFkIHRoZW0gaW5zdGVhZCBvZiBsaXN0aW5nIHRoZW0gb25lIGJ5IG9uZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY2xhc3NOYW1lcz17eyAuLi5zdHlsZXMgfX1cbiAgICogYGBgXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmcgfCB7XG4gICAqICBhcHBlYXI/OiBzdHJpbmcsXG4gICAqICBhcHBlYXJBY3RpdmU/OiBzdHJpbmcsXG4gICAqICBhcHBlYXJEb25lPzogc3RyaW5nLFxuICAgKiAgZW50ZXI/OiBzdHJpbmcsXG4gICAqICBlbnRlckFjdGl2ZT86IHN0cmluZyxcbiAgICogIGVudGVyRG9uZT86IHN0cmluZyxcbiAgICogIGV4aXQ/OiBzdHJpbmcsXG4gICAqICBleGl0QWN0aXZlPzogc3RyaW5nLFxuICAgKiAgZXhpdERvbmU/OiBzdHJpbmcsXG4gICAqIH19XG4gICAqL1xuICBjbGFzc05hbWVzOiBjbGFzc05hbWVzU2hhcGUsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlcicgb3IgJ2FwcGVhcicgY2xhc3MgaXNcbiAgICogYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKVxuICAgKi9cbiAgb25FbnRlcjogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdlbnRlci1hY3RpdmUnIG9yXG4gICAqICdhcHBlYXItYWN0aXZlJyBjbGFzcyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2VudGVyJyBvclxuICAgKiAnYXBwZWFyJyBjbGFzc2VzIGFyZSAqKnJlbW92ZWQqKiBhbmQgdGhlIGBkb25lYCBjbGFzcyBpcyBhZGRlZCB0byB0aGUgRE9NIG5vZGUuXG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbClcbiAgICovXG4gIG9uRW50ZXJlZDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEEgYDxUcmFuc2l0aW9uPmAgY2FsbGJhY2sgZmlyZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgdGhlICdleGl0JyBjbGFzcyBpc1xuICAgKiBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0OiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQtYWN0aXZlJyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0aW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQSBgPFRyYW5zaXRpb24+YCBjYWxsYmFjayBmaXJlZCBpbW1lZGlhdGVseSBhZnRlciB0aGUgJ2V4aXQnIGNsYXNzZXNcbiAgICogYXJlICoqcmVtb3ZlZCoqIGFuZCB0aGUgYGV4aXQtZG9uZWAgY2xhc3MgaXMgYWRkZWQgdG8gdGhlIERPTSBub2RlLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KVxuICAgKi9cbiAgb25FeGl0ZWQ6IFByb3BUeXBlcy5mdW5jXG59KSA6IHt9O1xuZXhwb3J0IGRlZmF1bHQgQ1NTVHJhbnNpdGlvbjsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXAgZnJvbSAnLi9UcmFuc2l0aW9uR3JvdXAnO1xuLyoqXG4gKiBUaGUgYDxSZXBsYWNlVHJhbnNpdGlvbj5gIGNvbXBvbmVudCBpcyBhIHNwZWNpYWxpemVkIGBUcmFuc2l0aW9uYCBjb21wb25lbnRcbiAqIHRoYXQgYW5pbWF0ZXMgYmV0d2VlbiB0d28gY2hpbGRyZW4uXG4gKlxuICogYGBganN4XG4gKiA8UmVwbGFjZVRyYW5zaXRpb24gaW4+XG4gKiAgIDxGYWRlPjxkaXY+SSBhcHBlYXIgZmlyc3Q8L2Rpdj48L0ZhZGU+XG4gKiAgIDxGYWRlPjxkaXY+SSByZXBsYWNlIHRoZSBhYm92ZTwvZGl2PjwvRmFkZT5cbiAqIDwvUmVwbGFjZVRyYW5zaXRpb24+XG4gKiBgYGBcbiAqL1xuXG52YXIgUmVwbGFjZVRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVwbGFjZVRyYW5zaXRpb24sIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlcGxhY2VUcmFuc2l0aW9uKCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBfYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIF9hcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsLmFwcGx5KF9SZWFjdCRDb21wb25lbnQsIFt0aGlzXS5jb25jYXQoX2FyZ3MpKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkVudGVyJywgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUVudGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjMgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4zKSwgX2tleTMgPSAwOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTNdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FbnRlcmluZycsIDAsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFbnRlcmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW40KSwgX2tleTQgPSAwOyBfa2V5NCA8IF9sZW40OyBfa2V5NCsrKSB7XG4gICAgICAgIGFyZ3NbX2tleTRdID0gYXJndW1lbnRzW19rZXk0XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF90aGlzLmhhbmRsZUxpZmVjeWNsZSgnb25FbnRlcmVkJywgMCwgYXJncyk7XG4gICAgfTtcblxuICAgIF90aGlzLmhhbmRsZUV4aXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjUpLCBfa2V5NSA9IDA7IF9rZXk1IDwgX2xlbjU7IF9rZXk1KyspIHtcbiAgICAgICAgYXJnc1tfa2V5NV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkV4aXQnLCAxLCBhcmdzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuaGFuZGxlRXhpdGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW42ID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuNiksIF9rZXk2ID0gMDsgX2tleTYgPCBfbGVuNjsgX2tleTYrKykge1xuICAgICAgICBhcmdzW19rZXk2XSA9IGFyZ3VtZW50c1tfa2V5Nl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5oYW5kbGVMaWZlY3ljbGUoJ29uRXhpdGluZycsIDEsIGFyZ3MpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVFeGl0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjcpLCBfa2V5NyA9IDA7IF9rZXk3IDwgX2xlbjc7IF9rZXk3KyspIHtcbiAgICAgICAgYXJnc1tfa2V5N10gPSBhcmd1bWVudHNbX2tleTddO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3RoaXMuaGFuZGxlTGlmZWN5Y2xlKCdvbkV4aXRlZCcsIDEsIGFyZ3MpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVwbGFjZVRyYW5zaXRpb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYW5kbGVMaWZlY3ljbGUgPSBmdW5jdGlvbiBoYW5kbGVMaWZlY3ljbGUoaGFuZGxlciwgaWR4LCBvcmlnaW5hbEFyZ3MpIHtcbiAgICB2YXIgX2NoaWxkJHByb3BzO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgY2hpbGQgPSBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGNoaWxkcmVuKVtpZHhdO1xuICAgIGlmIChjaGlsZC5wcm9wc1toYW5kbGVyXSkgKF9jaGlsZCRwcm9wcyA9IGNoaWxkLnByb3BzKVtoYW5kbGVyXS5hcHBseShfY2hpbGQkcHJvcHMsIG9yaWdpbmFsQXJncyk7XG5cbiAgICBpZiAodGhpcy5wcm9wc1toYW5kbGVyXSkge1xuICAgICAgdmFyIG1heWJlTm9kZSA9IGNoaWxkLnByb3BzLm5vZGVSZWYgPyB1bmRlZmluZWQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgIHRoaXMucHJvcHNbaGFuZGxlcl0obWF5YmVOb2RlKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBjaGlsZHJlbiA9IF90aGlzJHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBpblByb3AgPSBfdGhpcyRwcm9wcy5pbixcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY2hpbGRyZW5cIiwgXCJpblwiXSk7XG5cbiAgICB2YXIgX1JlYWN0JENoaWxkcmVuJHRvQXJyID0gUmVhY3QuQ2hpbGRyZW4udG9BcnJheShjaGlsZHJlbiksXG4gICAgICAgIGZpcnN0ID0gX1JlYWN0JENoaWxkcmVuJHRvQXJyWzBdLFxuICAgICAgICBzZWNvbmQgPSBfUmVhY3QkQ2hpbGRyZW4kdG9BcnJbMV07XG5cbiAgICBkZWxldGUgcHJvcHMub25FbnRlcjtcbiAgICBkZWxldGUgcHJvcHMub25FbnRlcmluZztcbiAgICBkZWxldGUgcHJvcHMub25FbnRlcmVkO1xuICAgIGRlbGV0ZSBwcm9wcy5vbkV4aXQ7XG4gICAgZGVsZXRlIHByb3BzLm9uRXhpdGluZztcbiAgICBkZWxldGUgcHJvcHMub25FeGl0ZWQ7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cCwgcHJvcHMsIGluUHJvcCA/IFJlYWN0LmNsb25lRWxlbWVudChmaXJzdCwge1xuICAgICAga2V5OiAnZmlyc3QnLFxuICAgICAgb25FbnRlcjogdGhpcy5oYW5kbGVFbnRlcixcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMuaGFuZGxlRW50ZXJpbmcsXG4gICAgICBvbkVudGVyZWQ6IHRoaXMuaGFuZGxlRW50ZXJlZFxuICAgIH0pIDogUmVhY3QuY2xvbmVFbGVtZW50KHNlY29uZCwge1xuICAgICAga2V5OiAnc2Vjb25kJyxcbiAgICAgIG9uRW50ZXI6IHRoaXMuaGFuZGxlRXhpdCxcbiAgICAgIG9uRW50ZXJpbmc6IHRoaXMuaGFuZGxlRXhpdGluZyxcbiAgICAgIG9uRW50ZXJlZDogdGhpcy5oYW5kbGVFeGl0ZWRcbiAgICB9KSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlcGxhY2VUcmFuc2l0aW9uO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZXBsYWNlVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIGluOiBQcm9wVHlwZXMuYm9vbC5pc1JlcXVpcmVkLFxuICBjaGlsZHJlbjogZnVuY3Rpb24gY2hpbGRyZW4ocHJvcHMsIHByb3BOYW1lKSB7XG4gICAgaWYgKFJlYWN0LkNoaWxkcmVuLmNvdW50KHByb3BzW3Byb3BOYW1lXSkgIT09IDIpIHJldHVybiBuZXcgRXJyb3IoXCJcXFwiXCIgKyBwcm9wTmFtZSArIFwiXFxcIiBtdXN0IGJlIGV4YWN0bHkgdHdvIHRyYW5zaXRpb24gY29tcG9uZW50cy5cIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn0gOiB7fTtcbmV4cG9ydCBkZWZhdWx0IFJlcGxhY2VUcmFuc2l0aW9uOyIsImltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuXG52YXIgX2xlYXZlUmVuZGVycywgX2VudGVyUmVuZGVycztcblxuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBFTlRFUkVELCBFTlRFUklORywgRVhJVElORyB9IGZyb20gJy4vVHJhbnNpdGlvbic7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuXG5mdW5jdGlvbiBhcmVDaGlsZHJlbkRpZmZlcmVudChvbGRDaGlsZHJlbiwgbmV3Q2hpbGRyZW4pIHtcbiAgaWYgKG9sZENoaWxkcmVuID09PSBuZXdDaGlsZHJlbikgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChvbGRDaGlsZHJlbikgJiYgUmVhY3QuaXNWYWxpZEVsZW1lbnQobmV3Q2hpbGRyZW4pICYmIG9sZENoaWxkcmVuLmtleSAhPSBudWxsICYmIG9sZENoaWxkcmVuLmtleSA9PT0gbmV3Q2hpbGRyZW4ua2V5KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEVudW0gb2YgbW9kZXMgZm9yIFN3aXRjaFRyYW5zaXRpb24gY29tcG9uZW50XG4gKiBAZW51bSB7IHN0cmluZyB9XG4gKi9cblxuXG5leHBvcnQgdmFyIG1vZGVzID0ge1xuICBvdXQ6ICdvdXQtaW4nLFxuICBpbjogJ2luLW91dCdcbn07XG5cbnZhciBjYWxsSG9vayA9IGZ1bmN0aW9uIGNhbGxIb29rKGVsZW1lbnQsIG5hbWUsIGNiKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9lbGVtZW50JHByb3BzO1xuXG4gICAgZWxlbWVudC5wcm9wc1tuYW1lXSAmJiAoX2VsZW1lbnQkcHJvcHMgPSBlbGVtZW50LnByb3BzKVtuYW1lXS5hcHBseShfZWxlbWVudCRwcm9wcywgYXJndW1lbnRzKTtcbiAgICBjYigpO1xuICB9O1xufTtcblxudmFyIGxlYXZlUmVuZGVycyA9IChfbGVhdmVSZW5kZXJzID0ge30sIF9sZWF2ZVJlbmRlcnNbbW9kZXMub3V0XSA9IGZ1bmN0aW9uIChfcmVmKSB7XG4gIHZhciBjdXJyZW50ID0gX3JlZi5jdXJyZW50LFxuICAgICAgY2hhbmdlU3RhdGUgPSBfcmVmLmNoYW5nZVN0YXRlO1xuICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGN1cnJlbnQsIHtcbiAgICBpbjogZmFsc2UsXG4gICAgb25FeGl0ZWQ6IGNhbGxIb29rKGN1cnJlbnQsICdvbkV4aXRlZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNoYW5nZVN0YXRlKEVOVEVSSU5HLCBudWxsKTtcbiAgICB9KVxuICB9KTtcbn0sIF9sZWF2ZVJlbmRlcnNbbW9kZXMuaW5dID0gZnVuY3Rpb24gKF9yZWYyKSB7XG4gIHZhciBjdXJyZW50ID0gX3JlZjIuY3VycmVudCxcbiAgICAgIGNoYW5nZVN0YXRlID0gX3JlZjIuY2hhbmdlU3RhdGUsXG4gICAgICBjaGlsZHJlbiA9IF9yZWYyLmNoaWxkcmVuO1xuICByZXR1cm4gW2N1cnJlbnQsIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgIGluOiB0cnVlLFxuICAgIG9uRW50ZXJlZDogY2FsbEhvb2soY2hpbGRyZW4sICdvbkVudGVyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFuZ2VTdGF0ZShFTlRFUklORyk7XG4gICAgfSlcbiAgfSldO1xufSwgX2xlYXZlUmVuZGVycyk7XG52YXIgZW50ZXJSZW5kZXJzID0gKF9lbnRlclJlbmRlcnMgPSB7fSwgX2VudGVyUmVuZGVyc1ttb2Rlcy5vdXRdID0gZnVuY3Rpb24gKF9yZWYzKSB7XG4gIHZhciBjaGlsZHJlbiA9IF9yZWYzLmNoaWxkcmVuLFxuICAgICAgY2hhbmdlU3RhdGUgPSBfcmVmMy5jaGFuZ2VTdGF0ZTtcbiAgcmV0dXJuIFJlYWN0LmNsb25lRWxlbWVudChjaGlsZHJlbiwge1xuICAgIGluOiB0cnVlLFxuICAgIG9uRW50ZXJlZDogY2FsbEhvb2soY2hpbGRyZW4sICdvbkVudGVyZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFuZ2VTdGF0ZShFTlRFUkVELCBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgaW46IHRydWVcbiAgICAgIH0pKTtcbiAgICB9KVxuICB9KTtcbn0sIF9lbnRlclJlbmRlcnNbbW9kZXMuaW5dID0gZnVuY3Rpb24gKF9yZWY0KSB7XG4gIHZhciBjdXJyZW50ID0gX3JlZjQuY3VycmVudCxcbiAgICAgIGNoaWxkcmVuID0gX3JlZjQuY2hpbGRyZW4sXG4gICAgICBjaGFuZ2VTdGF0ZSA9IF9yZWY0LmNoYW5nZVN0YXRlO1xuICByZXR1cm4gW1JlYWN0LmNsb25lRWxlbWVudChjdXJyZW50LCB7XG4gICAgaW46IGZhbHNlLFxuICAgIG9uRXhpdGVkOiBjYWxsSG9vayhjdXJyZW50LCAnb25FeGl0ZWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFuZ2VTdGF0ZShFTlRFUkVELCBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICAgICAgaW46IHRydWVcbiAgICAgIH0pKTtcbiAgICB9KVxuICB9KSwgUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7XG4gICAgaW46IHRydWVcbiAgfSldO1xufSwgX2VudGVyUmVuZGVycyk7XG4vKipcbiAqIEEgdHJhbnNpdGlvbiBjb21wb25lbnQgaW5zcGlyZWQgYnkgdGhlIFt2dWUgdHJhbnNpdGlvbiBtb2Rlc10oaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvdHJhbnNpdGlvbnMuaHRtbCNUcmFuc2l0aW9uLU1vZGVzKS5cbiAqIFlvdSBjYW4gdXNlIGl0IHdoZW4geW91IHdhbnQgdG8gY29udHJvbCB0aGUgcmVuZGVyIGJldHdlZW4gc3RhdGUgdHJhbnNpdGlvbnMuXG4gKiBCYXNlZCBvbiB0aGUgc2VsZWN0ZWQgbW9kZSBhbmQgdGhlIGNoaWxkJ3Mga2V5IHdoaWNoIGlzIHRoZSBgVHJhbnNpdGlvbmAgb3IgYENTU1RyYW5zaXRpb25gIGNvbXBvbmVudCwgdGhlIGBTd2l0Y2hUcmFuc2l0aW9uYCBtYWtlcyBhIGNvbnNpc3RlbnQgdHJhbnNpdGlvbiBiZXR3ZWVuIHRoZW0uXG4gKlxuICogSWYgdGhlIGBvdXQtaW5gIG1vZGUgaXMgc2VsZWN0ZWQsIHRoZSBgU3dpdGNoVHJhbnNpdGlvbmAgd2FpdHMgdW50aWwgdGhlIG9sZCBjaGlsZCBsZWF2ZXMgYW5kIHRoZW4gaW5zZXJ0cyBhIG5ldyBjaGlsZC5cbiAqIElmIHRoZSBgaW4tb3V0YCBtb2RlIGlzIHNlbGVjdGVkLCB0aGUgYFN3aXRjaFRyYW5zaXRpb25gIGluc2VydHMgYSBuZXcgY2hpbGQgZmlyc3QsIHdhaXRzIGZvciB0aGUgbmV3IGNoaWxkIHRvIGVudGVyIGFuZCB0aGVuIHJlbW92ZXMgdGhlIG9sZCBjaGlsZC5cbiAqXG4gKiAqKk5vdGUqKjogSWYgeW91IHdhbnQgdGhlIGFuaW1hdGlvbiB0byBoYXBwZW4gc2ltdWx0YW5lb3VzbHlcbiAqICh0aGF0IGlzLCB0byBoYXZlIHRoZSBvbGQgY2hpbGQgcmVtb3ZlZCBhbmQgYSBuZXcgY2hpbGQgaW5zZXJ0ZWQgKiphdCB0aGUgc2FtZSB0aW1lKiopLFxuICogeW91IHNob3VsZCB1c2VcbiAqIFtgVHJhbnNpdGlvbkdyb3VwYF0oaHR0cHM6Ly9yZWFjdGNvbW11bml0eS5vcmcvcmVhY3QtdHJhbnNpdGlvbi1ncm91cC90cmFuc2l0aW9uLWdyb3VwKVxuICogaW5zdGVhZC5cbiAqXG4gKiBgYGBqc3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAqICByZXR1cm4gKFxuICogICAgPFN3aXRjaFRyYW5zaXRpb24+XG4gKiAgICAgIDxDU1NUcmFuc2l0aW9uXG4gKiAgICAgICAga2V5PXtzdGF0ZSA/IFwiR29vZGJ5ZSwgd29ybGQhXCIgOiBcIkhlbGxvLCB3b3JsZCFcIn1cbiAqICAgICAgICBhZGRFbmRMaXN0ZW5lcj17KG5vZGUsIGRvbmUpID0+IG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZG9uZSwgZmFsc2UpfVxuICogICAgICAgIGNsYXNzTmFtZXM9J2ZhZGUnXG4gKiAgICAgID5cbiAqICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNldFN0YXRlKHN0YXRlID0+ICFzdGF0ZSl9PlxuICogICAgICAgICAge3N0YXRlID8gXCJHb29kYnllLCB3b3JsZCFcIiA6IFwiSGVsbG8sIHdvcmxkIVwifVxuICogICAgICAgIDwvYnV0dG9uPlxuICogICAgICA8L0NTU1RyYW5zaXRpb24+XG4gKiAgICA8L1N3aXRjaFRyYW5zaXRpb24+XG4gKiAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIGBgYGNzc1xuICogLmZhZGUtZW50ZXJ7XG4gKiAgICBvcGFjaXR5OiAwO1xuICogfVxuICogLmZhZGUtZXhpdHtcbiAqICAgIG9wYWNpdHk6IDE7XG4gKiB9XG4gKiAuZmFkZS1lbnRlci1hY3RpdmV7XG4gKiAgICBvcGFjaXR5OiAxO1xuICogfVxuICogLmZhZGUtZXhpdC1hY3RpdmV7XG4gKiAgICBvcGFjaXR5OiAwO1xuICogfVxuICogLmZhZGUtZW50ZXItYWN0aXZlLFxuICogLmZhZGUtZXhpdC1hY3RpdmV7XG4gKiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDUwMG1zO1xuICogfVxuICogYGBgXG4gKi9cblxudmFyIFN3aXRjaFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3dpdGNoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gU3dpdGNoVHJhbnNpdGlvbigpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfUmVhY3QkQ29tcG9uZW50LmNhbGwuYXBwbHkoX1JlYWN0JENvbXBvbmVudCwgW3RoaXNdLmNvbmNhdChhcmdzKSkgfHwgdGhpcztcbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogRU5URVJFRCxcbiAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICB9O1xuICAgIF90aGlzLmFwcGVhcmVkID0gZmFsc2U7XG5cbiAgICBfdGhpcy5jaGFuZ2VTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0dXMsIGN1cnJlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50ID09PSB2b2lkIDApIHtcbiAgICAgICAgY3VycmVudCA9IF90aGlzLnN0YXRlLmN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnRcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU3dpdGNoVHJhbnNpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgdGhpcy5hcHBlYXJlZCA9IHRydWU7XG4gIH07XG5cbiAgU3dpdGNoVHJhbnNpdGlvbi5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBmdW5jdGlvbiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgaWYgKHByb3BzLmNoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnN0YXR1cyA9PT0gRU5URVJJTkcgJiYgcHJvcHMubW9kZSA9PT0gbW9kZXMuaW4pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogRU5URVJJTkdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLmN1cnJlbnQgJiYgYXJlQ2hpbGRyZW5EaWZmZXJlbnQoc3RhdGUuY3VycmVudCwgcHJvcHMuY2hpbGRyZW4pKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRJTkdcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnQ6IFJlYWN0LmNsb25lRWxlbWVudChwcm9wcy5jaGlsZHJlbiwge1xuICAgICAgICBpbjogdHJ1ZVxuICAgICAgfSlcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgY2hpbGRyZW4gPSBfdGhpcyRwcm9wcy5jaGlsZHJlbixcbiAgICAgICAgbW9kZSA9IF90aGlzJHByb3BzLm1vZGUsXG4gICAgICAgIF90aGlzJHN0YXRlID0gdGhpcy5zdGF0ZSxcbiAgICAgICAgc3RhdHVzID0gX3RoaXMkc3RhdGUuc3RhdHVzLFxuICAgICAgICBjdXJyZW50ID0gX3RoaXMkc3RhdGUuY3VycmVudDtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICBjaGFuZ2VTdGF0ZTogdGhpcy5jaGFuZ2VTdGF0ZSxcbiAgICAgIHN0YXR1czogc3RhdHVzXG4gICAgfTtcbiAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgIGNhc2UgRU5URVJJTkc6XG4gICAgICAgIGNvbXBvbmVudCA9IGVudGVyUmVuZGVyc1ttb2RlXShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRVhJVElORzpcbiAgICAgICAgY29tcG9uZW50ID0gbGVhdmVSZW5kZXJzW21vZGVdKGRhdGEpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFTlRFUkVEOlxuICAgICAgICBjb21wb25lbnQgPSBjdXJyZW50O1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChUcmFuc2l0aW9uR3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZToge1xuICAgICAgICBpc01vdW50aW5nOiAhdGhpcy5hcHBlYXJlZFxuICAgICAgfVxuICAgIH0sIGNvbXBvbmVudCk7XG4gIH07XG5cbiAgcmV0dXJuIFN3aXRjaFRyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblN3aXRjaFRyYW5zaXRpb24ucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogVHJhbnNpdGlvbiBtb2Rlcy5cbiAgICogYG91dC1pbmA6IEN1cnJlbnQgZWxlbWVudCB0cmFuc2l0aW9ucyBvdXQgZmlyc3QsIHRoZW4gd2hlbiBjb21wbGV0ZSwgdGhlIG5ldyBlbGVtZW50IHRyYW5zaXRpb25zIGluLlxuICAgKiBgaW4tb3V0YDogTmV3IGVsZW1lbnQgdHJhbnNpdGlvbnMgaW4gZmlyc3QsIHRoZW4gd2hlbiBjb21wbGV0ZSwgdGhlIGN1cnJlbnQgZWxlbWVudCB0cmFuc2l0aW9ucyBvdXQuXG4gICAqXG4gICAqIEB0eXBlIHsnb3V0LWluJ3wnaW4tb3V0J31cbiAgICovXG4gIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbbW9kZXMuaW4sIG1vZGVzLm91dF0pLFxuXG4gIC8qKlxuICAgKiBBbnkgYFRyYW5zaXRpb25gIG9yIGBDU1NUcmFuc2l0aW9uYCBjb21wb25lbnQuXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZF0pXG59IDoge307XG5Td2l0Y2hUcmFuc2l0aW9uLmRlZmF1bHRQcm9wcyA9IHtcbiAgbW9kZTogbW9kZXMub3V0XG59O1xuZXhwb3J0IGRlZmF1bHQgU3dpdGNoVHJhbnNpdGlvbjsiLCJpbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2VcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgdGltZW91dHNTaGFwZSB9IGZyb20gJy4vdXRpbHMvUHJvcFR5cGVzJztcbmltcG9ydCBUcmFuc2l0aW9uR3JvdXBDb250ZXh0IGZyb20gJy4vVHJhbnNpdGlvbkdyb3VwQ29udGV4dCc7XG5leHBvcnQgdmFyIFVOTU9VTlRFRCA9ICd1bm1vdW50ZWQnO1xuZXhwb3J0IHZhciBFWElURUQgPSAnZXhpdGVkJztcbmV4cG9ydCB2YXIgRU5URVJJTkcgPSAnZW50ZXJpbmcnO1xuZXhwb3J0IHZhciBFTlRFUkVEID0gJ2VudGVyZWQnO1xuZXhwb3J0IHZhciBFWElUSU5HID0gJ2V4aXRpbmcnO1xuLyoqXG4gKiBUaGUgVHJhbnNpdGlvbiBjb21wb25lbnQgbGV0cyB5b3UgZGVzY3JpYmUgYSB0cmFuc2l0aW9uIGZyb20gb25lIGNvbXBvbmVudFxuICogc3RhdGUgdG8gYW5vdGhlciBfb3ZlciB0aW1lXyB3aXRoIGEgc2ltcGxlIGRlY2xhcmF0aXZlIEFQSS4gTW9zdCBjb21tb25seVxuICogaXQncyB1c2VkIHRvIGFuaW1hdGUgdGhlIG1vdW50aW5nIGFuZCB1bm1vdW50aW5nIG9mIGEgY29tcG9uZW50LCBidXQgY2FuIGFsc29cbiAqIGJlIHVzZWQgdG8gZGVzY3JpYmUgaW4tcGxhY2UgdHJhbnNpdGlvbiBzdGF0ZXMgYXMgd2VsbC5cbiAqXG4gKiAtLS1cbiAqXG4gKiAqKk5vdGUqKjogYFRyYW5zaXRpb25gIGlzIGEgcGxhdGZvcm0tYWdub3N0aWMgYmFzZSBjb21wb25lbnQuIElmIHlvdSdyZSB1c2luZ1xuICogdHJhbnNpdGlvbnMgaW4gQ1NTLCB5b3UnbGwgcHJvYmFibHkgd2FudCB0byB1c2VcbiAqIFtgQ1NTVHJhbnNpdGlvbmBdKGh0dHBzOi8vcmVhY3Rjb21tdW5pdHkub3JnL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvY3NzLXRyYW5zaXRpb24pXG4gKiBpbnN0ZWFkLiBJdCBpbmhlcml0cyBhbGwgdGhlIGZlYXR1cmVzIG9mIGBUcmFuc2l0aW9uYCwgYnV0IGNvbnRhaW5zXG4gKiBhZGRpdGlvbmFsIGZlYXR1cmVzIG5lY2Vzc2FyeSB0byBwbGF5IG5pY2Ugd2l0aCBDU1MgdHJhbnNpdGlvbnMgKGhlbmNlIHRoZVxuICogbmFtZSBvZiB0aGUgY29tcG9uZW50KS5cbiAqXG4gKiAtLS1cbiAqXG4gKiBCeSBkZWZhdWx0IHRoZSBgVHJhbnNpdGlvbmAgY29tcG9uZW50IGRvZXMgbm90IGFsdGVyIHRoZSBiZWhhdmlvciBvZiB0aGVcbiAqIGNvbXBvbmVudCBpdCByZW5kZXJzLCBpdCBvbmx5IHRyYWNrcyBcImVudGVyXCIgYW5kIFwiZXhpdFwiIHN0YXRlcyBmb3IgdGhlXG4gKiBjb21wb25lbnRzLiBJdCdzIHVwIHRvIHlvdSB0byBnaXZlIG1lYW5pbmcgYW5kIGVmZmVjdCB0byB0aG9zZSBzdGF0ZXMuIEZvclxuICogZXhhbXBsZSB3ZSBjYW4gYWRkIHN0eWxlcyB0byBhIGNvbXBvbmVudCB3aGVuIGl0IGVudGVycyBvciBleGl0czpcbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJztcbiAqXG4gKiBjb25zdCBkdXJhdGlvbiA9IDMwMDtcbiAqXG4gKiBjb25zdCBkZWZhdWx0U3R5bGUgPSB7XG4gKiAgIHRyYW5zaXRpb246IGBvcGFjaXR5ICR7ZHVyYXRpb259bXMgZWFzZS1pbi1vdXRgLFxuICogICBvcGFjaXR5OiAwLFxuICogfVxuICpcbiAqIGNvbnN0IHRyYW5zaXRpb25TdHlsZXMgPSB7XG4gKiAgIGVudGVyaW5nOiB7IG9wYWNpdHk6IDEgfSxcbiAqICAgZW50ZXJlZDogIHsgb3BhY2l0eTogMSB9LFxuICogICBleGl0aW5nOiAgeyBvcGFjaXR5OiAwIH0sXG4gKiAgIGV4aXRlZDogIHsgb3BhY2l0eTogMCB9LFxuICogfTtcbiAqXG4gKiBjb25zdCBGYWRlID0gKHsgaW46IGluUHJvcCB9KSA9PiAoXG4gKiAgIDxUcmFuc2l0aW9uIGluPXtpblByb3B9IHRpbWVvdXQ9e2R1cmF0aW9ufT5cbiAqICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgPGRpdiBzdHlsZT17e1xuICogICAgICAgICAuLi5kZWZhdWx0U3R5bGUsXG4gKiAgICAgICAgIC4uLnRyYW5zaXRpb25TdHlsZXNbc3RhdGVdXG4gKiAgICAgICB9fT5cbiAqICAgICAgICAgSSdtIGEgZmFkZSBUcmFuc2l0aW9uIVxuICogICAgICAgPC9kaXY+XG4gKiAgICAgKX1cbiAqICAgPC9UcmFuc2l0aW9uPlxuICogKTtcbiAqIGBgYFxuICpcbiAqIFRoZXJlIGFyZSA0IG1haW4gc3RhdGVzIGEgVHJhbnNpdGlvbiBjYW4gYmUgaW46XG4gKiAgLSBgJ2VudGVyaW5nJ2BcbiAqICAtIGAnZW50ZXJlZCdgXG4gKiAgLSBgJ2V4aXRpbmcnYFxuICogIC0gYCdleGl0ZWQnYFxuICpcbiAqIFRyYW5zaXRpb24gc3RhdGUgaXMgdG9nZ2xlZCB2aWEgdGhlIGBpbmAgcHJvcC4gV2hlbiBgdHJ1ZWAgdGhlIGNvbXBvbmVudFxuICogYmVnaW5zIHRoZSBcIkVudGVyXCIgc3RhZ2UuIER1cmluZyB0aGlzIHN0YWdlLCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgZnJvbVxuICogaXRzIGN1cnJlbnQgdHJhbnNpdGlvbiBzdGF0ZSwgdG8gYCdlbnRlcmluZydgIGZvciB0aGUgZHVyYXRpb24gb2YgdGhlXG4gKiB0cmFuc2l0aW9uIGFuZCB0aGVuIHRvIHRoZSBgJ2VudGVyZWQnYCBzdGFnZSBvbmNlIGl0J3MgY29tcGxldGUuIExldCdzIHRha2VcbiAqIHRoZSBmb2xsb3dpbmcgZXhhbXBsZSAod2UnbGwgdXNlIHRoZVxuICogW3VzZVN0YXRlXShodHRwczovL3JlYWN0anMub3JnL2RvY3MvaG9va3MtcmVmZXJlbmNlLmh0bWwjdXNlc3RhdGUpIGhvb2spOlxuICpcbiAqIGBgYGpzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBbaW5Qcm9wLCBzZXRJblByb3BdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogICByZXR1cm4gKFxuICogICAgIDxkaXY+XG4gKiAgICAgICA8VHJhbnNpdGlvbiBpbj17aW5Qcm9wfSB0aW1lb3V0PXs1MDB9PlxuICogICAgICAgICB7c3RhdGUgPT4gKFxuICogICAgICAgICAgIC8vIC4uLlxuICogICAgICAgICApfVxuICogICAgICAgPC9UcmFuc2l0aW9uPlxuICogICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzZXRJblByb3AodHJ1ZSl9PlxuICogICAgICAgICBDbGljayB0byBFbnRlclxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBXaGVuIHRoZSBidXR0b24gaXMgY2xpY2tlZCB0aGUgY29tcG9uZW50IHdpbGwgc2hpZnQgdG8gdGhlIGAnZW50ZXJpbmcnYCBzdGF0ZVxuICogYW5kIHN0YXkgdGhlcmUgZm9yIDUwMG1zICh0aGUgdmFsdWUgb2YgYHRpbWVvdXRgKSBiZWZvcmUgaXQgZmluYWxseSBzd2l0Y2hlc1xuICogdG8gYCdlbnRlcmVkJ2AuXG4gKlxuICogV2hlbiBgaW5gIGlzIGBmYWxzZWAgdGhlIHNhbWUgdGhpbmcgaGFwcGVucyBleGNlcHQgdGhlIHN0YXRlIG1vdmVzIGZyb21cbiAqIGAnZXhpdGluZydgIHRvIGAnZXhpdGVkJ2AuXG4gKi9cblxudmFyIFRyYW5zaXRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoVHJhbnNpdGlvbiwgX1JlYWN0JENvbXBvbmVudCk7XG5cbiAgZnVuY3Rpb24gVHJhbnNpdGlvbihwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuICAgIHZhciBwYXJlbnRHcm91cCA9IGNvbnRleHQ7IC8vIEluIHRoZSBjb250ZXh0IG9mIGEgVHJhbnNpdGlvbkdyb3VwIGFsbCBlbnRlcnMgYXJlIHJlYWxseSBhcHBlYXJzXG5cbiAgICB2YXIgYXBwZWFyID0gcGFyZW50R3JvdXAgJiYgIXBhcmVudEdyb3VwLmlzTW91bnRpbmcgPyBwcm9wcy5lbnRlciA6IHByb3BzLmFwcGVhcjtcbiAgICB2YXIgaW5pdGlhbFN0YXR1cztcbiAgICBfdGhpcy5hcHBlYXJTdGF0dXMgPSBudWxsO1xuXG4gICAgaWYgKHByb3BzLmluKSB7XG4gICAgICBpZiAoYXBwZWFyKSB7XG4gICAgICAgIGluaXRpYWxTdGF0dXMgPSBFWElURUQ7XG4gICAgICAgIF90aGlzLmFwcGVhclN0YXR1cyA9IEVOVEVSSU5HO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVOVEVSRUQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wcy51bm1vdW50T25FeGl0IHx8IHByb3BzLm1vdW50T25FbnRlcikge1xuICAgICAgICBpbml0aWFsU3RhdHVzID0gVU5NT1VOVEVEO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbFN0YXR1cyA9IEVYSVRFRDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgIHN0YXR1czogaW5pdGlhbFN0YXR1c1xuICAgIH07XG4gICAgX3RoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBUcmFuc2l0aW9uLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhfcmVmLCBwcmV2U3RhdGUpIHtcbiAgICB2YXIgbmV4dEluID0gX3JlZi5pbjtcblxuICAgIGlmIChuZXh0SW4gJiYgcHJldlN0YXRlLnN0YXR1cyA9PT0gVU5NT1VOVEVEKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgLy8gICBsZXQgbmV4dFN0YXR1cyA9IG51bGxcbiAgLy8gICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gIC8vICAgICBjb25zdCB7IHN0YXR1cyB9ID0gdGhpcy5zdGF0ZVxuICAvLyAgICAgaWYgKHRoaXMucHJvcHMuaW4pIHtcbiAgLy8gICAgICAgaWYgKHN0YXR1cyAhPT0gRU5URVJJTkcgJiYgc3RhdHVzICE9PSBFTlRFUkVEKSB7XG4gIC8vICAgICAgICAgbmV4dFN0YXR1cyA9IEVOVEVSSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIGlmIChzdGF0dXMgPT09IEVOVEVSSU5HIHx8IHN0YXR1cyA9PT0gRU5URVJFRCkge1xuICAvLyAgICAgICAgIG5leHRTdGF0dXMgPSBFWElUSU5HXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgcmV0dXJuIHsgbmV4dFN0YXR1cyB9XG4gIC8vIH1cbiAgO1xuXG4gIHZhciBfcHJvdG8gPSBUcmFuc2l0aW9uLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyh0cnVlLCB0aGlzLmFwcGVhclN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICB2YXIgbmV4dFN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAocHJldlByb3BzICE9PSB0aGlzLnByb3BzKSB7XG4gICAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICAgIGlmICh0aGlzLnByb3BzLmluKSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IEVOVEVSSU5HICYmIHN0YXR1cyAhPT0gRU5URVJFRCkge1xuICAgICAgICAgIG5leHRTdGF0dXMgPSBFTlRFUklORztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gRU5URVJJTkcgfHwgc3RhdHVzID09PSBFTlRFUkVEKSB7XG4gICAgICAgICAgbmV4dFN0YXR1cyA9IEVYSVRJTkc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVN0YXR1cyhmYWxzZSwgbmV4dFN0YXR1cyk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5jYW5jZWxOZXh0Q2FsbGJhY2soKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGltZW91dHMgPSBmdW5jdGlvbiBnZXRUaW1lb3V0cygpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMucHJvcHMudGltZW91dDtcbiAgICB2YXIgZXhpdCwgZW50ZXIsIGFwcGVhcjtcbiAgICBleGl0ID0gZW50ZXIgPSBhcHBlYXIgPSB0aW1lb3V0O1xuXG4gICAgaWYgKHRpbWVvdXQgIT0gbnVsbCAmJiB0eXBlb2YgdGltZW91dCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGV4aXQgPSB0aW1lb3V0LmV4aXQ7XG4gICAgICBlbnRlciA9IHRpbWVvdXQuZW50ZXI7IC8vIFRPRE86IHJlbW92ZSBmYWxsYmFjayBmb3IgbmV4dCBtYWpvclxuXG4gICAgICBhcHBlYXIgPSB0aW1lb3V0LmFwcGVhciAhPT0gdW5kZWZpbmVkID8gdGltZW91dC5hcHBlYXIgOiBlbnRlcjtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZXhpdDogZXhpdCxcbiAgICAgIGVudGVyOiBlbnRlcixcbiAgICAgIGFwcGVhcjogYXBwZWFyXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlU3RhdHVzID0gZnVuY3Rpb24gdXBkYXRlU3RhdHVzKG1vdW50aW5nLCBuZXh0U3RhdHVzKSB7XG4gICAgaWYgKG1vdW50aW5nID09PSB2b2lkIDApIHtcbiAgICAgIG1vdW50aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKG5leHRTdGF0dXMgIT09IG51bGwpIHtcbiAgICAgIC8vIG5leHRTdGF0dXMgd2lsbCBhbHdheXMgYmUgRU5URVJJTkcgb3IgRVhJVElORy5cbiAgICAgIHRoaXMuY2FuY2VsTmV4dENhbGxiYWNrKCk7XG5cbiAgICAgIGlmIChuZXh0U3RhdHVzID09PSBFTlRFUklORykge1xuICAgICAgICB0aGlzLnBlcmZvcm1FbnRlcihtb3VudGluZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBlcmZvcm1FeGl0KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnByb3BzLnVubW91bnRPbkV4aXQgJiYgdGhpcy5zdGF0ZS5zdGF0dXMgPT09IEVYSVRFRCkge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogVU5NT1VOVEVEXG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FbnRlciA9IGZ1bmN0aW9uIHBlcmZvcm1FbnRlcihtb3VudGluZykge1xuICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgdmFyIGVudGVyID0gdGhpcy5wcm9wcy5lbnRlcjtcbiAgICB2YXIgYXBwZWFyaW5nID0gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0LmlzTW91bnRpbmcgOiBtb3VudGluZztcblxuICAgIHZhciBfcmVmMiA9IHRoaXMucHJvcHMubm9kZVJlZiA/IFthcHBlYXJpbmddIDogW1JlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpLCBhcHBlYXJpbmddLFxuICAgICAgICBtYXliZU5vZGUgPSBfcmVmMlswXSxcbiAgICAgICAgbWF5YmVBcHBlYXJpbmcgPSBfcmVmMlsxXTtcblxuICAgIHZhciB0aW1lb3V0cyA9IHRoaXMuZ2V0VGltZW91dHMoKTtcbiAgICB2YXIgZW50ZXJUaW1lb3V0ID0gYXBwZWFyaW5nID8gdGltZW91dHMuYXBwZWFyIDogdGltZW91dHMuZW50ZXI7IC8vIG5vIGVudGVyIGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVOVEVSRURcbiAgICAvLyBpZiB3ZSBhcmUgbW91bnRpbmcgYW5kIHJ1bm5pbmcgdGhpcyBpdCBtZWFucyBhcHBlYXIgX211c3RfIGJlIHNldFxuXG4gICAgaWYgKCFtb3VudGluZyAmJiAhZW50ZXIgfHwgY29uZmlnLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgIHN0YXR1czogRU5URVJFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIucHJvcHMub25FbnRlcmVkKG1heWJlTm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByb3BzLm9uRW50ZXIobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFTlRFUklOR1xuICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyaW5nKG1heWJlTm9kZSwgbWF5YmVBcHBlYXJpbmcpO1xuXG4gICAgICBfdGhpczIub25UcmFuc2l0aW9uRW5kKGVudGVyVGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2FmZVNldFN0YXRlKHtcbiAgICAgICAgICBzdGF0dXM6IEVOVEVSRURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5wcm9wcy5vbkVudGVyZWQobWF5YmVOb2RlLCBtYXliZUFwcGVhcmluZyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLnBlcmZvcm1FeGl0ID0gZnVuY3Rpb24gcGVyZm9ybUV4aXQoKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgZXhpdCA9IHRoaXMucHJvcHMuZXhpdDtcbiAgICB2YXIgdGltZW91dHMgPSB0aGlzLmdldFRpbWVvdXRzKCk7XG4gICAgdmFyIG1heWJlTm9kZSA9IHRoaXMucHJvcHMubm9kZVJlZiA/IHVuZGVmaW5lZCA6IFJlYWN0RE9NLmZpbmRET01Ob2RlKHRoaXMpOyAvLyBubyBleGl0IGFuaW1hdGlvbiBza2lwIHJpZ2h0IHRvIEVYSVRFRFxuXG4gICAgaWYgKCFleGl0IHx8IGNvbmZpZy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICBzdGF0dXM6IEVYSVRFRFxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczMucHJvcHMub25FeGl0ZWQobWF5YmVOb2RlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJvcHMub25FeGl0KG1heWJlTm9kZSk7XG4gICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgc3RhdHVzOiBFWElUSU5HXG4gICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMzLnByb3BzLm9uRXhpdGluZyhtYXliZU5vZGUpO1xuXG4gICAgICBfdGhpczMub25UcmFuc2l0aW9uRW5kKHRpbWVvdXRzLmV4aXQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnNhZmVTZXRTdGF0ZSh7XG4gICAgICAgICAgc3RhdHVzOiBFWElURURcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5wcm9wcy5vbkV4aXRlZChtYXliZU5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5jYW5jZWxOZXh0Q2FsbGJhY2sgPSBmdW5jdGlvbiBjYW5jZWxOZXh0Q2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMubmV4dENhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwoKTtcbiAgICAgIHRoaXMubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNhZmVTZXRTdGF0ZSA9IGZ1bmN0aW9uIHNhZmVTZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgbmVjZXNzYXJ5LCBidXQgdGhlcmUgYXJlIHdlaXJkIHJhY2UgY29uZGl0aW9ucyB3aXRoXG4gICAgLy8gc2V0U3RhdGUgY2FsbGJhY2tzIGFuZCB1bm1vdW50aW5nIGluIHRlc3RpbmcsIHNvIGFsd2F5cyBtYWtlIHN1cmUgdGhhdFxuICAgIC8vIHdlIGNhbiBjYW5jZWwgYW55IHBlbmRpbmcgc2V0U3RhdGUgY2FsbGJhY2tzIGFmdGVyIHdlIHVubW91bnQuXG4gICAgY2FsbGJhY2sgPSB0aGlzLnNldE5leHRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGNhbGxiYWNrKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TmV4dENhbGxiYWNrID0gZnVuY3Rpb24gc2V0TmV4dENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB2YXIgYWN0aXZlID0gdHJ1ZTtcblxuICAgIHRoaXMubmV4dENhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQubmV4dENhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXZlbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm5leHRDYWxsYmFjay5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBhY3RpdmUgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMubmV4dENhbGxiYWNrO1xuICB9O1xuXG4gIF9wcm90by5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiBvblRyYW5zaXRpb25FbmQodGltZW91dCwgaGFuZGxlcikge1xuICAgIHRoaXMuc2V0TmV4dENhbGxiYWNrKGhhbmRsZXIpO1xuICAgIHZhciBub2RlID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gdGhpcy5wcm9wcy5ub2RlUmVmLmN1cnJlbnQgOiBSZWFjdERPTS5maW5kRE9NTm9kZSh0aGlzKTtcbiAgICB2YXIgZG9lc05vdEhhdmVUaW1lb3V0T3JMaXN0ZW5lciA9IHRpbWVvdXQgPT0gbnVsbCAmJiAhdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcjtcblxuICAgIGlmICghbm9kZSB8fCBkb2VzTm90SGF2ZVRpbWVvdXRPckxpc3RlbmVyKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcikge1xuICAgICAgdmFyIF9yZWYzID0gdGhpcy5wcm9wcy5ub2RlUmVmID8gW3RoaXMubmV4dENhbGxiYWNrXSA6IFtub2RlLCB0aGlzLm5leHRDYWxsYmFja10sXG4gICAgICAgICAgbWF5YmVOb2RlID0gX3JlZjNbMF0sXG4gICAgICAgICAgbWF5YmVOZXh0Q2FsbGJhY2sgPSBfcmVmM1sxXTtcblxuICAgICAgdGhpcy5wcm9wcy5hZGRFbmRMaXN0ZW5lcihtYXliZU5vZGUsIG1heWJlTmV4dENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMubmV4dENhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgc3RhdHVzID0gdGhpcy5zdGF0ZS5zdGF0dXM7XG5cbiAgICBpZiAoc3RhdHVzID09PSBVTk1PVU5URUQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgIGNoaWxkcmVuID0gX3RoaXMkcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgIF9pbiA9IF90aGlzJHByb3BzLmluLFxuICAgICAgICBfbW91bnRPbkVudGVyID0gX3RoaXMkcHJvcHMubW91bnRPbkVudGVyLFxuICAgICAgICBfdW5tb3VudE9uRXhpdCA9IF90aGlzJHByb3BzLnVubW91bnRPbkV4aXQsXG4gICAgICAgIF9hcHBlYXIgPSBfdGhpcyRwcm9wcy5hcHBlYXIsXG4gICAgICAgIF9lbnRlciA9IF90aGlzJHByb3BzLmVudGVyLFxuICAgICAgICBfZXhpdCA9IF90aGlzJHByb3BzLmV4aXQsXG4gICAgICAgIF90aW1lb3V0ID0gX3RoaXMkcHJvcHMudGltZW91dCxcbiAgICAgICAgX2FkZEVuZExpc3RlbmVyID0gX3RoaXMkcHJvcHMuYWRkRW5kTGlzdGVuZXIsXG4gICAgICAgIF9vbkVudGVyID0gX3RoaXMkcHJvcHMub25FbnRlcixcbiAgICAgICAgX29uRW50ZXJpbmcgPSBfdGhpcyRwcm9wcy5vbkVudGVyaW5nLFxuICAgICAgICBfb25FbnRlcmVkID0gX3RoaXMkcHJvcHMub25FbnRlcmVkLFxuICAgICAgICBfb25FeGl0ID0gX3RoaXMkcHJvcHMub25FeGl0LFxuICAgICAgICBfb25FeGl0aW5nID0gX3RoaXMkcHJvcHMub25FeGl0aW5nLFxuICAgICAgICBfb25FeGl0ZWQgPSBfdGhpcyRwcm9wcy5vbkV4aXRlZCxcbiAgICAgICAgX25vZGVSZWYgPSBfdGhpcyRwcm9wcy5ub2RlUmVmLFxuICAgICAgICBjaGlsZFByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoX3RoaXMkcHJvcHMsIFtcImNoaWxkcmVuXCIsIFwiaW5cIiwgXCJtb3VudE9uRW50ZXJcIiwgXCJ1bm1vdW50T25FeGl0XCIsIFwiYXBwZWFyXCIsIFwiZW50ZXJcIiwgXCJleGl0XCIsIFwidGltZW91dFwiLCBcImFkZEVuZExpc3RlbmVyXCIsIFwib25FbnRlclwiLCBcIm9uRW50ZXJpbmdcIiwgXCJvbkVudGVyZWRcIiwgXCJvbkV4aXRcIiwgXCJvbkV4aXRpbmdcIiwgXCJvbkV4aXRlZFwiLCBcIm5vZGVSZWZcIl0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIC8qI19fUFVSRV9fKi9cbiAgICAgIC8vIGFsbG93cyBmb3IgbmVzdGVkIFRyYW5zaXRpb25zXG4gICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgdmFsdWU6IG51bGxcbiAgICAgIH0sIHR5cGVvZiBjaGlsZHJlbiA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkcmVuKHN0YXR1cywgY2hpbGRQcm9wcykgOiBSZWFjdC5jbG9uZUVsZW1lbnQoUmVhY3QuQ2hpbGRyZW4ub25seShjaGlsZHJlbiksIGNoaWxkUHJvcHMpKVxuICAgICk7XG4gIH07XG5cbiAgcmV0dXJuIFRyYW5zaXRpb247XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb24uY29udGV4dFR5cGUgPSBUcmFuc2l0aW9uR3JvdXBDb250ZXh0O1xuVHJhbnNpdGlvbi5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBBIFJlYWN0IHJlZmVyZW5jZSB0byBET00gZWxlbWVudCB0aGF0IG5lZWQgdG8gdHJhbnNpdGlvbjpcbiAgICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzUxMTI3MTMwLzQ2NzE5MzJcbiAgICpcbiAgICogICAtIFdoZW4gYG5vZGVSZWZgIHByb3AgaXMgdXNlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQgdG8gY2FsbGJhY2sgZnVuY3Rpb25zXG4gICAqICAgICAgKGUuZy4gYG9uRW50ZXJgKSBiZWNhdXNlIHVzZXIgYWxyZWFkeSBoYXMgZGlyZWN0IGFjY2VzcyB0byB0aGUgbm9kZS5cbiAgICogICAtIFdoZW4gY2hhbmdpbmcgYGtleWAgcHJvcCBvZiBgVHJhbnNpdGlvbmAgaW4gYSBgVHJhbnNpdGlvbkdyb3VwYCBhIG5ld1xuICAgKiAgICAgYG5vZGVSZWZgIG5lZWQgdG8gYmUgcHJvdmlkZWQgdG8gYFRyYW5zaXRpb25gIHdpdGggY2hhbmdlZCBga2V5YCBwcm9wXG4gICAqICAgICAoc2VlXG4gICAqICAgICBbdGVzdC9DU1NUcmFuc2l0aW9uLXRlc3QuanNdKGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAvYmxvYi8xMzQzNWY4OTdiM2FiNzFmNmUxOWQ3MjRmMTQ1NTk2ZjU5MTA1ODFjL3Rlc3QvQ1NTVHJhbnNpdGlvbi10ZXN0LmpzI0wzNjItTDQzNykpLlxuICAgKi9cbiAgbm9kZVJlZjogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBjdXJyZW50OiB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgPyBQcm9wVHlwZXMuYW55IDogZnVuY3Rpb24gKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BWYWx1ZVtrZXldO1xuICAgICAgcmV0dXJuIFByb3BUeXBlcy5pbnN0YW5jZU9mKHZhbHVlICYmICdvd25lckRvY3VtZW50JyBpbiB2YWx1ZSA/IHZhbHVlLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuRWxlbWVudCA6IEVsZW1lbnQpKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpO1xuICAgIH1cbiAgfSksXG5cbiAgLyoqXG4gICAqIEEgYGZ1bmN0aW9uYCBjaGlsZCBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIGEgUmVhY3QgZWxlbWVudC4gVGhpcyBmdW5jdGlvbiBpc1xuICAgKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB0cmFuc2l0aW9uIHN0YXR1cyAoYCdlbnRlcmluZydgLCBgJ2VudGVyZWQnYCxcbiAgICogYCdleGl0aW5nJ2AsIGAnZXhpdGVkJ2ApLCB3aGljaCBjYW4gYmUgdXNlZCB0byBhcHBseSBjb250ZXh0XG4gICAqIHNwZWNpZmljIHByb3BzIHRvIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogPFRyYW5zaXRpb24gaW49e3RoaXMuc3RhdGUuaW59IHRpbWVvdXQ9ezE1MH0+XG4gICAqICAge3N0YXRlID0+IChcbiAgICogICAgIDxNeUNvbXBvbmVudCBjbGFzc05hbWU9e2BmYWRlIGZhZGUtJHtzdGF0ZX1gfSAvPlxuICAgKiAgICl9XG4gICAqIDwvVHJhbnNpdGlvbj5cbiAgICogYGBgXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCwgUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZF0pLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFNob3cgdGhlIGNvbXBvbmVudDsgdHJpZ2dlcnMgdGhlIGVudGVyIG9yIGV4aXQgc3RhdGVzXG4gICAqL1xuICBpbjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQgdGhlIGNoaWxkIGNvbXBvbmVudCBpcyBtb3VudGVkIGltbWVkaWF0ZWx5IGFsb25nIHdpdGhcbiAgICogdGhlIHBhcmVudCBgVHJhbnNpdGlvbmAgY29tcG9uZW50LiBJZiB5b3Ugd2FudCB0byBcImxhenkgbW91bnRcIiB0aGUgY29tcG9uZW50IG9uIHRoZVxuICAgKiBmaXJzdCBgaW49e3RydWV9YCB5b3UgY2FuIHNldCBgbW91bnRPbkVudGVyYC4gQWZ0ZXIgdGhlIGZpcnN0IGVudGVyIHRyYW5zaXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHN0YXlcbiAgICogbW91bnRlZCwgZXZlbiBvbiBcImV4aXRlZFwiLCB1bmxlc3MgeW91IGFsc28gc3BlY2lmeSBgdW5tb3VudE9uRXhpdGAuXG4gICAqL1xuICBtb3VudE9uRW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgc3RheXMgbW91bnRlZCBhZnRlciBpdCByZWFjaGVzIHRoZSBgJ2V4aXRlZCdgIHN0YXRlLlxuICAgKiBTZXQgYHVubW91bnRPbkV4aXRgIGlmIHlvdSdkIHByZWZlciB0byB1bm1vdW50IHRoZSBjb21wb25lbnQgYWZ0ZXIgaXQgZmluaXNoZXMgZXhpdGluZy5cbiAgICovXG4gIHVubW91bnRPbkV4aXQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0IHRoZSBjaGlsZCBjb21wb25lbnQgZG9lcyBub3QgcGVyZm9ybSB0aGUgZW50ZXIgdHJhbnNpdGlvbiB3aGVuXG4gICAqIGl0IGZpcnN0IG1vdW50cywgcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgYGluYC4gSWYgeW91IHdhbnQgdGhpc1xuICAgKiBiZWhhdmlvciwgc2V0IGJvdGggYGFwcGVhcmAgYW5kIGBpbmAgdG8gYHRydWVgLlxuICAgKlxuICAgKiA+ICoqTm90ZSoqOiB0aGVyZSBhcmUgbm8gc3BlY2lhbCBhcHBlYXIgc3RhdGVzIGxpa2UgYGFwcGVhcmluZ2AvYGFwcGVhcmVkYCwgdGhpcyBwcm9wXG4gICAqID4gb25seSBhZGRzIGFuIGFkZGl0aW9uYWwgZW50ZXIgdHJhbnNpdGlvbi4gSG93ZXZlciwgaW4gdGhlXG4gICAqID4gYDxDU1NUcmFuc2l0aW9uPmAgY29tcG9uZW50IHRoYXQgZmlyc3QgZW50ZXIgdHJhbnNpdGlvbiBkb2VzIHJlc3VsdCBpblxuICAgKiA+IGFkZGl0aW9uYWwgYC5hcHBlYXItKmAgY2xhc3NlcywgdGhhdCB3YXkgeW91IGNhbiBjaG9vc2UgdG8gc3R5bGUgaXRcbiAgICogPiBkaWZmZXJlbnRseS5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEVuYWJsZSBvciBkaXNhYmxlIGVudGVyIHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBleGl0IHRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiwgaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBSZXF1aXJlZCB1bmxlc3MgYGFkZEVuZExpc3RlbmVyYCBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogWW91IG1heSBzcGVjaWZ5IGEgc2luZ2xlIHRpbWVvdXQgZm9yIGFsbCB0cmFuc2l0aW9uczpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9ezUwMH1cbiAgICogYGBgXG4gICAqXG4gICAqIG9yIGluZGl2aWR1YWxseTpcbiAgICpcbiAgICogYGBganN4XG4gICAqIHRpbWVvdXQ9e3tcbiAgICogIGFwcGVhcjogNTAwLFxuICAgKiAgZW50ZXI6IDMwMCxcbiAgICogIGV4aXQ6IDUwMCxcbiAgICogfX1cbiAgICogYGBgXG4gICAqXG4gICAqIC0gYGFwcGVhcmAgZGVmYXVsdHMgdG8gdGhlIHZhbHVlIG9mIGBlbnRlcmBcbiAgICogLSBgZW50ZXJgIGRlZmF1bHRzIHRvIGAwYFxuICAgKiAtIGBleGl0YCBkZWZhdWx0cyB0byBgMGBcbiAgICpcbiAgICogQHR5cGUge251bWJlciB8IHsgZW50ZXI/OiBudW1iZXIsIGV4aXQ/OiBudW1iZXIsIGFwcGVhcj86IG51bWJlciB9fVxuICAgKi9cbiAgdGltZW91dDogZnVuY3Rpb24gdGltZW91dChwcm9wcykge1xuICAgIHZhciBwdCA9IHRpbWVvdXRzU2hhcGU7XG4gICAgaWYgKCFwcm9wcy5hZGRFbmRMaXN0ZW5lcikgcHQgPSBwdC5pc1JlcXVpcmVkO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHB0LmFwcGx5KHZvaWQgMCwgW3Byb3BzXS5jb25jYXQoYXJncykpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYSBjdXN0b20gdHJhbnNpdGlvbiBlbmQgdHJpZ2dlci4gQ2FsbGVkIHdpdGggdGhlIHRyYW5zaXRpb25pbmdcbiAgICogRE9NIG5vZGUgYW5kIGEgYGRvbmVgIGNhbGxiYWNrLiBBbGxvd3MgZm9yIG1vcmUgZmluZSBncmFpbmVkIHRyYW5zaXRpb24gZW5kXG4gICAqIGxvZ2ljLiBUaW1lb3V0cyBhcmUgc3RpbGwgdXNlZCBhcyBhIGZhbGxiYWNrIGlmIHByb3ZpZGVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBgYGBqc3hcbiAgICogYWRkRW5kTGlzdGVuZXI9eyhub2RlLCBkb25lKSA9PiB7XG4gICAqICAgLy8gdXNlIHRoZSBjc3MgdHJhbnNpdGlvbmVuZCBldmVudCB0byBtYXJrIHRoZSBmaW5pc2ggb2YgYSB0cmFuc2l0aW9uXG4gICAqICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgZG9uZSwgZmFsc2UpO1xuICAgKiB9fVxuICAgKiBgYGBcbiAgICovXG4gIGFkZEVuZExpc3RlbmVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImVudGVyaW5nXCIgc3RhdHVzIGlzIGFwcGxpZWQuIEFuIGV4dHJhIHBhcmFtZXRlclxuICAgKiBgaXNBcHBlYXJpbmdgIGlzIHN1cHBsaWVkIHRvIGluZGljYXRlIGlmIHRoZSBlbnRlciBzdGFnZSBpcyBvY2N1cnJpbmcgb24gdGhlIGluaXRpYWwgbW91bnRcbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQsIGlzQXBwZWFyaW5nOiBib29sKSAtPiB2b2lkXG4gICAqL1xuICBvbkVudGVyOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC4gQW4gZXh0cmEgcGFyYW1ldGVyXG4gICAqIGBpc0FwcGVhcmluZ2AgaXMgc3VwcGxpZWQgdG8gaW5kaWNhdGUgaWYgdGhlIGVudGVyIHN0YWdlIGlzIG9jY3VycmluZyBvbiB0aGUgaW5pdGlhbCBtb3VudFxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkLlxuICAgKlxuICAgKiBAdHlwZSBGdW5jdGlvbihub2RlOiBIdG1sRWxlbWVudCwgaXNBcHBlYXJpbmc6IGJvb2wpXG4gICAqL1xuICBvbkVudGVyaW5nOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYWZ0ZXIgdGhlIFwiZW50ZXJlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLiBBbiBleHRyYSBwYXJhbWV0ZXJcbiAgICogYGlzQXBwZWFyaW5nYCBpcyBzdXBwbGllZCB0byBpbmRpY2F0ZSBpZiB0aGUgZW50ZXIgc3RhZ2UgaXMgb2NjdXJyaW5nIG9uIHRoZSBpbml0aWFsIG1vdW50XG4gICAqXG4gICAqICoqTm90ZSoqOiB3aGVuIGBub2RlUmVmYCBwcm9wIGlzIHBhc3NlZCwgYG5vZGVgIGlzIG5vdCBwYXNzZWQuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50LCBpc0FwcGVhcmluZzogYm9vbCkgLT4gdm9pZFxuICAgKi9cbiAgb25FbnRlcmVkOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgZmlyZWQgYmVmb3JlIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdDogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRpbmdcIiBzdGF0dXMgaXMgYXBwbGllZC5cbiAgICpcbiAgICogKipOb3RlKio6IHdoZW4gYG5vZGVSZWZgIHByb3AgaXMgcGFzc2VkLCBgbm9kZWAgaXMgbm90IHBhc3NlZC5cbiAgICpcbiAgICogQHR5cGUgRnVuY3Rpb24obm9kZTogSHRtbEVsZW1lbnQpIC0+IHZvaWRcbiAgICovXG4gIG9uRXhpdGluZzogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGZpcmVkIGFmdGVyIHRoZSBcImV4aXRlZFwiIHN0YXR1cyBpcyBhcHBsaWVkLlxuICAgKlxuICAgKiAqKk5vdGUqKjogd2hlbiBgbm9kZVJlZmAgcHJvcCBpcyBwYXNzZWQsIGBub2RlYCBpcyBub3QgcGFzc2VkXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKG5vZGU6IEh0bWxFbGVtZW50KSAtPiB2b2lkXG4gICAqL1xuICBvbkV4aXRlZDogUHJvcFR5cGVzLmZ1bmNcbn0gOiB7fTsgLy8gTmFtZSB0aGUgZnVuY3Rpb24gc28gaXQgaXMgY2xlYXJlciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuXG5mdW5jdGlvbiBub29wKCkge31cblxuVHJhbnNpdGlvbi5kZWZhdWx0UHJvcHMgPSB7XG4gIGluOiBmYWxzZSxcbiAgbW91bnRPbkVudGVyOiBmYWxzZSxcbiAgdW5tb3VudE9uRXhpdDogZmFsc2UsXG4gIGFwcGVhcjogZmFsc2UsXG4gIGVudGVyOiB0cnVlLFxuICBleGl0OiB0cnVlLFxuICBvbkVudGVyOiBub29wLFxuICBvbkVudGVyaW5nOiBub29wLFxuICBvbkVudGVyZWQ6IG5vb3AsXG4gIG9uRXhpdDogbm9vcCxcbiAgb25FeGl0aW5nOiBub29wLFxuICBvbkV4aXRlZDogbm9vcFxufTtcblRyYW5zaXRpb24uVU5NT1VOVEVEID0gVU5NT1VOVEVEO1xuVHJhbnNpdGlvbi5FWElURUQgPSBFWElURUQ7XG5UcmFuc2l0aW9uLkVOVEVSSU5HID0gRU5URVJJTkc7XG5UcmFuc2l0aW9uLkVOVEVSRUQgPSBFTlRFUkVEO1xuVHJhbnNpdGlvbi5FWElUSU5HID0gRVhJVElORztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb247IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3NlcnRUaGlzSW5pdGlhbGl6ZWRcIjtcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNMb29zZVwiO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgVHJhbnNpdGlvbkdyb3VwQ29udGV4dCBmcm9tICcuL1RyYW5zaXRpb25Hcm91cENvbnRleHQnO1xuaW1wb3J0IHsgZ2V0Q2hpbGRNYXBwaW5nLCBnZXRJbml0aWFsQ2hpbGRNYXBwaW5nLCBnZXROZXh0Q2hpbGRNYXBwaW5nIH0gZnJvbSAnLi91dGlscy9DaGlsZE1hcHBpbmcnO1xuXG52YXIgdmFsdWVzID0gT2JqZWN0LnZhbHVlcyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBvYmpba107XG4gIH0pO1xufTtcblxudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgY29tcG9uZW50OiAnZGl2JyxcbiAgY2hpbGRGYWN0b3J5OiBmdW5jdGlvbiBjaGlsZEZhY3RvcnkoY2hpbGQpIHtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cbn07XG4vKipcbiAqIFRoZSBgPFRyYW5zaXRpb25Hcm91cD5gIGNvbXBvbmVudCBtYW5hZ2VzIGEgc2V0IG9mIHRyYW5zaXRpb24gY29tcG9uZW50c1xuICogKGA8VHJhbnNpdGlvbj5gIGFuZCBgPENTU1RyYW5zaXRpb24+YCkgaW4gYSBsaXN0LiBMaWtlIHdpdGggdGhlIHRyYW5zaXRpb25cbiAqIGNvbXBvbmVudHMsIGA8VHJhbnNpdGlvbkdyb3VwPmAgaXMgYSBzdGF0ZSBtYWNoaW5lIGZvciBtYW5hZ2luZyB0aGUgbW91bnRpbmdcbiAqIGFuZCB1bm1vdW50aW5nIG9mIGNvbXBvbmVudHMgb3ZlciB0aW1lLlxuICpcbiAqIENvbnNpZGVyIHRoZSBleGFtcGxlIGJlbG93LiBBcyBpdGVtcyBhcmUgcmVtb3ZlZCBvciBhZGRlZCB0byB0aGUgVG9kb0xpc3QgdGhlXG4gKiBgaW5gIHByb3AgaXMgdG9nZ2xlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBgPFRyYW5zaXRpb25Hcm91cD5gLlxuICpcbiAqIE5vdGUgdGhhdCBgPFRyYW5zaXRpb25Hcm91cD5gICBkb2VzIG5vdCBkZWZpbmUgYW55IGFuaW1hdGlvbiBiZWhhdmlvciFcbiAqIEV4YWN0bHkgX2hvd18gYSBsaXN0IGl0ZW0gYW5pbWF0ZXMgaXMgdXAgdG8gdGhlIGluZGl2aWR1YWwgdHJhbnNpdGlvblxuICogY29tcG9uZW50LiBUaGlzIG1lYW5zIHlvdSBjYW4gbWl4IGFuZCBtYXRjaCBhbmltYXRpb25zIGFjcm9zcyBkaWZmZXJlbnQgbGlzdFxuICogaXRlbXMuXG4gKi9cblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xuICBfaW5oZXJpdHNMb29zZShUcmFuc2l0aW9uR3JvdXAsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFRyYW5zaXRpb25Hcm91cChwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSB8fCB0aGlzO1xuXG4gICAgdmFyIGhhbmRsZUV4aXRlZCA9IF90aGlzLmhhbmRsZUV4aXRlZC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTsgLy8gSW5pdGlhbCBjaGlsZHJlbiBzaG91bGQgYWxsIGJlIGVudGVyaW5nLCBkZXBlbmRlbnQgb24gYXBwZWFyXG5cblxuICAgIF90aGlzLnN0YXRlID0ge1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IHRydWVcbiAgICAgIH0sXG4gICAgICBoYW5kbGVFeGl0ZWQ6IGhhbmRsZUV4aXRlZCxcbiAgICAgIGZpcnN0UmVuZGVyOiB0cnVlXG4gICAgfTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVHJhbnNpdGlvbkdyb3VwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLm1vdW50ZWQgPSB0cnVlO1xuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgY29udGV4dFZhbHVlOiB7XG4gICAgICAgIGlzTW91bnRpbmc6IGZhbHNlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gIH07XG5cbiAgVHJhbnNpdGlvbkdyb3VwLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGZ1bmN0aW9uIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIF9yZWYpIHtcbiAgICB2YXIgcHJldkNoaWxkTWFwcGluZyA9IF9yZWYuY2hpbGRyZW4sXG4gICAgICAgIGhhbmRsZUV4aXRlZCA9IF9yZWYuaGFuZGxlRXhpdGVkLFxuICAgICAgICBmaXJzdFJlbmRlciA9IF9yZWYuZmlyc3RSZW5kZXI7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoaWxkcmVuOiBmaXJzdFJlbmRlciA/IGdldEluaXRpYWxDaGlsZE1hcHBpbmcobmV4dFByb3BzLCBoYW5kbGVFeGl0ZWQpIDogZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIGhhbmRsZUV4aXRlZCksXG4gICAgICBmaXJzdFJlbmRlcjogZmFsc2VcbiAgICB9O1xuICB9IC8vIG5vZGUgaXMgYHVuZGVmaW5lZGAgd2hlbiB1c2VyIHByb3ZpZGVkIGBub2RlUmVmYCBwcm9wXG4gIDtcblxuICBfcHJvdG8uaGFuZGxlRXhpdGVkID0gZnVuY3Rpb24gaGFuZGxlRXhpdGVkKGNoaWxkLCBub2RlKSB7XG4gICAgdmFyIGN1cnJlbnRDaGlsZE1hcHBpbmcgPSBnZXRDaGlsZE1hcHBpbmcodGhpcy5wcm9wcy5jaGlsZHJlbik7XG4gICAgaWYgKGNoaWxkLmtleSBpbiBjdXJyZW50Q2hpbGRNYXBwaW5nKSByZXR1cm47XG5cbiAgICBpZiAoY2hpbGQucHJvcHMub25FeGl0ZWQpIHtcbiAgICAgIGNoaWxkLnByb3BzLm9uRXhpdGVkKG5vZGUpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgIHRoaXMuc2V0U3RhdGUoZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IF9leHRlbmRzKHt9LCBzdGF0ZS5jaGlsZHJlbik7XG5cbiAgICAgICAgZGVsZXRlIGNoaWxkcmVuW2NoaWxkLmtleV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzLFxuICAgICAgICBDb21wb25lbnQgPSBfdGhpcyRwcm9wcy5jb21wb25lbnQsXG4gICAgICAgIGNoaWxkRmFjdG9yeSA9IF90aGlzJHByb3BzLmNoaWxkRmFjdG9yeSxcbiAgICAgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfdGhpcyRwcm9wcywgW1wiY29tcG9uZW50XCIsIFwiY2hpbGRGYWN0b3J5XCJdKTtcblxuICAgIHZhciBjb250ZXh0VmFsdWUgPSB0aGlzLnN0YXRlLmNvbnRleHRWYWx1ZTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2YWx1ZXModGhpcy5zdGF0ZS5jaGlsZHJlbikubWFwKGNoaWxkRmFjdG9yeSk7XG4gICAgZGVsZXRlIHByb3BzLmFwcGVhcjtcbiAgICBkZWxldGUgcHJvcHMuZW50ZXI7XG4gICAgZGVsZXRlIHByb3BzLmV4aXQ7XG5cbiAgICBpZiAoQ29tcG9uZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVHJhbnNpdGlvbkdyb3VwQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogY29udGV4dFZhbHVlXG4gICAgICB9LCBjaGlsZHJlbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFRyYW5zaXRpb25Hcm91cENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0VmFsdWVcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzLCBjaGlsZHJlbikpO1xuICB9O1xuXG4gIHJldHVybiBUcmFuc2l0aW9uR3JvdXA7XG59KFJlYWN0LkNvbXBvbmVudCk7XG5cblRyYW5zaXRpb25Hcm91cC5wcm9wVHlwZXMgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gIC8qKlxuICAgKiBgPFRyYW5zaXRpb25Hcm91cD5gIHJlbmRlcnMgYSBgPGRpdj5gIGJ5IGRlZmF1bHQuIFlvdSBjYW4gY2hhbmdlIHRoaXNcbiAgICogYmVoYXZpb3IgYnkgcHJvdmlkaW5nIGEgYGNvbXBvbmVudGAgcHJvcC5cbiAgICogSWYgeW91IHVzZSBSZWFjdCB2MTYrIGFuZCB3b3VsZCBsaWtlIHRvIGF2b2lkIGEgd3JhcHBpbmcgYDxkaXY+YCBlbGVtZW50XG4gICAqIHlvdSBjYW4gcGFzcyBpbiBgY29tcG9uZW50PXtudWxsfWAuIFRoaXMgaXMgdXNlZnVsIGlmIHRoZSB3cmFwcGluZyBkaXZcbiAgICogYm9ya3MgeW91ciBjc3Mgc3R5bGVzLlxuICAgKi9cbiAgY29tcG9uZW50OiBQcm9wVHlwZXMuYW55LFxuXG4gIC8qKlxuICAgKiBBIHNldCBvZiBgPFRyYW5zaXRpb24+YCBjb21wb25lbnRzLCB0aGF0IGFyZSB0b2dnbGVkIGBpbmAgYW5kIG91dCBhcyB0aGV5XG4gICAqIGxlYXZlLiB0aGUgYDxUcmFuc2l0aW9uR3JvdXA+YCB3aWxsIGluamVjdCBzcGVjaWZpYyB0cmFuc2l0aW9uIHByb3BzLCBzb1xuICAgKiByZW1lbWJlciB0byBzcHJlYWQgdGhlbSB0aHJvdWdoIGlmIHlvdSBhcmUgd3JhcHBpbmcgdGhlIGA8VHJhbnNpdGlvbj5gIGFzXG4gICAqIHdpdGggb3VyIGA8RmFkZT5gIGV4YW1wbGUuXG4gICAqXG4gICAqIFdoaWxlIHRoaXMgY29tcG9uZW50IGlzIG1lYW50IGZvciBtdWx0aXBsZSBgVHJhbnNpdGlvbmAgb3IgYENTU1RyYW5zaXRpb25gXG4gICAqIGNoaWxkcmVuLCBzb21ldGltZXMgeW91IG1heSB3YW50IHRvIGhhdmUgYSBzaW5nbGUgdHJhbnNpdGlvbiBjaGlsZCB3aXRoXG4gICAqIGNvbnRlbnQgdGhhdCB5b3Ugd2FudCB0byBiZSB0cmFuc2l0aW9uZWQgb3V0IGFuZCBpbiB3aGVuIHlvdSBjaGFuZ2UgaXRcbiAgICogKGUuZy4gcm91dGVzLCBpbWFnZXMgZXRjLikgSW4gdGhhdCBjYXNlIHlvdSBjYW4gY2hhbmdlIHRoZSBga2V5YCBwcm9wIG9mXG4gICAqIHRoZSB0cmFuc2l0aW9uIGNoaWxkIGFzIHlvdSBjaGFuZ2UgaXRzIGNvbnRlbnQsIHRoaXMgd2lsbCBjYXVzZVxuICAgKiBgVHJhbnNpdGlvbkdyb3VwYCB0byB0cmFuc2l0aW9uIHRoZSBjaGlsZCBvdXQgYW5kIGJhY2sgaW4uXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGUsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICogZm9yIGFsbCBjaGlsZHJlbi4gTm90ZSB0aGF0IHNwZWNpZnlpbmcgdGhpcyB3aWxsIG92ZXJyaWRlIGFueSBkZWZhdWx0cyBzZXRcbiAgICogb24gaW5kaXZpZHVhbCBjaGlsZHJlbiBUcmFuc2l0aW9ucy5cbiAgICovXG4gIGFwcGVhcjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEEgY29udmVuaWVuY2UgcHJvcCB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgZW50ZXIgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZW50ZXI6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIHByb3AgdGhhdCBlbmFibGVzIG9yIGRpc2FibGVzIGV4aXQgYW5pbWF0aW9uc1xuICAgKiBmb3IgYWxsIGNoaWxkcmVuLiBOb3RlIHRoYXQgc3BlY2lmeWluZyB0aGlzIHdpbGwgb3ZlcnJpZGUgYW55IGRlZmF1bHRzIHNldFxuICAgKiBvbiBpbmRpdmlkdWFsIGNoaWxkcmVuIFRyYW5zaXRpb25zLlxuICAgKi9cbiAgZXhpdDogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIFlvdSBtYXkgbmVlZCB0byBhcHBseSByZWFjdGl2ZSB1cGRhdGVzIHRvIGEgY2hpbGQgYXMgaXQgaXMgZXhpdGluZy5cbiAgICogVGhpcyBpcyBnZW5lcmFsbHkgZG9uZSBieSB1c2luZyBgY2xvbmVFbGVtZW50YCBob3dldmVyIGluIHRoZSBjYXNlIG9mIGFuIGV4aXRpbmdcbiAgICogY2hpbGQgdGhlIGVsZW1lbnQgaGFzIGFscmVhZHkgYmVlbiByZW1vdmVkIGFuZCBub3QgYWNjZXNzaWJsZSB0byB0aGUgY29uc3VtZXIuXG4gICAqXG4gICAqIElmIHlvdSBkbyBuZWVkIHRvIHVwZGF0ZSBhIGNoaWxkIGFzIGl0IGxlYXZlcyB5b3UgY2FuIHByb3ZpZGUgYSBgY2hpbGRGYWN0b3J5YFxuICAgKiB0byB3cmFwIGV2ZXJ5IGNoaWxkLCBldmVuIHRoZSBvbmVzIHRoYXQgYXJlIGxlYXZpbmcuXG4gICAqXG4gICAqIEB0eXBlIEZ1bmN0aW9uKGNoaWxkOiBSZWFjdEVsZW1lbnQpIC0+IFJlYWN0RWxlbWVudFxuICAgKi9cbiAgY2hpbGRGYWN0b3J5OiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9O1xuVHJhbnNpdGlvbkdyb3VwLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25Hcm91cDsiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGRlZmF1bHQgUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTsiLCJleHBvcnQgZGVmYXVsdCB7XG4gIGRpc2FibGVkOiBmYWxzZVxufTsiLCJleHBvcnQgeyBkZWZhdWx0IGFzIENTU1RyYW5zaXRpb24gfSBmcm9tICcuL0NTU1RyYW5zaXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBSZXBsYWNlVHJhbnNpdGlvbiB9IGZyb20gJy4vUmVwbGFjZVRyYW5zaXRpb24nO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBTd2l0Y2hUcmFuc2l0aW9uIH0gZnJvbSAnLi9Td2l0Y2hUcmFuc2l0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVHJhbnNpdGlvbkdyb3VwIH0gZnJvbSAnLi9UcmFuc2l0aW9uR3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBUcmFuc2l0aW9uIH0gZnJvbSAnLi9UcmFuc2l0aW9uJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgY29uZmlnIH0gZnJvbSAnLi9jb25maWcnOyIsImltcG9ydCB7IENoaWxkcmVuLCBjbG9uZUVsZW1lbnQsIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuLyoqXG4gKiBHaXZlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmAsIHJldHVybiBhbiBvYmplY3QgbWFwcGluZyBrZXkgdG8gY2hpbGQuXG4gKlxuICogQHBhcmFtIHsqfSBjaGlsZHJlbiBgdGhpcy5wcm9wcy5jaGlsZHJlbmBcbiAqIEByZXR1cm4ge29iamVjdH0gTWFwcGluZyBvZiBrZXkgdG8gY2hpbGRcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hpbGRNYXBwaW5nKGNoaWxkcmVuLCBtYXBGbikge1xuICB2YXIgbWFwcGVyID0gZnVuY3Rpb24gbWFwcGVyKGNoaWxkKSB7XG4gICAgcmV0dXJuIG1hcEZuICYmIGlzVmFsaWRFbGVtZW50KGNoaWxkKSA/IG1hcEZuKGNoaWxkKSA6IGNoaWxkO1xuICB9O1xuXG4gIHZhciByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoY2hpbGRyZW4pIENoaWxkcmVuLm1hcChjaGlsZHJlbiwgZnVuY3Rpb24gKGMpIHtcbiAgICByZXR1cm4gYztcbiAgfSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAvLyBydW4gdGhlIG1hcCBmdW5jdGlvbiBoZXJlIGluc3RlYWQgc28gdGhhdCB0aGUga2V5IGlzIHRoZSBjb21wdXRlZCBvbmVcbiAgICByZXN1bHRbY2hpbGQua2V5XSA9IG1hcHBlcihjaGlsZCk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBXaGVuIHlvdSdyZSBhZGRpbmcgb3IgcmVtb3ZpbmcgY2hpbGRyZW4gc29tZSBtYXkgYmUgYWRkZWQgb3IgcmVtb3ZlZCBpbiB0aGVcbiAqIHNhbWUgcmVuZGVyIHBhc3MuIFdlIHdhbnQgdG8gc2hvdyAqYm90aCogc2luY2Ugd2Ugd2FudCB0byBzaW11bHRhbmVvdXNseVxuICogYW5pbWF0ZSBlbGVtZW50cyBpbiBhbmQgb3V0LiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgcHJldmlvdXMgc2V0IG9mIGtleXNcbiAqIGFuZCBhIG5ldyBzZXQgb2Yga2V5cyBhbmQgbWVyZ2VzIHRoZW0gd2l0aCBpdHMgYmVzdCBndWVzcyBvZiB0aGUgY29ycmVjdFxuICogb3JkZXJpbmcuIEluIHRoZSBmdXR1cmUgd2UgbWF5IGV4cG9zZSBzb21lIG9mIHRoZSB1dGlsaXRpZXMgaW5cbiAqIFJlYWN0TXVsdGlDaGlsZCB0byBtYWtlIHRoaXMgZWFzeSwgYnV0IGZvciBub3cgUmVhY3QgaXRzZWxmIGRvZXMgbm90XG4gKiBkaXJlY3RseSBoYXZlIHRoaXMgY29uY2VwdCBvZiB0aGUgdW5pb24gb2YgcHJldkNoaWxkcmVuIGFuZCBuZXh0Q2hpbGRyZW5cbiAqIHNvIHdlIGltcGxlbWVudCBpdCBoZXJlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcmV2IHByZXYgY2hpbGRyZW4gYXMgcmV0dXJuZWQgZnJvbVxuICogYFJlYWN0VHJhbnNpdGlvbkNoaWxkTWFwcGluZy5nZXRDaGlsZE1hcHBpbmcoKWAuXG4gKiBAcGFyYW0ge29iamVjdH0gbmV4dCBuZXh0IGNoaWxkcmVuIGFzIHJldHVybmVkIGZyb21cbiAqIGBSZWFjdFRyYW5zaXRpb25DaGlsZE1hcHBpbmcuZ2V0Q2hpbGRNYXBwaW5nKClgLlxuICogQHJldHVybiB7b2JqZWN0fSBhIGtleSBzZXQgdGhhdCBjb250YWlucyBhbGwga2V5cyBpbiBgcHJldmAgYW5kIGFsbCBrZXlzXG4gKiBpbiBgbmV4dGAgaW4gYSByZWFzb25hYmxlIG9yZGVyLlxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNoaWxkTWFwcGluZ3MocHJldiwgbmV4dCkge1xuICBwcmV2ID0gcHJldiB8fCB7fTtcbiAgbmV4dCA9IG5leHQgfHwge307XG5cbiAgZnVuY3Rpb24gZ2V0VmFsdWVGb3JLZXkoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiBuZXh0ID8gbmV4dFtrZXldIDogcHJldltrZXldO1xuICB9IC8vIEZvciBlYWNoIGtleSBvZiBgbmV4dGAsIHRoZSBsaXN0IG9mIGtleXMgdG8gaW5zZXJ0IGJlZm9yZSB0aGF0IGtleSBpblxuICAvLyB0aGUgY29tYmluZWQgbGlzdFxuXG5cbiAgdmFyIG5leHRLZXlzUGVuZGluZyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciBwZW5kaW5nS2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIHByZXZLZXkgaW4gcHJldikge1xuICAgIGlmIChwcmV2S2V5IGluIG5leHQpIHtcbiAgICAgIGlmIChwZW5kaW5nS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgbmV4dEtleXNQZW5kaW5nW3ByZXZLZXldID0gcGVuZGluZ0tleXM7XG4gICAgICAgIHBlbmRpbmdLZXlzID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBlbmRpbmdLZXlzLnB1c2gocHJldktleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGk7XG4gIHZhciBjaGlsZE1hcHBpbmcgPSB7fTtcblxuICBmb3IgKHZhciBuZXh0S2V5IGluIG5leHQpIHtcbiAgICBpZiAobmV4dEtleXNQZW5kaW5nW25leHRLZXldKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV4dEtleXNQZW5kaW5nW25leHRLZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwZW5kaW5nTmV4dEtleSA9IG5leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXTtcbiAgICAgICAgY2hpbGRNYXBwaW5nW25leHRLZXlzUGVuZGluZ1tuZXh0S2V5XVtpXV0gPSBnZXRWYWx1ZUZvcktleShwZW5kaW5nTmV4dEtleSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGRNYXBwaW5nW25leHRLZXldID0gZ2V0VmFsdWVGb3JLZXkobmV4dEtleSk7XG4gIH0gLy8gRmluYWxseSwgYWRkIHRoZSBrZXlzIHdoaWNoIGRpZG4ndCBhcHBlYXIgYmVmb3JlIGFueSBrZXkgaW4gYG5leHRgXG5cblxuICBmb3IgKGkgPSAwOyBpIDwgcGVuZGluZ0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICBjaGlsZE1hcHBpbmdbcGVuZGluZ0tleXNbaV1dID0gZ2V0VmFsdWVGb3JLZXkocGVuZGluZ0tleXNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIGNoaWxkTWFwcGluZztcbn1cblxuZnVuY3Rpb24gZ2V0UHJvcChjaGlsZCwgcHJvcCwgcHJvcHMpIHtcbiAgcmV0dXJuIHByb3BzW3Byb3BdICE9IG51bGwgPyBwcm9wc1twcm9wXSA6IGNoaWxkLnByb3BzW3Byb3BdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SW5pdGlhbENoaWxkTWFwcGluZyhwcm9wcywgb25FeGl0ZWQpIHtcbiAgcmV0dXJuIGdldENoaWxkTWFwcGluZyhwcm9wcy5jaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgcmV0dXJuIGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgaW46IHRydWUsXG4gICAgICBhcHBlYXI6IGdldFByb3AoY2hpbGQsICdhcHBlYXInLCBwcm9wcyksXG4gICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgcHJvcHMpLFxuICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBwcm9wcylcbiAgICB9KTtcbiAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV4dENoaWxkTWFwcGluZyhuZXh0UHJvcHMsIHByZXZDaGlsZE1hcHBpbmcsIG9uRXhpdGVkKSB7XG4gIHZhciBuZXh0Q2hpbGRNYXBwaW5nID0gZ2V0Q2hpbGRNYXBwaW5nKG5leHRQcm9wcy5jaGlsZHJlbik7XG4gIHZhciBjaGlsZHJlbiA9IG1lcmdlQ2hpbGRNYXBwaW5ncyhwcmV2Q2hpbGRNYXBwaW5nLCBuZXh0Q2hpbGRNYXBwaW5nKTtcbiAgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2tleV07XG4gICAgaWYgKCFpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHJldHVybjtcbiAgICB2YXIgaGFzUHJldiA9IChrZXkgaW4gcHJldkNoaWxkTWFwcGluZyk7XG4gICAgdmFyIGhhc05leHQgPSAoa2V5IGluIG5leHRDaGlsZE1hcHBpbmcpO1xuICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRNYXBwaW5nW2tleV07XG4gICAgdmFyIGlzTGVhdmluZyA9IGlzVmFsaWRFbGVtZW50KHByZXZDaGlsZCkgJiYgIXByZXZDaGlsZC5wcm9wcy5pbjsgLy8gaXRlbSBpcyBuZXcgKGVudGVyaW5nKVxuXG4gICAgaWYgKGhhc05leHQgJiYgKCFoYXNQcmV2IHx8IGlzTGVhdmluZykpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdlbnRlcmluZycsIGtleSlcbiAgICAgIGNoaWxkcmVuW2tleV0gPSBjbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgb25FeGl0ZWQ6IG9uRXhpdGVkLmJpbmQobnVsbCwgY2hpbGQpLFxuICAgICAgICBpbjogdHJ1ZSxcbiAgICAgICAgZXhpdDogZ2V0UHJvcChjaGlsZCwgJ2V4aXQnLCBuZXh0UHJvcHMpLFxuICAgICAgICBlbnRlcjogZ2V0UHJvcChjaGlsZCwgJ2VudGVyJywgbmV4dFByb3BzKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICghaGFzTmV4dCAmJiBoYXNQcmV2ICYmICFpc0xlYXZpbmcpIHtcbiAgICAgIC8vIGl0ZW0gaXMgb2xkIChleGl0aW5nKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2xlYXZpbmcnLCBrZXkpXG4gICAgICBjaGlsZHJlbltrZXldID0gY2xvbmVFbGVtZW50KGNoaWxkLCB7XG4gICAgICAgIGluOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChoYXNOZXh0ICYmIGhhc1ByZXYgJiYgaXNWYWxpZEVsZW1lbnQocHJldkNoaWxkKSkge1xuICAgICAgLy8gaXRlbSBoYXNuJ3QgY2hhbmdlZCB0cmFuc2l0aW9uIHN0YXRlc1xuICAgICAgLy8gY29weSBvdmVyIHRoZSBsYXN0IHRyYW5zaXRpb24gcHJvcHM7XG4gICAgICAvLyBjb25zb2xlLmxvZygndW5jaGFuZ2VkJywga2V5KVxuICAgICAgY2hpbGRyZW5ba2V5XSA9IGNsb25lRWxlbWVudChjaGlsZCwge1xuICAgICAgICBvbkV4aXRlZDogb25FeGl0ZWQuYmluZChudWxsLCBjaGlsZCksXG4gICAgICAgIGluOiBwcmV2Q2hpbGQucHJvcHMuaW4sXG4gICAgICAgIGV4aXQ6IGdldFByb3AoY2hpbGQsICdleGl0JywgbmV4dFByb3BzKSxcbiAgICAgICAgZW50ZXI6IGdldFByb3AoY2hpbGQsICdlbnRlcicsIG5leHRQcm9wcylcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn0iLCJpbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuZXhwb3J0IHZhciB0aW1lb3V0c1NoYXBlID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zaGFwZSh7XG4gIGVudGVyOiBQcm9wVHlwZXMubnVtYmVyLFxuICBleGl0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBhcHBlYXI6IFByb3BUeXBlcy5udW1iZXJcbn0pLmlzUmVxdWlyZWRdKSA6IG51bGw7XG5leHBvcnQgdmFyIGNsYXNzTmFtZXNTaGFwZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuc3RyaW5nLCBQcm9wVHlwZXMuc2hhcGUoe1xuICBlbnRlcjogUHJvcFR5cGVzLnN0cmluZyxcbiAgZXhpdDogUHJvcFR5cGVzLnN0cmluZyxcbiAgYWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nXG59KSwgUHJvcFR5cGVzLnNoYXBlKHtcbiAgZW50ZXI6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGVudGVyRG9uZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgZW50ZXJBY3RpdmU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4aXQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGV4aXREb25lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBleGl0QWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nXG59KV0pIDogbnVsbDsiLCJtb2R1bGUuZXhwb3J0cyA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBkbGwtcmVmZXJlbmNlIGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NSAqLyBcImRsbC1yZWZlcmVuY2UgZGxsXzUwMzBmMzg3ZDMyOGU0NDE1Nzg1XCIpKShcIi4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzXCIpOyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3JpZ2luYWxNb2R1bGUpIHtcblx0aWYgKCFvcmlnaW5hbE1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHR2YXIgbW9kdWxlID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbE1vZHVsZSk7XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiZXhwb3J0c1wiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBDaXJjbGVBY2NlbnQxIChwcm9wcykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIscHJvcHMsW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7XCJjeFwiOlwiNjkuNVwiLFwiY3lcIjpcIjIwMy41XCIsXCJyXCI6XCIyMDNcIixcInN0cm9rZVwiOlwiIzRENTVCQ1wiLFwia2V5XCI6MH0pLFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7XCJvcGFjaXR5XCI6XCIwLjlcIixcImN4XCI6XCI1Ni41XCIsXCJjeVwiOlwiMjE2LjVcIixcInJcIjpcIjE5MFwiLFwic3Ryb2tlXCI6XCIjNEQ1NUJDXCIsXCJrZXlcIjoxfSksUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLHtcIm9wYWNpdHlcIjpcIjAuOFwiLFwiY3hcIjpcIjM5LjVcIixcImN5XCI6XCIyMzcuNVwiLFwiclwiOlwiMTgxXCIsXCJzdHJva2VcIjpcIiM0RDU1QkNcIixcImtleVwiOjJ9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIse1wib3BhY2l0eVwiOlwiMC43XCIsXCJjeFwiOlwiMjdcIixcImN5XCI6XCIyNTZcIixcInJcIjpcIjE2Ny41XCIsXCJzdHJva2VcIjpcIiM0RDU1QkNcIixcImtleVwiOjN9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIse1wib3BhY2l0eVwiOlwiMC42XCIsXCJjeFwiOlwiMTBcIixcImN5XCI6XCIyNjlcIixcInJcIjpcIjE1NS41XCIsXCJzdHJva2VcIjpcIiM0RDU1QkNcIixcImtleVwiOjR9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIse1wib3BhY2l0eVwiOlwiMC41XCIsXCJjeFwiOlwiLTcuNVwiLFwiY3lcIjpcIjI4Ni41XCIsXCJyXCI6XCIxMzhcIixcInN0cm9rZVwiOlwiIzRENTVCQ1wiLFwia2V5XCI6NX0pLFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7XCJvcGFjaXR5XCI6XCIwLjRcIixcImN4XCI6XCItMjRcIixcImN5XCI6XCIzMDNcIixcInJcIjpcIjEyMS41XCIsXCJzdHJva2VcIjpcIiM0RDU1QkNcIixcImtleVwiOjZ9KV0pO1xufVxuXG5DaXJjbGVBY2NlbnQxLmRlZmF1bHRQcm9wcyA9IHtcImlkXCI6XCJhY2NlbnQtY2lyY2xlXCIsXCJ3aWR0aFwiOlwiMjczXCIsXCJoZWlnaHRcIjpcIjI4M1wiLFwidmlld0JveFwiOlwiMCAwIDI3MyAyODNcIixcImZpbGxcIjpcIm5vbmVcIn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlQWNjZW50MTtcblxuQ2lyY2xlQWNjZW50MS5kZWZhdWx0ID0gQ2lyY2xlQWNjZW50MTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIERlZmF1bHRBdmF0YXIgKHByb3BzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIixwcm9wcyxbUmVhY3QuY3JlYXRlRWxlbWVudChcIm1hc2tcIix7XCJpZFwiOlwibWFzazBcIixcIm1hc2tUeXBlXCI6XCJhbHBoYVwiLFwibWFza1VuaXRzXCI6XCJ1c2VyU3BhY2VPblVzZVwiLFwieFwiOlwiMFwiLFwieVwiOlwiMFwiLFwid2lkdGhcIjpcIjkwXCIsXCJoZWlnaHRcIjpcIjkwXCIsXCJrZXlcIjowfSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIse1wiY3hcIjpcIjQ1XCIsXCJjeVwiOlwiNDVcIixcInJcIjpcIjQ1XCIsXCJmaWxsXCI6XCIjNzE3NkI4XCJ9KSksUmVhY3QuY3JlYXRlRWxlbWVudChcImdcIix7XCJtYXNrXCI6XCJ1cmwoI21hc2swKVwiLFwia2V5XCI6MX0sW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7XCJjeFwiOlwiNDVcIixcImN5XCI6XCI0NVwiLFwiclwiOlwiNDVcIixcImZpbGxcIjpcIiM3MTc2QjhcIixcImtleVwiOjB9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2lyY2xlXCIse1wiY3hcIjpcIjQ1XCIsXCJjeVwiOlwiMzFcIixcInJcIjpcIjE5XCIsXCJmaWxsXCI6XCIjNTA1NTkzXCIsXCJrZXlcIjoxfSksUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLHtcImN4XCI6XCI0NC41XCIsXCJjeVwiOlwiODIuNVwiLFwiclwiOlwiMzQuNVwiLFwiZmlsbFwiOlwiIzUwNTU5M1wiLFwia2V5XCI6Mn0pXSldKTtcbn1cblxuRGVmYXVsdEF2YXRhci5kZWZhdWx0UHJvcHMgPSB7XCJ3aWR0aFwiOlwiOTBcIixcImhlaWdodFwiOlwiOTBcIixcInZpZXdCb3hcIjpcIjAgMCA5MCA5MFwiLFwiZmlsbFwiOlwibm9uZVwifTtcblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0QXZhdGFyO1xuXG5EZWZhdWx0QXZhdGFyLmRlZmF1bHQgPSBEZWZhdWx0QXZhdGFyO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gSWNvbkJ1c2luZXNzRGV2ZWxvcG1lbnQgKHByb3BzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIixwcm9wcyxbUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNNDQuMDgzMyAyMS4wODMzSDQwLjIxMTdDNDAuMjI3IDIwLjc2NDIgNDAuMjUgMjAuNDQ2IDQwLjI1IDIwLjEyNUM0MC4yNSAxMS43NTY4IDM0Ljk3NjMgNC4xNzE2MyAyNy4xMjI3IDEuMjQ5NjdDMjcuMTA3NCAxLjI0MzkyIDI3LjA5MjEgMS4yNDAwOCAyNy4wNzY3IDEuMjM1MjlDMjcuMDcyOSAxLjIzNDMzIDI3LjA3IDEuMjMxNDYgMjcuMDY2MiAxLjIzMDVDMjcuMDYxNCAxLjIyODU4IDI3LjA1NjYgMS4yMjg1OCAyNy4wNTE4IDEuMjI3NjNDMjQuODI1NiAwLjQxNDk1OCAyMi40OTY5IDAgMjAuMTI1IDBDMTguNTI0NiAwIDE2Ljk3NTkgMC4yMDc5NTggMTUuNDgyOCAwLjU2MjU0MkMxNS4zMDc1IDAuNTgxNzA4IDE1LjEzNTkgMC42Mjc3MDggMTQuOTcxMSAwLjY5NDc5MkM2LjM2NzE3IDIuOTc5NDYgMCAxMC44MTE5IDAgMjAuMTI1QzAgMjAuMjEwMyAwLjAxMDU0MTcgMjAuMjk0NiAwLjAxMTUgMjAuMzc5OUMwLjAxNDM3NSAyMC40Mjk4IDAuMDExNSAyMC40ODA1IDAuMDE4MjA4MyAyMC41Mjg1QzAuMTEyMTI1IDI1LjE2NjggMS43OTU5MiAyOS42NDEyIDQuODA3OTYgMzMuMTYzMUM0LjgwODkyIDMzLjE2NDEgNC44MTA4MyAzMy4xNjYgNC44MTE3OSAzMy4xNjdDNC44MTM3MSAzMy4xNjg5IDQuODE1NjIgMzMuMTcwOCA0LjgxNzU0IDMzLjE3MzdDOC42NDg5NiAzNy42NzExIDE0LjIyNzQgNDAuMjUgMjAuMTI1IDQwLjI1SDM3LjUzODlMNDIuNzI4MiA0NS40Mzg0QzQzLjA5NDMgNDUuODA1NSA0My41ODUgNDYgNDQuMDgzMyA0NkM0NC4zMjk2IDQ2IDQ0LjU3OTggNDUuOTUyMSA0NC44MTY1IDQ1Ljg1NDNDNDUuNTMzMyA0NS41NTcyIDQ2IDQ0Ljg1ODYgNDYgNDQuMDgzM1YyM0M0NiAyMS45NDIgNDUuMTQxMyAyMS4wODMzIDQ0LjA4MzMgMjEuMDgzM1pNMjUuMTA2NCAxMy4xNjA4TDI3LjYwNzcgNS42NjM3NUMzMi45NDI3IDguNDM5MDggMzYuNDE2NyAxNC4wMTk1IDM2LjQxNjcgMjAuMTI1QzM2LjQxNjcgMjAuNDQ1MSAzNi40MDcxIDIwLjc2NTIgMzYuMzg4OSAyMS4wODMzSDMxLjQ4N0MzMC45MjE2IDE5Ljk4NTEgMzAuMDc4MiAxOS4wNTA3IDI5LjAxMzUgMTguMzgwOEwyNi4zOTYzIDE2Ljc1NzRDMjUuMTg2IDE1Ljk5ODQgMjQuNjU2IDE0LjUxNzggMjUuMTA2NCAxMy4xNjA4Wk0xMy45MDczIDUuMDcyNDZMMTQuNTIxNiA3LjUyOTYyQzE0LjgzNiA4Ljc4NTA0IDE0LjMwMTIgMTAuMDc1OSAxMy4xOTA1IDEwLjc0MjlDMTEuNjQzOCAxMS42NzE1IDEwLjU1MDMgMTMuMTQ2NCAxMC4xMTMzIDE0Ljg5NjNMOS42OTQ1IDE2LjU3MzRDOS4zNDE4MyAxNy45ODUgOC4wMjcgMTguOTA1IDYuNTkxNDIgMTguNzcyOEM1LjcyMTI1IDE4LjY5MDQgNC44MDMxNyAxOC42MDYgMy45MTU3NSAxOC41Mjc1QzQuNTA5OTIgMTIuNDM4MiA4LjQ3MDcxIDcuMzI2NDYgMTMuOTA3MyA1LjA3MjQ2Wk0xOC4yMDgzIDM2LjMwMzZDMTUuMDMwNSAzNS45MjcgMTIuMDUyIDM0LjYxMTIgOS42MTQ5NiAzMi41NDVMMTAuODU5OCAzMS45OTY4QzEyLjUwMzQgMzEuMjY2NiAxNC4zODg0IDMxLjI1MzIgMTYuMDM4NyAzMS45NTk1TDE3Ljc4MDkgMzIuNzAyMkMxNy45MTggMzIuNzYyNSAxOC4wNjY1IDMyLjgwODUgMTguMjA4MyAzMi44NjIyVjM2LjMwMzZaTTE4LjIwODMgMjNWMjguNzE4NEwxNy41NDUyIDI4LjQzNTdDMTQuOTIyMiAyNy4zMTE1IDExLjkxODggMjcuMzMyNiA5LjMxMzA4IDI4LjQ5MDNMNy44MDU2MyAyOS4xNTQ0QzcuNDk4OTYgMjkuMjg5NSA3LjE3NTA0IDI5LjQzMTQgNi44NTk3NSAyOS41Njk0QzUuMzM4ODcgMjcuNDQwOSA0LjM3IDI0Ljk3MTMgNC4wMDY3OSAyMi4zODM4QzQuNzUwNDYgMjIuNDUwOSA1LjUwODUgMjIuNTIwOCA2LjIyOTE3IDIyLjU4OThDNi40NDg2MyAyMi42MSA2LjY2NzEyIDIyLjYyMDUgNi44ODM3MSAyMi42MjA1QzkuOTYyODMgMjIuNjIwNSAxMi42NTEgMjAuNTUyNCAxMy40MTI4IDE3LjUwM0wxMy44MzE2IDE1LjgyNTlDMTQuMDIwNCAxNS4wNjk4IDE0LjQ5MjkgMTQuNDMxNSAxNS4xNjI3IDE0LjAzQzE3LjcyOTIgMTIuNDkgMTguOTY2NCA5LjUwMzc5IDE4LjI0IDYuNjAxTDE3LjYwMjcgNC4wNDk5MkMxOC40MjY4IDMuOTIwNTQgMTkuMjY1NCAzLjgzMzMzIDIwLjEyNSAzLjgzMzMzQzIxLjQ0NDYgMy44MzMzMyAyMi43NDYgNC4wMDI5NiAyNC4wMTY4IDQuMzE0NDJMMjEuNDY4NiAxMS45NTA0QzIwLjQ1OTUgMTQuOTkxMiAyMS42NDg4IDE4LjMwMzIgMjQuMzY2NiAyMC4wMUwyNi4wOTczIDIxLjA4MzNIMjAuMTI1QzE5LjA2NyAyMS4wODMzIDE4LjIwODMgMjEuOTQyIDE4LjIwODMgMjNaTTQyLjE2NjcgMzkuNDU1NUwzOS42ODg0IDM2Ljk3ODJDMzkuMzI5IDM2LjYxODkgMzguODQxMiAzNi40MTY3IDM4LjMzMzMgMzYuNDE2N0gyMi4wNDE3VjMxLjQ1NjNDMjIuMDQxNyAzMS40NTM1IDIyLjA0MTcgMzEuNDUwNiAyMi4wNDE3IDMxLjQ0NjdWMjQuOTE2N0gzMC4xODM3QzMwLjE4NDYgMjQuOTE2NyAzMC4xODU2IDI0LjkxNjcgMzAuMTg2NSAyNC45MTY3QzMwLjE4NzUgMjQuOTE2NyAzMC4xODk0IDI0LjkxNjcgMzAuMTkwNCAyNC45MTY3SDM4LjEwMzNINDIuMTY2N1YzOS40NTU1WlwiLFwia2V5XCI6MH0pLFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse1wiZFwiOlwiTTI2LjgzMzMgMjguNzVIMjUuODc1QzI0LjgxNyAyOC43NSAyMy45NTgzIDI5LjYwODcgMjMuOTU4MyAzMC42NjY3QzIzLjk1ODMgMzEuNzI0NyAyNC44MTcgMzIuNTgzMyAyNS44NzUgMzIuNTgzM0gyNi44MzMzQzI3Ljg5MTMgMzIuNTgzMyAyOC43NSAzMS43MjQ3IDI4Ljc1IDMwLjY2NjdDMjguNzUgMjkuNjA4NyAyNy44OTEzIDI4Ljc1IDI2LjgzMzMgMjguNzVaXCIsXCJrZXlcIjoxfSksUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNMzIuNTgzMyAyOC43NUgzMS42MjVDMzAuNTY3IDI4Ljc1IDI5LjcwODMgMjkuNjA4NyAyOS43MDgzIDMwLjY2NjdDMjkuNzA4MyAzMS43MjQ3IDMwLjU2NyAzMi41ODMzIDMxLjYyNSAzMi41ODMzSDMyLjU4MzNDMzMuNjQxMyAzMi41ODMzIDM0LjUgMzEuNzI0NyAzNC41IDMwLjY2NjdDMzQuNSAyOS42MDg3IDMzLjY0MTMgMjguNzUgMzIuNTgzMyAyOC43NVpcIixcImtleVwiOjJ9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0zOC4zMzMzIDI4Ljc1SDM3LjM3NUMzNi4zMTcgMjguNzUgMzUuNDU4MyAyOS42MDg3IDM1LjQ1ODMgMzAuNjY2N0MzNS40NTgzIDMxLjcyNDcgMzYuMzE3IDMyLjU4MzMgMzcuMzc1IDMyLjU4MzNIMzguMzMzM0MzOS4zOTEzIDMyLjU4MzMgNDAuMjUgMzEuNzI0NyA0MC4yNSAzMC42NjY3QzQwLjI1IDI5LjYwODcgMzkuMzkxMyAyOC43NSAzOC4zMzMzIDI4Ljc1WlwiLFwia2V5XCI6M30pXSk7XG59XG5cbkljb25CdXNpbmVzc0RldmVsb3BtZW50LmRlZmF1bHRQcm9wcyA9IHtcIndpZHRoXCI6XCI0NlwiLFwiaGVpZ2h0XCI6XCI0NlwiLFwidmlld0JveFwiOlwiMCAwIDQ2IDQ2XCIsXCJmaWxsXCI6XCJub25lXCJ9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEljb25CdXNpbmVzc0RldmVsb3BtZW50O1xuXG5JY29uQnVzaW5lc3NEZXZlbG9wbWVudC5kZWZhdWx0ID0gSWNvbkJ1c2luZXNzRGV2ZWxvcG1lbnQ7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBJY29uQ29udGVudFdyaXRlciAocHJvcHMpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLHByb3BzLFtSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk00NC4wODMzIDkuNTgzMzNIMzguMzMzM1YxLjkxNjY3QzM4LjMzMzMgMC44NTg2NjcgMzcuNDc0NyAwIDM2LjQxNjcgMEg1Ljc1QzIuNTc4ODcgMCAwIDIuNTc4ODcgMCA1Ljc1VjQwLjI1QzAgNDMuNDIxMSAyLjU3ODg3IDQ2IDUuNzUgNDZINDAuMjVDNDMuNDIxMSA0NiA0NiA0My40MjExIDQ2IDQwLjI1VjExLjVDNDYgMTAuNDQyIDQ1LjE0MTMgOS41ODMzMyA0NC4wODMzIDkuNTgzMzNaTTUuNzUgNDIuMTY2N0M0LjY5Mjk2IDQyLjE2NjcgMy44MzMzMyA0MS4zMDcgMy44MzMzMyA0MC4yNVY1Ljc1QzMuODMzMzMgNC42OTI5NiA0LjY5Mjk2IDMuODMzMzMgNS43NSAzLjgzMzMzSDM0LjVWMTEuNVY0MC4yNUMzNC41IDQwLjkyMjcgMzQuNjIyNyA0MS41NjU4IDM0LjgzNTQgNDIuMTY2N0g1Ljc1Wk00Mi4xNjY3IDQwLjI1QzQyLjE2NjcgNDEuMzA3IDQxLjMwNyA0Mi4xNjY3IDQwLjI1IDQyLjE2NjdDMzkuMTkzIDQyLjE2NjcgMzguMzMzMyA0MS4zMDcgMzguMzMzMyA0MC4yNVYxMy40MTY3SDQyLjE2NjdWNDAuMjVaXCIsXCJrZXlcIjowfSksUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNMjguNzUgOS41ODMzN0g5LjU4MzMyQzguNTI1MzIgOS41ODMzNyA3LjY2NjY2IDEwLjQ0MiA3LjY2NjY2IDExLjVDNy42NjY2NiAxMi41NTggOC41MjUzMiAxMy40MTY3IDkuNTgzMzIgMTMuNDE2N0gyOC43NUMyOS44MDggMTMuNDE2NyAzMC42NjY3IDEyLjU1OCAzMC42NjY3IDExLjVDMzAuNjY2NyAxMC40NDIgMjkuODA4IDkuNTgzMzcgMjguNzUgOS41ODMzN1pcIixcImtleVwiOjF9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0yNC45MTY3IDIxLjA4MzRIOS41ODMzMkM4LjUyNTMyIDIxLjA4MzQgNy42NjY2NiAyMS45NDIgNy42NjY2NiAyM0M3LjY2NjY2IDI0LjA1OCA4LjUyNTMyIDI0LjkxNjcgOS41ODMzMiAyNC45MTY3SDI0LjkxNjdDMjUuOTc0NyAyNC45MTY3IDI2LjgzMzMgMjQuMDU4IDI2LjgzMzMgMjNDMjYuODMzMyAyMS45NDIgMjUuOTc0NyAyMS4wODM0IDI0LjkxNjcgMjEuMDgzNFpcIixcImtleVwiOjJ9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0yMyAyNi44MzM0SDkuNTgzMzJDOC41MjUzMiAyNi44MzM0IDcuNjY2NjYgMjcuNjkyIDcuNjY2NjYgMjguNzVDNy42NjY2NiAyOS44MDggOC41MjUzMiAzMC42NjY3IDkuNTgzMzIgMzAuNjY2N0gyM0MyNC4wNTggMzAuNjY2NyAyNC45MTY3IDI5LjgwOCAyNC45MTY3IDI4Ljc1QzI0LjkxNjcgMjcuNjkyIDI0LjA1OCAyNi44MzM0IDIzIDI2LjgzMzRaXCIsXCJrZXlcIjozfSksUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNMjEuMDgzMyAzMi41ODM0SDkuNTgzMzJDOC41MjUzMiAzMi41ODM0IDcuNjY2NjYgMzMuNDQyIDcuNjY2NjYgMzQuNUM3LjY2NjY2IDM1LjU1OCA4LjUyNTMyIDM2LjQxNjcgOS41ODMzMiAzNi40MTY3SDIxLjA4MzNDMjIuMTQxMyAzNi40MTY3IDIzIDM1LjU1OCAyMyAzNC41QzIzIDMzLjQ0MiAyMi4xNDEzIDMyLjU4MzQgMjEuMDgzMyAzMi41ODM0WlwiLFwia2V5XCI6NH0pXSk7XG59XG5cbkljb25Db250ZW50V3JpdGVyLmRlZmF1bHRQcm9wcyA9IHtcIndpZHRoXCI6XCI0NlwiLFwiaGVpZ2h0XCI6XCI0NlwiLFwidmlld0JveFwiOlwiMCAwIDQ2IDQ2XCIsXCJmaWxsXCI6XCJub25lXCJ9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEljb25Db250ZW50V3JpdGVyO1xuXG5JY29uQ29udGVudFdyaXRlci5kZWZhdWx0ID0gSWNvbkNvbnRlbnRXcml0ZXI7XG4iLCJ2YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5mdW5jdGlvbiBJY29uQ3VzdG9tZXJSZWxhdGlvbnNoaXAgKHByb3BzKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIixwcm9wcyxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0zNi44OTU4IDE1LjMzMzNIMzYuNDE2N1YxMy40MTY3QzM2LjQxNjcgNi4wMTgzMyAzMC4zOTgzIDAgMjMgMEMxNS42MDE3IDAgOS41ODMzMyA2LjAxODMzIDkuNTgzMzMgMTMuNDE2N1YxNS4zMzMzSDkuMTA0MTdDNC4wODQ0MiAxNS4zMzMzIDAgMTkuNDE3NyAwIDI0LjQzNzVDMCAyOS40NTcyIDQuMDg0NDIgMzMuNTQxNyA5LjEwNDE3IDMzLjU0MTdIMTQuMzc1QzE1LjQzMyAzMy41NDE3IDE2LjI5MTcgMzIuNjgzIDE2LjI5MTcgMzEuNjI1VjE3LjI1QzE2LjI5MTcgMTYuMTkyIDE1LjQzMyAxNS4zMzMzIDE0LjM3NSAxNS4zMzMzSDEzLjQxNjdWMTMuNDE2N0MxMy40MTY3IDguMTMyNDIgMTcuNzE1NyAzLjgzMzMzIDIzIDMuODMzMzNDMjguMjg0MyAzLjgzMzMzIDMyLjU4MzMgOC4xMzI0MiAzMi41ODMzIDEzLjQxNjdWMTUuMzMzM0gzMS42MjVDMzAuNTY3IDE1LjMzMzMgMjkuNzA4MyAxNi4xOTIgMjkuNzA4MyAxNy4yNVYzMS42MjVDMjkuNzA4MyAzMi42ODMgMzAuNTY3IDMzLjU0MTcgMzEuNjI1IDMzLjU0MTdIMzIuNTgzM1Y0MC4yNUMzMi41ODMzIDQxLjMwNyAzMS43MjM3IDQyLjE2NjcgMzAuNjY2NyA0Mi4xNjY3SDI5LjcwODNWNDEuMjA4M0MyOS43MDgzIDQwLjE1MDMgMjguODQ5NyAzOS4yOTE3IDI3Ljc5MTcgMzkuMjkxN0gyMS4wODMzQzIwLjAyNTMgMzkuMjkxNyAxOS4xNjY3IDQwLjE1MDMgMTkuMTY2NyA0MS4yMDgzVjQ0LjA4MzNDMTkuMTY2NyA0NS4xNDEzIDIwLjAyNTMgNDYgMjEuMDgzMyA0NkgyNy43OTE3SDMwLjY2NjdDMzMuODM3OCA0NiAzNi40MTY3IDQzLjQyMTEgMzYuNDE2NyA0MC4yNVYzMy41NDE3SDM2Ljg5NThDNDEuOTE1NiAzMy41NDE3IDQ2IDI5LjQ1NzIgNDYgMjQuNDM3NUM0NiAxOS40MTc3IDQxLjkxNTYgMTUuMzMzMyAzNi44OTU4IDE1LjMzMzNaTTEyLjQ1ODMgMjNIMTEuNUMxMC40NDIgMjMgOS41ODMzMyAyMy44NTg3IDkuNTgzMzMgMjQuOTE2N0M5LjU4MzMzIDI1Ljk3NDcgMTAuNDQyIDI2LjgzMzMgMTEuNSAyNi44MzMzSDEyLjQ1ODNWMjkuNzA4M0g5LjEwNDE3QzYuMTk4NSAyOS43MDgzIDMuODMzMzMgMjcuMzQ0MSAzLjgzMzMzIDI0LjQzNzVDMy44MzMzMyAyMS41MzA5IDYuMTk4NSAxOS4xNjY3IDkuMTA0MTcgMTkuMTY2N0gxMi40NTgzVjIzWk0zNi44OTU4IDI5LjcwODNIMzMuNTQxN1YyNi44MzMzSDM0LjVDMzUuNTU4IDI2LjgzMzMgMzYuNDE2NyAyNS45NzQ3IDM2LjQxNjcgMjQuOTE2N0MzNi40MTY3IDIzLjg1ODcgMzUuNTU4IDIzIDM0LjUgMjNIMzMuNTQxN1YxOS4xNjY3SDM2Ljg5NThDMzkuODAxNSAxOS4xNjY3IDQyLjE2NjcgMjEuNTMwOSA0Mi4xNjY3IDI0LjQzNzVDNDIuMTY2NyAyNy4zNDQxIDM5LjgwMTUgMjkuNzA4MyAzNi44OTU4IDI5LjcwODNaXCJ9KSk7XG59XG5cbkljb25DdXN0b21lclJlbGF0aW9uc2hpcC5kZWZhdWx0UHJvcHMgPSB7XCJ3aWR0aFwiOlwiNDZcIixcImhlaWdodFwiOlwiNDZcIixcInZpZXdCb3hcIjpcIjAgMCA0NiA0NlwiLFwiZmlsbFwiOlwibm9uZVwifTtcblxubW9kdWxlLmV4cG9ydHMgPSBJY29uQ3VzdG9tZXJSZWxhdGlvbnNoaXA7XG5cbkljb25DdXN0b21lclJlbGF0aW9uc2hpcC5kZWZhdWx0ID0gSWNvbkN1c3RvbWVyUmVsYXRpb25zaGlwO1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gSWNvbkdhbWVEZXZlbG9wbWVudCAocHJvcHMpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLHByb3BzLFtSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0xOC42MDUxIDEwLjE0NDlDMTcuODU3NCA5LjM5NjYyIDE2LjY0MjYgOS4zOTY2MiAxNS44OTQ5IDEwLjE0NDlMMTQuMzc1IDExLjY2NDdMMTIuODU1MSAxMC4xNDQ5QzEyLjEwNzQgOS4zOTY2MiAxMC44OTI2IDkuMzk2NjIgMTAuMTQ0OSAxMC4xNDQ5QzkuMzk2NjIgMTAuODkzNSA5LjM5NjYyIDEyLjEwNjQgMTAuMTQ0OSAxMi44NTUxTDExLjY2NDcgMTQuMzc1TDEwLjE0NDkgMTUuODk0OUM5LjM5NjYyIDE2LjY0MzUgOS4zOTY2MiAxNy44NTY0IDEwLjE0NDkgMTguNjA1MUMxMC41MTg3IDE4Ljk4IDExLjAwOTEgMTkuMTY2NyAxMS41IDE5LjE2NjdDMTEuOTkwOSAxOS4xNjY3IDEyLjQ4MTMgMTguOTggMTIuODU1MSAxOC42MDUxTDE0LjM3NSAxNy4wODUzTDE1Ljg5NDkgMTguNjA1MUMxNi4yNjg3IDE4Ljk4IDE2Ljc1OTEgMTkuMTY2NyAxNy4yNSAxOS4xNjY3QzE3Ljc0MDkgMTkuMTY2NyAxOC4yMzEzIDE4Ljk4IDE4LjYwNTEgMTguNjA1MUMxOS4zNTM0IDE3Ljg1NjQgMTkuMzUzNCAxNi42NDM1IDE4LjYwNTEgMTUuODk0OUwxNy4wODUzIDE0LjM3NUwxOC42MDUxIDEyLjg1NTFDMTkuMzUzNCAxMi4xMDY0IDE5LjM1MzQgMTAuODkzNSAxOC42MDUxIDEwLjE0NDlaXCIsXCJrZXlcIjowfSksUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNMzEuNjI1IDI0LjkxNjdDMjcuOTI2IDI0LjkxNjcgMjQuOTE2NyAyNy45MjY5IDI0LjkxNjcgMzEuNjI1QzI0LjkxNjcgMzUuMzIzMSAyNy45MjYgMzguMzMzNCAzMS42MjUgMzguMzMzNEMzNS4zMjQgMzguMzMzNCAzOC4zMzMzIDM1LjMyMzEgMzguMzMzMyAzMS42MjVDMzguMzMzMyAyNy45MjY5IDM1LjMyNCAyNC45MTY3IDMxLjYyNSAyNC45MTY3Wk0zMS42MjUgMzQuNUMzMC4wNDAxIDM0LjUgMjguNzUgMzMuMjA5OSAyOC43NSAzMS42MjVDMjguNzUgMzAuMDQwMSAzMC4wNDAxIDI4Ljc1IDMxLjYyNSAyOC43NUMzMy4yMDk5IDI4Ljc1IDM0LjUgMzAuMDQwMSAzNC41IDMxLjYyNUMzNC41IDMzLjIwOTkgMzMuMjA5OSAzNC41IDMxLjYyNSAzNC41WlwiLFwia2V5XCI6MX0pLFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse1wiZFwiOlwiTTQ1LjQzODUgMC41NjE1MjNDNDQuNjkwNyAtMC4xODY3MDcgNDMuNDc2IC0wLjE4NjcwNyA0Mi43MjgyIDAuNTYxNTIzTDM2Ljc2NDMgNi41MjUzN0MzNS4wNDA1IDUuNTA5NDggMzIuODQwMiA1LjUxMjI5IDMxLjExODIgNi42NjA2TDI4LjY0MTkgOC4zMTI0MkwyNC41NCA0LjIxMDk2QzI0LjUyNzggNC4xOTgzMiAyNC41MTI0IDQuMTg5OSAyNC40OTk3IDQuMTc4MkMyMS43OTEzIDEuNDg0MjkgMTguMTk5OSAwIDE0LjM3NSAwQzEwLjUzMzIgMCA2LjkyNDA1IDEuNDk2OTMgNC4yMTM3NyA0LjIxMDk2QzEuNDk2OTMgNi45MjQwNSAwIDEwLjUzMzIgMCAxNC4zNzVDMCAxOC4yMTY4IDEuNDk2OTMgMjEuODI1OSA0LjIxMDk2IDI0LjUzNjJDNi45NDIzIDI3LjI3NTEgMTAuNTg0NyAyOC43NjA4IDE0LjM1NDkgMjguNzYwOEMxNS4wMDU4IDI4Ljc2MDggMTUuNjYwOSAyOC42OTkgMTYuMzE1NSAyOC42MDkxTDE3LjM3OTIgMjkuNjczN0MxNi43NjUyIDM0LjEyMTQgMTguMjUwNCAzOC41ODU1IDIxLjQ2MTkgNDEuNzg3MkMyNC4xNzQxIDQ0LjUwMzEgMjcuNzgzMiA0NiAzMS42MjUgNDZDMzUuNDY2OCA0NiAzOS4wNzU5IDQ0LjUwMzEgNDEuNzg2MiA0MS43ODlDNDQuNTAzMSAzOS4wNzU5IDQ2IDM1LjQ2NjggNDYgMzEuNjI1QzQ2IDI3Ljc5OTIgNDQuNTE0OCAyNC4yMDU0IDQxLjgxOSAyMS40OTY1QzQxLjgwODIgMjEuNDg0OCA0MS44MDA3IDIxLjQ3MTMgNDEuNzg5IDIxLjQ2MUwzNy44MTQ5IDE3LjQ4NjhMMzkuNDg3MyAxNC44MDY0QzQwLjU3OTkgMTMuMDU2NCA0MC41MzczIDEwLjkwNTcgMzkuNDkyOSA5LjIxNjQ3TDQ1LjQzODUgMy4yNzA4N0M0Ni4xODY3IDIuNTIzMTEgNDYuMTg2NyAxLjMxMDIyIDQ1LjQzODUgMC41NjE1MjNaTTM5LjA3NSAzOS4wNzc4QzM3LjA4NzcgNDEuMDY5NCAzNC40NDE1IDQyLjE2NjcgMzEuNjI1IDQyLjE2NjdDMjguODA4NSA0Mi4xNjY3IDI2LjE2MjMgNDEuMDY5NCAyNC4xNzEyIDM5LjA3NUMyMS42Mjg1IDM2LjUzOTMgMjAuNTU4MyAzMi45MzAxIDIxLjMwODQgMjkuNDE5MUMyMS4zMDkzIDI5LjQxNCAyMS4zMDkzIDI5LjQwOTMgMjEuMzEwMyAyOS40MDQ2QzIxLjMyODUgMjkuMzE2MiAyMS4zMzQ2IDI5LjIyNzMgMjEuMzQwMiAyOS4xMzdDMjEuMzQyMSAyOS4xIDIxLjM1MDUgMjkuMDYxNiAyMS4zNTA1IDI5LjAyNTFDMjEuMzUwNSAyOC45NTQgMjEuMzM5MyAyOC44ODM0IDIxLjMzMTMgMjguODEyMkMyMS4zMjU3IDI4Ljc1OTQgMjEuMzI2NyAyOC43MDYgMjEuMzE2NCAyOC42NTQxQzIxLjMwNzUgMjguNjA5MSAyMS4yODkyIDI4LjU2NjEgMjEuMjc3MSAyOC41MjIxQzIxLjI1NjkgMjguNDQ4MiAyMS4yNDA2IDI4LjM3MjQgMjEuMjExNSAyOC4zMDE3QzIxLjE5MzggMjguMjU2MyAyMS4xNjY2IDI4LjIxNjEgMjEuMTQ0NiAyOC4xNzIxQzIxLjExMDkgMjguMTA0MiAyMS4wODA1IDI4LjAzNSAyMS4wMzkzIDI3Ljk3MThDMjEuMDE3NCAyNy45MzgxIDIwLjk4ODMgMjcuOTA5NiAyMC45NjQ1IDI3Ljg3NzhDMjAuOTEyNSAyNy44MDggMjAuODYxMSAyNy43Mzc5IDIwLjc5OTggMjcuNjc1NkMyMC43OTYgMjcuNjcxOSAyMC43OTQxIDI3LjY2NzIgMjAuNzg5OSAyNy42NjM1TDE4LjMzNjUgMjUuMjA5MUMxOC4zMzE5IDI1LjIwNCAxOC4zMjYzIDI1LjIwMTIgMTguMzIyNSAyNS4xOTY1QzE4LjI2ODcgMjUuMTQzNiAxOC4yMDc0IDI1LjA5OTYgMTguMTQ3IDI1LjA1MzhDMTguMTA1OSAyNS4wMjIgMTguMDY4NCAyNC45ODU1IDE4LjAyNTQgMjQuOTU3OEMxNy45NzYyIDI0LjkyNiAxNy45MjIgMjQuOTAzMSAxNy44NyAyNC44NzY0QzE3LjgxMjUgMjQuODQ1NSAxNy43NTY4IDI0LjgxMDQgMTcuNjk3MyAyNC43ODYxQzE3LjU4OTMgMjQuNzQyMSAxNy40NzUxIDI0LjcwOTggMTcuMzU5IDI0LjY4NTVDMTcuMzU1MyAyNC42ODQ2IDE3LjM1MTUgMjQuNjgyNyAxNy4zNDY5IDI0LjY4MThDMTcuMjU4NCAyNC42NjQ0IDE3LjE2NjcgMjQuNjYwNyAxNy4wNzU1IDI0LjY1NkMxNy4wNDMyIDI0LjY1NDIgMTcuMDEwNCAyNC42NDc2IDE2Ljk3NzcgMjQuNjQ3NkMxNi45MjE1IDI0LjY0NzYgMTYuODY0OSAyNC42NTg4IDE2LjgwNzMgMjQuNjYzNUMxNi43MzcxIDI0LjY3MDUgMTYuNjY2NSAyNC42NzMzIDE2LjU5NzIgMjQuNjg2NEMxNi41OTE2IDI0LjY4NzggMTYuNTg1MSAyNC42ODc4IDE2LjU3OSAyNC42ODg4QzEzLjA2NTcgMjUuNDM4OSA5LjQ1ODg2IDI0LjM3MTUgNi45MjAzMSAyMS44MjQxQzQuOTMwNjQgMTkuODM3NyAzLjgzMzMzIDE3LjE5MTUgMy44MzMzMyAxNC4zNzVDMy44MzMzMyAxMS41NTg1IDQuOTMwNjQgOC45MTIzMSA2LjkyNDk5IDYuOTIyMThDOC45MTIzMSA0LjkzMDY0IDExLjU1ODUgMy44MzMzMyAxNC4zNzUgMy44MzMzM0MxNy4xOTE1IDMuODMzMzMgMTkuODM3NyA0LjkzMDY0IDIxLjgyNSA2LjkyMjE4QzIxLjgzMyA2LjkyOTY3IDIxLjg0MjMgNi45MzUyOCAyMS44NTA3IDYuOTQzMjRMMjcuMDIxOSAxMi4xMTQ0QzI3LjAzOTIgMTIuMTMyNiAyNy4wNTc1IDEyLjE1MDkgMjcuMDc1NyAxMi4xNjc3TDM0LjAyODMgMTkuMTIwOEMzNC4wNDU2IDE5LjEzODEgMzQuMDYyOSAxOS4xNTU5IDM0LjA4MTIgMTkuMTczMkwzOS4wNTQgMjQuMTQ2QzM5LjA2MjggMjQuMTU0OSAzOS4wNjg1IDI0LjE2NTIgMzkuMDc2OSAyNC4xNzVDNDEuMDY5NCAyNi4xNjIzIDQyLjE2NjcgMjguODA4NSA0Mi4xNjY3IDMxLjYyNUM0Mi4xNjY3IDM0LjQ0MTUgNDEuMDY5NCAzNy4wODc3IDM5LjA3NSAzOS4wNzc4Wk0zMS40MDU1IDExLjA3NzVMMzMuMjQ0NSA5Ljg1MDUyQzMzLjgyOSA5LjQ1OTggMzQuNjE3IDkuNTM3NDggMzUuMTE1MyAxMC4wMzQ5TDM2LjAyNTUgMTAuOTQ1QzM2LjUxNTQgMTEuNDM1OSAzNi42MDE1IDEyLjE4OTMgMzYuMjM0NiAxMi43Nzc1TDM1LjAzMyAxNC43MDQ5TDMxLjQwNTUgMTEuMDc3NVpcIixcImtleVwiOjJ9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0yNi4yNzE4IDI0LjM1NTFDMjcuMDIgMjMuNjA2NCAyNy4wMiAyMi4zOTM1IDI2LjI3MTggMjEuNjQ0OEwyNC4zNTUxIDE5LjcyODJDMjMuNjA3NCAxOC45Nzk5IDIyLjM5MjYgMTguOTc5OSAyMS42NDQ5IDE5LjcyODJDMjAuODk2NiAyMC40NzY5IDIwLjg5NjYgMjEuNjg5OCAyMS42NDQ5IDIyLjQzODVMMjMuNTYxNSAyNC4zNTUxQzIzLjkzNTQgMjQuNzI5OSAyNC40MjU4IDI0LjkxNjYgMjQuOTE2NyAyNC45MTY2QzI1LjQwNzUgMjQuOTE2NiAyNS44OTc5IDI0LjcyOTkgMjYuMjcxOCAyNC4zNTUxWlwiLFwia2V5XCI6M30pXSk7XG59XG5cbkljb25HYW1lRGV2ZWxvcG1lbnQuZGVmYXVsdFByb3BzID0ge1wid2lkdGhcIjpcIjQ2XCIsXCJoZWlnaHRcIjpcIjQ2XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNDYgNDZcIixcImZpbGxcIjpcIm5vbmVcIn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvbkdhbWVEZXZlbG9wbWVudDtcblxuSWNvbkdhbWVEZXZlbG9wbWVudC5kZWZhdWx0ID0gSWNvbkdhbWVEZXZlbG9wbWVudDtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIEljb25QbGF5IChwcm9wcykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIscHJvcHMsW1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIix7XCJjeFwiOlwiMjNcIixcImN5XCI6XCIyM1wiLFwiclwiOlwiMjNcIixcImtleVwiOjB9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLHtcImRcIjpcIk0zMiAyMS4yNjc5QzMzLjMzMzMgMjIuMDM3NyAzMy4zMzMzIDIzLjk2MjMgMzIgMjQuNzMyMUwyMCAzMS42NjAzQzE4LjY2NjcgMzIuNDMwMSAxNyAzMS40Njc4IDE3IDI5LjkyODJMMTcgMTYuMDcxOEMxNyAxNC41MzIyIDE4LjY2NjcgMTMuNTY5OSAyMCAxNC4zMzk3TDMyIDIxLjI2NzlaXCIsXCJmaWxsXCI6XCJ3aGl0ZVwiLFwia2V5XCI6MX0pXSk7XG59XG5cbkljb25QbGF5LmRlZmF1bHRQcm9wcyA9IHtcImNsYXNzTmFtZVwiOlwiaWNvblwiLFwid2lkdGhcIjpcIjQ2XCIsXCJoZWlnaHRcIjpcIjQ2XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNDYgNDZcIixcImZpbGxcIjpcIm5vbmVcIn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvblBsYXk7XG5cbkljb25QbGF5LmRlZmF1bHQgPSBJY29uUGxheTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIEljb25Qcm9kdWN0QWR2ZXJ0aXNlbWVudCAocHJvcHMpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLHByb3BzLFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIse1wiZFwiOlwiTTQ1LjQ0MSAyMy41NjE2TDQzLjUyNDQgMjEuNjQ1TDI5LjE2IDcuMjgwNTZDMjkuMTU4IDcuMjc4NjUgMjkuMTU2MSA3LjI3NjczIDI5LjE1MzMgNy4yNzM4NkwyNC4zNTc4IDIuNDc4MzdMMjIuNDQxMSAwLjU2MTcwOEMyMS42OTM2IC0wLjE4Njc0OCAyMC40Nzg0IC0wLjE4Njc0OCAxOS43MzA5IDAuNTYxNzA4QzE4Ljk4MjUgMS4zMTAxNiAxOC45ODI1IDIuNTIzNDEgMTkuNzMwOSAzLjI3MTg3TDIwLjU2OTUgNC4xMTA0MUwzLjQ4NzI0IDMxLjQ0MUwzLjI3NDQ5IDMxLjIyODNDMi41MjY5OSAzMC40Nzk4IDEuMzExODMgMzAuNDc5OCAwLjU2NDMzMyAzMS4yMjgzQy0wLjE4NDEyMyAzMS45NzY3IC0wLjE4NDEyMyAzMy4xOSAwLjU2NDMzMyAzMy45Mzg0TDIuNDgwOTkgMzUuODU1MUwxMC4xNDc2IDQzLjUyMThMMTIuMDY0MyA0NS40Mzg0QzEyLjQzODEgNDUuODEzMSAxMi45Mjg3IDQ2IDEzLjQxOTQgNDZDMTMuOTEgNDYgMTQuNDAwNyA0NS44MTMxIDE0Ljc3NDUgNDUuNDM4NEMxNS41MjI5IDQ0LjY5IDE1LjUyMjkgNDMuNDc2NyAxNC43NzQ1IDQyLjcyODNMMTQuNTYxNyA0Mi41MTU1TDE2Ljg4MTggNDEuMDY1NkMxNy45MzAyIDQzLjQwNDggMjAuMjc3MiA0NS4wNDE3IDIzLjAwMjcgNDUuMDQxN0MyNi43MDE4IDQ1LjA0MTcgMjkuNzExIDQyLjAzMjUgMjkuNzExIDM4LjMzMzRDMjkuNzExIDM2LjcwOTkgMjkuMTI4MyAzNS4yMDgyIDI4LjEzODQgMzQuMDI5NUw0MS44OTIzIDI1LjQzMzNMNDIuNzMwOSAyNi4yNzE4QzQzLjEwNDYgMjYuNjQ2NSA0My41OTUzIDI2LjgzMzQgNDQuMDg2IDI2LjgzMzRDNDQuNTc2NiAyNi44MzM0IDQ1LjA2NzMgMjYuNjQ2NSA0NS40NDEgMjYuMjcxOEM0Ni4xODk1IDI1LjUyMzMgNDYuMTg5NSAyNC4zMTAxIDQ1LjQ0MSAyMy41NjE2Wk0yMy4wMDI3IDQxLjIwODNDMjEuNjQyOCA0MS4yMDgzIDIwLjUwMTQgNDAuMjU5NiAyMC4yMDM0IDM4Ljk4ODhMMjQuODE3OCAzNi4xMDUyQzI1LjQ3MzMgMzYuNjQyOSAyNS44Nzc3IDM3LjQ2MTMgMjUuODc3NyAzOC4zMzM0QzI1Ljg3NzcgMzkuOTE4NCAyNC41ODc4IDQxLjIwODMgMjMuMDAyNyA0MS4yMDgzWk0yMy4wMjU3IDMyLjcwNDFMMTcuMjE0NCAzNi4zMzQzQzE3LjIwOTYgMzYuMzM3MiAxNy4yMDY3IDM2LjM0MSAxNy4yMDE5IDM2LjM0MzlMMTEuNzc5NyAzOS43MzI1TDYuMjY5MjggMzQuMjIyMUwyMy4zNTE1IDYuODkxNDhMMjUuMzI4NiA4Ljg2ODUyTDE2LjYxNjQgMjEuOTM2M0MxNi4wMjg5IDIyLjgxNyAxNi4yNjc1IDI0LjAwNzMgMTcuMTQ4MiAyNC41OTM4QzE3LjQ3NDEgMjQuODEzMiAxNy44NDQgMjQuOTE2NyAxOC4yMDkxIDI0LjkxNjdDMTguODI4MiAyNC45MTY3IDE5LjQzNjcgMjQuNjE2OCAxOS44MDU3IDI0LjA2MjhMMjguMDkyNCAxMS42MzMzTDM5LjExMDMgMjIuNjUxMkwyMy4wMjU3IDMyLjcwNDFaXCJ9KSk7XG59XG5cbkljb25Qcm9kdWN0QWR2ZXJ0aXNlbWVudC5kZWZhdWx0UHJvcHMgPSB7XCJ3aWR0aFwiOlwiNDdcIixcImhlaWdodFwiOlwiNDZcIixcInZpZXdCb3hcIjpcIjAgMCA0NyA0NlwiLFwiZmlsbFwiOlwibm9uZVwifTtcblxubW9kdWxlLmV4cG9ydHMgPSBJY29uUHJvZHVjdEFkdmVydGlzZW1lbnQ7XG5cbkljb25Qcm9kdWN0QWR2ZXJ0aXNlbWVudC5kZWZhdWx0ID0gSWNvblByb2R1Y3RBZHZlcnRpc2VtZW50O1xuIiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxuZnVuY3Rpb24gSWNvblRyYXZlbEd1aWRhbmNlIChwcm9wcykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIscHJvcHMsUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIix7XCJkXCI6XCJNMS45MTY2NyA0Nkg0NC4wODMzQzQ1LjE0MTMgNDYgNDYgNDUuMTQxMyA0NiA0NC4wODMzVjMyLjY4NDlDNDYgMjkuNTk3IDQ0Ljc5MjcgMjYuNjk5IDQyLjYwMDkgMjQuNTI0NUM0MC40MDgyIDIyLjM0ODIgMzcuNTIxNSAyMS4yMDUgMzQuNDA4OCAyMS4xODc3QzI5LjEzMDQgMjEuMjI4OSAyNi4zNjU5IDIxLjIxOTUgMjQuOTE2NyAyMS4xOTU2VjEuOTE2NjdDMjQuOTE2NyAwLjg1ODY2MyAyNC4wNTggMCAyMyAwSDEuOTE2NjdDMC44NTg2NjMgMCAwIDAuODU4NjYzIDAgMS45MTY2N1Y0NC4wODMzQzAgNDUuMTQxMyAwLjg1ODY2MyA0NiAxLjkxNjY3IDQ2Wk0zLjgzMzMzIDM4LjMzMzNINy42NjY2N1Y0Mi4xNjY3SDMuODMzMzNWMzguMzMzM1pNMjEuMDgzMyAzOC4zMzMzVjQyLjE2NjdIMTEuNVYzOC4zMzMzSDIxLjA4MzNaTTM0LjUgMzguMzMzM1Y0Mi4xNjY3SDI0LjkxNjdWMzguMzMzM0gzNC41Wk0zOC4zMzMzIDQyLjE2NjdWMzguMzMzM0g0Mi4xNjY3VjQyLjE2NjdIMzguMzMzM1pNMjEuMDgzMyAzLjgzMzMzVjcuNjY2NjdIMTcuMjVDMTYuMTkyIDcuNjY2NjcgMTUuMzMzMyA4LjUyNTMzIDE1LjMzMzMgOS41ODMzM0MxNS4zMzMzIDEwLjY0MTMgMTYuMTkyIDExLjUgMTcuMjUgMTEuNUgyMS4wODMzVjE1LjMzMzNIMTcuMjVDMTYuMTkyIDE1LjMzMzMgMTUuMzMzMyAxNi4xOTIgMTUuMzMzMyAxNy4yNUMxNS4zMzMzIDE4LjMwOCAxNi4xOTIgMTkuMTY2NyAxNy4yNSAxOS4xNjY3SDIxLjA4MzNWMjIuOTIyM0MyMS4wNzA3IDIzLjIwMDMgMjEuMTE4IDIzLjQ4MjkgMjEuMjI4OSAyMy43NDk2QzIxLjgwNCAyNS4xMjE2IDIxLjgwNjggMjUuMTIxNiAzNC40Mzg3IDI1LjAyMkMzNi40OTcyIDI1LjAzNTUgMzguNDM5NiAyNS43OTY0IDM5LjkgMjcuMjQ2NUM0MS4zNjE4IDI4LjY5NTMgNDIuMTY2NyAzMC42MjY0IDQyLjE2NjcgMzIuNjg0OVYzNC41SDMuODMzMzNWMy44MzMzM0gyMS4wODMzWlwifSkpO1xufVxuXG5JY29uVHJhdmVsR3VpZGFuY2UuZGVmYXVsdFByb3BzID0ge1wid2lkdGhcIjpcIjQ2XCIsXCJoZWlnaHRcIjpcIjQ2XCIsXCJ2aWV3Qm94XCI6XCIwIDAgNDYgNDZcIixcImZpbGxcIjpcIm5vbmVcIn07XG5cbm1vZHVsZS5leHBvcnRzID0gSWNvblRyYXZlbEd1aWRhbmNlO1xuXG5JY29uVHJhdmVsR3VpZGFuY2UuZGVmYXVsdCA9IEljb25UcmF2ZWxHdWlkYW5jZTtcbiIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIExvZ29KY3BybyAocHJvcHMpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLHByb3BzLFtSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLHtcIndpZHRoXCI6XCI5M1wiLFwiaGVpZ2h0XCI6XCI2MVwiLFwiZmlsbFwiOlwidXJsKCNwYXR0ZXJuMClcIixcImtleVwiOjB9KSxSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLHtcImtleVwiOjF9LFtSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0dGVyblwiLHtcImlkXCI6XCJwYXR0ZXJuMFwiLFwicGF0dGVybkNvbnRlbnRVbml0c1wiOlwib2JqZWN0Qm91bmRpbmdCb3hcIixcIndpZHRoXCI6XCIxXCIsXCJoZWlnaHRcIjpcIjFcIixcImtleVwiOjB9LFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIix7XCJ4bGlua0hyZWZcIjpcIiNpbWFnZTBfMjY1OjI1XCIsXCJ0cmFuc2Zvcm1cIjpcInRyYW5zbGF0ZSgwIC0wLjI2MjI5NSkgc2NhbGUoMC4wMDAyODIxNjcgMC4wMDA0MzAxODkpXCJ9KSksUmVhY3QuY3JlYXRlRWxlbWVudChcImltYWdlXCIse1wiaWRcIjpcImltYWdlMF8yNjU6MjVcIixcIndpZHRoXCI6XCIzNTQ0XCIsXCJoZWlnaHRcIjpcIjM1NDRcIixcInhsaW5rSHJlZlwiOlwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQURkZ0FBQTNZQ0FZQUFBQWpZd0VxQUFBS04ybERRMUJ6VWtkQ0lFbEZRell4T1RZMkxUSXVNUUFBZUp5ZGxuZFVVOWtXaDgrOU43MVFraENLbE5CcmFGSUNTQTI5U0pFdUtqRUpFRXJBa0FBaU5rUlVjRVJSa2FZSU1pamdnS05Ea2JFaWlvVUJVYkhyQkJsRTFIRndGQnVXU1dTdEdkKzhlZS9ObTk4ZjkzNXJuNzNQM1dmdmZkYTZBSkQ4Z3dYQ1RGZ0pnQXloV0JUaDU4V0lqWXRuWUFjQkRQQUFBMndBNEhDenMwSVcrRVlDbVFKODJJeHNtUlA0RjcyNkRpRDUreXJUUDR6QkFQK2ZsTGxaSWpFQVVKaU01L0w0MlZ3WkY4azRQVmVjSmJkUHlaaTJORTNPTUVyT0lsbUNNbGFUYy9Jc1czejJtV1VQT2ZNeWhEd1p5M1BPNG1YdzVOd240NDA1RXI2TWtXQVpGK2NJK0xreXZpWmpnM1JKaGtER2IrU3hHWHhPTmdBb2t0d3U1bk5UWkd3dFk1SW9Nb0l0NDNrQTRFakpYL0RTTDFqTXp4UExEOFhPekZvdUVpU25pQmttWEZPR2paTVRpK0hQejAzbmk4WE1NQTQzalNQaU1kaVpHVmtjNFhJQVpzLzhXUlI1YlJteUlqdllPRGs0TUcwdGJiNG8xSDlkL0p1UzkzYVdYb1IvN2hsRUgvakQ5bGQrbVEwQXNLWmx0ZG42aDIxcEZRQmQ2d0ZRdS8ySHpXQXZBSXF5dm5VT2ZYRWV1bnhlVXNUaUxHY3JxOXpjWEVzQm4yc3BMK2p2K3A4T2YwTmZmTTlTdnQzdjVXRjQ4NU00a25ReFExNDNibVo2cGtURXlNN2ljUGtNNXArSCtCOEgvblVlRmhIOEpMNklMNVJGUk11bVRDQk1sclZieUJPSUJabENoa0Q0bjVyNEQ4UCtwTm01bG9uYStCSFFsbGdDcFNFYVFINGVBQ2dxRVNBSmUyUXIwTzk5QzhaSEEvbk5pOUdabUozN3o0TCtmVmU0VFA3SUZpUi9qbU5IUkRLNEVsSE83SnI4V2dJMElBQkZRQVBxUUJ2b0F4UEFCTGJBRWJnQUQrQURBa0VvaUFSeFlESGdnaFNRQVVRZ0Z4U0F0YUFZbElLdFlDZW9CbldnRVRTRE5uQVlkSUZqNERRNEJ5NkJ5MkFFM0FGU01BNmVnQ253Q3N4QUVJU0Z5QkFWVW9kMElFUElITEtGV0pBYjVBTUZReEZRSEpRSUpVTkNTQUlWUU91Z1VxZ2Nxb2Jxb1dib1crZ29kQnE2QUExRHQ2QlJhQkw2RlhvSEl6QUpwc0Zhc0JGc0JiTmdUemdJam9RWHdjbndNamdmTG9LM3dKVndBM3dRN29SUHc1ZmdFVmdLUDRHbkVZQVFFVHFpaXpBUkZzSkdRcEY0SkFrUklhdVFFcVFDYVVEYWtCNmtIN21LU0pHbnlGc1VCa1ZGTVZCTWxBdktIeFdGNHFLV29WYWhOcU9xVVFkUW5hZysxRlhVS0dvSzlSRk5SbXVpemRITzZBQjBMRG9abllzdVJsZWdtOUFkNkxQb0VmUTQraFVHZzZGampER09HSDlNSENZVnN3S3pHYk1iMDQ0NWhSbkdqR0dtc1Zpc090WWM2NG9OeFhLd1ltd3h0Z3A3RUhzU2V3VTdqbjJESStKMGNMWTRYMXc4VG9ncnhGWGdXbkFuY0Zkd0U3Z1p2QkxlRU8rTUQ4WHo4TXZ4WmZoR2ZBOStDRCtPbnlFb0U0d0pyb1JJUWlwaExhR1MwRVk0UzdoTGVFRWtFdldJVHNSd29vQzRobGhKUEVROFR4d2x2aVZSU0dZa05pbUJKQ0Z0SWUwbm5TTGRJcjBnazhsR1pBOXlQRmxNM2tKdUpwOGgzeWUvVWFBcVdDb0VLUEFVVml2VUtIUXFYRkY0cG9oWE5GVDBWRnlzbUs5WW9YaEVjVWp4cVJKZXlVaUpyY1JSV3FWVW8zUlU2WWJTdERKVjJVWTVWRGxEZWJOeWkvSUY1VWNVTE1XSTRrUGhVWW9vK3lobktHTlVoS3BQWlZPNTFIWFVSdXBaNmpnTlF6T21CZEJTYWFXMGIyaUR0Q2tWaW9xZFNyUktua3FOeW5FVktSMmhHOUVENk9uME12cGgrblg2TzFVdFZVOVZ2dW9tMVRiVks2cXYxZWFvZWFqeDFVclUydFZHMU42cE05UjkxTlBVdDZsM3FkL1RRR21ZYVlScjVHcnMwVGlyOFhRT2JZN0xITzZja2ptSDU5eldoRFhOTkNNMFYyanUweHpRbk5iUzF2TFR5dEtxMGpxajlWU2JydTJobmFxOVEvdUU5cVFPVmNkTlI2Q3pRK2Vrem1PR0NzT1RrYzZvWlBReHBuUTFkZjExSmJyMXVvTzZNM3JHZWxGNmhYcnRldmYwQ2Zvcy9TVDlIZnE5K2xNR09nWWhCZ1VHclFhM0RmR0dMTU1VdzEyRy9ZYXZqWXlOWW93MkdIVVpQVEpXTXc0d3pqZHVOYjVyUWpaeE4xbG0wbUJ5elJSanlqSk5NOTF0ZXRrTU5yTTNTekdyTVJzeWg4MGR6QVhtdTgySExkQVdUaFpDaXdhTEcwd1MwNU9adzJ4bGpsclNMWU10Q3kyN0xKOVpHVmpGVzIyejZyZjZhRzF2blc3ZGFIM0hobUlUYUZObzAyUHpxNjJaTGRlMnh2YmFYUEpjMzdtcjUzYlBmVzVuYnNlMzIyTjMwNTVxSDJLL3diN1gvb09EbzRQSW9jMWgwdEhBTWRHeDF2RUdpOFlLWTIxbW5YZENPM2s1clhZNjV2VFcyY0ZaN0h6WStSY1hwa3VhUzR2TG8zbkc4L2p6R3VlTnVlcTVjbHpyWGFWdURMZEV0NzF1VW5kZGQ0NTdnL3NERDMwUG5rZVR4NFNucVdlcTUwSFBaMTdXWGlLdkRxL1hiR2YyU3ZZcGI4VGJ6N3ZFZTlDSDRoUGxVKzF6MzFmUE45bTMxWGZLejk1dmhkOHBmN1Iva1A4Mi94c0JXZ0hjZ09hQXFVREh3SldCZlVHa29BVkIxVUVQZ3MyQ1JjRTlJWEJJWU1qMmtMdnpEZWNMNTNlRmd0Q0EwTzJoOThLTXc1YUZmUitPQ1E4THJ3bC9HR0VUVVJEUnY0QzZZTW1DbGdXdklyMGl5eUx2UkpsRVNhSjZveFdqRTZLYm8xL0hlTWVVeDBoanJXSlh4bDZLMDRnVHhIWEhZK09qNDV2aXB4ZjZMTnk1Y0R6QlBxRTQ0Zm9pNDBWNWl5NHMxbGljdnZqNEVzVWxuQ1ZIRXRHSk1Za3RpZTg1b1p3R3p2VFNnS1cxUzZlNGJPNHU3aE9lQjI4SGI1THZ5aS9uVHlTNUpwVW5QVXAyVGQ2ZVBKbmlubEtSOGxUQUZsUUxucWY2cDlhbHZrNExUZHVmOWlrOUpyMDlBNWVSbUhGVVNCR21DZnN5dFRQek1vZXp6TE9LczZUTG5KZnRYRFlsQ2hJMVpVUFppN0s3eFRUWno5U0F4RVN5WGpLYTQ1WlRrL01tTnpyM1NKNXluakJ2WUxuWjhrM0xKL0o5ODc5ZWdWckJYZEZib0Z1d3RtQjBwZWZLK2xYUXFxV3JlbGZycnk1YVBiN0diODJCdFlTMWFXdC9LTFF1TEM5OHVTNW1YVStSVnRHYW9ySDFmdXRiaXhXS1JjVTNOcmhzcU51STJpallPTGhwN3FhcVRSOUxlQ1VYUzYxTEswcmZiK1p1dnZpVnpWZVZYMzNha3JSbHNNeWhiTTlXekZiaDF1dmIzTGNkS0ZjdXp5OGYyeDZ5dlhNSFkwZkpqcGM3bCt5OFVHRlhVYmVMc0V1eVMxb1pYTmxkWlZDMXRlcDlkVXIxU0kxWFRYdXRadTJtMnRlN2VidXY3UEhZMDFhblZWZGE5MjZ2WU8vTmVyLzZ6Z2FqaG9wOW1IMDUreDQyUmpmMmY4MzZ1cmxKbzZtMDZjTis0WDdwZ1lnRGZjMk96YzB0bWkxbHJYQ3JwSFh5WU1MQnk5OTRmOVBkeG15cmI2ZTNseDRDaHlTSEhuK2IrTzMxdzBHSGU0K3dqclI5Wi9oZGJRZTFvNlFUNmx6ZU9kV1YwaVh0anVzZVBocDR0TGZIcGFmamU4dnY5eC9UUFZaelhPVjQyUW5DaWFJVG4wN21uNXcrbFhYcTZlbmswMk85UzNydm5JazljNjB2dkcvd2JORFo4K2Q4ejUzcDkrdy9lZDcxL0xFTHpoZU9YbVJkN0xya2NLbHp3SDZnNHdmN0h6b0dIUVk3aHh5SHVpODdYZTRabmpkODRvcjdsZE5YdmErZXV4Wnc3ZExJL0pIaDYxSFhiOTVJdUNHOXlidjU2RmI2cmVlM2MyN1AzRmx6RjMyMzVKN1N2WXI3bXZjYmZqVDlzVjNxSUQwKzZqMDY4R0RCZ3p0ajNMRW5QMlgvOUg2ODZDSDVZY1dFemtUekk5dEh4eVo5Snk4L1h2aDQvRW5XazVtbnhUOHIvMXo3ek9UWmQ3OTQvREl3RlRzMS9sejAvTk92bTErb3Y5ai8wdTVsNzNUWTlQMVhHYTltWHBlOFVYOXo0QzNyYmYrN21IY1RNN252c2U4clA1aCs2UGtZOVBIdXA0eFBuMzREOTRUeis0OXdaaW9BQUFBSmNFaFpjd0FBTGlNQUFDNGpBWGlsUDNZQUFDQUFTVVJCVkhpYzdOc3hBUUF3RElDd0hmVnZ1WlBSZzBRQkJwamRmUUFBQUFBQUFBQUFBQUFBQUFCUU05Y0JBQUFBQUFBQUFBQUFBQUFBQUhEQllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQUFBQUFDREpZQWNBQUFBQUFBQUFBQUFBQUFCQWtzRU9BQUFBQUFBQUFBQUFBQUFBZ0NTREhRQUFBQUFBQUFBQUFBQUFBQUJKQmpzQUFBQUFBQUFBQUFBQUFBQUFrZ3gyQUFBQUFBQUFBQUFBQUFBQUFDUVo3QUFBQUFBQUFBQUFBQUFBQUFCSU10Z0JBQUFBQUFBQUFBQUFBQUFBa0dTd0F3QUFBQUFBQUFBQUFBQUFBQ0RKWUFjQUFBQUFBQUFBQUFBQUFBQkFrc0VPQUFBQUFBQUFBQUFBQUFBQWdDU0RIUUFBQUFBQUFBQUFBQUFBQUFCSkJqc0FBQUFBQUFBQUFBQUFBQUFBa2d4MkFBQUFBQUFBQUFBQUFBQUFBQ1FaN0FBQUFBQUFBQUFBQUFBQUFBQklNdGdCQUFBQUFBQUFBQUFBQUFBQWtHU3dBd0FBQUFBQUFBQUFBQUFBQUNESllBY0FBQUFBQUFBQUFBQUFBQUJBa3NFT0FBQUFBQUFBQUFBQUFBQUFnQ1NESFFBQUFBQUFBQUFBQUFBQUFBQkpCanNBQUFBQUFBQUFBQUFBQUFBQWtneDJBQUFBQUFBQUFBQUFBQUFBQUNRWjdBQUFBQUFBQUFBQUFBQUFBQUJJTXRnQkFBQUFBQUFBQUFBQUFBQUFrR1N3QXdBQUFBQUFBQUFBQVBqczI0RUFBQUFBZ0NCLzYwRXVqd0FBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQTQyRkVtZ0FBSUFCSlJFRlVBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFpTDE3QWRLckxCTTgvcnpuZk4zcGRDN2t3aVVKbUVFUVJNUXloQ1NFRUFpRVc0U1JjVVpHdkRBNzVleGE0MDdWV283S3FvdzFLWFpuYW5hQkNJZ1dqZ0dkTFd1V2NuVFVXcTN5Z3VNU2N5V0VjRmxBQkM5NFEwQkVpRnlUN3ZQdStSS3V6c2dnQXFmVDcrOVh2Tjg1NS8wNm5hZVQ3cTlUZFAzckFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQUFBQUFBQUFBUUpFRWRnQUFBQUFBQUFBQUFBQUFBQUFVU1dBSEFBQUFBQUFBQUFBQUFBQUFRSkVFZGdBQUFBQUFBQUFBQUFBQUFBQVVTV0FIQUFBQUFBQUFBQUFBQUFBQVFKRUVkZ0FBQUFBQUFBQUFBQUFBQUFBVVNXQUhBQUFBQUFBQXY2V3FxdEtyVi83VHdGQU05VWFuVFJrY0hoa2NURU81bDBaemI3U3BCM3U5a2NIUlhGZDFycW9tajFZN2Y4MUEvZVI1WC8rNTBXaDJYdGRSTmFPcGFaNTgvNmx1bWgyanpSUG5VZTBZaVNwR2R1d1kyRjczUnJmblI5TklydE5JMDd0LzVPNWZUTngrUjF5MXZWbTVzdm4xT1FFQUFBQUFBSUJuSjdBREFBQUFBQUJnM0ZsKzdwcWgyRHVtamVaNmFwMnJxVTJrcVJIVjVCUjVjdjhZcVg5TTdURW01b2poaUYzWDdmUHRlUnBxMzBXNzh0QXp6K1BKdGV4akczZjluQzAvL2hzT1BIN3M5V081WFJ0UGxIVFY0enY5TjYxVC9kU1FxZisyVDEwLy9Yem45Y0RUcjNmOUJvUDlRNjUzVGJIVDlKaTdaOFRMWWtVcys5alZJKzNHby8zVi9sN2IyM2UvZmRkNWZxdzlQcElpUGR6dVA1eHlQQnlwYWMvVHcrM2JQTngvTHFKNXNMMStNSEpxajgyRDdWNS9iYXVpMlRhNnZYN280WHI3QTlmZmY5VTJFUjhBQUFBQUFBRGpqY0FPQUFBQUFBQ0FNZW53VlZkT21qSXdQTE0za0dZMFRacFJWZldNbkdKR3lubEc5TXV5bkdaRWV4MDVUMnVQVXlQU3RIWi82czYxOThTZENWcWRZbWZJOXVSdDQvb1gwWS9kMHEvdHBHZGMvZXZ6M1VML1ozK1QrK3VaSDhXdmZhenAxM2Y3cWllZlMwLzcwK3J2VjRQOWR6b2hsczQ4cFRuMm81dTJ0WnZiY3J2YU43Mi8vWU84UDZmOFFQdmVmdEgrUGZ5eVNYRmZOSEZmU3ZtK0psWDN4a2g3SFhIZnhnZStkcjg0RHdBQUFBQUFnTEZJWUFjQUFBQUFBTUJMWXVkZDVhWU56WW9KYVZiRTZLd1U5ZDd0OXA3dG1wa2o5azd0ZXZ5NnYvYWFQbW1QaVUvODJ1cnhtN2s5STRaN3NvbmI3VUs0M1ZXL3ZPdEhqTk9lL0JOUFQwdjEwdU5wWHJYcmlaMS9aWS8vTkhMcHpGTkdqcjFrMDMwNXhUM3RXOStUSTkrYmNybzNJdjg4Y3R6VFZIRlAxVFIzalRiMVhjMEQ5OSt6Y2VXS2JTL2xCd1lBQUFBQUFFQzVCSFlBQUFBQUFBRDhUdnJoM01nK3ZUbFZVKzFYVjJtL25LczVLY1hzSERFbmNzeEtFYk1pdGNkOUprNTc2bGZWejNnZkVybHhyOWYrSlQ4UlVlNks4cDY2WmQ3allWNGRkWHRTelpnV3gxeXk2WkYyNSs1MjNkVitEdDJWVTl3Wk9mK3NQYjh6NWZ5VFhLYzc4Mmk2Yy8yN0Y5L1gzWWNFQUFBQUFBREFlQ0N3QXdBQUFBQUE0RGQ2emJtZkc5eHI3LzNtTmxVOXQ0cG1ic3BwYmtUYU4xTHMxejY5WCtROEorMHpjZVpBUDVPcWR2MmE5UFFiekNubmVINzZkeS9jZitkNnNzVjdLc3JySDFJZGNjd2xHeC9PRVhlMjF6OXBQeGQvbENQOXBIM3FwemxHMi9QNFVXb2Uvc242ZDU4c3dnTUFBQUFBQU9BM0V0Z0JBQUFBQUFBVTdQQlZWMDZhUG5ueXl5TjYrMWVSOTgrUlhwWWk1c2F1dUdudVByTitiMVo3ckhaMWNwVmdqakVtRGFmSXIyaFBYdEVQOEo3NDlFeFAzQ0d4bnRLUDhCNXN6KzZJeUhkRVRuYzBxZmxoYXFvN1JuSytZN1RaY2NjMTcxbDJiemV6QXdBQUFBQUFNQllJN0FBQUFBQUFBTWF4cXFyUzBaZXNtejFRMVFla1NBZWtLaDJRYzd3OFJSd1FLUTZZT1huYTdIZ3ltMHY2T2NhanllMDZyUDM4UG16WDNmQ3FuYTFvcnozcjFZT3g5SktOMjlybnZ4KzVYU20rbXlQL29CbU43emVSdjN2TkF5TS9hbFl1RytuNkF3QUFBQUFBQU9ERkk3QURBQUFBQUFBWUI0NithTk9NQ1VQVndTbkh3U25GUVRtMXgwZ0hMNy8wNm9QYXB5YzkvVzJUaWc2ZWJtcTc1a1ZxVit6S1RPczZvbTZQUzZZUDdsajZrWTEzdE51M3Q2c2YzOTNlTkhGYlNqdHUyM1QvVlQ5cVZxNXNPcHdiQUFBQUFBQ0FGNERBRGdBQUFBQUFZRGV4OEoyckI2YTg1ckFENjdwM1NFN05JU21xUXlMRks5dW5EaDRlcm1ma0hFKzdGeDN3QWhobzEwR1ByMTN4WGRVL0c0d2wwMDkrZE9sSE5uNC9SNzR0Y3R3YUtYOTd0RW0zYk5zUjM3bmw3Q1cvNm5Kb0FBQUFBQUFBbmp1QkhRQUFBQUFBd0JoejlFV2JKZzRQcGxkRkx3N05rVjZaSWgwU2tRK1pObjllUC9LWjBIK2JGRlhIVTBMeGh0cDFhUHYxZWVpdW9qVkZyLzJ5bkRFaDh0S1BiUHhwdTNGcmZ6VTUzOUtrZEhQZC9PcW05ZTgrK2I1T0p3WUFBQUFBQU9CZkVkZ0JBQUFBQUFCMFpQbTVhM3IxN0lrSE56a2RWcVY0ZFVRK0xOcno0ZUg2d1BicHV2ODJUOTJKemozcFlEZlIvMkxkNy9GMVlrcHAxeGR6TlNXTy9zakdPeVBIVFpIeUxVMlR2bDNsa1p1YWJRL2R0SEhsaW0yZFRnd0FBQUFBQUZBd2dSMEFBQUFBQU1CTFlObEgxKzFWOTRaZVcxWE52QlF4THlLOXBwNDkvTXIycVFuVmsrMWMwdEhCK0Rhbi9ScWYwMzZobjF6dHZBbGxMNnJwZStTalA3TGhoem5TalNueWpVMXVic2hOM0xoNTAxM2ZhejV6eG1qWEF3TUFBQUFBQUl4M0Fqc0FBQUFBQUlBWFVIWG01K3JqanQzM29McFh6OHRSdlRhbGFJOHhiM0J3YU5hdXQxRFFBYy9RTDJ2M2J4LzJiNCtuVjFGRi83K2psc3g1Nk9pTE45emNQbjk5NUxpdXlYSDl5TGI3YnJ4bTVlOC8zUEc4QUFBQUFBQUE0NHJBRGdBQUFBQUE0SGxhZnU2YVhyM1AwS0VwcFFVUjZmQjJ6VC94aFAzbnRVOE41M2dxcFpQVUFjL0RwSFl0MnJuNkNWNjdCcWJOR0ZseThZWmJjODdYcDVTdmEzZTM3bmpzMGV1dSthOG5QTkQxc0FBQUFBQUFBTHNyZ1IwQUFBQUFBTUJ6MEkvcDB1eUpyNjVUSEpGemRVU0ttTitiTSttMWtXTmkxN01CeGVqL2ZQZXdsTkpoRWVtcy9zYkFoSWw1eWNVYmJtOWZpN1pFYXE1dFJ2T1diYVAxZGJlY3ZlUlhIYzhLQUFBQUFBQ3dXeERZQVFBQUFBQUEvSnFxcXRKeEg5dHdZSzlYOSs4ZXRUQWlMZXJObWJUenpuVDk1NU5iMGdGalIvOFY2ZUQyOGVEMjFldXRWUjB4clk1bXljWHJiOHY5NkM3UzFhTXh1dm1CSHp4MHczY3VYdkZZMThNQ0FBQUFBQUNNTlFJN0FBQUFBQUNnZU10WHI5bXpib1lYUjRxRmtkS2lFLzkrY3orc205SDFYQURQVXhXUkRra3BEbW5QeitwRkhUTVBtUHJZVVJkdHVDNGliMDQ1WDdNOWpXN2ErcDdqdjljMFRlNTZXQUFBQUFBQWdDNEo3QUFBQUFBQWdLSlU1NTVibmJEUGlzT3FxbHFTSXgzVmJpM3BwVWtIUmhYdVN3ZU1aeFBhRjduRkVXbHgvemFjZysyTDN1SVByN3QzeVlVYk5veW12REUxellhZlZYZGY4OE4zbi9GSTE0TUNBQUFBQUFDOGxBUjJBQUFBQUFEQXVIYnk2bi9aSS9JZVI2WElSK1dVbHB3MDU3VCszZW1tZGowWHdCaXdaNlE0dllwMGVsUjF6SWs1T3haZnRPR0c5dlZ5UTVQVGhvalJEVmYvNVRFLzducElBQUFBQUFDQUY1UEFEZ0FBQUFBQUdGZVdyVjQzZTBJejRaaFVwYVBieTZVcDluaHRwS2lqZlhDTE9vQm5OZEMrVGk1b1h5OFhWQ25lRlZIRlVSZXQvMzZPV05mdXI0OG1yN3Y2ZmNkK3UybWEzUFdnQUFBQUFBQUFMeFNCSFFBQUFBQUFzRnRiZnVtbVYvUjYxYkdSMHRHUjA5S2hHRG80cXE2bkFoZzNEa2p0YW8vL0lhb1VSNjVhKzR1akxseTNQaUt0elNNalYyM2U4dlBybXMrY01kcjFrQUFBQUFBQUFNK1h3QTRBQUFBQUFOaXQ5SU82Z1Y1OVhFUmFGaW1PR3hqbzdkZjFUQURGU0RFemNqcTlQVHM5OVhxeGFQSHNCL3JCWFpQVDJ0RTBjdFhXYmJHbFdibHNwT3N4QVFBQUFBQUFuaXVCSFFBQUFBQUFNS1lKNmdER3JoU3hSL3Q0YWtweGFpOTZzV2hxL09ySUM5ZXZqeHhyOG1qenpTMWI3cjdXSGU0QUFBQUFBSUN4VEdBSEFBQUFBQUNNS2NzdjNUS3IxOHZMcTFTZDBGNmVPRERRbTl2MVRBQThaMU5TeElwSXNTTDFxdjRkN242NStNTDFheUx5LzIyYTBXOXVPZnY0bTV1bXlWMFBDUUFBQUFBQThBU0JIUUFBQUFBQTBLbWpQcnA1NnRTaDZyakljVUpLNmNUQmdmU3FpSlM2bmd1QUY4VDBkcjJoZlYxL1ExWDFZdEdxdFhjdnZuRDlONXNjMzBpcHVmTHF2enpteDEwUENBQUFBQUFBbEUxZ0J3QUFBQUFBdktTV243dW0xNXN6dERoRmZYSks2WVE5aHVwRjBmK1poYVFPb0FUN3RPc3RWWXEzUkZTeCtNTDF0K2FJcjBjMC8zTC90b2V1K3M3S0ZkdTZIaEFBQUFBQUFDaUx3QTRBQUFBQUFIalJIWGZwbHBkTjZPVlRVbFNuRE80NytjUjJhMXJYTXdFd0poeVMyaFZSdld2NjFDazdqdnp3K28wNTRzclIwWkd2WHZmd1ZWdWJsU3VicmdjRUFBQUFBQURHTjRFZEFBQUFBQUR3Z2p2Nm9rMFRKdzMzbGxVcG5SSXBWZ3dOcEVQQ0xlb0FlSFlEN1RxMi9XNXhiSy91L2ZlRmswLzgrWkdyMW44dEluOXRlenp5OWV2ZWU5STlYUThJQUFBQUFBQ01Qd0k3QUFBQUFBRGdCYkg4NzYvZWY3Q3VUODBwblRabHlzRHg3ZGJFeUYxUEJjQnVLOFZlN2VOWjdjbFpnekhjSExscTNkWjI3NnN4a3I5eXpiVjNYOTE4NW96UnJrY0VBQUFBQUFCMmZ3STdBQUFBQUFEZ2VWbTRldlhBekRUdm1JanFkZTNscVlPOTNxSDlmZmVwQStCRlVFVktDOXJqZ3VpbER5MDhjdmE5UjY1YTk5VW1tcTg4K3VDalgvMS9LMCsrcitzQkFRQUFBQUNBM1pQQURnQUFBQUFBZU02V2ZYVGRYa05EUTZlbGxFNmJXYzAvcWQzYW8rdVpBQ2pTbnBIaXJDcXFzNGFuREk4YytlRzFteUxTVjBaemZIbkxlNWZlMlBWd0FBQUFBQURBN2tOZ0J3QUFBQUFBUEt1VFBySDUwTHF1VGsrUlhqOXg0c1FqMjYyNjY1a0E0R2w2RVdscGUxeGFwL2piUmF2VzNaRWovNThtbWk5VnQ5KzI1cHFQdjJOSDF3TUNBQUFBQUFCamw4QU9BQUFBQUFCNGhvV3JWdy9NVFBPTzZkK2xMaUtkM3F2clYzUTlFd0E4WnluMlQ1SGVWVWY5cmpqNFZROHMrdkM2citUY2ZHbjd5SU5mdWVIOXAvNnk2L0VBQUFBQUFJQ3hSV0FIQUFBQUFBREV3dFZmSHA0Wis1eWNxdlNIZTFielg5OXVUZTk2SmdCNEFlelJyamVuVkwxNVFtL3Fqa1dyMXE3SmtiL1FOTnUvZU8zWko5N1o5WEFBQUFBQUFFRDNCSFlBQUFBQUFGQ281UmV2bVRZNGVkTHZwK2hIZGJOWHRGdkRYYzhFQUMraWdZaDBZdnQ5NzhTNkdycGswUVZyTjdmWFgyaEdSeisvNWYzTHZ0djFjQUFBQUFBQVFEY0VkZ0FBQUFBQVVKQ1RMcjk2bjE3dS9XR2srSU1Ka3ljdmI3Y0d1NTRKQURwUVJVcUwyK1BpcWxmL3owV3IxdDBVT1grK1NlbWZ0N3gzNlkxZER3Y0FBQUFBQUx4MEJIWUFBQUFBQURET0xiOTB5NnpCQ2ZGSGtkTWJlOUZiRmlucXJtY0NnREhtc0VqcHNDcmlyeGV0V25kYmsvUG5VcVIvdnVaOVM3ZDJQUmdBQUFBQUFQRGlFdGdCQUFBQUFNQTR0R3oxdXRuRDljUTM1b2cvbmpBaExZMytuWG9BZ09maTRKVFNPZTN4bklXcjF0MmVjLzZzMkE0QUFBQUFBTVl2Z1IwQUFBQUFBSXdUcDY3ZU9ydEorWXlvNG96aGV1TE9xQzUxUFJRQTdONE9laUsyVzdCcTNYY2o1Mzlxb3ZuczF2Y3R1Nzdyd1FBQUFBQUFnQmVHd0E0QUFBQUFBSFpqci92a3Boa3BELzVSZTNwbTFIRjhGYW5Pa2JzZUN3REduUlR4aXZieG5EcnFjeFplc083V25QTm4ydTNQYkRuN21HOTNQUnNBQUFBQUFQRDhDZXdBQUFBQUFHQTNjOHluTmJzT0FBQWdBRWxFUVZUNUc2Wk1tVEg0QnpuU21Ta05uQndwQnJ1ZUNRQUtjMGhLYVdWN1hMbndnblUzNVdpdUdIMHNYWEhkWHgzemc2NEhBd0FBQUFBQWZqc0NPd0FBQUFBQTJBMjg4cU5mbmZEeTRiMWZsM0oreTVTWlE2OXZ0eWFtcm9jQ0FQb09TNUgrdGpjaC9tYmhCV3MzNWh4WDdCalo4ZGtiUHJqODdxNEhBd0FBQUFBQS9uMENPd0FBQUFBQUdLT3Fxa29uWDNiMU1WV3UzbmJnOE41LzNHNU5qeVNyQTRBeHF2OU5la243clhySjRNREFoUXN1V1B1TkhQbUtSL0w5WDdqbDdOTi8xZlZ3QUFBQUFBREF2MDFnQndBQUFBQUFZOHhKbjloOGFLK3UzN2Jpc212ZUZwRitMelIxQUxDNzZiWGZ2bGUwMzhkWERLZnBseTY0WU8wWGM4US9YdmRROC9WbTViS1Jyb2NEQUFBQUFBQ2VJckFEQUFBQUFJQXhZUG1sVzJZTlRVaHZqWnplTnREcnplOTZIZ0RnQlRQY3JyZW1kczJmVk4xMXhQbHIvL2RvMnZHUDE3OXYrZGF1QndNQUFBQUFBQVIyQUFBQUFBRFFtZVhucmhtYXNPK1UweVBsUHhtYVVLMkkvdiszZDdjNkFCalBacVVVNytuRndIdU91T0JidDBTa1QrZnRJNS9lZXM3eFArMTZNQUFBQUFBQUtKWEFEZ0FBQUFBQVhtS25YTDU1Y1JXOVB4MTYyWlF6Mjh2cG9hb0RnT0trU0llMmg3OUxnNzIvV1hEQjJpdWphZjdYZlkvRUY3Ky9jdG1qWGM4R0FBQUFBQUFsRWRnQkFBQUFBTUJMWVBubG0vY2JpdDVaT2NXZjFxbDNTTmZ6QUFCalJ0MnVGWkdxRlRPRzQ1Y0x6bDk3Ulk3bVU5ZWV2V3hMMTRNQkFBQUFBRUFKQkhZQUFBQUFBUEFpZWMyNW54dmNkNytYbjE2bDlQYWgxRHVsM2FyZHF3NEFlQmJUMi9VWEthcS9XSEQrMnBzajUwL201dUZQWC91QkZUL3ZlakFBQUFBQUFCaXZCSFlBQUFBQUFQQUNPKzBUbXcrTmdkNS9uRHYzNVgrU2M5cXI2M2tBZ04zU3F5T2xWVkZQK3JzanpsLzd4ZHpFNWRjLytzMXZOQ3RYTmwwUEJnQUFBQUFBNDRuQURnQUFBQUFBWGdESGZHckRsQ25OMEptcGlyZkhRRy9KcmwzM3F3TUFmbWVEN1hwVCsyK01OeDArZlB5UDVwKzM5aDhlR3huNTVNM25IUC9EcmdjREFBQUFBSUR4UUdBSEFBQUFBQUMvZzFNK2RjMkNYcTcvZkdvYWVuTlVNYm5yZVFDQThTek5UU24rZW1pZzk2RWp6bC83OVNaaTlRM2Z1L1ZMemNmZnNhUHJ5UUFBQUFBQVlIY2xzQU1BQUFBQWdOOVMvMjUxVTJQd0xSSFZPM3BSTDNDak9nRGdKVmExYTBYN3NPTHdBdy81MlJIbmZldnluUFBsVzkrLzdJNnVCd01BQUFBQWdOMk53QTRBQUFBQUFKNmpVeTdiTXE5WFYzOCtOWWJlMWw1TzZYb2VBSURXN0VqcFF5bWxjM2JkMVc1azlRM2YrNjY3MmdFQUFBQUF3SE1rc0FNQUFBQUFnR2R4OUVXYkprNmQwbnR6VlZYdjdOWFZvcTduQVFENERSNi9xMTI5WXQ0QnIvenAvUFBYWE5aRVhIYjkyY3QrMHZWZ0FBQUFBQUF3bGduc0FBQUFBQURnMzNES0p6WWYxQnZvdlhQYUhvTnZieStuZHowUEFNQnpsVkxzMno2dXJDUCthdjc1My9weU5LT1hYdi9CRTY1c21pWjNQUnNBQUFBQUFJdzFBanNBQUFBQUFIaGNkZWJuNnBOUE9lRDFkWXIvM0J2b25kUnVwYTVuQWdENEhmVGFmOHk4SWFmNkRmUCt4MVczenp0dnpTZDJOS09mdXZrRHkzL1I5V0FBQUFBQUFEQldDT3dBQUFBQUFDamU4a3UzekJxYWtQN1Q2MVljOEk3MmNtN1g4d0FBdkFnT3FpS2RQNkhxL2JmRHoxdHpSUnFOUzdaK2NObjFYUThGQUFBQUFBQmRFOWdCQUFBQUFGQ3NVeS9ic3JDcTZuZE5IRXB2aWtpRFhjOERBUEFTbUpnaS9WblU4V2Z6ejF2enJmYmZRQis3L3BIOCtXYmxzcEd1QndNQUFBQUFnQzRJN0FBQUFBQUFLTXJDMVZzSDlxN1RHMVBLLzZXcTZ5VzdkbE8zUXdFQWRDSWQyejRjTzI5aSt2SDg4NzcxOFllYWgxZC81d01yZnQ3MVZBQUFBQUFBOEZJUzJBRUFBQUFBVUlUVC9tSGRYdW4vczNjbmNGNVc5ZjdBejNsK004TW1pR3RtMXkwUkRZWGNjTXRDQjFSVWRpbGJic3N0VGJOdWFtcHU2TTlSTnBkTXExdmUvS3ZJVXRkN3VTMW1XYWdENDVZRnNncUNtbGRMVzB6TlhKQmw1bm4renlDMzIyTG1BcHhaM205ZjN6bm5QQVA0U1FGL0UvT1prL2M0NlcwMThUUGxjWHVsT2dDQVA5bWhuQWs5c3U0WDdudlpuZDl1RHZsVmk3OTQyS0xVb1FBQUFBQUFZRk5Rc0FNQUFBQUFvRU03K29hZnY3c1NhMCtQb2NjSFF3eGRVdWNCQUdqRFdsOHJmYUltWkovWTk3STc1NFM4dUhyaDZqazM1OVZxbmpvWUFBQUFBQUJzTEFwMkFBQUFBQUIwT0ZtV3hhT3ZuM3QwRE5rWmxWaGJuem9QQUVBN2RGakk0bUY3ZHp2OEYvdE9idnJhcXVmK2VOMnl5U05lU0IwS0FBQUFBQUEyTkFVN0FBQUFBQUE2alBkY2RWKzMzcHQzK2VneDE5OS9lbm5jSTNVZUFJQU9ZTmVReFM5MzNiTDNSWHRQdnZQYWx0VnJ2N3FrT3ZpWHFVTUJBQUFBQU1DR29tQUhBQUFBQUVDN2Q4UjFQM3RiWGFYdWxDMTZkem1sUEc2ZE9nOEFRQWUwZVl6aHpKcXV0YWZ1TTducHYvSllYTG5vN01QdVR4MEtBQUFBQUFEZUtnVTdBQUFBQUFEYXJXTnVtTGQ3Rml0bmRxblVmYlE4ZGttZEJ3Q2dFNmdOTVg0NEMvSEQrMXg2NTV5aWFQbnk0dFYzM3BKWHEzbnFZQUFBQUFBQThHWW8yQUVBQUFBQTBPNGNQV1hlSVZsUk9TdUxsUkhsTVV1ZEJ3Q2drem9zeHNwaEE3b2V2bUx2UzV1dWVQblhMMDliY2ZYUTFhbERBUUFBQUFEQUc2RmdCd0FBQUFCQXU1QTFOR1RIN0RCOFJNakNXWlZRT1NURTFJa0FBR2hWdml6YnZYeDdiZmZ0dTErOHorU21yN3p3eCtadlBESnA4QjlUNXdJQUFBQUFnTmREd1E0QUFBQUFnRGF0dnFHcGE0OGRlMzNzNkoxR2ZDR3MrK1J0QUFEYXFMZUhHQ2YxN0YxNzd0NlQ3L3ptcXJ6bHF1WG5IZjVrNmxBQUFBQUFBUEJhRk93QUFBQUFBR2lUM252RHZUMDNqOTArMDJPblhxZVh4KzFjV0FjQTBHNzBpakdjMmExUytmdytselpOejR0dythSnpCaTFQSFFvQUFBQUFBRjZOZ2gwQUFBQUFBRzNLc1ZQdTNpYUc3cC92SGJ0OXRqeHVrVG9QQUFCdldsMEk4Wk5aREovWVovS2QzeW1LNWtrTHo2MmZuem9VQUFBQUFBRDhPUVU3QUFBQUFBRGFoS09uek51aEVpcG5acUhIQ2VXeGUrbzhBQUJzTUZtSVlXeU1OY2Z0ZlduVFQwSkxQbW5oZVlmZm1Ub1VBQUFBQUFDMFVyQURBQUFBQUNDcG9kZk8zNk9tSnA1ZEV5c2ZLWSsxcWZNQUFMRFJ4SEtHaGtvMmRPOUxtKzR1aW56U2t2TUczNXJuZVpFNkdBQUFBQUFBblplQ0hRQUFBQUFBU1F5OS92NjlhbU04djdZMmZpQzAzbW9DQUVCbmNtaU0yUS83VDVwOS83c25ONDFmY3Q3aDMxZTBBd0FBQUFBZ0JRVTdBQUFBQUFBMnFXT3Z2MytmckpLTnE4MnlVVUd4RGdDZ1U0c2g3RmUrK1c3L2liTVh2M3ZTbkFsTDFqVE56S3ZWUEhVdUFBQUFBQUE2RHdVN0FBQUFBQUEyaVdOdW5EZXdVbVRqc2tvMlBLejdYR29BQUhoRitlSndRSWp4cHY1ZERsdis3a2xORTVZcy9QMjM4NXZHdHFUT0JRQUFBQUJBeDZkZ0J3QUFBQURBUm5YTTlRc09ybFRDaFpWUUdhcFdCd0RBYXlsZkx1NVJ2cGsyWUo5dHF1dUtkbXZDOUx3NnFEbDFMZ0FBQUFBQU9pNEZPd0FBQUFBQU5vcGhVK1lmR0dPOHFGSUpRMU5uQVFDZzNla1RZN2hoUUpkdy90NlQ1bHl5ZU9IVE05eG9Cd0FBQUFEQXhxQmdCd0FBQUFEQUJqWHNocm43eDZ5bUljWjRUT29zQUFDMGUzMUNqRGNPMkdlYjg5ODlxZW1TSlF0Ly8yMUZPd0FBQUFBQU5pUUZPd0FBQUFBQU5vamgxeTNZcjZnSkY4V3M1dGp5R0ZQbkFRQ2dRK2tiWTVnMllPOXR4dTA5YWM3Rmk5YzAvVWRlcmVhcFF3RUFBQUFBMFA0cDJBRUFBQUFBOEpZTXYzSGUzaUZVcXFFbWpJeUtkUUFBYkV3eDdGNittZEcvN3JEekJreWVmZUVENXczK2JwN25SZXBZQUFBQUFBQzBYd3AyQUFBQUFBQzhLVU52bkw5SFRSRWJZcXk4UHlqV0FRQ3dLY1d3Wnd6WmYvZWZPSHRoLzhtenEwdk9PZnptMUpFQUFBQUFBR2lmRk93QUFBQUFBSGhEanJueFp6dG5vYTVhRytKSFF3eVYxSGtBQU9qVTlzNUM5djEzVDI3NldkR1NYN2o0L01ObnBRNEVBQUFBQUVEN29tQUhBQUFBQU1EcmN0UU5DN2Z2a2hYbjE0UXVKeFNocUV1ZEJ3QUEvc3lCc1pMOVpNQ2twamt4dHB5MzZKejZuNllPQkFBQUFBQkErNkJnQndBQUFBREFhenJpNjNPMzZ0cTk5b3Rkc3ZDNUVHTDMxSGtBQU9EdmlURWNGa0xsM2dHVG0yNkpSY3Y1aTg2dFg1dzZFd0FBQUFBQWJadUNIUUFBQUFBQXIycm9sMjdyVWJmVjFxZDM2MUY3Wm5uY1BIVWVBQUI0dldJSXcwS3NIRE5nVXRPM1FwNWZ0UGo4dzMrUk9oTUFBQUFBQUcyVGdoMEFBQUFBQUgraGY4UE11bDEyMnZYVGRWdHZjMzU1M0M1MUhnQUFlSk95R01NL2wyK1BIekNwNmJxV3NPcmlwZWNlOVp2VW9RQUFBQUFBYUZzVTdBQUFBQUFBV0NkcmFNaUc3VHppQTd2czNPZVM4dGduZFI0QUFOZ3dZbTBNNGVTYTBQV2o3NTdZOU9WVmExKytmRVYxNlBPcFV3RUFBQUFBMERZbzJBRUFBQUFBRUliZnVHRG9zSjFHVGl5Mys2VE9BZ0FBRzBtUEVNTzRyblZkVHhvd2NjNzRZdTNUMXl5cGpsMlRPaFFBQUFBQUFHa3AyQUVBQUFBQWRHTERyMXV3WDZ5Smw4VVE2ME5NblFZQUFEYUZ1RTJNNGVwUXQvVnAvU2ZOR2JmMC9QcHY1M2xlcEU0RkFBQUFBRUFhQ25ZQUFBQUFBSjNRa2RmTzM3RkxYVFloMXNRUGw4Y3NkUjRBQUVoZ2x4akNqTDNHTjM2aC82VEdzNWFjV3o4N2RTQUFBQUFBQURZOUJUc0FBQUFBZ0U2ay9zYW0zajJLemMvdFdwZDl2angyVFowSEFBQ1NpMkcvR0xMR0FSTm4zeEtLbGk4dVBuL0lnNmtqQVFBQUFBQ3c2U2pZQVFBQUFBQjBBdjBiWnRidHRFdWZremNMbTE4UVl0ZzZkUjRBQUdoellod1dZczNRQVpObS83K1ZvYmpva1hQcmY1YzZFZ0FBQUFBQUc1K0NIUUFBQUFCQUJ6ZHM2c0xqZHRtNXorUnkyeWQxRmdBQWFPTnFRb2duZHcveEl3TW16cjdzMmJVdlhmbEVkZGpLMUtFQUFBQUFBTmg0Rk93QUFBQUFBRHFvWTZiTTM3Y21abGRtTVF3S01YVWFBQUJvVjNxR0dDL1pzbTZ6ay9hYTFIanVzdk9Iek1qenZFZ2RDZ0FBQUFDQURVL0JEZ0FBQUFDZ2d6bnFob1hiZDYwVUUycXk3R1BsTVV1ZEJ3QUEyckYveWtJMmJjOUxHai9mZitJZFgxaHkzdUM3VXdjQ0FBQUFBR0REVXJBREFBQUFBT2dnUmw0N3Yzdm9rcDNacFJLK0dFTHNrVG9QQUFCMEZER0dnU0ZVN2h3d1ljNS9OVGV2UG50WjlhakhVbWNDQUFBQUFHRERVTEFEQUFBQUFHam5zaXlMdzZiTSszRHNrazBxanp2RTFJRUFBS0JqaXVWZkg2aXA3VEppd01UWlZ6VS8vOExFWlpOSHZKQTZGQUFBQUFBQWI0MkNIUUFBQUFCQU96Wmk2djBIREo4eS8rcHllMURxTEFBQTBFbDBEU0dlVTlPcjF5ZjZqMjg4ZCttRlEyN004N3hJSFFvQUFBQUFnRGRId1E0QUFBQUFvQjBhZnVPODdiSlFNeUhHeWlmS1k1WTREZ0FBZEViYmhTeTdvZDhsalNmdk5YN09xUStNTyt4bnFRTUJBQUFBQVBER0tkZ0JBQUFBQUxRai9SdG0xcjF6bHo2ZnoyTE5CZVd4VitvOEFBRFEyY1VZRGd3eC9IU3ZDYk52ak0wdm43dWtlc3h2VTJjQ0FBQUFBT0QxVTdBREFBQUFBR2duUnQ2dzhPaDM3dExueStWMjk5UlpBQUNBdnhCTG53aTEzY2ZzTldIMitOajh6TlZMcW1QWHBBNEZBQUFBQU1BL3BtQUhBQUFBQU5ER0hUdDEvcTQxSVY0ZEt2SFkxRmtBQUlEWDFDdkdlRm1vM2ZwVC9TK1pjK3FTQ3c3N1NlcEFBQUFBQUFDOE5nVTdBQUFBQUlBMjZqMVgzZGR0NnkyN25GTVRzaStXeDY2cDh3QUFBSy9iN3FFU2Z0eC93dXp2dFRTdk9YMVo5YWpIVWdjQ0FBQUFBT0RWS2RnQkFBQUFBTFJCSTIrY1AycnJMYnQrdWR6dW5Eb0xBQUR3SnNVNHFsTGI1YWk5SnN5KzdJVm5uN24wOFMrTmZUbDFKQUFBQUFBQS9wS0NIUUFBQUFCQUczTDA5UXY2MU5hRXEyUE1qa21kQlFBQTJDQzZ4UmlydmJiYSttUDlKODQrZGNsNWgvOGdkU0FBQUFBQUFQNlBnaDBBQUFBQVFCc3c4dHI1M1l1NjdOeTZtbmhXZWV5U09nOEFBTERCN1JKQ3ZIbXZDWE51enB0WG43cXNldFJqcVFNQkFBQUFBS0JnQndBQUFBQ1EzTWdwODRlRkx0bFhZd2c3cDg0Q0FBQnNYREdHRVpYYUxrUDJtamhuUWx6NzlCVkxxbVBYcE00RUFBQUFBTkNaS2RnQkFBQUFBQ1J5OUpSNU85VEZtcXRDbG8xSm5RVUFBTmlrdXNjUUpvVGFyVC9hZjhMc3p5NDUvL0RHMUlFQUFBQUFBRG9yQlRzQUFBQUFnRTJzdnFHcFpyTjM5dnA4WFZaelVYbnNtVGdPQUFDUXpoNGh4anYybXRENHJkaTg2b3dsMVdOK216b1FBQUFBQUVCbm8yQUhBQUFBQUxBSkRac3kvOENlNyt4MVRRaHg3OVJaQUFDQXRpR0crT0ZRMCsyWXZjYlBQbmRaeTUzZnpLdlZQSFVtQUFBQUFJRE9Rc0VPQUFBQUFHQVRxTCt4cVhmUGJQUEpsVXAyWW5uTVV1Y0JBQURhbk40eGhtL3NXZk8rait3MWZ0YkpENHc3Y21ucVFBQUFBQUFBbllHQ0hRQUFBQURBUmpaeTZxSVA5TXcydjdyY2JwYzZDd0FBME9ZZEdtUHQvRDNIejc3c3hUODhNL0h4TDQxOU9YVWdBQUFBQUlDT1RNRU9BQUFBQUdBakdUbHQvbzR4Vkw0ZVl6aTJTQjBHQUFCb1QrcktqeVBHOWR4aXl3L3VlVW5qS1VzdnFMOHRkU0FBQUFBQWdJNUt3UTRBQUFBQVlBUExqcDlaR1g1c244L0dXQmxmSG51bXpnTUFBTFJUTWZhSk1jemFhMExqMUpibWxXYzhXQjMyZE9wSUFBQUFBQUFkallJZEFBQUFBTUFHTk9LR2hlOGVNYXpQTjBPSUI2VE9BZ0FBZEJUeFk1V2FIa2YzRzMvSGFjdkdEZjVXNmpRQUFBQUFBQjJKZ2gwQUFBQUF3QVpRZjJOVDExNnhkeldyaVdlVXg5clVlUUFBZ0E1bm15eG1NL1lhMy9peHZHWHR5Y3VxUnoyV09oQUFBQUFBUUVlZ1lBY0FBQUFBOEJhTm1ycmdmYjJ5M3RlVzI3NnBzd0FBQUIxY2pFZGxOWFVQN0RsaDlnVVBMbjdtSy9sTlkxdFNSd0lBQUFBQWFNOFU3QUFBQUFBQTNxVDMzbkJ2enkxcmVreU9NVHU1UEdhcDh3QUFBSjFHanhqQ2xmMEdiSG44WHVObmZlcUJjVWN1VFIwSUFBQUFBS0M5VXJBREFBQUFBSGdUUms1YmVQUldOVDJ1S2JjN3BzNENBQUIwVnZIQUVHdnYzM1A4N1BFUFB2SElwZmsxSjY1Tm5RZ0FBQUFBb0wxUnNBTUFBQUFBZUFPT21EWjNxeDZoN3NvWTRzZFNad0VBQUNoMWlURmMwbStIUHNmdE5mNk9UejR3YnZDQzFJRUFBQUFBQU5vVEJUc0FBQUFBZ05kcDVOU0Z4L1dJZGY5V2J0K1dPZ3NBQU1CZjJUdkU3R2Q3am0rOC9PV1dYMTN5YVBYanExSUhBZ0FBQUFCb0R4VHNBQUFBQUFEK2dXT25MTnltcGhLK0ZtUDhRT29zQUFBQXI2RzIvTGpsdk82VkhVZnQwVEQ3WDVaWEQvOTU2a0FBQUFBQUFHMmRnaDBBQUFBQXdHdG92Yld1dGhLL1htNjNUWjBGQUFEZ2RZbWhYMDFOdUdldjhiT3ZXTm55eXdhMzJRRUFBQUFBL0gwS2RnQUFBQUFBcjhLdGRRQUFRRHRYRTJJNHAxdGx4eEZ1c3dNQUFBQUErUHNVN0FBQUFBQUEvc3JJcVlzK1VGdUpYeXUzMjZUT0FnQUE4QmIxcTFUQ1BmM0d6NzVpbGR2c0FBQUFBQUQraG9JZEFBQUFBTUI2STYrZHYzWHNVdmw2ak9IOXFiTUFBQUJzUURVeHZIS2JYYitHMnorK3JEcGtYdXBBQUFBQUFBQnRoWUlkQUFBQUFFQnA1TFQ1dzBMWHlyWGxkcnZVV1FBQUFEYVNmckZTdWJmZkpiTW5Mbi95a1FuNU5TZXVUUjBJQUFBQUFDQTFCVHNBQUFBQW9GTWJmY085UFVOTmp5dGpxSnlRT2dzQUFNQW1VQnRqcUw3ckhYMk8zZVBDMnorMi9PSWhENllPQkFBQUFBQ1Frb0lkQUFBQUFOQnBqWjQyLy9CUTIrT0djcnRUS0ZLbkFRQUEySVJpMkw5U1Y1bmZiL3pzQzVhMzNIbGxYcTNtcVNNQkFBQUFBS1NnWUFjQUFBQUFkRHJ2dWVxK2J0dHUzVzFpaUpYUGw4Y3NkUjRBQUlCRXVzWVFMbjlYOXI3aDc3cnd0azg4ZVBFUi81TTZFQUFBQUFEQXBxWmdCd0FBQUFCMEtzT25MdGh2bTYyN1RTKzNlNlRPQWdBQTBDYkU4TDZzcm1aaHYvR05weTRiVno4bGRSd0FBQUFBZ0UxSndRNEFBQUFBNkJTeTQyZFdSZ3piN2V5YUxMdW9QTmFtemdNQUFOREc5SW9oM3RCdmZPUHdvbVhsU1E5V2h6MmRPaEFBQUFBQXdLYWdZQWNBQUFBQWRIakgzTGhvNTVIRGQ1dGFidCtiT2dzQUFFQmJGa01jRXlzOUR0bnpranRPV0hyQjRCK216Z01BQUFBQXNMRXAyQUVBQUFBQUhkcm9xUXMvVmxlSlh5MjN2VkpuQVFBQWFDZTJDekg3d1o3alovLzdINTV2UHZQWGx4M3hVdXBBQUFBQUFBQWJpNElkQUFBQUFOQWhIWDM5ZlZ0MnJlMzZqWkRGRDhUVVlRQUFBTnFmMWcrbFR1N2RxK2J3dmcyTkgzNm9XajgvZFNBQUFBQUFnSTFCd1E0QUFBQUE2SEJHVHA5ZjM3V3U2NDBoeEg5S25RVUFBS0E5aXlIc1hwT0ZuNzZyb2ZHQ0ZlR3VLL0pxTlUrZENRQUFBQUJnUTFLd0F3QUFBQUE2aklIWHpxOTlSN2ZLeFZtb2ZMRThacW56QUFBQWRCQjFNUXVYN2w0Y2V0UWVGL3p3WThzdk9mYkoxSUVBQUFBQUFEWVVCVHNBQUFBQW9FTVlkZjJDUHUvb1d2bFdER0ZnNml3QUFBQWRVWXl4UHRaMVc3VEhKYmVmdVB5Q0lkOU5uUWNBQUFBQVlFTlFzQU1BQUFBQTJyMlIweGQ5SXF2THZsSnVlNmJPQWdBQTBNRnRsWVhzTy8wdWJ2em04OFhLMDUrb0RsdVpPaEFBQUFBQXdGdWhZQWNBQUFBQXRGdEhYanQvOCs3ZEt0ZGtJWHd3ZFJZQUFJQk9KWVpQOTRyZDNyTmJ3MjBmZkxoNnhBT3A0d0FBQUFBQXZGa0tkZ0FBQUFCQXV6Umkyb0tEZTNUTFpwVGJYVkpuQVFBQTZKemluclZaNWVmdmFyamp6QWVyZzcrZU9nMEFBQUFBd0p1aFlBY0FBQUFBdEN0WlEwTTJZdGRSWjFaaU5yNDgxcWJPQXdBQTBNbDFpMW44dDM0WE53NWV1V3JWQ1k5TlBPWVBxUU1CQUFBQUFMd1JDbllBQUFBQVFMc3hkUHBQdHgyNTY4aXA1ZmFvMUZrQUFBRDRNekdNNmQ2dDY4QTlxbzBmV2Q1UWYxZnFPQUFBQUFBQXI1ZUNIUUFBQUFEUUxveWVOdi93YnJINzlISzdmZW9zQUFBQXZLb2RzcHJRMksraHNibzgzRFU1cjFiejFJRUFBQUFBQVA0UkJUc0FBQUFBb0UzTGpwOVpHVGw4dHd0RHJKeGZIaXVwOHdBQUFQQ2Fha0lXSnV4UkhEcG90NGJiUHZwdzlZaW5VZ2NDQUFBQUFIZ3RDbllBQUFBQVFKczFZdXFpZDR3Y3Z0dU1janNvZFJZQUFBRGVnQmlQckkyVkJmMGE3dmpJc3VyZ09hbmpBQUFBQUFEOFBRcDJBQUFBQUVDYk5ITHFvaU1yV1poZWJyZEpuUVVBQUlBM1pmdVF4ZHZmMWRCNDhZcGx6MDdJYnhyYmtqb1FBQUFBQU1CZlU3QURBQUFBQU5xVTdQaVpsWkhEZDdzd3k4SzQxbVBxUEFBQUFMd2xsWmlGaHI1N2JmbStQdU1hUC9MSStQcmZwUTRFQUFBQUFQRG5GT3dBQUFBQWdEWmorSTN6dGhzMVlyY1pJY1Q2b2loU3h3RUFBR0FEaVNFTXJ1MFM1dS9lY051SFZsU1B1RE4xSGdBQUFBQ0EvNlZnQndBQUFBQzBDU09uTHh4VVcxUDM3WEw3OXRSWkFBQUEyQ2kyejdMS0hlOXF1T09DRlExSFhKcm51YStzQWdBQUFBQWtwMkFIQUFBQUFDU1ZOVFJrby9xTU9xY1NzNHZMWXlWMUhnQUFBRGFxbXBERlNiczMzSDdvVGcyelB2WjQ5Y2huVXdjQ0FBQUFBRG8zQlRzQUFBQUFJSm1qcjc5dnkxRzdqcDdldWsyZEJRQUFnRTNxMk81WnpZTGRxN2Q5WUVYREVUOUxIUVlBQUFBQTZMd1U3QUFBQUFDQUpFWlBYN2gvdHk3ZC82dmM3cHc2Q3dDZFhsSE9TK1U4WDg3SzhyQ3lYRi84dnlsZWpLM1BpckFxeEdKVkVlTHE4dm1xVUJTcldwOFZSVnlWeFdKTmlLRzV5R056NjVybnhab3NlK1ZaM3B6bDVmdnpscGpubFpDdFcxdi9wbG1zNVBuYWxqeXJyV1I1MFpKVmlpeHJDZm02TlM5aWx0WGtXZm5qMTZ6Ymw4L3pXS2xrSWRRV1JWNFhZdFkxNUtGcmtZVzZyQ2pxaWhpN2xqOWsxL0xiMThaWW5rUG9Ia0xjTEJaRnVaYjdHRGNyMTNWVHZtK3p1SDdmR2lQQlAyOEErRjg3WnBYS25YczAzSDdHOHVxUXI2VU9Bd0FBQUFCMFRncDJBQUFBQU1BbU4zckd3aE5pekw0YVdvc0FBTEJodEpiZW5pN25tWEtlWFRkRk9URThWeFRoRDBYNVBBdmhqM2tJejJleGVINXRjLzVjVnVUUHYxZzBQNy93dVRuUDU5VnFuamIrcHBkbFdkeXZlbk8zMmkyNjk4d3EzYmFJUmRFN0ZsbnZHSXJlZVJiWHJUSEV6WXZ5ZWZuUGNjc1l3cFloeEMzSzc3cE5DTVhXNWI1NzZ2OE5BSFFJZGEwZkg3N3I0anNPZktGNCthUW5xc05XcGc0RUFBQUFBSFF1Q25ZQUFBQUF3Q2J6bnF2dTY3YnROdDMvTFlic1gxSm5BYUJkZUM0VTRiZmwrdHNRaTErSEVIOWRGTVh2UXhHZmppRi9Lcy9EVTNsenk5TnJhMnFmL3VubkRuait6Zjl0Qm0yd3dPMUpudWV0Ti9ldFhEKy9lNlBmZjJERExkMXJlL2ZjTmxhNmJKc1YrZFl4Wmx1WC83NjJEYUhZSnNTNGRmbURiMWVldDQ4aGJCOWlheW12ZkFzQWYxZjg1NTZ4KzRDK0RiT09lNmg2NUNPcDB3QUFBQUFBblllQ0hRQUFBQUN3U1F5L1lkNDd0OTJtKzh3WXdqNnBzd0NRM05weWZsUE9FNkVvSjVZVGlpZERYcFRuK09UYVN2TnZXbFpWZm5QUGFRZTluRG9vZjkvY1YyNFllbXo5dkthQkoxOWIyNjFmdjdjWFdkeSthSW5iWlRGc1grN2Z2cTU4VjRSM2xEOEhkaXAvRHV6b1ZqeUFUbTlBSmRiTTdkdHcrOGNmcWc2NU9YVVlBQUFBQUtCelVMQURBQUFBQURhNlVUTVdIVnRUVnpjdGhyQkY2aXdBYkJJdkZpRThGb3Z3eXlJV3Z3eEZlRHdVOGJFODVyL01Xckpmem5ubTFsL24xV3FlT2lTYnp0eHJUbXd0VmY1eS9meGRBNjlzMnJxMlV0a3hDNVVkWTRnN0YxbXhRd2h4eC9MbjBzNGhoaDNMYitJbVBJQ09yM2NsWnQ5NzE4V05rMVlzZmZiQy9LYXhMYWtEQVFBQUFBQWRtNElkQUFBQUFMRFJaQTBOMmNoZFI0L0xZcXkySGxQbkFXQ0RhUzNIUFZHRThHZ3Npa2VMR1A0bmhuSU4yYU5yWG1wNTlPNHpEbjdxdGIvN0Fac2tKTzNQM0M4TWVycGNXbWYrcTcxL255L2QxcU5iYmJkZEswWFdKOCt5ZDhZUWRpa2Y5eW5YUHVYYVdzRHo1NThBSFVOcm1mcTgzZmZjWXY4ZHptLzg4SzhtMUQrVE9oQUFBQUFBMEhINUF5WUFBQUFBWUtNNDh0cjVtNC9xTTJwYXVSMmVPZ3NBYjlwVG9RZ1BGYkdja0QrYzUrdjJqNno4M2U4Zm1Wc2R0akoxT0RxZkJXY2M4Vks1TEY0L2YySGd5ZGZXMXUzUmQ2Y3MxTDZ6eUdLZkdJcmRRZ3g3bE8vYW8vVVd2S0RzRDlBT3hTTTNxd3R6OTJpNGZjenk2cENGcWRNQUFBQUFBQjJUZ2gwQUFBQUFzTUdObnJLdzMyYmRhNzViYnZ1bXpnTEFQOVJTaE5ZYjZNTHlVQlRMOHhCWGhDSmZ2ckxJSHJ6dmxJRnVpNkhkbUh2TmlXdkw1WkgxTSt2UDN6ZXc0WmJ1WFh0djJiZkk0dnJDWGRqOXo5WnVtem9yQUc5QURMdkVrTjJ6KzBXTm4xNXhVZjJNMUhFQUFBQUFnSTVId1E0QUFBQUEyS0RHekZoNFhLek5iaWkzUFZObkFlQXZGT1g4cXB3SHlzMERJUytXNWxuTGtqVXZ4K1gzbkhiUXk2bkR3Y2EwL3NiRmhldm5UN0tHaG16ZzVrTjJybzNaZ0NJV0EyS01lNWFQOXlwbnQzSnFFMFFGNE5WMXo3SXdmWStMNzlqL29WOC8rc1g4bFZJMUFBQUFBTUFHb1dBSEFBQUFBR3dRMmZFekt5Tkg3SFp4RE5tNW9mV09BUUJTZWo0VVlYRVJpOFhsZm5ITTh5VXZ0V1FQL1BSekJ6eWZPaGkwSlhtMW1wZkxvK3ZuZS8vN3ZIL0R6THFlVzJ5M1J3eHhyL0sxemJyU1hSR0tBZVY1cCtCMURrQXlzWWduOWQxdWx6dkw3WGRUWndFQUFBQUFPZzRGT3dBQUFMNUwrUXNBQUNBQVNVUkJWQURnTFJ0ejQ2TGVvMGJzOXUwUTR0RFVXUUE2b1YrV3M2QW93c0tRNTR2elVDeWU4OWxEZnBIbmVaRTZHTFJYUzZwajE1VEw0dlh6SndkTmJ0eXEwclhMUGlHR3ZVT00rOFFpN2x2dSs1YnZ5cElFQmVnOFdsL1gzTFNtZWZVNXY3ams2TWRUaHdFQUFBQUFPaFlGT3dBQUFBRGdMUms5WTk3dXNhYjIreUhFM1ZObkFlZ0VIZ3VobUYrdTk3ZUVmUDZhb3BoLzkwa0hQL1UzMytveitTWVBCcDNCZmVmVVAxTXV0NitmZGZwZGZtL1AzbDJLZDJjaDI3Yzg3aE9LMEZyQWE3MzF6cC9GQW13WTgwSkxmdHFERFVQdVNSMEVBQUFBQU9pWS9LRU9BQUFBQVBDbWpaNis4SmdZNjc1VmJqZFBuUVdnQS9wOUVjTGNVSVM1ZVd5NXI5SmNtWHZiS1FPZlNSMEsrRXZMempya2hYSzVlLzJzTTdEaGx1NjFXMnl4YjFaa0I3UWVRd3l0Nnp0VFpRUm9uNHJmbHErRHpsOFI3cDZTTjFSOTlRQUFBQUFBWUtOUnNBTUFBQUFBM3JBc3krTElhUXZQampHYjBIcE1uUWVnQTFoZHpvSlFoSitHVVB4OGRiSDI1M2VmOHQ3L3lmTzhTQjBNZU9QbVZvZXRESDlWdXR0djh0M2JkTzBlRGl4Q1pXQXNpZ05DaksybHV5MlRoUVJvdTFhVmMrVXpLMSthL05Ua0VTK0VNRGgxSGdBQUFBQ2dnMU93QXdBQUFBRGVrUGRjZFYrMzBkTVdYbHVFOEpIVVdRRGFzU2ZMK1drUmlwK0ZsdnplWDdVOGQvK0t6dzFkL1JmZjRtUVh0VUJIY3Y4NWgvNitYRzVaUCt1K1lNRUJYN3B6dDVoVkRvMGhIQnhqT0tSOC9LNXlZc3FjQUlsOXB5aUtzNVpYQnorYU9nZ0FBQUFBMEhrbzJBRUFBQUFBcjl1eDEvMzhuN2JicHZ0M3krMytxYk1BdENPdHQ5QXRMZWZPUEMvdUtXSitiK05KQno2V09CT1EyUG9iS2g5YVA5ZTNQanRvY3VOV1daZXU3NGxaT0xqOHJlT1FFT0xBOG5HM2xEa0JOcEhGTFhrNDdhR0w2bWVuRGdJQUFBQUFkRDRLZGdBQUFBREE2ekptNnFJRHVuYnQrcjF5Ky9iVVdRRGF1TFhsM0IrSzRzNmlpUGZFdkxqbnRsTUdQcE02Rk5EMjNYZE9mZXZ2RlRldm43RDdxVC91c3ZYT1BmWUxzZktlOHZpK0VNTjd5M1h6bEJrQk5yQ25pcUs0NEtGbGY3Z3V2MmxzUytvd0FBQUFBRURucEdBSEFBQUFBUHhEWTJZcy9GQ3NaTmNGTjZnQXZKcjFoYm93SjhUUTFOenkwdDJObnhuMFl1cFFRUHUzNHVxaHE4dmwzdlZ6ZVhiOHpNb0JCMisvVDR6RlliR0lneFR1Z0hac1RWR0VyNjBwWHJqazBlckk1MUtIQVFBQUFBQTZOd1U3QUFBQUFPRHZ5cklzanA2NjRLSVlzd3ZLWTB5ZEI2Q05hQTVGbUZmK3JqaW5YQlhxZ0UxbS9lMU84OWJQRlFwM1FMdFVoSnVibS9Nekg3NTR5TU9wb3dBQUFBQUF0Rkt3QXdBQUFBQmUxY2hyNTNjZlBXM2hsSEw3L3RSWkFCSXJ5bm13ZkhONzBSTHV5Q3AvYkpyMTZjRi9UQjBLNEc4S2R3MU5OUU43WlFka3NUSWt4bUp3Q1BIZzhubHQycFFBZjdJc3ovUFRWMVNIekVvZEJBQUFBQURnenluWUFRQUFBQUIvWThUVVJlK283VmJ6L1hLN1grb3NBR2tVdnlsQ25CV0tjUHVxdFdzYTcvcnNJYjlPblFqZ0g4bXJnNXJMNWQ3MWMvSEJEVC91Rlh2MU9xeDRwV3czSkliUUwzRkVvSE42TnVTaFlVVzQ2K3Q1dGRxY09nd0FBQUFBd0Y5VHNBTUFBQUFBL3NLWXFRdjJxNjFVV3N0MTcwaWRCV0FUV2wzT1hVVW9ibXRwanJQbWZQYkFSWG1lRjZsREFid1ZQNjBPZmI1Y2JsNC80Y0F2MzdWRFZtUkh4Q3dPTG85SGxMTk55bnhBaDlkY0ZPSHJLNHZtaHNlclJ6NGJRbjNxUEFBQUFBQUFyMHJCRGdBQUFBRDRrekhURjQyS2xjcjBjdHNqZFJhQWphLzRSZm5tMWlJUFAzbjZ4ZWRtTHpqamlKZis5SzdQNU9saUFXd2tQenY5dmI4cWwrdGJKenQrWnVYQWc3WWZHR054ZEJIaU1UR0VmY3ZuV2VLSVFFZFJGTE5haW5qNmltcjlzdFJSQUFBQUFBRCtFUVU3QUFBQUFHQ2Q0MllzL2tLTThmTGdFNnVCam10MTBYcExYVkhjMmhLYmY5UjQ0c0hMVXdjQ1NDVy9hV3hMdWR5M2Zxb0hYdEcwWGFqVURzMWlPTG84SDFsTzc2UUJnWGFxV05HU3h6TlhWQWZma2pvSkFBQUFBTURycFdBSEFBQUFBSjFjZlVOVFRlOCt2YjhTWS94TUtGS25BZGpnZmxmKzNuWkxIb3RiVmoyMzlvNjd6anJraGRTQkFOcWluNTA1NkxmbE1xVjFzdkwxNFg0OWF3NnFpY1V4NVhsNGlIR3Z0T21BZHVDNVBBK1hQQlQrOExXOE9uWk42akFBQUFBQUFHK0VnaDBBQUFBQWRHTEhmdXZudmJib3M4Vi9oaGlPU3AwRllFTXBRbGhXTGpmbnplRUhqVS85OEw2OFdzMVRad0pvVC9McW9PWnl1WHY5bkxmL1ZVMTlhb3JLaUJqaThQSjE0NkhCbnpNRC82ZWxmUEYxWGN2cU5lTldUQmo2KzlSaEFBQUFBQURlREgvd0FRQUFBQUNkMU1ocDgzZnNVdWx5UzRpaGYrb3NBRzlSU3puMzVLSDRma3R6eTgyTm56bm9rZjk3MS83SlFnRjBGUE5PRzlUNisrcVZyWFBRNU1hdFlwY3V4NGFpOVdhN01MUjh0bG5pZUVBaVJWRTBoaUtlL21DMWZuSHFMQUFBQUFBQWI0V0NIUUFBQUFCMFFtT21MdGl2cHFibUIrWDI3YW16QUx4SnEwTlIzRkd1MzMwcGI3NzU3cE1PZmlwMUlJRE80TDV6NnA4cGw2bXQ4ODZHcHE1djY1WFZGeUdPQ0NHT0xwOXRtemdlc0drOG11ZjVXY3VyUTc2VE9nZ0FBQUFBd0lhZ1lBY0FBQUFBbmN5b0dZdU9yZFJrL3hIY05nSzBQeThWSWZ5d0tQTHZ2cmc2L09pbm56dmcrZFNCQURxelI2dURWcFhMajFvbk8zN21adzg0NEcyRGlwZ2RGMk5vTGR2NVFnN1E4YnhRNU1YRTFlR0pxeDZ0Zm54VjZqQUFBQUFBQUJ1S2doMEFBQUFBZENLalp5dytxUkxqMTRML2J4Qm9QMTRvUXZoQnpNTi92N2l5K2RaN1Rqdm81ZFNCQVBoYitVMWpXOHFsc1hXeWhvWi9QYUJuL2FIcnluWWhIRmMrZTBmaWVNQmJreGRGbUxLNldIWCtvOVZqZnBzNkRBQUFBQURBaHVhVGFBQUFBQUNnRThpeUxJNmV0bUI4RnVONXFiTUF2QTR2aEZEOG9GQ3FBMmlYOG1vMUw1YzdXeWRyYURoOVlLLzZnOHBYcE1mRklvd05NZXlZT2gvd1JoVDNGQzM1YVE5V2g4eExuUVFBQUFBQVlHTlJzQU1BQUFDQURxNS93OHk2VWRNWFhsZHUvemwxRm9EWDhISW93Zy9MdWVtRmxXdC9xRlFIMERHc0w5dmQyenBabHAyNTN4VjN2YWNTaXVORGpPOHZuNzB0Y1R6ZzczczhoT0tjQnk4Y2NsT2U1MFhxTUFBQUFBQUFHNU9DSFFBQUFBQjBZR051WE5TNzcyNTl2MU51RDArZEJlQlZyQ2xuVnNpTG0xNzY0NXJ2MzNYV0lTK2tEZ1RBeHJPK3BITjM2MlRIenp4dHY0RnZHNXhWc2cvRkVFYVh6elpQSEE5NHhVc2hGSmU5K0lkbkwzLzhTMk5mRHVQeTFIa0FBQUFBQURZNkJUc0FBQUFBNktCR1Q1bTNRMVpiZDJ1NTNUTjFGb0EvMC9wWjJuZm5vWmorMG92Ti8zM1BhUWM5bXpvUUFKdGVmdFBZbHRCYXNpNW45MU4vZlBJV08yMTJkQkhDaDBLSXc4dG4zUkxIZzg2b3RRQTdvN2xsOWJrcnFrT2ZTQjBHQUFBQUFHQlRVckFEQUFBQWdBNW81TlJGZTlhMGx1dGkyQ0YxRm9EMWxoVjVNYU9sZWUyTTIwODUrUEhVWVFCb08xWmNQWFIxdVh5dmRmcGRmblBQelNwYmpvcEYvT2Z5dGV6Zzhsa2xjVHpvQklxZmhaYjh0S1hWSWZlbFRnSUFBQUFBa0lLQ0hRQUFBQUIwTUdObUxIaHZiVTNsKytWMml5SjFHS0N6KzAwUmltL25SY3VNMjA0OGNIN3FNQUMwZmN2T0d2RkN1VXhyblgwbnpuNUhUZGZhajhRUVBocEMzQ3QxTnVob3lvOFhmeDFEZnU2REZ4NHhMYzl6SHo0Q0FBQUFBSjJXZ2gwQUFBQUFkQ0JqcGk4YWxXV1ZiNVhiYnFtekFKM1dxbENFN3hVeFRGdjd4SXV6R3F1RG1sTUhBcUI5bW4vZTRVK1d5Mld0TS9DS3UvZU5NWHcweHZqaDhyeHQ0bWpRM3IxY3pwZWViWG5tMHQ5V3g3NFl4dVdwOHdBQUFBQUFKS1ZnQndBQUFBQWR4SEhmV254eWxzV3ZsZHRLNml4QXA5TjY0OGxQaXlKTVcvdlNpLy9SZU9xZzUxSUhBcUJqbVh2bW9hMDNvYzdQR3ByTzJxOUhaV2lXdGQ1cUYwYVUwelZ4Tkdobml2OE1xK01YbDE1eStPT3Brd0FBQUFBQXRCVUtkZ0FBQUFEUXptVlpGa2RQWDNCUkRQSEMxRm1BVHVmWFJRaFQ4aUsvOGJZVEJqNlVPZ3dBSFYvK3lzMm90N1JPLzRaWlczYmRyUHMvWjdINFpBangzYW16UVJ1M0lMU0UwNVpXNis5TUhRUUFBQUFBb0sxUnNBTUFBQUNBZGl3N2ZtWmx6TFNGWHkrM24wNmRCZWcwbW9zUWZoU0s0cnExVDc3MG84WlhpZzRBc01rdHFSNzViTGw4cFhVR1huSDN2bGxXZkNxRStPSHkzRHR4TkdoTGZwdUgvUHdWTFhkUHlhdlZQSFVZQUFBQUFJQzJTTUVPQUFBQUFOcXBZNy8yNHk1alJ2YWRIa0ljRzBLUk9nN1E4VDJVaDNEZDJqWEYxTWJQN1AvYjFHRUE0TS9OUGZQUStlVXlmMkRETFdmRkhyM0doaXorUy9rNmVWRDVMS2JPQm9tc0xvcmk2dWFXTlJOV1ZJYytIOExnMUhrQUFBQUFBTm9zQlRzQUFBQUFhSWRHMzNCdnoyNWJ2dU43NWJZK2RSYWdRMXRURk9FN2VRei9mdnVKQTV2eVBOZm1CYUJObTFzZHRySmNwcmJPL3BjMjljbHFLcDhNTWZ4TGVkNHVjVFRZWk1vWGJOOWIyN3oyckllcVJ6NlNPZ3NBQUFBQVFIdWdZQWNBQUFBQTdjeXhVeFp1MDYxTHp4K1YyLzFUWndFNnBpS0VoOHY1ZjdGNXpaUWZuM1R3VStzZWZpcFBuQW9BM3BoNVp3OXFMUmVkMTc5aDVrWGROdHR1VFBsZnVKUGNha2NIdHlUa0xhY3Z2V0RJSGFtREFBQUFBQUMwSndwMkFBQUFBTkNPakp3MmY4ZHVkYld6eXUzdXFiTUFIYzdhSW9Udng2TDQ5MW1mUHVBT3Q5VUIwRkVzcVk1ZFV5Ny8wVG9ESnpmdEVXc3JKNVg3ajVlelJkcGtzTUU4WFJSNTljRWxmL2ozL0theExhbkRBQUFBQUFDME53cDJBQUFBQU5CT0hEZDl3YnRxc3BxZmxOc2RVbWNCT3BUZmhDSmN1N1psN1RkdlArbWdKOWM5T2NGdGRRQjBUSFBQR2JTOFhFNGYySERMK2JGSHJ3K0dtSDBtdUJtYTltdHRLSXF2cm14NTRaSkhxeU9mU3gwR0FBQUFBS0M5VXJBREFBQUFnSFpnN0l4RkEyTldjMnU1M1NwMUZxQkRhTDJkcmlrVStUZWVMaForZCs2Sko2NU5IUWdBTnFXNTFXRXJ5K1g2MXRuLzBqbjdaWlhLS1NIR0Q1WG5ib21qd2V0U3ZwajdVZDdjZk1hRDFTT1dwODRDQUFBQUFORGVLZGdCQUFBQVFCczNac2FpdzdLWWZiL2M5a3FkQldqM1hncWhtQmFLNG11M25qQnc2U3VQQnFaTkJBQ0p6VHY3c1B2TDVWTjdUbTc4WXZlYTJoTmpqS2NFdDBiVFZoWEY4bENFTHl5OW9QN1cxRkVBQUFBQUFEb0tCVHNBQUFBQWFNTkdUMTk0VENXcnpBeHUwZ0RlbWtlTEVQNXR6WXN2WHQ5NDZxRG5Vb2NCZ0xabzZUbjF6NVRMNUt5aDZZcDl1bGRHWlZuNDEvTDh2dFM1WUwwL2hLSzRhTmtUdi9oR2ZvM2Jod0VBQUFBQU5pUUZPd0FBQUFCb284WithL0h4bGF3eXJkeldwczRDdEV0RitkY2RlVkY4OWJiYkh2dGhmdFBZbHRTQkFLQTl5S3VEbXN1bDlZdGN6TnpuMGp2M3FhbkV6NFVZUHhSODBRdlNhQzZLNHB0NXk4cnFnOVZoVDRkUW56b1BBQUFBQUVDSG8yQUhBQUFBQUczUTJCbExUZ2d4WGxOdUs2bXpBTzNPcWhDSzZTRXZycnIxaElGTDF6MDVZZi9Fa1FDZ2ZWcHc5dnNXbE11bjlwdDg5em14SnB3WVF6aWxQTDhqZFM0NmlhSzRJdy9GNmN2R0RWNlNPZ29BQUFBQVFFZW1ZQWNBQUFBQWJjellieTArSTJUeDhsQ0VtRG9MMEs0OEZZcmlHM256bXEvLytLU0RuMG9kQmdBNmt2dlBPZlQzNVRLeGY4UE1LK3A2YlB2QkdMSXp5aGZyQTFMbm9tTXFRbmk0L1BsMTVnUGo2bTlPblFVQUFBQUFvRE5Rc0FNQUFBQ0FObVRzdDVkY0ZHS3NwczRCdEN0TFF4R3VXdlhFQzlNYnE0TldwUTREQUIzWmt1cllOZVV5TmN1eWFmdGQxblJFQ1BHTThseXV2amdHRzhUemVWRk15RnFldldyOXp6VUFBQUFBQURZQkJUc0FBQUFBYUNPTys5Yml5MktNWjZYT0FiUWJjMXFLNHZMYlRoeDRhNTduUmVvd0FOQ1pyUDl2NzZ6VzJYL1MzUU5pYlRpamZQREJHRUpkNm15MFMrWEx1dUs2MVMwdEZ6eGNQY0pOeEFBQUFBQUFtNWlDSFFBQUFBQWtsbVZaSEROOTBkVXh4bjlOblFWbzgxcksrVzdJODh0K2RNTCtjOWM5K1ZTZU5oRUFkSEx6emoxMGNibDhmTitKczgrcjFGVStWNFI0Y2d5aGQrcGN0Qk5GYUNxS2x0TWZHRGQ0UWVvb0FBQUFBQUNkbFlJZEFBQUFBQ1NVTlRSa28yY3N2S2JjbnBnNkM5Q21yU3FLTUNYRU5WKzY5Wk1IUFpJNkRBRHd0K2FmZC9pVDVYSnV2OHR2bnRnOTl2NU1EUEgwOHJ4ZDZseTBVVVY0ckh4OWQvWUQ0dzc3ejlSUkFBQUFBQUE2T3dVN0FBQUFBRWdrTzM1bVpjeW9NVGVVMjQrbXpnSzBXWDhNUmZqRzJyRDJxdHMrZGVEdlVvY0JBUDZ4WldlTmVLRmNMbnRuUTlOWHR1aWVmU0xHY0daNTNqVjFMdHFNRjRzUUpxMXNmdnpLUjZzZlg1VTZET250TXU0bisrYXgrWGVQWDNMc2s2bXpBQUFBQUVCbnBXQUhBQUFBQUFrTXZIWis3ZWhSZldlVTIvZW56Z0swU2I4TFJiaXFPUS9mbUhYaXZuOU1IUVlBZU9NZXJRNXFMVTlka3gwLzg5cDk5OXZtL1NITHppN1BlNmZPUlRKRitkZTBsdWJtYzVkVmgvdzZkUmpTNnpQdUIyK0xsVzdqYXlxVlQ0WlErWjlkTDdoMThDOHVPZnJ4MUxrQUFBQUFvRE5Tc0FNQUFBQ0FUYXgvdzh5NnZuMzcvbWNNY1dUcUxFQWJVNFRIaWxoODZmbm4xMTUzejJrSHZadzZEZ0R3MXVVM2pXMHBsLy9Jc3V5bWZTK2JmVlFvc3JORERJZWx6c1VtZFc5ejNuTGFnK01HejAwZGhQU3lVMy9jWmRmZU5hZG1OZDNPTDQrOWltTGQ0MTJ6ckxacDUvTitWUC9ZeEdNZVRac1FBQUFBQURvZkJUc0FBQUFBMklTTy9kcVB1L1R0dS92TUdNS3cxRm1BTnFRSUQ1Y3pjZFdUTDB4dnJBNXFUaDBIQU5qdzhqeHZyZEg4dUhYMnUreXVRMklXTGlqM1F4UEhZdVA2VmNqRE9Vc3ZyUC8yK24vL2RISjlMN3g5Uko4dGFyNVVidnU4eXJ0M3FxMnRhOXJ0d3R2ckg3NTR5TU9iT2hzQUFBQUFkR1lLZGdBQUFBQ3dpZFRmMk5SMWk2MjIvMDRNNGVqVVdZQTJZMmtSd3NTZnpIcjBwdlczMndBQW5jRDlYM3p2dmVWeTlQNlhOeDBVWXRaYXRHdjlHQ0VtanNXRzgzTDVHdS95NTlhK2VPa1QxV0VydzdnOGRSNFM2MXVkdFdmNWEvM0xJUXRIL0lOditrL2w3d1JON3p6L3R2cEhKeHl4ZkpPRUF3QUFBQUFVN0FBQUFBQmdVMmd0MTIxWnUrVjNneHNxZ05CNllWMVlWQlRGK0ZsUDNQS2R2RnJOd3lmM1RSMEpBRWhnM2xtRDdpdVhZL2U5OU02QldSWXZiTjBIUmJ2MnJIeUpGNzY5SnE0NTU2SHpqdnhWNmpDa3Q4UDUzOXVxVzgxbUY0ZVlmVHE4L3MvUmVYdFdFK2ZzWEowMStMR0dJNWR1ekh3QUFBQUF3Q3NVN0FBQUFBQmdJM3ZQVmZkMWUvdTJXMzQveEgvNGxlcUJqbTloVVJRWC9lVEVnVGZuZVY2RXNGL3FQQUJBR3pELzdQZk5MWmZoZTA5cTNMZW1wdWFDRU9MSW9Halh6aFR6bXZONDJvUGpEcnNuZFJMU3krb2Jhblo5N3lHbmRLdmRyRm9ldDN5ajM3Lzh4ZisybXBEZHNkdTQyNFk4UFA2SUJ6WkNSQUFBQUFEZ3p5allBUUFBQU1CR05QTGErZDIzZjF1UG04dnQ0Q0oxR0NDZElpekpRM0h4ckJNSC92ZTZZdDJuOHRTSkFJQTJhT0c1OWZQTFpmUitsODE1ZHdqWkJUSEdNVUhScnEzN2Rjano4NWUyM0RWMTNjM0VkSHA5TC9ySlVYM2VkOGlWNVMvZGZtL2x4Mmt0MllWS2JPeFR2WFh3SXcxSEw5bFErUUFBQUFDQXY2VmdCd0FBQUFBYlNXdTVybTZ6Mmx2SzdlR3Bzd0RKTEN2eTBQQ1RKMzh3YzkwblhDdldBUUN2dy8xZlBHeFJ1WXpkZDFMVDNyRW1heWozSTFKbjRtK3NLdWZLc1BicFNVdXFZMThNb1Q1MUhoTGI5Y0tmN0Y3SnNpK0ZVRGwyQS82dzI4UlFlNGVTSFFBQUFBQnNYQXAyQUFBQUFMQVJLTmRCcC9kUUVZcUxmdnpMVzI1NjVTYVRmVlBuQVFEYW9mbm5EbHBZTGlQM21Uem53Q3lyWEJ4aU9ESjFKa0lvaXZDZHRjMHRaLzEvOXU0OVRzdXlUdno0ZGQzUE13ZU9uazFOUlBHQW9DQXo0ayszWEZGTDhaaW1DRm1LZ0xsYVdacW1DYWpqZzV6RUU1WmJsbGxaR2xCVWNwU0RvbFM3Vzl0dkxVSGJkY3NESGJkYWF6c3BJdlBjdjV0Mjk5ZTJXUXJNelBVOE0rODNqZGYzbXBjeG56K1VsOCs4bnUvYy85TDJwbWRTdDVEZW9Dc1c3VmpxMStlNlVsWjZiM0Z0NklRdjhmc2x1d092WFgzOGQ2ZWY4RVFuL1A0QUFBQUEwT05ac0FNQUFBQ0FEdmJHdVYvdnRkZnJlaThLbHV1Z0I4bzNoRHhNZS9FSHYvM01tclpSbTBNNFBIVVFBTkFOZk91YVk3OVJIS05IelBucU1hVVliaXptWTFJMzlVUjV5TDlkcmNiTG43ejIyTFdwVzBndkc3ZXd0UC9CTzF4WTd0OW5lbkhkclpPLzNHNmhGQi9lYitxSzQ1NmRjZEozT3ZsckFRQUFBRUNQWThFT0FBQUFBRHJROGZldWJkN3JkVHMvVUl4dlR0MENkS21maER5ZitmMGZQUHZ4OVcxak5xV09BUUM2cDI5Zi9kZGZLWTVSclRkOTljUVk4MmtoeGlOVE4vVVFQOHREdU83Sng1Ky9wN3BnVEh2cUdOSTc2SVpWeHgwNFpNZTV4VDhYdzd2d3krNWVMcGNmSGpSMTlYSFB6RGpoWDdydzZ3SUFBQUJBdDJmQkRnQUFBQUE2eUpibHVsMGFmNzljZDJMcUZxRExQSitINmswLzM1ejk3VGN2T3Z3RlQ2d0RBTHJDWXgvODYxVlpscTArYlBhanAyVXh6aWcrTlN4MVV6ZTFLZVQ1aDE3NFRYWDY5MmE5NlZlcFkwaHYzeWtQRDJwcUNEZkhXRHJyUHorVGQzWENIcVZ5Zk1TU0hRQUFBQUIwTEF0MkFBQUFBTkFCVHIxelJkTXV1K3oxeFdJY25ib0Y2Qkl2aEpEUGZYbHpuTFBxb3BIZWJBMEFkTGxxdGJwbHMyZEpObTdoOGhHdHU1MGZzMWdKSWU2VHVxc2JXVnl0YnY3QUUxUGYvTjNVSWFTM3g2VUwrKzZ3eTQ2VEd4dmpGY1cxT1hWT3FSd2ZQbURxZzhkOWI4YkovNXE0QlFBQUFBQzZCUXQyQUFBQUFMQ2RobFVXTmg1ODBPQXZGT01wcVZ1QVR2ZHk4WEZQdmpsTVczN1I0VDlKSFFNQVVGMHdwcjA0UGoyb3NuYitUcjNpcFNHR2E0cjdMcW03NnRpVG9acGZzVzdxY2F0U2g1QmVWcWxrKzRjM2p0OWgxNTIyUENseXI1ZzY2QS8yaXVYeW1vRlRWaDI3WWVhSjMwc2RBd0FBQUFEMXpvSWRBQUFBQUd5SDR5dHJ5NE1QR2p5L0dFOVAzUUowcXJ6NDljVThWcTlkUG5Ia1U2bGpBQUQrdDJmYVJtMHNqbHRhSzJzL0VYdkZENFlZM2xmY2U2ZnVxaVBQNTNsK3c1TXZmK1d1YWx2YjV0UXhwSGRnMjBOdlBEQTdlbTR4amt6ZDhzcmk2eHNiNHByOXJsODk2dGxwSnp5YnVnWUFBQUFBNnBrRk93QUFBQURZUnRtNGhhV3p6eHo4MldKOGErb1dvRk45cFpyblZ6MDQ2ZkIvVEIwQ0FQQnFIbXNiOVIvRk1ibDE1aU4zaG9iU0RUR0VDY0Y3QS82U3pTRVBIOGxmM2xSWjMzYmlMMEk0TG5VUGlSMTAzYW9Cc1Z5YW5XWHgzT0phUXcrdGUwVUR5akUrTlBDNlpjZHN1UEhVSDZXT0FRQUFBSUI2NVp2b0FBQUFBTEFOc2tvbE8rdU1zKzR1eHJlbGJnRTZTLzdQZWNpdldUNXg1T0xVSlFBQVcrdXhLY2R0V2JhNWFQak5EOTFXeWh2bnhCaE9TOTFVYS9JUVZvWk4xU3ZXdHgzL25kUXRwTGQzWldudjNxSFgxYkZjdWlyVTE5TWZCNVd6cG9jUHVIYkpxTzlOUC8ybnFXTUFBQUFBb0I1WnNBTUFBQUNBclpSbFdUejcvc2Z2TE1hSnFWdUFUdkhUUEEvVE52N2d0eDlmMHpacWMrb1lBSUR0c2U2cU4vOXpjWncrWXRhamI4cEsyYTNGZkZqcXBocndWS2hXcjFnLzliamxxVU5JYjh0ci9BUGJWcC9iTy9TYUhVTVlrTHBuV3hUZGcwT3AxK29CVXg4NDdnY3p6bncrZFE4QUFBQUExQnNMZGdBQUFBQ3dsYzY2Ny9HYmkrTmRxVHVBRHZkaW5vZGJmeE0zenZucXBEZjhKblVNQUVCSCt2YmtZeC9PS3BYV0VjM0hqZzh4VGk4KzlmclVUUW44Ujhqekc5ZC8vN3NmcnQ1MTBjdXBZMGp2d01wREl3OXNXejIzR044WVU4ZHN2MkZOcGI2ckJsMng2RTNQM0hiR2Y2U09BUUFBQUlCNllzRU9BQUFBQUxiQ09aOWJOejNHZUdYcURxQkQ1WVg3ODVmeUtRKythK1FQVXNjQUFIU1dhbHRidFRnKzNYTDE2aS9FWFJxdkNqRitvTGozU2QzVkJkcnpFTzUrNmJjdlh2L1VqSk4rSHNLeHFYdEliRkJsK1I3bDBEUWpDM0ZDY2MxUzkzU1lHRnF6dm4wZTNQMmF4U2YrYlBaYi9OQVFBQUFBQUhpTkxOZ0JBQUFBd0dzMFp0NzZLVEhHcWFrN2dJNlUvME5lalZjc3YvRHdyNmN1QVFEb0t0K2FjOEx2aXVPRzFwbVAzQjNLcFMxUHN4c2Z1dE9TMFI5YkUwTDcrOWROUG41ZDZoRFNHMVM1dDdreHZQNktodEEwdWJqMlRkM1RLV0k0cW45VDd5VURyMXg0OG9aYng3eVlPZ2NBQUFBQTZvRUZPd0FBQUFCNERjWjhidDE3WTR3elVuY0FIV1pEbm9kckhuem55QVhWYWpWUEhRTUFrTUpqVTQ3N1VYRk1iTG5wS3grS01aOGJRandtZFZNSGVpWVAxYXZXWFhQY2wxS0hVQnNPcmp4MFZtUFkrK1ppSEpTNnBRdU1hdWk3NDhKczNNSzNWaGVNMlpRNkJnQUFBQUJxblFVN0FBQUFBSGdWNTh4ZmYwR004WTdVSFVDSDJQSUVoem0vL05WTE4vM2Q1VWU5R0NaVlUvY0FBQ1QzclE4ZTg2MHN5NDQ5YlBZajQyS0ljNHBQRFVqZHRCMStuWWQ4eGtzLzJYakhVM2VjOUZMcUdOSTdvTEp5ZURtVWJ3OGhIcCs2cFl1ZE1tandEcC9OeGkxOGUzWEJtUGJVTVFBQUFBQlF5eXpZQVFBQUFNQmZjTTc4OVdjWHh5ZUtqNWk2QmRodW53OTV1SHJwcEpZTnFVTUFBR3JOZnozVmQvN2VsYVdMZCsvVjc0UEZTNkNyaW51djFGMWJvWnJuNGRQNXBqQjFmZHV4LzVZNmh2UUdUMTJ4VzJnc1R5K0g4b1hGdFpTNko1R3hndzdhNGJkWmxyM1RrN3NCQUFBQTRNK3pZQWNBQUFBQWY4WTU4OWFORGpIZUgzd2ZEZXJkK3ZZOHYrekJpYTJQcEE0QkFLaDFQMnc3N1lYaWFEdGs1aU9mYkNxWGJpbm1NYW1iWGxVZXZoYmE4OHZYWFh2c1A2Vk9JYjNza3JzYkR0cHozL2ZHcHZKMUlZODdwdTVKTG9aSmc2YXUrRzB4WFpZNkJRQUFBQUJxbFRjR0FRQUFBTUFyT0h2K3VxT3pHTDlVakUycFc0QnQ5c3VRaCt1V3IzajZydXFDTWUycFl3QUE2c21UVTQ3Yjh0VGZjMXBtZmVXNFdBcDNGUE93MUUydllFUEk4NnZYVHozK0M1N094UmFESzZ0T08yalBRYmVFR0FhbmJxa3BNYjd2Z090WC9lcDcwMDY4UG5VS0FBQUFBTlFpQzNZQUFBQUE4TCtjTmU5Ymg1ZGllVmt4OWs3ZEFteVRhdkh4eVR6OGJzcXlpVWYvUEV4c1NkMERBRkMzdmpYNW1FZXl5dHJXRWIzeWkwUElwaGVmcW9Vbmd2MHVoSHpPZi96ODMyL2VjT3VZRjhQa2F1b2VFaHRjV1RFMGhvYmJZaXlOVHQxU3UrSjErMSszNnRkUDMzamlMYWxMQUFBQUFLRFdXTEFEQUFBQWdQL2hyZmV2SDF6T3lnOFdZLy9VTGNBMmVTeHZEKzlaZG1ITDExT0hBQUIwRjlXMlVadUw0MjhQbTdWbVljeEtjMktJNXhmM21DQWxMMzU5ZG1OZW5mSXZVNDc3VVlLdlQ0MFpXRm0xYzNQTTJtSnNlSGZ3SHBoWEZXT2NjOEQxcTMvNXZXa24zSk82QlFBQUFBQnFpVzh1QWdBQUFNQi9HZk81OVh1WFMyRmxNZTZXdWdYWWFyK3NWdk5yVjZ4ODVtUFZCV1BhVThjQUFIUkhqMDgrL3FmRmNjR0ltWS9jRTB1bGp4VHpJVjM0NWI4UnF1SHliMDhaNVFjcEVMSktwWHhBT1BwdmVvWFN0T0s2UytxZU9ySmxNZlpqZzY1Zi9md3owMDU0SUhVTUFBQUFBTlFLQzNZQUFBQUFVRGo3czkvY3BkVFF2RElQWVdEcUZtQ3I1SVZQaGZqQ05jc25IZjN6TUtrMWRROEFRTGYzN1NuSGZTVzc1TzZXNGZzZWRGbU04ZnJpVS8wNjhjdjlxUGd2VmsxOG13QUFJQUJKUkVGVXZpbnJwaDcvMldxMW1uZmkxNkZPREw1aDlRa0h4YU52RDdGTEZ6eTdrMUlXd3J4QjE2ODgrWmxwb3g5TkhRTUFBQUFBdGNDQ0hRQUFBQUE5M2tuM3JldlR2NkY1V1RFT1RkMENiSVU4UE5sZURlOTY4TUxXcjZaT0FRRG9hYXAzWGZSeWNkd3lvckoyZm13S3Q0WVl4M2JzVjhoZkRDSGUvTE5mYkpyejR6a24vQzVNcm5ic2IwL2RPZkQ2aHc0c2w3TmJZcGE5SlhWTE45Q2NoV3pSZnRldVBPN1o2YU1mU3gwREFBQUFBS2xac0FNQUFBQ2dSeHRXV2RoNDhPREJYeXpHSTFPM0FLL1o3NHFQYVQvZG5OLyt6WXRhWDA0ZEF3RFFrMzI3YmRRUGkyUGM4SnNldWFlVWwrNE1NUnk0bmIvbGxxZlVmZUhsYW43MWsxT08zZEFCaWRTNXdaVVYvYlBZT0xWY3ppNHZybzJwZTdxUi9xVXNlM0NmNjVjZC9mMXBwMzQzZFF3QUFBQUFwR1RCRGdBQUFJQWVLNnRVc2pFSG5mV1pZaHlkdWdWNGJmSThQUER5NXZ5eVZSZTFmajkxQ3dBQWY3RHVnOGV0R2xSWk83eC9VN2d1eG5oVjhhbUdyZjA5OGhEK3FWb05sNitmTXVwcm5aQkluY25HTFN3ZE5IU25DN1BZZUdOeDNUMTFUemUxZTJOb1hMbnZOWXVQZm03MlczNmNPZ1lBQUFBQVVyRmdCd0FBQUVDUGRmWkJiLzFRaUdGYzZnN2dOZmx4TllUM0xwL1k4cVhVSVFBQXZMSm4ya1p0TEk2cExiUFd6Z3RaL0hneC85VnIvTC8rVzU3blU5ZHZXdnZwYWx0YnRSTVRxUk9ESzZ1UEdUeDA1N25GYS9hVzFDMDl3SDdseHVZVmc2NVlkTXd6dDUzeEg2bGpBQUFBQUNBRkMzWUFBQUFBOUVoajU2MmZFbU44VCtvTzRGVlY4enpjdFdselBtWFZSYTIvU2gwREFNQ3IrOWJrVVU5a2xjclJ3NXVQdXlTR01LdjRWUDgvODdlK1ZQeTMzaDBiWDNweHhsTnRKLzA2aEdPN3NKSmF0UDkxRHc1c2FHaWFrOFhTMk5RdFBVc2NGdnYyWGpSbzByMmpuL25rQlJ0VDF3QUFBQUJBVjdOZ0J3QUFBRUNQTTNiZTR4TkR6S2FuN2dEK3NqemszNm5tNGVMbEUxdS9scm9GQUlDdDgxOVBvdnZJME1wRER6UTFOWHc0eEhqV0gvME5lZmhTSGpkZjlmZzFiM29tVFNHMVpJL0t3cjQ3eFowKzJGaHV1cks0OWtyZDB4UEZFSTRKZSs5MWZ6WnU0ZGpxZ2pIdHFYc0FBQUFBb0N0WnNBTUFBQUNnUnhrei8vRlRzNWg5UFB6K3ZXTkFqWG9waEh6bWhnM1B6RjdmTm1aVDZoZ0FBTGJkZDlyZS9PUGlPSHZFekVmUGlLWHN6anlFWDFSRDlmM3Jyemx1VGVvMjBzdXlMQjdVdHZyOG5lTE9XNTUwdUpkWDZzbWR0ZC9nSFQ1Y25POU9IUUlBQUFBQVhjbUNIUUFBQUFBOXh0ajcxaDJabGJNRndmZkZvSGJsNGV1YjJ6ZS84OEYzSHZGa0NLMnBhd0FBNkNEZm5uTHNvbUdWdFE4LytaMmZ2K2pwV0d3eHVQTFFVY1hIM09JMXdKR3BXL2dqNzlyL3V0VS9mdnJHRTZhbkRnRUFBQUNBcnVLTlJBQUFBQUQwQ0crOWYvM2dobkpjV294OVVyY0FyK2gzSVEvWEx2dis0ZzlWMjlxcXFXTUFBT2g0Njl0Ry9UWjFBK2tOcnF6WU80c05zN0lzZTBmd2RQbmFGTU8wUWRldS92RXowMC80Wk9vVUFBQUFBT2dLRnV3QUFBQUE2UGJHM1AvWW5nMmxoaFhGdUd2cUZ1QlA1U0dzcnI2MDZXK1dYM3prY3lHMHBNNEJBQUE2d2NBckYvYnEzWC9ucTdLczhlcmdoOS9VdWhpejhMSDlybC8xczJlbm5iZzBkUXdBQUFBQWREWUxkZ0FBQUFCMGEyLzkxTi8zYStqVmIza3g3cHU2QmZnVHZ3eDVmc1h5QzBmZVc2MVc4OVF4QUFCQXg4dXlMQTV1VzMxTzd4MTNubE5jQjZidTRUVXJaeUhPSHpobDVYRWJabzcrWnVvWUFBQUFBT2hNRnV3QUFBQUE2TGFPdVB1eGhuMzc5ZjlDQ1BtSTFDM0FuMWoyNGtzdlhmelF4VWY5S0V5c3BtNEJBQUE2d2VDMmgxc09ycXllRzBJOHhrL1VxRXQ5eXFXNFpMK3JWLy9WczNOT2VEWjFEQUFBQUFCMEZndDJBQUFBQUhSYisvVnQrR2h4akU3ZEFmd1BlZmhsaVBrVlN5NW8vWFRxRkFBQW9ITU1xaXpmb3lrMnp5aVY0NFRpbXFYdVlYdkUxMlZONGNHQlY2NTZ3NFpiVC94RjZob0FBQUFBNkF3VzdBQUFBQURvbHNiT1gzOXRpUEhDMUIzQUgvbkRVK3NBQUlCdVovQmxLNXF5blJzdmE4cWFwOFlRK3FmdW9jTU1MdmVPaXdaTnV2ZUVaejU1d2NiVU1RQUFBQURRMFN6WUFRQUFBTkR0akoyM2ZueUljVnJxRHVELysxV2VoL2N2bmREeXFkUWhBQUJBNXhoU1dYTm1hZGZHbTR2eGdOUXRkSXFqNCt2My9FeVdWZDVXcmJaVlU4Y0FBQUFBUUVleVlBY0FBQUJBdDNMT3ZDZmVIR084dXhoajZoWWdoRHlFTlpzMjVSTlhYZFQ2L2RRdEFBQkF4eHZhOXZDd1VJNjN4eXk4S1hVTG5TMmVzOStVdjlyeTJ1NERxVXNBQUFBQW9DTlpzQU1BQUFDZzJ6anJjK3VIbGJPNHNCZ2JVN2NBNFlVOHp5Y3YzN0Rrem1xYnB4c0FBRUIzTTZTeWROY1llMWRDT2Y1TjhQNlRuaVBHSy9lL2R2V0dwNmVmOE9IVUtRQUFBQURRVVh5REV3QUFBSUJ1NGZSNy8rOGV2WnFhbHhUakRxbGJnUENOOW1yN0Jjc25qbndxaE5iVUxRQUFRQWZLTHJtNzRlQTk5MzlYekhyZlVGeDNTdDFEQWpIY3Z2OTFxNTk3K3NZVGxxUk9BUUFBQUlDT1lNRU9BQUFBZ0xwM3h0MlA5ZTdWcjJuTG03b0dwbTZCSHU3bFBPUTN2dkRjYjJhdGFSdTFPWFVNQUFEUXNZYmN1T2Jrd2EvZi83WmlQRGgxQzBtVlFzZy9OMmpLaW1PZW1YblN0MUxIQUFBQUFNRDJzbUFIQUFBQVFGM0xLcFZzekVGbjNSZENISm02QlhxNHAvTHE1dk9XVGp6aS82WU9BUUFBT3RiUTYxY09EdVh5YlRIR1UxSzNVQ3RpMzFncUxSbDQzYklqTjl4NDZvOVMxd0FBQUFEQTlyQmdCd0FBQUVCZE8vdWdzMjRLTWI0MWRRZjBZSGtld2tkL3VpbS82cHNYSGZGQzZoZ0FBS0RqREtvczJyRzUxTys2ME5EdzN1TGFrTHFIbXZQNmNtaGNzc2VsQzQvNXR6dkgvRFoxREFBQUFBQnNLd3QyQUFBQUFOU3RzZk9mdURqRytJSFVIZENEL1Z0b3o5KzVkRkxyc3RRaEFBQkF4OG5HTFN3TkdiYlR4YzJsL3BVWXdxNTV5Rk1uVWJ0YSt1eTB3N3ppbjVrenF3dkd0S2VPQVFBQUFJQnRZY0VPQUFBQWdMbzA5bk9QbnhpeTBwMnBPNkRIeXZQRjFmRENPNWROT3ZybnFWTUFBSUNPTTZUeXlQRkREdDNsOW1JY0hsUEhVQzlPMi9lZy9yY1Y1MldwUXdBQUFBQmdXMWl3QXdBQUFLRHVuRFAvOFVOaVZ2cEM4UDB0NkhwNWVER1AxUThzbWRENmtkUXBBQUJBeHptNDh2Q2dyQlJ2TGo3T1N0MUMvWWtodm0vLzYxWjk5K2tiVC9URGtBQUFBQUNvTzk2QUJBQUFBRUJkT1dQK1k3czJoY2JGeGRnL2RRdjBOSGtJNjJPMS9lMUxKaDMrUk9vV0FBQ2dZd3l1ck9oZktqVk5McFd5OXhmWHB0UTkxTE40Kzc1VFZ2enJjek5QV3BXNkJBQUFBQUMyaGdVN0FBQUFBT3JHc01yQ3hvTUhIL3pGWWh5VXVnVjZtRHdQNFc5L0YzNTExWnBKb3phbWpnRUFBTFpmVnFsa2cwdEhUeWlYbW1ZVTF6MVM5OUF0bExOU2FjR2dxYXYvNnBrWkoveEw2aGdBQUFBQWVLMHMyQUVBQUFCUU40WU1IbnhYaU9HWUxZL1JBcnJNdjFmejZzU2xFMXFYcGc0QkFBQTZ4cERwRDcxeFNIYk0zR0ljbWJxRmJtZkhrSVVsQTZZK2NOUVBacHo1Zk9vWUFBQUFBSGd0TE5nQkFBQUFVQmZHem4vaXloRGp4TlFkME1Pc0RSczN2bVBweFVmOUtIVUlBQUN3L1E2NTdwR0JlVk9ZbllYU3VCQ0xYOUE1RGlobmZiNlFYWEwzNk9wZEY3MmNPZ1lBQUFBQVhvMEZPd0FBQUFCcTN0alByVHN0bExLYlVuZEFEOUtlNS9tTVpROCtQYTI2WUV4NzZoZ0FBR0Q3N0hYMTZqNDc5aTlkSFp2aVZUR0VYcWw3NlA2S2Y4Nk8yM2ZYZ1I4dXhrdFN0d0FBQUFEQXE3RmdCd0FBQUVCTk8vdStkWWVXR3JMN2k3R1V1Z1Y2aUIvbjFlcDVTeWEyUGhJbXRLUnVBUUFBdGtPV1pmSGdhYXZQM2FsLzZhWVE0dDZwZStoaFlyeDR2K3RXZitmWkcwLzRVT29VQUFBQUFQaExMTmdCQUFBQVVMUE9tUC9ZcmszbHhzWEYyRDkxQy9RUUt6ZHRmSEg4aW92LzZtZXBRd0FBZ08welpQckRSd3k5OGVHNWVSN2VrTHFGbml1R2NOdkFhMWMrdFdINjZKV3BXd0FBQUFEZ3o3RmdCd0FBQUVCTk91THV4eHIyNjkvd2hXTGNMM1VMOUFEdEljOXZXTHBoOGN4cVcxczFkUXdBQUxEdGhsWWUyaXNyWjdOS01Ucy8vSDYvQ1pJcVpUR2J0ODhIbHgzNS9adE8vVzdxR0FBQUFBQjRKUmJzQUFBQUFLaEorL1ZybkZzY3g2YnVnRzR2RHo5cEQrSGNaUk5hMW9iUWtyb0dBQURZUm9NcTl6YjNMZzI0SWl1WEpoZlh2cWw3NEwvRkVIWXFOVFlzMnUyeUZVZjkvSTZUZnAyNkJ3QUFBQUQrTnd0MkFBQUFBTlNjYythdnZ5aUw4ZDE1NmhEby9oNStzZjJsZDZ5KzhNaWZwZzRCQUFDMjNkQVphOGIwTHU4ekozZ0tQRFVxaGpDa1gvL3MvaXlybkZHdGVuSTZBQUFBQUxYRmdoMEFBQUFBTldYc2d2Vi9uY1Y0WitvTzZPYmFROGluTDEzKzlJM1ZCV1BhVThjQUFBRGI1dURLUXlQSzVXeHVGdUtvMUMzd0dwdzJjTXBmVFMvT0thbERBQUFBQU9CL3NtQUhBQUFBUU0wWTk5bkg5b21OalY4b3hzYlVMZENOL1h0N3RmcU9aUk5iVjRVTFdsSzNBQUFBMitEQXl1cmRtMHFsRzh2bDBvWEZ0WlM2QjE2ckdNTTFnNjVkc2U2WjZTZk5UOTBDQUFBQUFQL05naDBBQUFBQU5lR011eC9yM2RTLzhZRVl3dXRTdDBBMzlvOGJOMVhQV1hWUjYvZFRod0FBQUZzdnF5eHNIRkxhK2RLbWN2bjY0cnBENmg3WUJqSEU3SjVCVTFZODljek1rNzZWT2dZQUFBQUF0ckJnQndBQUFFQk5hTzdmK0luaThEZ3Q2RHgzdGYvNjN5NWZkZWxKTDZVT0FRQUF0dDdRR1krOFpXaDVsMXVLOGNEVUxiQ2Rlb2NzUHZENnFTdEcvbWpHU1Q5UEhRTUFBQUFBRnV3QUFBQUFTRzdzL0NldWpER2NtN29EdXFrWDgycDQxNUlKSSs1TkhRSUFBR3k5d1pVMVF4dks4ZllzaEJOVHQwQ0hpWEdmeGhnWFpNZFhUcXl1YWR1Y09nY0FBQUNBbnMyQ0hRQUFBQUJKalYydy9rMGh4dG1wTzZDYmVqcTBoN09YVEJ6eGVPb1FBQUJnNnd5c3JOcTViNm5jMWxDTzd3N2UzMEUzRkVNNGJ1QWJqcHBUakZla2JnRUFBQUNnWi9NTldBQUFBQUNTT1d2QjQvczJoTkw4NFB0VTBCbFd2THg1NHpzZW5IVFVMMUtIQUFBQXIxMVdxWlNIbHY3NjNmM0tEVzNGZGVmVVBkQ1pZb2p2MysvYWxZODlPMzMwZmFsYkFBQUFBT2k1dkhFSkFBQUFnQ1RHemYxNnI0WTkrMzZ4R0hkTjNRTGRUQjd5Zk5hUzVVOWZYMTB3cGoxMURBQUE4Tm9ObmZISWlZZVVqcms5eERBMFR4MERYU1NHK0xGQjF5NS80cG5wcDN3N2RRc0FBQUFBUFpNRk93QUFBQURTMkxQUHg0cS90cWJPZ0c3bU44WEh4RVVYdEh3eFhOQ1N1Z1VBQUhpTkRwM3gwSUVoWkxlVVFueExpS2xyb012MURxSDg1UUZUSHhqNWd4bG5QcDg2QmdBQUFJQ2V4NElkQUFBQUFGMXUzTHoxbDRVc25wKzZBN3FaNzRidzhsc1hqVC9peWRRaEFBREFhM1BBNUlkM2FPNVh1ajZHMHFYRnRURjFEeVMwYjBQc05TOGJ0L0JrVDJNSEFBQUFvS3Rac0FNQUFBQ2dTNDFkc1A2dll4WnZUdDBCM1VtZWg1WDVpNzg3ZDhrbGIveGw2aFlBQU9EVlplTVdsZzQ1Yk5jTGUvVXIzVmhjZDAvZEE3VWhuckR2Z2YxbkZNTTFxVXNBQUFBQTZGa3MyQUVBQUFEUVpjYmMvOWllV2JseFFURTJwRzZCYmlQUGIxbTYvT2xyL0lSL0FBQ29ENGRNZjNUVUlZZnRNcmNZUjZSdWdScDA5Y0RKcS81aHc2d1RGNlVPQVFBQUFLRG5zR0FIQUFBQVFKYzR2cksydk52Z1hlWVg0NTZwVzZDYjJGaXQ1aGN0bWRCeVg3aWdKWFVMQUFEd0tvYk1XTDFmS1pUblpGa2NFMEpNblFPMUttYWxjTzgrSDF4MnhQZHZPdlc3cVdNQUFBQUE2QmtzMkFFQUFBRFFKWFk5ZU9mWnhYRk02ZzdvSHZJZmhiejlyVXNtalB4bTZoSUFBT0F2RzFaWjJEYzA3RHE1SEJ1dUtLN05xWHVnRHV4UUtqZDhjZTlMbGg3MXc3dE9leUYxREFBQUFBRGRud1U3QUFBQUFEcmR1QVhyeDhRUXIwamRBZDFCSHNJL2JuNHBQM1A1UlNOL2tyb0ZBQUQ0ODdJc2kwT21yVGsvYTloMVZuSGRLM1VQMUpVWWhwVjNhYnlybU1hblRnRUFBQUNnKzdOZ0J3QUFBRUNuR25mLytzR2hITzhKVzk0YUJXeXYrYy8vWXVPa3Y3djhxQmRUaHdBQUFIL2UwSm1Qdk9HUUc5Zk1MVjRKSDVHNkJlcFZqT0g4ZmFldStvZm5acHo0MGRRdEFBQUFBSFJ2RnV3QUFBQUE2RFRqUHJxMmI3N3pMbCtNSWZSUDNRSjFMaTlNV3pyeDhFcTFXczFUeHdBQUFLL3NvSm1yQmpUbWpiTkxNWjRib2g4MEE5c3J4akIzbjZrUFB2YjlHU2QvSTNVTEFBQUFBTjJYQlRzQUFBQUFPcy9PdTN3c2huQkk2Z3lvY3krR1VKMncrSUxXejRjTHFxbGJBQUNBVnpEd3lvVzkrdSt5NjFWTm9mSHFFRU9mMUQzUWpUU1dZdmI1QVZNZmFQM0JqRE9mVHgwREFBQUFRUGRrd1E0QUFBQ0FUakYyL2hNWHh4amVucm9ENnR4UFFyNzVqRVVYalB4bTZoQUFBT0JQWlZrV2gweDdhRnkvWFhhZFhWd0hwdTZCN2ludVV3NjlQNU5sbGRPcjFUWS9lUVlBQUFDQURtZkJEZ0FBQUlBT04rYis5YTJsY3B5YnVnUHEzT09icXB0UGYzREN5QitrRGdFQUFQN1U4SmtQalR6a3hqVnpRd3h2VE4wQzNWNE1wK3d6NWFnUEZ0T3MxQ2tBQUFBQWREOFc3QUFBQUFEb1VPUHVmbXlIVXIvR0JjWFluTG9GNmxVZTh1Vy9iSC94YlYrZCtJYmZwRzRCQUFEKzJMREs4ajFpUSs4WklaUW5oQml5MUQzUVU4UVFwdzJjL09EZmJaaDE4bGRTdHdBQUFBRFF2Vml3QXdBQUFLRERaRmtXejVtMzdwNWlQQ0IxQzlTclBJUy8vZTJ6djc3OHEyMmpOcWR1QVFBQS9tQlE1ZDdtUGczN1hCNGJlazh1cnYxVDkwQVBWSTVaYWQ2ZTF5NXAvY24wMDMrYU9nWUFBQUNBN3NPQ0hRQUFBQUFkNXB6N0gzOWZjWnlkdWdQcVZIdnhjY1hpOFNNK2xEb0VBQUQ0WThOblBISlczNGFCTnhmam9OUXQwSlBGR1BacXlwdnV5N0xLNkdxMXJacTZCd0FBQUlEdXdZSWRBQUFBQUIxaTdJSjFSOFlzbTVPNkErcFJIc0x2aW8rM0x4ay9ZbkhxRmdBQTRBK0d6Rm96dkp4bnQ4Y1lqMC9kQXZ5bkdNT2I5NWx5MVBYRmVFUHFGZ0FBQUFDNkJ3dDJBQUFBQUd5MzArYzlzVk92TEZ0UWpJMnBXNkFPL1RUbW0wOWZmTUhJYjZZT0FRQUEvdE9ReXRKZHk0MTlLdzBodXpqRVVOcnlVekdBMmhGRHZHNi9hMWQ4OWRucEp6MmN1Z1VBQUFDQSttZkJEZ0FBQUlEdGttVlpQR2ZlNC9lRUVBZW1ib0U2OUZTMWZmTXBTeWFPZkNaMUNBQUFVTHpHdmVUdWhrUDJPZkM5RFkxOXJ5dXVPNmJ1QWY2c0xPVFpmWHRldTJURVQ2YWYvdFBVTVFBQUFBRFVOd3QyQUFBQUFHeVhjK2F0ZTA5eHZEVjFCOVNocjczdzI1ZlBYUDN1STU1UEhRSUFBSVJ3Nkl4SFRqbDA0SUczRmVQZzFDM0FheERESHMxNTAyZXlySEp5dGRwV1RaMERBQUFBUVAyeVlBY0FBQURBTmp0bi9ycVdHTE5iWXVvUXFEK2YvMDMxVnhlc2VmZW9qYWxEQUFDZ3B4dFNXWDF3UTJQRGJWa1dUMDdkQW15bEdFN2NaOHBSSHl5bVdhbFRBQUFBQUtoZkZ1d0FBQUFBMkNialBycTJiMm5uWGVibklUU2xib0U2Yy91U1p4WjlvTnJtcCtzREFFQksrMDVadmxQL3ZyMXZhR2hzZUZkeGJVamRBMnliR09LMC9TYXZXdnZzckJQL1BuVUxBQUFBQVBYSmdoMEFBQUFBMnlUdXZQTkhpK09nMUIxUVIvTGkxOVdMeG8rNEpZUVJxVnNBQUtESHlpcHJ5NGMyNUgvVHYxL3ZTbkhkTlhVUHNOM0tvWlRQRzNqbHFwWU50NTc0aTlReEFBQUFBTlFmQzNZQUFBQUFiTFd4ODU2WW1HWHh2TlFkVUVjMjVYbDEwdUx4cmZlbkRnRUFnSjdzMEZtUHZtbFlRN2c5eERoc3kwL0FBTHFMdUUvV0s3OG55N0t6cXRXcWY3a0JBQUFBMkNvVzdBQUFBQURZS3VmTWYrTGdVaFkrbkxvRDZzaHY4anlNV1R5K2RWWHFFQUFBNkttR1ZkWWVrRFdHbTBzaG5obGk2aHFnYzhRekIwNVpmbWt4K0w0VkFBQUFBRnZGZ2gwQUFBQUFyOW1wZDY1bzZyZmIzcDhyeGo2cFc2Qk8vRFJ2Yno5bDBZVFd4MUtIQUFCQVR6UzRzcUovYzBPdnFWbGp1S3k0TnFYdUFUcGJObWZnNUFjZjNURHI1UFdwU3dBQUFBQ29IeGJzQUFBQUFIak4rdTIyOTZ6aWFFbmRBZlVoZjdiYUhrWXZudEQ2M2RRbEFBRFEwMlNWU2phc2NkU0VwcVplTTBJZTlramRBM1NaNWxncXpSdDQ1Y0lqTnR3NjVzWFVNUUFBQUFEVUJ3dDJBQUFBQUx3bWI1dTNiblRJc3N0VGQwQjl5Sjk0Y1hNWXZYTGlpQituTGdFQWdKN21rSm1QSERPc2FkVGNFR0pMVEIwRGRMbmkzL3REWXE5K3R4VGplMUszQUFBQUFGQWZMTmdCQUFBQThLck92bS9kN2cwTjhkUGg5KzlSQXY2U1BJUi8yUFR5eHROV1RqcnFGNmxiQUFDZ0p6bGs1aU1EUzFrMnA1eGw1d1N2WDZHSGkrL2FkK3JLbGMvTkdMMDRkUWtBQUFBQXRjK0NIUUFBQUFCL1VaWmxjZXo4ZFo4T2VkZ2pkUXZVdkR5c2VPbm5QeHV6NHNvVGZwYzZCUUFBZW9xOXJsN2RaOWVkRzY4dVovR3E0dG9yZFE5UUUyTEk0ejM3WHJQNHNPZG12OFhUNVFFQUFBRDRpeXpZQVFBQUFQQVhqWjMzN2ZjV3g4bXBPNkQyNVF1ZWZ2Wjc0OWUzamRtVXVnUUFBSHFDTFQ4UTV0QVphODdmYmVmR21jWDE5UjVhQi95UkdIWU5wZWJQWkZubHhHcTFyWm82QndBQUFJRGFaY0VPQUFBQWdEL3JuUGxQREM5bDJaelVIVkFIUHJGNDZmY3VxUzRZMDU0NkJBQUFlb0pEWno5NjVMQVpqOHdOTVJ5VnVnV29hVy9hZS9KUkh5aE8zOThDQUFBQTRNK3lZQWNBQUFEQUt6ciszclhOdS9mYTVmNWliRXJkQXJVc3o4T3RTeWEwWEZXdFZ2UFVMUUFBME4wTnJUeTBWMk5qdzZ4U2pPZUg2SkYxd0t2TFFyeHg3eWtyVnY5dzVrbmZTdDBDQUFBQVFHMnlZQWNBQUFEQUs5cTllWmVaeFhGbzZnNm9aWG1ldHkwYVAySmFHRjlOblFJQUFOM2F3Q3NYOXRwcHQ5MnViR3hxK0dCeDdadTZCNmdyamVXWTNWZjhPVEp5dzYxalhrd2RBd0FBQUVEdHNXQUhBQUFBd0o5NDI3d24zaHhLNGZMVUhWREQ4dUovNzE4MGZzUWRxVU1BQUtDN08yeldvMk4zMm0yM09jVTRNSFVMVUxlR3h1WitOeFhuKzFLSEFBQUFBRkI3TE5nQkFBQUE4RWRPbi9mRVRuMUs0VlBGR0ZPM1FJMXFENkg2TncrYzMvTEoxQ0VBQU5DZEhUcjk0WlpTcVR3M3huaE02aGFnTzRpWERweThjdG1HV2FOWHBpNEJBQUFBb0xaWXNBTUFBQURnai9USjRsMGg1SHVuN29BYXRUa1A0WUpGNTdkOExuVUlBQUIwVjRmTld2TzZHRXJUeStYeXhPSmFTdDBEZEJzeFp2a25CMHg5WVBnUFpwejVmT29ZQUFBQUFHcUhCVHNBQUFBQS9yOXhDNTQ4UDhZd05uVUgxS2hOZVo2L2ZkSDRFVjlNSFFJQUFOM1JzTXJDeGxMVHJwZkhXSnBhWFB1bjdnRzZvN2hYS1cvK1dER01TVjBDQUFBQVFPMndZQWNBQUFEQTc1MjE0UEY5RzJQNXc2azdvRVp0REhrWXMyajhpR1dwUXdBQW9Ec2FNZnVSdDVTYWRydTFHQTlJM1FKMGN6R2V2ZStVbFJPZW16bjYwNmxUQUFBQUFLZ05GdXdBQUFBQUNGbWxrbzBkTXVaVHhiaEQ2aGFvUVMrMGgveU1KZU5IUEpRNkJBQUF1cHREcHo5NlNMa2NiaTllbVo2UXVnWG9RV0s0WTY4cEt4Lzk4Y3pSejZWT0FRQUFBQ0E5QzNZQUFBQUFoTEVIbjMxWmNSeWJ1Z05xMEcvejl2eTBKUk5HckUwZEFnQUEzY2toczlmc1VvNmxhZVdHK0RkaHkzc1g4dFJGUUEvVHZ6R0VUMlZaNVUzVmFsczFkUXdBQUFBQWFWbXdBd0FBQU9qaHp2NzhrME1hWXB5WnVnTnEwRy9hcTlWVGwweG8rV3JxRUFBQTZDNnl5dHJ5b1UzNXV4dENxYTI0N3B5NkIrakJZamgybjhsSHZxK1k1cVpPQVFBQUFDQXRDM1lBQUFBQVBkZ1Jkei9Xc0gvL3BzK0dHSnBUdDBDTitYVjdlMzd5a2drdGY1ODZCQUFBdW91V1dZK09IdDRjYndzaERrM2RBdkNmNHN6WFg3Tjg1WTltbi9MUHFVc0FBQUFBU01lQ0hRQUFBRUFQdG4vL3Bxa2hoc05UZDBDTitWV29WazlhTXFIbDY2bERBQUNnT3hneDQ1SEJzWnpkRnJMc2xCRHkxRGtBLzFPdmNxbDBiM1o4NVEzVk5XMmJVOGNBQUFBQWtJWUZPd0FBQUlBZWF1eUNKMGRtTVV4SjNRRTE1bGViMjl0SEw1M1ErbzNVSVFBQVVPOEdWZGJ1dUVOVHVDNldTKzh0cmcycGV3QmVTUXpoaUgyT09uSnFNVlpTdHdBQUFBQ1FoZ1U3QUFBQWdCNW8zTnl2OThyMjZ2ZVo0QTJPOEQvOXFwcUhFNWRPYVAzSDFDRUFBRkRQc25FTFM4TmFkNzl3aCtZNHZianVscm9INEZYRk9IWGZLY3VYUGpmemxIOUtuUUlBQUFCQTE3TmdCd0FBQU5BVDdkVnZ5NXNjaDZUT2dCcnkzMCt1czF3SEFBRGJvZVdtUjQ0L3JIVzMyNHR4ZU9vV2dLM1FFR0xwTTlsbEsxcXJkNXowVXVvWUFBQUFBTHFXQlRzQUFBQ0FIbWJzZ2lmZmtNVndlZW9PcUJWNUNMK3U1dFdUbDA1by9VYnFGZ0FBcUZlSDNmVHdvQ3d2M3h4aTZhelVMUURiYU9pQXZ2R0c0cHljT2dRQUFBQ0FybVhCRGdBQUFLQUhHVGYzNjcyeXZmcDlxaGl6MUMxUUkzNFROK2NuTDU3UThnK3BRd0FBb0I0TnE2enRXMm9LazdQWWNFV0lvVGwxRDhEMmlDRjhZT0ExeTc2OFlmYXBubkFQQUFBQTBJTllzQU1BQUFEb1NmYnFONzM0NjBHcE02QW01T0czMWRCK3lxSUpyWCtmT2dVQUFPcE5WcWxraHpVZk42SGNIR2NVMXoxUzl3QjBrSElzbFQrVlhiYWl0WHJIU1MrbGpnRUFBQUNnYTFpd0F3QUFBT2doeGk1NDhnMVpESmVuN29BYThVSTE1cWN0T3EvMWE2bERBQUNnM2d5Zi9lZ2JEMnM2Ym00eGpremRBdEFKaGc3b0cyOG96c21wUXdBQUFBRG9HaGJzQUFBQUFIcUFjWE8vM2l2YnE5K25pakZMM1FJMVlHTWV3cG1Memh1eE5uVUlBQURVaytFelZ3MG9aVTJ6U3pFN3Q3akcxRDBBbmFYNEErNERBNjlaOXVVTnMwLzl4OVF0QUFBQUFIUStDM1lBQUFBQVBjRmUvYVlYZnowb2RRYlVnSmZiUTNYczR2TmFWcWNPQVFDQWVyRjNaV252M1p2N1hWMHFOVjlWWEh1bjdnSG9BdVZZS244cXUyeEZhL1dPazE1S0hRTUFBQUJBNTdKZ0J3QUFBTkROalYzdzVCdXlHQzVMM1FFMVlIUEk4N2N2UHI5bFNlb1FBQUNvQjFtV3hSR3pIejEzOTE3OVp4ZlhBU0ZQWFFUUXBZWU82QjF2S003SnFVTUFBQUFBNkZ3VzdBQUFBQUM2c1ZQdlhOSFViL2NCbnlqR1V1b1dTS3hhRGRWSmk4NXZXWmc2QkFBQTZzSHdtV3RIanBqMTZOeGlmR1BxRm9CVVlnd2YySGZLOG9YUHpUemxuMUszQUFBQUFOQjVMTmdCQUFBQWRHUDlkaHR3ZlhFTVNkMEJpZVY1Q085YWRGN0xaMU9IQUFCQXJSdGFlV2l2NWw2Tk04cmxPTDY0WnFsN0FCSXJoMUQ2UkhiSjNmK25ldGRGTDZlT0FRQUFBS0J6V0xBREFBQUE2S2JHelh0OFJDeVZyMHJkQWNsVjg2c2ZHRC9pNDZrekFBQ2dsZzJxckczZXNWZThvcmxYNCtUaTJqZDFEMEFOR1RGZzV3RlhGK2VNMUNFQUFBQUFkQTRMZGdBQUFBRGQwUEdWdGVYZGgreDZUekUycEc2QnBQTDh4aStQSDNGTDZnd0FBS2hsTGJNZk9XdkhYcVdiaTNGUTZoYUFXaFJEdk83MTF5ei8wbzltbi9MUHFWc0FBQUFBNkhnVzdBQUFBQUM2b2QyRzdQS0I0bWhOM1FHSmZlakw1NCs0UG5VRUFBRFVxdFpaYTBlRUxNNk5XV2xVNmhhQUd0ZlVrSlh1enJMS01kVnFXelYxREFBQUFBQWR5NElkQUFBQVFEY3o3djcxZzJORDFwYTZBeEw3OUtMeExaZUg4N3puRFFBQS9yZVd5dXJkUTNQampiRVVMeXl1cGRROUFIWGlqWHRmZmRTbHhmbWgxQ0VBQUFBQWRDd0xkZ0FBQUFEZFNGYXBaR09IakxtN0dKdUloYngwQUFBZ0FFbEVRVlJUdDBBcWVjaS90SGpKOTk1WnJWYnoxQzBBQUZCTGhsVVdOcFo3N1g1cGJHNjZMc1N3WStvZWdIcVRaV0hHWGxOV0x2N3h6TkhQcFc0QkFBQUFvT05Zc0FNQUFBRG9SczQ1ZU16RnhmSFhxVHNnbFR5RU5TLy94Nys5dmJwZ1RIdnFGZ0FBcUNVdHM5ZWUxdEJyOTF1S2NYQ0lxV3NBNmxiZmhqemNWWnducFE0QkFBQUFvT05Zc0FNQUFBRG9Kc1o5NXZIWHgrYnlyTlFka05EL2pTLy83c3hsbDU3MFV1b1FBQUNvRllmUFhqTzBtcFZ2aTFrY25ib0ZvRHVJTVl6ZTU1b1Y3L2orN0pQdVQ5MENBQUFBUU1ld1lBY0FBQURRVFdUTnBRL2xJZXlRdWdNU2VXclQ1dnlVWlJQZjhKdlVJUUFBVUF1R1ZWYnQzTkM3cVMyV3l1K091ZmNHQUhTa21NWGJCcnozZ1JVLytQQ1p6NmR1QVFBQUFHRDcrU1k2QUFBQVFEZHc3dWZYbnhGQ2RsYnFEa2dqLytITG0vTFJ5eWExL0R4MUNRQUFwSlpWMXBaSDlBNlhOUFp1dnFHNDdwSzZCNkNiMmozcjIzeHpjVTVLSFFJQUFBREE5ck5nQndBQUFGRG4zdnFwdisvWDNHZUhPMU4zUUNMUGg4MWg5TkpKTFJ0U2h3QUFRR3F0TjMzMXhCRzk0MjB4aEVOU3R3QjBlekZPR0REbHdmdCtNUFBrTmFsVEFBQUFBTmcrRnV3QUFBQUE2bHh6bngxbUZNZmVxVHNnZ1JmemFqampnUWtqdnBNNkJBQUFVanA4eGxjUERJM2hscGlGdDZSdUFlaEJpajkyczQ5bWsrNDlyUHJKQ3phbWpnRUFBQUJnMjFtd0F3QUFBS2hqWXhlc083SVVTKzlKM1FFSnRJZHEvcllIeG8vNHU5UWhBQUNReXVES2l2NTllL1daR2hyRDVjVzFNWFVQUUE5MDBJQTk5cmkyT0s5TkhRSUFBQURBdHJOZ0J3QUFBRkNuanJqN3NZWURkbWo2ZURGbXFWdWdxK1Y1ZU5jRDQwY3NUdDBCQUFBcFpPTVdsa2FNM1AzQ1ByMzczRmhjZDAvZEE5RERYVFh3Nm1Yek44dzU5WW5VSVFBQUFBQnNHd3QyQUFBQUFIWHFnQjJhdGp5aFlIanFEdWg2ZWRzRDU0KzRPM1VGQUFDa2NQanNSMGUxakh6ZDdjWFlrcm9GZ045ckRPWHlSN01zTzZaYXJlYXBZd0FBQUFEWWVoYnNBQUFBQU9yUW1NOTlhMkJEdWJFdGRRZDB0VHlFdXg0NGI4UzAxQjBBQU5EVldtOWF1Mi9Nc3B0Q3FUUTJkUXNBZitMb0FSOThjRkp4M3BNNkJBQUFBSUN0WjhFT0FBQUFvQTQxbEJ2dktJNCtxVHVnaXkxWnZPUzdsNGJ6RGt2ZEFRQUFYV1pZWlczZmhsN1o1SmhsVnhUWDV0UTlBTHl5UElhYjlyNXE2YUlmM256YXY2ZHVBUUFBQUdEcldMQURBQUFBcURQbmZuNzlHU0ZrWjZUdWdLNlU1K0diRytQUHpxMHVHTk9ldWdVQUFMcENsbVd4WmZhajV6ZjJ6bVlWMTcxUzl3RHdsOFVRZGltVnkzT0tjVkxxRmdBQUFBQzJqZ1U3QUFBQWdEcHkwbjNyK3V6VWxIMG81S2xMb0F2bDRabXdhZVBwS3k0ODRYZXBVd0FBb0N1TXZIbnRVYTJ6SDUwYllqelN5eitBT2hMamhJR1RIL3owaGxrbmZ5VjFDZ0FBQUFDdm5RVTdBQUFBZ0RxeVUyUFdGa0xjSjNVSGRLSG53K2FYVDNuZ3dpTi9tam9FQUFBNjI0aWIxKzVkenVPc0VMTjNoTGpsWVVnQTFKbmlUKy9zSTlrbGQ3ZFU3N3JvNWRReEFBQUFBTHcyRnV3QUFBQUE2c1E1ODU4WVhpN0Y5NmZ1Z0M2MHNacTNuN2xvNHNpblVvY0FBRUJuR25qbHdsNjd2bTczcThveHV6ckUwQ2QxRHdEYjVaQzlkOXJueXVLY25Ub0VBQUFBZ05mR2doMEFBQUJBSGNpeUxJNWJzTzRqd2ZkejZEbnlrRmNuTERxLzlXdXBRd0FBb0xOc2VhMDNZdmFqNSt5MjUrdm1GUDhGUERCMUR3QWRKSWJyWG4vVmcvTitkUFBKRzFLbkFBQUFBUERxdkNFTEFBQUFvQTZNWGZENCtCRGlHMU4zUU5mSnIvM3krUzBMVWxjQUFFQm5HWG5UbzRlMzNyUjJib2poNk5RdEFIU3NHRUx2VWtOMmV6R2VsYm9GQUFBQWdGZG53UTRBQUFDZ3hwMTE3K003TnZVdTM1UzZBN3JRcDcvMGpzTm1wbzRBQUlET01PeVd0WHMwaG14R0xKVW1GTmNzY1E0QW5TU0c4TmFCVTVhZnRHSG1LU3RTdHdBQUFBRHdsMW13QXdBQUFLaHhqYjNMbGVKNFhlb082Q0tQZnZkNy8zcHhDTU5UZHdBQVFJY2FmTm1LcG40RGVsL1dGTEtweGJWLzZoNEF1a0xwanV5eUZjT3JkNXowVXVvU0FBQUFBUDQ4QzNZQUFBQUFOZXpjeno5NVdJemgzYWs3b0d2a1Q3MzQwb3RucjI4YnN5bDFDUUFBZEtUV205ZWUyVy92UGpjWDR3R3BXd0RvVWdmdDNUdGNXWnd6VTRjQUFBQUE4T2Rac0FNQUFBQ29VVm1XeGJFTDF0MFpRL1E5SEhxQzUwTjcrNmtQVGpycUY2bERBQUNnbzR5WTg1Vmg1U3pjbnNYc1RhbGJBRWdqeGpobDc4bEw3L3Zock5PK243b0ZBQUFBZ0ZmbXpWa0FBQUFBTmVxY2VldlBpeUVjbmJvRHVzQ205cng2OXFMeHJVK25EZ0VBZ0k1d1JHWHRybm52ckZMTzRzWEZ0WlM2QjRDayttU2g0ZmJpUER0MUNBQUFBQUN2eklJZEFBQUFRQTBhZC9kak8yUTdOczFKM1FGZElRL1Y5eXc2YjhUYTFCMEFBTEM5anJqazdvWjgvNFBmRS90azE4Y1Fkc3BUQndGUUUySU1adzJjdkhMMGhsbWpWNlp1QVFBQUFPQlBXYkFEQUFBQXFFRnh4OGEyNHRnamRRZDBnZHUrL0k0Um4wZ2RBUUFBMit2d1c3NTZTbmJBd2JmR0VBNU8zUUpBRFlyNTNPeVN1NGRYNzdybzVkUXBBQUFBQVB3eEMzWUFBQUFBTmVhYytVOGNYQzdGUzFOM1FCZFk5c0RpZjcwNnZHTjQ2ZzRBQU5obVI4eGVlM0FvWjdkbUlaeVN1Z1dBV2hZUEhyRHpnUGNWdzYycFN3QUFBQUQ0WXhic0FBQUFBR3BNdVJUdktJNkcxQjNReVo1NDZaY2IzMTVkTUtZOWRRZ0FBR3lMdzI1YXZsTkQxdi82V0M2OUo0VGNhemdBWG9ONC9aN3ZYM0xmVDI0Ly9hZXBTd0FBQUFENEF3dDJBQUFBQURWazNJTDFiOG15N01UVUhkREpubjk1MDZZemxsMzZmMzZkT2dRQUFMWldObTVoNmZDUnUxL2NXT3BmS2E2N3B1NEJvSzcwYjJ4dW1GV2NrMUtIQUFBQUFQQUhGdXdBQUFBQWFzU3BkNjVvNnYrNkFiZWw3b0JPdHJrOUQyT1hUQno1VE9vUUFBRFlXa2ZjOU5YakR6OWlqN25GT0N4MUN3QjFLc1lMQms1WitkRU5NMGQvTTNVS0FBQUFBUC9KZ2gwQUFBQkFqZWkvKzk1WEZNZitxVHVnTStWNXVITFJlY1BYcE80QUFJQ3RjZGhOLzQrOWV3K3d1aXp3UC80ODMzTm1ocnVpNWczTnpmQ1M1VjNEVytFRmpMU3NERU5VMUhJMWF6VUZCVUdVdzBna2d0elMyc3BmdS8yMlhVMmR0Q3l2b0MxNXE2MDFGY1h3VnE2WFRFM05SRzR6MysvdlMxdS9kUTJVeThCelp1YjFLdVo1dmxidy9vT1FJL09aYy92MkRkV21hYkVTajA3ZEFrQ0hsNVhmWm1kWmRtQ2U1MFhxR0FBQUFBQU03QUFBQUFEcXdxZXV2bi9yYmxuRCthazdZTDBxd2o5ZGY4SnVYMDJkQVFBQXEydW41bHY2OU9uWmMzeGp0ZW1zOHJFcGRROEFuY2IrMjV4MzA0ankvSmZVSVFBQUFBQVkyQUVBQUFEVWhhYXM0Wkx5NkpXNkE5YWplNWErK3R3WFE5Z3RkUWNBQUx5anJMazUyNnZuSVNmMzZkVnJjdm00WmVvZUFEcWpPR1h6c1RkYy84S1VvLzZVdWdRQUFBQ2dxek93QXdBQUFFanNNMWMvT0tDU1ZZNVAzUUhyMGJQTFc1ZDkrc1l6aGl4TkhRSUFBTzlrMzZuekR0cXIxNkd6WW9oN3AyNEJvRlBicWlrMmppM1A4YWxEQUFBQUFMbzZBenNBQUFDQWhMSXNpNSs1ZXY3TThocFR0OEI2c3JRMWJ6dm1SeWZ0ODN6cUVBQUFlRHY3Zk9VbjIyVk5EVk5qcFhKTThCb05nQTBnaGppeTMraWJ2L1hzdEk4K2xib0ZBQUFBb0NzenNBTUFBQUJJYU5qMzVnOHJqLzFUZDhENmt1ZkZtVGVNMlBQZTFCMEFBTEFxZTA2ZjA3T2g2RFltYTJvWVhUNTJUOTBEUUpmU3ZWTE5wcFRuOE5RaEFBQUFBRjJaZ1IwQUFBQkFJc05tL2F4NzFxLzNsTlFkc0I1OTZ3Y2pkcjhpZFFRQUFLek1pbmNVMzN2YXZ3OXZDTjB2Q1RGc2s3b0hnQzVyMkxiamJycnM2WXVQdUNkMUNBQUFBRUJYWldBSEFBQUFrRWpzMTN0a2VXeVh1Z1BXazNzZmUvelJNMFBZTFhVSEFBRDhqWDJuM3pWZ242bnpacFd2elBaTDNRSkFseGRqcU16SXNtei9QTStMMURFQUFBQUFYWkdCSFFBQUFFQUN3Lzd2TDdmTWVuUWZtN29EMXBQblc5dUtZK2JYaGk1TEhRSUFBRysyOTdTNVcyZFowOFV4eEJFaHhwaTZCd0QrWXNBMlkyNDZyanovTFhVSUFBQUFRRmRrWUFjQUFBQ1FRT3pSZlhKNTlFN2RBZXRCYTk3V051eUdFL2Q4Tm5VSUFBRDgxZmJOODdwdDByTXlxaEs3alNzZmU2WHVBWUMzS21LOGVKdlRmM3o5TTkvNDJCdXBXd0FBQUFDNkdnTTdBQUFBZ0ExczJGVVA3SkZWcXllbjdvRDFvZ2hqZjNEaW5qOU5uUUVBQUgrMTcvU2ZmbWF6WHBWTHl1dmZwVzRCZ0ZXSklXd2JObTQ0cDd4T1N0MENBQUFBME5VWTJBRUFBQUJzWUZtMU9tM0ZrYm9EMmx0UmhKWWZucmpIakhCQ25qb0ZBQURDQjJmOGRNOVFaRE5qekFiKytTOFVpWU1BNEIzRUdNWnNOZkpIMy9yZHpJLy9QblVMQUFBQVFGZGlZQWNBQUFDd0FRMzczdndoV1NVYmxMb0QybCt4Y05tclMwL0o4OXluTFFNQWtOU2UwK2RzM2hDN1RRb2hPeVhFVUVuZEF3QnJvRmUxVzdXNVBFOVBIUUlBQUFEUWxSallBUUFBQUd3Z3c0YTFWQ3BEM3pmVitvaE9hRkZiVy9qMGpXZDg4TFhVSVFBQWRGMjdOcmMwOXVpNXhaY2FzdTRYbEk4YnBlNEJnTFVSUXp5bDM5aWJaajg3NVloSFVyY0FBQUFBZEJVR2RnQUFBQUFiU0J5NjgwbmxzV3ZxRG1oM2VYSGFEMC9jL2VIVUdRQUFkRjBEcHQxNVZJL2VXMTVhWG5kSTNRSUE2NmhhQ1hGS2VYNGlkUWdBQUFCQVYyRmdCd0FBQUxBQkRQblhCM3R1MGxTWmxMb0QybHNSd2pldkg3SDdsYWs3QUFEb212YWErdS92YjZoVVo0UktQRHgxQ3dDMG14aVA2bmZlTFFPZnZXVEl2TlFwQUFBQUFGMkJnUjBBQUFEQUJ0QzNzVEt5UExaTzNRSHRxN2p2ajYydm5wMjZBZ0NBcnVmOVUrN1l0R2RqNDhTR2F2WDA0TSs5QWVpRUtsbTROTXV5RCtaNVhxUnVBUUFBQU9qcy9FRURBQUFBd0hyMjZYOTljUE9tcHNxWTFCM1F6djZZaDN6WUhTY05YSkk2QkFDQXJpTnJubGZkdTFmbGk3MGFHMnZsNHlhcGV3QmdQZHBuNnpFL1ByWThyMG9kQWdBQUFORFpHZGdCQUFBQXJHZU5UZG1LVC96c25ib0QybEZSL3V0elB6aGh6OGRUaHdBQTBIWHNlK21kaCsvYnV6cXp2Tzd5MzMvRkcvb0EwTGxsTVp1Y25YWExkZm5zSVV0VHR3QUFBQUIwWmdaMkFBQUFBT3ZSTVZmZHYwTkR0ZUhVMUIzUW5vcFFmUFc2RTNhL0xuVUhBQUJkdzk2WDNybERKWXVYWmxsMlZPb1dvSDZWcjFWL0hJdHdhNGp4cStWalROMEQ3ZVE5Mi9Rb1RpL1AyYWxEQUFBQUFEb3pBenNBQUFDQTlhaWgwakJweFpHNkE5clJMeDU3L0xFeElleWV1Z01BZ0U1dXIrWjVHemYwcWw1WXpiSXp5c2ZHMUQxQWZTcENXRkRrWWRTakV3ZmR1dUo1NStiYnR3OHhqRXpkQmUwbmp0OTg3QTMvOU1LVW8vNlV1Z1FBQUFDZ3N6S3dBd0FBQUZoUGhsMzEwTjZWYXZ4TTZnNW9SMzhzMmxxSHo2OE5YWlk2QkFDQXppc2IxbExaZDhCV3B6VDBycTc0Z2lXYnArNEI2dGJMUlpFM1B4YnUrWG8rc2RiNjE3LzRhSGhsN0k1RjN3K0hHUFpPR1FmdDZGM2RZdU81NVZsTEhRSUFBQURRV1JuWUFRQUFBS3dubFVxOHVEeGk2ZzVvTDBVb1RydnV4TDJlU04wQkFFRG5OZURTdXdidU8yRExXZVYxajlRdFFOMXFMVitoZm12UjB0Y25QRDM1azM4SVlmRC8rZy96MnRCbE96YmZkbXhXVk80ckgzdW5TWVIyTjJxcmtULzYrdTltZnZ6M3FVTUFBQUFBT2lNRE93QUFBSUQxNE5ockh4cVV4VGo0bmYrYjBERVVJWHpydXVOM3Z5WjFCd0FBbmRPQVMrN2VQalFXMDBJV2owN2RBdFN4SXN6Sjg3YVJqellmL3ZEYi9kY2VyUjMrK0U3TnQ1OGVRL2kzRFpVRzYxbXZocWFHQzhyenpOUWhBQUFBQUoyUmdSMEFBQUJBTzh1eUxCNTc5ZnlMVTNkQWV5bENNZi8zTHk0K08zVUhBQUNkejY3TjgzcjE3RjBkRnh2RHFCQml0eUoxRUZDdkhtOHI4bk1lclEyNllYWC9Cd3RyaDEyNWMvUHRoNVhYejYzSEx0aHdZamh0eS9OdW1mWDhKVU9lU0owQ0FBQUEwTmtZMkFFQUFBQzBzODljL2VBeDViRlA2ZzVvSjR0aWtRKzcrK3o5RnFjT0FRQ2c4OGlhbTdOOSt4eDJZczgrMWNubDQ5YXBlNEM2OVZvb3d1VDg1V1d6SDUwOVpPa2EvNDhYNVYvcTB6UGJ2N3krYnoyMHdZYlcyQmlMU2VWNVhPb1FBQUFBZ003R3dBNEFBQUNnSFIzYVBLKzY1UzZiZlRsMUI3U2J2Qmo1L1JGN1BwSTZBd0NBem1QQXpEc1AyTGZQb0ZreGhIMVR0d0IxS3k5QzhVK3R5K0lGajMvNTBOK3Y3WGZ5M05UQmkvclhiaDlXemNMUHk4ZnU3ZGdIYWNRNGJOdnpicHI2OUNWSDNKODZCUUFBQUtBek1iQURBQUFBYUVkYjdyelpTZVd4UStvT2FBOUZLTDUvM1lqZHIwamRBUUJBNXpCZzVwM2J4aENueEpBTkx4OWo2aDZnWGhVL3pkdkMyUXViRC90VmUzeHZqemNmTm4rbjVybWp5bDkvL3JFOXZqOUlMSXRaZGxGNUhwVTZCQUFBQUtBek1iQURBQUFBYUNkSFhuNUxVNTh0dHBrUWZaNG9uY1BUaTVjdVBpMTFCQUFBSGQ5MjU3UjAzN0xmbHFOanpNNHJIM3VrN2dIcVZCR2VLaitNV2RnOCtObzh6NHYyL0s0WDFnWjlZNmZtMndmRkVEN2RudDh2SlBMeGQ0KzlaYi8vbWpMa1o2bERBQUFBQURvTEF6c0FBQUNBZHRKbjgyMU9peUcrTzNVSHRJTzJVT1FqYnY3Y2ZpK25EZ0VBb09QS3NpeCtjTnFkdzdmYVpxc3A1ZU8ycVh1QU9sV0VSZVhIcVcrODl2SzBwNllQWFJ4cStYcjVZZDVZOXFmUDkyenN2Vjk1N2JkZWZnRFlrR0w0Y3ZseFVPb01BQUFBZ003Q3dBNEFBQUNnSFh6aWl2dDY5Tnk0NmZ6VUhkQXVpakRsK3lmc01TOTFCZ0FBSGRkKzArYnQ4OEZMNzV3VllqZ3dkUXRRdDRxaUNOOE5yWXZQLy9Xa0k1OWQzei9ZMDVNLytZZWRKczc1Ykl6WnJXSEZQQWs2dHNPMkhYUHpvVTlQL2VnZHFVTUFBQUFBT2dNRE93QUFBSUIyMEhQanhqUExZOHZVSGRBT2Z2N0tFNjlNVEIwQkFFREhOT0RTZVZ2R1NuVnlxRlpQTGgrejFEMUEzZnA1bnVkbkw2d04rdG1HL0VFWFRodzhaK2ZtMjJlVjE1RWI4c2VGOVNGVzRxVHlNTEFEQUFBQWFBY0dkZ0FBQUFEcmFOZ1Y5MjFVMmJocGRPb09XSGZGNjh1WEZ5UHVxQTFzVFYwQ0FFREhzbjN6dkc3djZsMFpGU3ZWc2VWajc5UTlRTjE2cnNpTGNZODJELzV1bnVkRmlvRGk1ZVhqd2liVncwS0l1Nlg0OGFFZEhmRHVjVGNkK1Y4WEgzRmo2aEFBQUFDQWpzN0FEZ0FBQUdBZFZUWnVXdkZWenpkTjNRSHRZTlFOSisveFdPb0lBQUE2bGdFejdqejZYWDJxMDJJSTI2ZHVBZXJXNGxBVTAxOHBYcm5rK2RyUTEwTXRUeGF5Y1BhUXBmMXJ0NStRWmVFL3lsKzN1aVVMZ1hhUlRjcXk3S1pVZzFVQUFBQ0F6c0xBRGdBQUFHQWRER3Rac0VrbGhKR3BPNkFkL1BEN3grMStSZW9JQUFBNmpuMm0zN1ZiTmNhWldjd085Vm45d0NvVjRacFFMRC92a2RwSGZwczY1YThlYno1cy9rN05jOGVGRUdlbWJvRjF0T2RXWTI3NmRIbTJwQTRCQUFBQTZNZ003QUFBQUFEV1FTV0VjOHFqVCtvT1dFZlBMMW1XbjVvNkFnQ0FqbUh2S1hlOXE2RXhYTlNReFJXL2g2eWs3Z0hxMXEvYThyYXpGOVlHL3pSMXlNbzgxbno0N0IxcXR4MFJRaHljdWdYV1JSWkNMY3Vhcjh2emhHOE5DUUFBQU5EQkdkZ0JBQUFBcktWUGZPKyt6WHBXbXM1TTNRSHJxTWp6L0pRYlQ5N2p4ZFFoQUFEVXQzMVB2Nktoc3RQN3pteHNpaGVXanh1bjdnSHExZ3NoTHk3ODlZSlh2cDFmUGJRdGRjeXFsSytGaTc5cm5udHlVd2dQbG8rYnB1NkJ0UmJEQi9xTkhuQk1lYnM2ZFFvQUFBQkFSMlZnQndBQUFMQ1dlbGE3blZzZXZVTlJwRTZCZFZCODgvb1Q5cmdwZFFVQUFQVnQvNWwzSGxIZGVaY1o1WFduNENVUXNITExpaUxNeW90bGt4ZldocnlXT21aMS9MWTI2TGtkbXVlZWxvWDQvZFF0c0U2eU1DSExtcS8xTG5ZQUFBQUFhOGZBRGdBQUFHQXRER3U1LzEyVjBQZ1BxVHRnSFQyK0tJL25wbzRBQUtCKzdUL2pybDJLR0dmRW1IMGtkUXRRdjRvaTNORGFtcC83MkVXREhrdmRzcVllcXcyNmJxZm0yNzliWGtla2JvRjFzTXZXWS9ZZFZwNVhwUTRCQUFBQTZJZ003QUFBQUFEV1FpVTBqaW1QWHFrN1lCMjBsZi82N0MwamRsdVVPZ1FBZ1Bxeit5VjM5KzNSRkNhR0xINGhodENRdWdlb1Y4WERJUzlHUFZJYmRGdnFrbld4UEx6K3BZYlE2OUR5Mmk5MUM2eTFtRTNJaHJWY2sxODl0QzExQ2dBQUFFQkhZMkFIQUFBQXNJWSsrYjJIdHVoUnpiNlF1Z1BXUlJIQzlPdEc3SFpYNmc0QUFPcEwxanl2dXU5RzFkTjZOTWFMeXQ4MWJwcTZCNmhiZndoNVB2SFg0ZTV2NUxWYWErcVlkZlZrN1JPdjdqang5bE5pRERlWGp6RjFENnlOOGlmdXpsdHQzMk40ZWYzWDFDMEFBQUFBSFkyQkhRQUFBTUFhNmw2Tks5NjlybWZxRGxoYlJTam1MMzM1ZHhOQzJDMTFDZ0FBZFdTL21YY2RObUNqaHBubGRWZnpFbUFWV29zaWZQMk5vclg1cWRyaEw0Y3dLSFZQdTNsMDRtRzM3dFE4OTRvUTRtbXBXMkJ0WlNHN01EdTArWHY1SFIxLytBb0FBQUN3SVJuWUFRQUFBS3dCNzE1SEo3QXNiNHNuM1hqR2tLV3BRd0FBcUEvN3pKclh2NkZvbUI1amRsVHFGcUNPRmNWdGJVVWN1YkIyNklMVUtldkxLNHZmT0xkdjk1NkhsOWUvUzkwQ2EybkhyVDc0d1JYdll2ZmQxQ0VBQUFBQUhZbUJIUUFBQU1BYTZGSE56aTJQN3FrN1lHMFZSZmp5RDBiczlxdlVIUUFBcExkLzh5MTlZcC9lNHh0aXcxa2hocWJVUFVEZGVpemsrYmtMYW9OdVNCMnl2cjB3NWFnLzdkaDgrMmRqQ0xlSEZXOEdCaDFRalBIOGJGakxsZm5WUTl0U3R3QUFBQUIwRkFaMkFBQUFBS3ZwRTkrN2I3T2UxVzZucCs2QXRWZmM5L1FiYlZOU1Z3QUFrRmJXM0p6dDEzdnc1K0pHZmI1Y1BtNlJ1Z2VvVzM4c1gwZGU5RWpieTVmbnRhSExVc2RzS0kvV0R2djNuWnJuWGg1Qy9GTHFGbGdiTVlTZHQ5NnUxekhsOVh1cFd3QUFBQUE2Q2dNN0FBQUFnTlhVczlwdFpIbjBTdDBCYTJsWlcxdisyVitjdXRmeTFDRUFBS1N6MzR3N1A3emZSb05tbGRjOVU3Y0FkYXV0Q01XM2w3ZTFYZmhZYmZBTHFXTlNXQlNXak9zWnVnOHByenVtYm9HMUViTXdQc3VhcjhueldwNjZCUUFBQUtBak1MQURBQUFBV0EwZnYrcWh2cjBic2pOU2Q4RGFLb3J3NVIrTTJQUEIxQjBBQUtTeHo0eWZiTmVZTlUzTnNzcG5VcmNBOWFzSXhieThMVC83MTdWQjk2ZHVTZW1aMnNmZTJMRjI2OGt4cTk1WlBsWlM5OEJhK01CV1kvYjlaSGxlbHpvRUFBQUFvQ013c0FNQUFBQllEYjBic2krVlI1L1VIYkIyaXZ1ZWZxTnRTdW9LQUFBMnZEMm56K25admRKalRHT2xhWFFvUXZmVVBVRGQrazNSVm94WlVEdTBKWFZJdlhpMCtTUDM3dFE4ZDBZSWNYVHFGbGdiTVdRWFpGbDJmWjduUmVvV0FBQUFnSHBuWUFjQUFBRHdEbzY4OGovNmJOVFk2NnpVSGJDV2xyVzE1Wi85eGFsN0xVOGRBZ0RBaHBObFdSd3cvYzRSM2FzOXZoSkM3SmU2QjZoYnJ4ZWh1SGhKMjlNem5xeWR0Q1IxVEwxWjh0cXJ0VzU5K3E1NEY3QWRVcmZBbW9vaDdObHY5STFIbHRjZnAyNEJBQUFBcUhjR2RnQUFBQUR2b0UrMXh6K1VSOS9VSGJBMmloQys4b01SZXo2WXVnTUFnQTNuZ09sM0RkaHY1bDJ6eSt1QTFDMUEzU3FLVUh3M3RPWGpGdFFHUFpjNnBsNDlOWDNvNHAxcWMwOE5NZjRrL0htdkJCMU52Q0FZMkFFQUFBQzhJd003QUFBQWdMY3g1RjhmN0xsSnQrckkxQjJ3ZG9yNWp6MzIyTVVoN0pZNkJBQ0FEV0N2V1QvcDF5MDBmU1ZVc3hIQkVBUllsU0w4ckRXMm5yM3dnc0UvVDUzU0VTeHNIalJ2eDlydDM0d3huSjY2QmRaWURBTzJHWHZ6NEdlbWZIUk82aFFBQUFDQWVtWmdCd0FBQVBBMituYXIvSDE1dkN0MUI2eUZ0cncxL1AzODJ0QmxxVU1BQUZpL3RwdlYwbjNyc1BYb2JyRnBUUG5ZTTNVUFVLK0taNHBRblBmcjJ1Q3I4and2VXRkMEpQSFY1ZWNWZlJ1T2pDRnNtN29GMWxUNTgvYjg4akN3QXdBQUFIZ2JCbllBQUFBQXF6Q3NaVUZqSmNSelVuZkEyaWxtWFhmaTd2K1J1Z0lBZ1BVbnk3TDR3UmwzSHRNdmJqMjFmTnd1ZFE5UXR4WVhvWmoyNm10dFU1K2JPbmhSdUNCUDNkUGhMSnc5NUxYK0UyLy9RaVdFSDZkdWdUVVhEOTUyekkzN1B6MzF5SHRUbHdBQUFBRFVLd003QUFBQWdGV29oR0pFQ05GWEpxY2plbUw1b3JZSnFTTUFBRmgvUGpqanAzdnVOL1BPV2VWcmxnK25iZ0hxVmxHRTR0cXdOSTVaTU9uUXAxTEhkSFNQVHp6c3hwMXF0MThaWWpndWRRdXNxU0tyakN1UG8xSjNBQUFBQU5RckF6c0FBQUNBbFJqVzBsS3BoRjNHcE82QXRWQzB0WVZUZjNqcVhtK2tEZ0VBb1AwTnVIVGVscFdHaHNuVlN2WGs4akZMM1FQVXJmOXNhODNQZnFSMjJGMnBRenFUUlc4c1BxdG56KzZEeSt1N1VyZkFtb2doZkd5cmMyN2U5WGZUUHpvL2RRc0FBQUJBUFRLd0F3QUFBRmlKV096ODZSRERqcWs3WUkwVnhUOWRQMkwzbjZUT0FBQ2dmZTEwMWkxTm0yN2Y1NnhLUTNWOCtkZ25kUTlRdDU0UFJUNStRZHRkMzhscnRUeDFUR2Z6ekxTUHZiVER4TGxuWlNGZW1ib0YxbENzVnVQWThqdytkUWdBQUFCQVBUS3dBd0FBQUhpTExNdmlzZGM4TkM1MUI2eTU0dmVMbGk3Mnpvc0FBSjNNQVRQdk9XclQ3WHRQTDYvOS8vd2VOQUIvYTJsUkZMTmIyNVpOWGxnYjhsb0loNlh1NmJRZW16am9xaDBuM2o2OC9OWDQ0NmxiWUkzRU1Hekw4MjZaOFB3bFE1NUluUUlBQUFCUWJ3enNBQUFBQU41aTJQY2VHRkllZTZUdWdEV1ZGOFhJbXorMzM4dXBPd0FBYUI4SHp2cnByaUZVWjhZc0hGWVkxZ0dyVkZ6WDJscU0vblh0c0NkVGwzUVZjY255TDRadURRZVgxOTZwVzJBTlZCcENNYm84VDA4ZEFnQUFBRkJ2RE93QUFBQUEzaUxHekx2WDBlRVVJZHg4M2ZGN1hKVzZBd0NBZGJmdmpIbWJOV2JWNWhDcnB3Vi9wZ3VzMnZ5UXQ0MTg2TUpCdDZjTzZXb1dUaG55ekk0VGI2K1YxeG1wVzJDTnhIanlGcU91Yi83OWpFLzlMblVLQUFBQVFEM3hoekVBQUFBQWJ6TDhtdm43WlZubFEwWHFFRmd6aTFyejhBK3BJd0FBV0RmN25uNUZROE5PNy90Q1k5WXdNY1RRTjNVUFVMZGVLb3E4OXNqOFY3NlpYejIwTFhWTVYvWDRJNjk4dGYvN05qNmh2TzZWdWdYV1FGTmpRN2N2bGFjdk1BWUFBQUR3SmdaMkFBQUFBRytTeGNybzFBMnc1b3JhRDAvWTdUZXBLd0FBV0hzSHpMNzdvNDN2KzhDTTh2ZDJPNmR1QWVyVzhxSUlYMXYweHVLTGZ2dVZJMTVKSGRQVnJSZzM5cS9kZW5vV0svZVdqNVhVUGJEYVlqejlYV2ZkY3ZHTHM0ZThsam9GQUFBQW9GNFkyQUVBQUFEOHhmQnJIdHd4eTZxZlROMEJhNklJNGY1WEhudGxkdW9PQUFEV3pvQ3Yzck5UTmNRWk1XWkgvUGt2ZUR0dFlHV0tjSE5iVyt1b1IycURmNTA2aGYveGVQTkhmckZEYmM0L3hoalBTTjBDYTJEamJ0M0RxZVU1UFhVSUFBQUFRTDB3c0FNQUFBRDRpNWhWemltUExIVUhySUU4aHZDRk8yb0RXMU9IQUFDd1p2YWFQVy9qYnFIeHdtcU1aNWFQRGFsN2dMcTFzUHcyNnFFTERya3BkUWdyOStxcmJlUDc5cTBlWFY2M1R0MENxNjBvenNwT3YrS3IrVGRPWFo0NkJRQUFBS0FlR05nQkFBQUFsSTcvM2tOYnhHcDJZdW9PV0VOWHRCeTM2ODlTUndBQXNQcXlZUzJWL2ZmZit0VHVXZU5GNWVPN1V2Y0FkZXZWb2lnbVBmTE1FNWNad05TM0YyY1BlVzNIaVhQUExxL1hwRzZCMVdOT0JkTUFBQ0FBU1VSQlZCYmp0bHR0dE8zdzh2WXZxVk1BQUFBQTZvR0JIUUFBQU1BSzFXekZ1MFowUzUwQmErQ0ZwYSs5Tmk1MUJBQUFxMisvMmZjZXV0K0IvV2FXMTkxU3R3QjFxeTBVeFRkYjI5Nm9QVkw3MkVzaEhKcTZoOVh3Nk1SQjErNVltM3RUaU9HSTFDMnd1cklZenMyeTdMdDVuaGVwV3dBQUFBQlNNN0FEQUFBQXVyeGhMUXQ2VlVQNFF1b09XQk5GVVp6em85TVBmQ1YxQndBQTcyekFyTHUzcjJUWnRFb01SNmR1QWVwWEVjSWRiYTNGeUVkcWh6Nll1b1UxdDd3b3ptaUk4YUh5MmlOMUM2eW1YYmNhZmROSHkvT20xQ0VBQUFBQXFSbllBUUFBQUYxZUZvcFRRb2licE82QU5YREg5U1AyK0xkd2ZKNjZBd0NBdDdITHRIdDY5MjBNNTFlejdPemdIYk9CVlh1eWZIVTMrdUh4aDF5WE9vUzE5NXVMQnY5bWg0bHpMNG9oVEVuZEFxc3JpOFhvWUdBSEFBQUFZR0FIQUFBQWRHM0RXbG9xMWJETFdhazdZQTBzTC9MV00vSThMMUtIQUFDd2NsbHpjM2JBeG9lZnZFbGpuRnpFc0dYcUhxQStsUy9xL2hSRDhaVkZ5LzlyMXBPMWs1YWs3bUhkUGZIOGIyYjAzL0k5SjVmWG5WTzN3T3FKQjI5ejNvLzNldWFTajkyWHVnUUFBQUFnSlFNN0FBQUFvRXVyaEYwK1ZSN3ZTZDBCcTYrWStmMFQ5bndrZFFVQUFDdDN3T3k3RGp5ZzcrR3p5dXMrcVZ1QXVyWGk3Y2kvRTVlL01YNSs3WWpuVThmUWZ2SnZuTHE4LzhRNVg4cEN2QzExQzZ5dUdDb2p5Mk5FNmc0QUFBQ0FsQXpzQUFBQWdDNHRGbUZraUtrcllMVTkrL0lmWDVtVU9nSUFnTDgxWU9hZDIxWXJsU2xackF3UHdhc01ZQldLY0hkYmJEMTd3Zm1EZnBrNmhmWGo4WW1ENSt4WW0zTmRpUEhvMUMyd1dtTDh6THZPdVhIc2k5T1BmRFoxQ2dBQUFFQXFCbllBQUFCQWwzWGMxUThPaUpYcUFhazdZUFVWNTl6eGhZR3ZwNjRBQU9CLzdOdjg0eDVOZlRjOXI2RlNIVjArZGsvZEE5U3RwME1leGo0ODRkQ3I4and2VXNld2ZyWGxyYU1xbFlZaDViVkg2aFpZRFkyTjFleU04aHlYT2dRQUFBQWdGUU03QUFBQW9NdUtsZXFvMUEyd0JtNXZPVzYzcTFOSEFBRHczN0lzaS92UHVuTjRVOTlOcDVTUDI2YnVBZXJXRytXM1MxNzd3MHZUbnBvK2RIRzRJRS9kd3did3hLU1BQclhEeERsVFlvZ1hwVzZCMVJGalBHM3JNZi82NWVlbW5yQW9kUXNBQUFCQUNnWjJBQUFBUUpjMDlNcGZiZGZVMEhSMGlLbExZTFVzTC9MV00xTkhBQUR3M3c3NjZyMzc3ai9ycmxreFJPK0lEYXhLVVJUaHFtVngyZGhIenovODZkUXhiSGh0Ly9YY3RPcTcrNTFjWHJkUDNRS3JZWk9RYlhKU2VYNDlkUWdBQUFCQUNnWjJBQUFBUUpmVTFOQjRab2orMlFnZHhtWGZQMkhQUjFKSEFBQjBkWHRQdTJmcmJrM2g0aGppaVBLYkw5Y0JyRUx4eTdZUXpsb3cvcEI3VXBlUXpwUC9kTktTOTA2Y2MzWWx4QnRTdDhEcXlFSjJkcFkxZnlQUGE5NXFFd0FBQU9oeWZCSVpBQUFBME9WODZwL3Y2ZDJqOThaL243b0RWdE1McnkxYWZsSHFDQUNBcm16NzVubmR0dXJiTUtwN1V4eFhQdlpLM1FQVXJlZENubzkvdU8zT2Y4bHJCaXFFOE1URXdUL2FzVGIzcGhEREVhbGJZRFhzc01XWWZUOVdua2FoQUFBQVFKZGpZQWNBQUFCME9UMTY5am01UERaSzNRR3Jvd2pGdU50TzNldVBxVHNBQUxxcUEyYmZjL1RXZlJzdkxhL3ZTZDBDMUswbDViY1pZZmxMRjgrdkRYMDloRU5UOTFCUGx1ZG5oY2Jzc1BMV2xEb0Yza21seU00S0JuWUFBQUJBRjJSZ0J3QUFBSFFwV1hOek52ejl4NXlSdWdOVzB5K3VmK3o2NzRTd1crb09BSUF1WjhEc2UvYW9oakFyaTNGZzZoYWdqaFhodXVXdGJhTi9YVHZzeWRRcDFLZEh2M0w0NHp2VTVrNlBNWnlmdWdYZVVReUhiRDNteGc4OE4vWEloMUtuQUFBQUFHeElCbllBQUFCQWwvS1pYVDQ5cER4MlROMEJxNkVvMmxyUHltdTFQSFVJQUVCWGN0RDBlemN2R290SkRWazhKUlNoa3JvSHFGc1BGbTM1MmZNdlBQUW5xVU9vZjMvNnc2c1g5OWxzNDVQTDY5YXBXK0FkeEpobFo1Ym41MU9IQUFBQUFHeElCbllBQUFCQWwxS0o4Y3pVRGJDYS92WDdJL2E4TjNVRUFFQlhzV3R6UytOR20vUTdJelNHQ1RIRWpWTDNBSFhyeFNLRUN4NSs0S1Z2NTFjUGJVc2RROGZ3L09WRFg5K2hObmQ4ak9HZlU3ZkFPeWwvSDNSQzMzTmF4cjB5ZmVqTHFWc0FBQUFBTmhRRE93QUFBS0RMR05ZeWY2ZHFxSHdrZFFlc2hrWExsdWZqVWtjQUFIUVZCM3oxbnFNMjJxVGZwZVYxaDlRdFFOMWFYbjY3N1BYbGY1ejBaTzBUcjZhT29lTjVZdExkLy9MZUNRZWVFVVBZTzNVTHZJTWUzUnQ2bmxLZTAxS0hBQUFBQUd3b0JuWUFBQUJBbDFFSmxSWHZYaGRUZDhBN0tZcGk2ZzBuN3Y1czZnNEFnTTV1L3hsMzdWSnBxTXpNWWp3OGRRdFF4NHB3VTJ0UmpGb3cvcENGcVZQb3VQSzhsci8zd2ptaktwVTRMM1VMdkpNWTRqOWt3MXBtZUtkT0FBQUFvS3N3c0FNQUFBQzZoR0V0OTIxVUxacE9ETkcranJyM1RPdWkxa3RUUndBQWRHWUh6cnB0azVqMXJsVWFLbDhNL3N3VVdJVWloQVhsTVdyKytRZmZtcnFGenVHSlNZTi91bU50Ymt1SVlXanFGbmc3TVlUdHRucFBqMCtVMSt0U3R3QUFBQUJzQ1A2d0NBQUFBT2dTcW5uVFowTVdlNmZ1Z0hkUzVNVzRINTY2MXh1cE93QUFPcU9zZVY1MS83NE5wOGRLNzRubDQ2YXBlNEM2OVVvb3dzU0hsOC83ZWw2cnRhYU9vWE5adG56WmVZMk5qUjh2cjAycFcrRHR4QkRQREFaMkFBQUFRQmRoWUFjQUFBQjBlbGx6Y3piOC9jZjhRK29PZUNkRkNQOXgvWWc5L2kwY242ZE9BUURvZEQ0MDY1N0REOXlrY1ViNWU2NzNwMjRCNmxacitXdkV0L0xYOHdrUFR6NzBEeUVjbkxxSFR1aTNYem5peVIwbnpwa1ZRand2ZFF1OHZYandWdWZjdk92dnBuOTBmdW9TQUFBQWdQWE53QTRBQUFEbzlENnp5ekdEeTZOLzZnNTRCMFVzOGxGNW5oZXBRd0FBT3BQOUw3dHpoMnFvWGhvcThhalVMVUJkdTcyMXJXM2tnZ3NPTXlSaHZYdmxsYmF2OU8xYlBibThicEc2QmQ1T3BWcDhzVHkra0xvREFBQUFZSDB6c0FNQUFBQTZ2VXBjOFlrZ01YVUd2TDBpWE50eTNPNTNwODRBQU9nczlwMTYrMGJkdW5lL29CcXFYeW9mRzFQM0FQV3BDT0h4a0JmbnpCOS95QTJwVytnNlhwdzk1TFVkSjk1MllRalp0MUszd051TEo3enJyQ3ZQZTNIMmNhK2xMZ0VBQUFCWW53enNBQUFBZ0U1dDZKVy8ycTZwc2VuSTFCM3dEcGJscmN2UFR4MEJBTkFaWk1OYUtnY2MxTytVYnQxN1RDb2ZOMC9kQTlTdDEwSVJKaS83L1pMWkMyY1BXWm82aHE3bjhVZGUrNmYrNzl2NGpQSzZXK29XZUJ1OW1wbzJPckU4TDA4ZEFnQUFBTEErR2RnQkFBQUFuVnBUWStQcDVWRkozUUZ2cXlpK2Z0MkplejJST2dNQW9LTTdjTlpkQXc4NHFOL01HTUtlcVZ1QXVwVVhJWHluV0JiR3o2OGQvSHpxR0xxdS9PcWhiVHRPdkhWTUNKVmJVcmZBMjRyWkY3SXMrMXFlci9qbEV3QUFBS0J6TXJBREFBQUFPcTBqTDcrbGFlTXQzdjI1RUZPWHdOdDZ0V2hiK3VYVUVRQUFIZGtCcytmOVhTVnJ2Q1NyVkQ2VHVnV29hejl0YTJzOSs2RUxEdnRWNmhCWTRkR0pIN20xZjIzdTdUR0V3MUszd052WVpjdFJQejY0UEgrU09nUUFBQUJnZlRHd0F3QUFBRHF0amJmWTVwZ1F3K2FwTytEdEZDRjg1ZnNqOXYxRDZnNEFnSTVvMStaNXZUYnEyeml1a2pXT0toKzdwZTRCNnRaVDVhdXZNZlBISDNxdGQyQ2kzc1JRbkZkKy9NV2ZyMUNuc2l4OE1SallBUUFBQUoyWWdSMEFBQURRZWNYc2k2a1Q0QjA4OWNxeWx5OUxIUUVBME5Ga1dSYjNuM1hQaUkwM2FibzRoR0xyMUQxQTNWcFUvaG94OWRXWFhwcjIxUFNoaThPNFBIVVAvSTNIbWdmL1ovOEpjNzhYWXhpZXVnVldLY1pQYlA2bEc3Wis0YXRIUFpjNkJRQUFBR0I5TUxBREFBQUFPcVZoTFF2MnFJYXdmK29PZUR0RlhseHd4MGtEbDZUdUFBRG9TRDQwODU3OURweDk5Nnp5T2lCMUMxQzNpcUlJLzdaMFdSaTNzSGJ3TTZsajRKMjB0aTY3b0tHaDhkUGx0VEYxQzZ4Q1EyTzNodFBLYzJMcUVBQUFBSUQxd2NBT0FBQUE2SlFxSVh3K2RRTzhnd2V1Zi96NkswUFlMWFVIQUVDSHNQKzBlZHRVdWpWZEhLdlo4ZVZqVE4wRDFLMmZ0K2JoN0lmUEgvaXoxQ0d3dW43N2xTT2U3RDloN2ovR0dNNUszUUtyRk1QbnNtRXRrL0tyaDdhbFRnRUFBQUJvYndaMkFBQUFRS2N6ckdWQnIyb0l4Nlh1Z0xmVEZ0ck96MnUxUEhVSEFFQzlPM0RXejdwbldSaGQ3ZFkwcG56c21ib0hxRnZQRlVVeDdxSHhoMzQzei9NaWRReXNxY1Z0clpON1ZLdWZMYTk5VXJmQUtteTc1WGJkanlqUEg2VU9BUUFBQUdodkJuWUFBQUJBcDFQTmkyTkRGbjB5RW5XcytPbjF3L2U0S1hVRkFFQTl5N0lzN2ovN25tT3lTcGhhUG02WHVnZW9WOFhpRU9MMGZHbTRaSDd0NE5mRE9GL0hoSTdwMmNsRFh1dy9ZZTdVR01PWFU3ZkFxbVFoKzN3d3NBTUFBQUE2SVFNN0FBQUFvUE9KOGZPcEUrQnRGS0dJNTZXT0FBQ29aL3RmZHZmZUI4NitaMVo1UFNoMUMxQy9paEN1YVYwYXoxdFFHL2piMUMzUUhwYThzR1JtOXkyNmZiRzhicDI2QlZZcWhpSGJqUHp4dTUrWitiSC9TcDBDQUFBQTBKNE03QUFBQUlCT1pmZzE4L2ZLc3NvK3FUdmdiZnlnNWJoZGY1WTZBZ0NnSGcyNGRONldqWTFOazZ1eGNuSlk4U1lwQUN0Vi9LcjhNUExCc1FmUFMxMEM3ZW1aYjN6c2pmZE91RzFpRnJOdnBXNkJWYWlFeHV5VThxeWxEZ0VBQUFCb1R3WjJBQUFBUUtlU3hleTAxQTN3TnRxS3R0YnhxU01BQU9yTlRwZmYwclI1MGVlc3BtNU40NHNpOUVuZEE5U3BJcnhRRk1XRjh4OTQ2ZHY1MVVQYlV1ZkErdkNidSs3OTUvZCs2TURSNVhXSDFDMndjdkdVN05EbVNma2R0ZGJVSlFBQUFBRHR4Y0FPQUFBQTZEUSs5Yy8zOU83UmE2UGpVbmZBcWhYZi9mNEplejZTdWdJQW9KNGNOUHZlVDI2UmJUd3R4TkEvZFF0UXQ1WVZJY3hhc216eDVJVzFJYStsam9IMWFjVm9hWWNMNTlaQ0ZxNU0zUUtyMEcvcmZUNTRaSG4rTUhVSUFBQUFRSHN4c0FNQUFBQTZqZTY5Tng1ZUhyMVRkOEFxTEZ2ZUZpNUtIUUVBVUM4T25QV3pYU3ZWTURPcnhNTlN0d0IxN1liV3R1WG5QalIrMEdPcFEyQkRlV0x5M1ZkdmYrR0I0MklJdTZadWdaV0t4V25Cd0E0QUFBRG9SQXpzQUFBQWdFNGpodkQzcVJ0Z1ZZcWkrRDgvUEdHMzM2VHVBQUJJYmQ4Wjh6YnIzdERVWEttR3o1ZVBsZFE5UUowcXdzTjVubzk2Y1B3aHQ2Vk9nUTB0ejJ2NVg5N0Y3cnJVTGJCeThTT2JuWHZEdGk5ZGV0VFRxVXNBQUFBQTJvT0JIUUFBQU5BcERHdVp2MnMxVlBaTjNRR3JzTGh0YVQ0NWRRUUFRRXI3bm41RlE3Y1A3UG9QM1J1YkpwU1BmVlAzQUhYckQwVWVKczVmSHI2UjF3NXBUUjBEcVR3eCtmQWZiSC9CYmIrTU1leVR1Z1ZXb3RLVU5aeGNucE5TaHdBQUFBQzBCd003QUFBQW9GT29oc29wcVJ0Z2xZcmk4dXMvdThkenFUTUFBRkw1MEdYM0hOSDlBN3RPTDY4N3AyNEI2dGFLTWQzWDI1WXViWjVmTy96bDFER1FXcDdueGZZVGJydXdFcktiVTdmQXlzUVlQcHRselpOWHZPTmk2aFlBQUFDQWRXVmdCd0FBQUhSNFIxNStTOVBHVzJ4N3dvclA2b0E2OU5xeVJhMVRVMGNBQUtSdzBJeDdkNDZOY1hxTTJSR3BXNEM2ZGx0YmFCczVmK3loQzFLSFFEMTU4cUxEYitrL1ljNWRNY2FEVXJmQVNyeG5pM1AzUGJRODU2WU9BUUFBQUZoWEJuWUFBQUJBaDdmUmx0dCtNb1M0YWVvT1dMbGk5ZzlQM2V1bDFCVUFBQnZTWHJQbmJkeXIwbmhoMWhqUExCOGJVdmNBZGFvb0hpcy9uSHYvMkVOdVNKMEM5U29QK1lXVlVQbEo2ZzVZbVN6R3p3VURPd0FBQUtBVE1MQURBQUFBT3J3WTRpbXBHMkFWL3Jnay9HbG02Z2dBZ0EwbEc5WlNPZWpBZnAvdlZXbHFMaDgzUzkwRDFLMC9Ga1Z4VWI3MHBjdm4xNFl1U3gwRDllekppejd5Ny8xcmMrYkdFQWVsYm9HM2lpRjhxdTg1TFp1OE1uM295NmxiQUFBQUFOYUZnUjBBQUFEUW9SMTM5UU4vRnlzTmg2WHVnSlVwUXBqMW8rRUh2cEs2QXdCZ1F6aG85cjJISHZTaGZqTkRpTHVsYmdIcVZsdjVPdW5iYnl4WmR1Rmp0Y0V2cEk2QmppTFA0NFdWTEJqWVVZKzY5YXoyT0w0OEwwc2RBZ0FBQUxBdURPd0FBQUNBRGkxV3FwOHRqeXgxQjZ6RXEvbXlmRmJxQ0FDQTllM0RzKzdldnFobTA3SktQRHAxQzFEWDVyWG14ZG56eHcyOFAzVUlkRFJQVGhyMHMvNjFPVGZHRUk5TTNRSi9LNTRTRE93QUFBQ0FEczdBRGdBQUFPaXdzdWJtYlBqN2p6azVkUWVzVkZITXZPNmszVjlOblFFQXNMN3NmL2t0ZlJxS2pjYUhhdVdzR0VKVDZoNmdUaFhoTjBVb3h0dy9kbUJMNmhUb3lJb1FKcFYvdnpXd294N3QzbS8wVFhzL08rMkkvMHdkQWdBQUFMQzJET3dBQUFDQUR1dlluWTgrcER6ZW5ib0RWdUtWUHk1cW5aMDZBZ0JnZlZqeGhTNE8ydlR3a3h2Q3hwTkRERnVtN2dIcVV4SEM2K1dIaTE5YldzeDRzalp3U2VvZTZPaWVhQjc4OHgxcWMyNE5JWDRrZFF2OGpTeWVWSDQwc0FNQUFBQTZMQU03QUFBQW9PT3FWRTVLblFBclV4Umh4bTJuN3ZYSDFCMEFBTzN0Z05sM0hYamdwaCtaVlY3M1NkMEMxSzN5SlZIeDNXVkxsbzliVUJ2MFhPb1k2RXhhOCtLaWFtWmdSLzJKSVF6UGhyV2NtMTg5ZEZucUZnQUFBSUMxWVdBSEFBQUFkRWlmK3VkN2V2Zm92ZkhScVR0Z0pWNTliZEh5eTFKSEFBQzBwNE5tM0x0ZDFoQ25WQ3ZWWWVIUG4wTU44TGVLRUg0V2kvenMrOGNlL1BQVUxkQVovV2JTNGZmMHI4MlpHME1jbExvRjNtS3p6Zit1KzVIbGVYM3FFQUFBQUlDMVlXQUhBQUFBZEVqZCt2UVpHb3JRTTNVSC9JMGlmTlc3MXdFQW5jV2UwK2YwN04zVWEweldHRWVYajkxVDl3QjE2NWtpRCtjOU9QN2dxL0k4TDFMSFFHZFcvbjl0VXN5Q2dSMTFweEt5azRLQkhRQUFBTkJCR2RnQkFBQUFIVkwyMzUrd0FmWG10ZGVYTEpxZE9nSUFZRjFsV1JZUHV1eWU0WDI2OWJxa0tPSTJxWHVBdXJXNEtJcHA4ZVZsVSsrZk9uaFJHSmVuN29GTzc0bEpnMys2dzRRNS94NWlQRGgxQzd6RkVWdVArY0htejAzOTVBdXBRd0FBQUFEV2xJRWRBQUFBME9FY2M5VkQyemMyWmg5TzNRRi9vd2hmdi9seis3MmNPZ01BWUYwTS9PcGRBdzY2N0o1Wk1ZVDlRb2lwYzRENlZJU2l1SFpabm85NStQeERua29kQTEzUXBQTGJ3YWtqNEMwYVltZzhyanhucFE0QkFBQUFXRk1HZGdBQUFFQ0gwOUFZVHd3KzA1ZjZzK2lOWlcwelVrY0FBS3l0RDMzdG5xMWp5QzZPbGVxSTZQZmJ3S3I5WjJncnp2N1YrUVB2U2gwQ1hkVmpGdzIrWTRmYTNMdkw2NEdwVytCL2lmR2tZR0FIQUFBQWRFQUdkZ0FBQUVDSGttVlpISDd0UXlOU2Q4QmJGVVg0eG8wbjcvRmk2ZzRBZ0RXMWZmTzhidHR1MmpRcWk5bTQ4ckZYNmg2Z2JqMWZmaHYvd0pLZmZDZXYxZkxVTWREVjVVVzRLSXZoMXRRZDhCWjdiSG51amJzL2YrbVJENlFPQVFBQUFGZ1RCbllBQUFCQWh6TDhtb2RXZkdYdTdWTjN3RnNzQ2NYeTZha2pBQURXMU1ETDd4MjY3V1pOVTh2cmUxSzNBSFZyYVJHSzJXOHNYang1WVczSWF5RjhPSFVQVUhyaW9rRzM3VkNiKy9QeU9pQjFDN3haVnNsT0tBOERPd0FBQUtCRE1iQURBQUFBT3BaWW5GQitTRjBCLzB0UmhQL2JjdnhldjB2ZEFRQ3d1Z1pjT20vTGJ0MmJ2aGRpSEppNkJhaGpSZmpCOGxDTW5uL2V3TWRUcHdCL0s4L3ppN01zKzBIcURuaXpHTUx3YkZqTDJQenFvVzJwV3dBQUFBQldsNEVkQUFBQTBHRU1hMW5RV0kzeG1OUWQ4QmF0TVM2ZG1qb0NBR0JOTkhacjJLRThqT3VBVlptZnQrVWo3eDkzOE8ycFE0QlYrODNrSVRlODk4SmJGNFFRZDBuZEFtL1NiNHR0dXg5Y252NGVBZ0FBQUhRWUJuWUFBQUJBaDFFdDhpTkN6RFpKM1FGdlZvVGltcGJoK3p5WnVnTUFBS0FkdkZTK3lLbmRmOThMMy9UT1ExRC84and2ZHJod3p0U1FoZStrYm9FM2k1WHNoR0JnQndBQUFIUWdCbllBQUFCQWgxRms4ZmlZT2dMK3R5SXY0cFRVRVFBQUFPdG9lU2lLZjJ3TGl5WStjTjRScjZTT0FWYmZFeS8rOXNydHQzalBwUEs2YmVvVytLc1l3dEhaT1MxZnpLY1BYWnk2QlFBQUFHQjFHTmdCQUFBQUhjTFIvL2VCamJ2M2F2aFk2ZzU0aXg5ZmQ5eXU4MU5IQUFBQXJJT2IyL0ppMUFOakIvNDZkUWl3NXZKdm5McDgrOXJjR1ZrSU0xTzN3SnYwMmJMYS9hanl2RHAxQ0FBQUFNRHFNTEFEQUFBQU9vVHV2YXBEeTZOYjZnNTRzOWE4emJ2WEFRQUFIZFhDdHJ4dDFBTmpEN2twZFFpd2JwWXNMcTdvMFQxZVVGNDNUZDBDZnhWRGRrSXdzQU1BQUFBNkNBTTdBQUFBb0VNb1FqdytwbzZBLyszdTY0L2Y0NTdVRVFBQUFHdWtDSzhXTVV4NjRNbUZsNjE0NTZ2VU9jQzZlMjdxNEVYOWEzTy9WbDRucEc2Qk4vbEl2N05hM3ZYczdLRXZwZzRCQUFBQWVDY0dkZ0FBQUVEZEczcmwvRzJhbWlvZlR0MEJiNVlYWVZycUJnQUFnRFhRRm9wd3hhTGlqUWtMenh2eVlnaGVaa05uc3VTTkpaZDE2OUh0blBMYU0zVUwvRVZEMGRUam1QTDhldW9RQUFBQWdIZGlZQWNBQUFEVXZhYW1PS3c4c3RRZDhEK0tYMS8vMlBVL0NtSFgxQ0VBQUFDcm9iaWpyYTF0NUFQakRuMHdkUW13Zmp3ejdXTXY5YS9OL1haNS9WTHFGdmlyR09PeHdjQU9BQUFBNkFBTTdBQUFBSUFPSURzMmRRRzhXWkhINlhtdGxxZnVBQUFBZUFkUDVxRnQ5Sy9HSEhKZDZoQmcvU3Z5NVROaTF2Q0Y4dHFRdWdYKzRzRE56cjFoMjVjdVBlcnAxQ0VBQUFBQWI4ZkFEZ0FBQUtocncxb1c5Sy9Hc0UvcURuaVQzeTErNWRudmV2YzZBQUNnanYycEtNS1VWeGNYTTU2c0hiSWtkUXl3WVR3eDZhTlB2WGZDM0d0aURNZW5ib0cveUpwaTVUUGxPVDExQ0FBQUFNRGJNYkFEQUFBQTZsbzFGc2VHRUZObndQOVhGTVZsTjU0eFpHbnFEZ0FBZ0pYSXl4Y3QzMW0yT0l5Zlh4djRmT29ZWU1Ocmk4WE1hb2dHZHRTTklzdU9EUVoyQUFBQVFKMHpzQU1BQUFEcVdnemgyQ0oxQlB5UFJZdVd2UEhOMUJFQUFBQnZWWVRpN2hpS3MvOXp6TUJmcG00QjB2bHQ4K0QvN0YrYk82KzhEa3pkQWl2RUVQYlo4cHdmOVg5KytzY2ZUOTBDQUFBQXNDb0dkZ0FBQUVEZEd0WXlmOWVHV0hsLzZnNzRIOFYzYnY3Y2ZpK25yZ0FBQVBqL2l2QjBFWXF4OTQ4OStLbzh6MzJOR2lBVWVUNHpacG1CSFhXalVxMnVlQmU3TDZmdUFBQUFBRmdWQXpzQUFBQ2dialdFeXJHcEcrQk44dkxmczFOSEFBQUEvTVVib1NndWVlbjNMMHg3YXZyUXhXRk1ucm9IcUJPL21YenZqN2EvOE1BVjd4YldQM1VMckZDRVlHQUhBQUFBMURVRE93QUFBS0F1WlZrV2o3djJJUU03NmtaUmhCKzNITGZIWTZrN0FBQ0FMcThvWDU5YzFkb2F4ajU0L29lZlRoMEQxSjg4citYdnJjMmRIVU80TEhVTHJGRCtYSHovVm1OK3ROdnZwbjc4d2RRdEFBQUFBQ3RqWUFjQUFBRFVwV092bmI5M2VXeWZ1Z1ArcXNqYlpxUnVBQUFBdXJ4ZkZtMXRaOTgzOXVDN1U0Y0E5VzNSSDE3OVRxOU5OcnFvdlBaTjNRSXJ4Rmc5cGp3TTdBQUFBSUM2WkdBSEFBQUExS1dzaUVOWGZHbGpxQWRGRWU3Ny9nbDd6RXZkQVFBQWRGblBGWGsrL3Y0bC8vNHZlYTJXcDQ0QjZ0L3psdzk5dmYrRnQxMFJZaHlUdWdWV2lLRllNYkM3TUhVSEFBQUF3TW9ZMkFFQUFBQjFxWWhocUgwZGRhTW9acVZPQUFBQXVxUWxSUkZtTEYrY1h6eS9OdkQxRUFhbTdnRTZrR1hMODhzYUd5c2p5MnRENmhZSUllNjAxVGszNy9xNzZSK2RuN29FQUFBQTRLME03QUFBQUlDNmMwTExRM3ZIbUwwM2RRZjhXUkdlWC96eWM5ZUVzRnZxRWdBQW9HdTVibm0rYlBRRDV4MzJaT29Rb0dQNnJ5bERudWsvNGJhV0VPTHcxQzJ3UXF6OCtWM3NET3dBQUFDQXVtTmdCd0FBQU5TZElrVHZYa2ZkS0VMNDVvMW5ERm1hdWdNQUFPZ3lIbXpMdzhoZm5mZWhPMUtIQUoxQWF6RXpWQTNzcUE4eHhxSGxNU0YxQndBQUFNQmJHZGdCQUFBQWRlY3ZuMmdCOVdCWnlKZC9NM1VFQUFEUUpid1lRbkhCZmI5ODRkdjUxVVBiVXNjQW5jUGpYL25JTC9wUG1ITnZlZDAvZFF1VTNyZjFtQnMvOE56VUl4OUtIUUlBQUFEd1pnWjJBQUFBUUYwNS9uc1A3aGticXYxVGQ4Qi9LNjV0T1g2djM2V3VBQUFBT3JYbFJSRXVLOTdJSjkxWEcvaHE2aGlnRXlyQzEwSTBzS05PeEhoTStkSEFEZ0FBQUtnckJuWUFBQUJBWFlrTmxXTlNOOEJmdFJYRlYxTTNBQUFBbmRwTnJVWHJxUHRISDdJd2RRalFlVDM1NkIrdjNYNm5QdE5EaUZ1a2JvSHk1K0hROGtNdGRRVUFBQURBbXhuWUFRQUFBUFZtYU9vQStJdWZYVGQ4OS85SUhRRUFBSFErUlNnVzVIays2bGRqRHI0MWRRdlErZVZYRDEzMjNnbHovazhNWVh6cUZpaC9IdTdTYi9RTnV6dzc3YWdGcVZzQUFBQUEvc3JBRGdBQUFLZ2J3Njk1OEFPVlNuV0gxQjN3MzRxdnBTNEFBQUE2blZlS29wajRxeWNXL21QK2pWT1hwNDRCdW81bFJmSE5waGpQQ3o1WGlIcVFOUnhkZmpTd0F3QUFBT3FHZjJnR0FBQUExSTFLcGZxcDFBM3daMFY0OFkwL1BIZHRDTHVsTGdFQUFEcUgxdkoxeHJjV3R5MmY4UERZUS84UXdvZFQ5d0Jkek5PVERuKzYvNFZ6ZmhoaStIVHFGaWl0K09mQVgwNGRBUUFBQVBCWEJuWUFBQUJBM1NoQzhha1lZdW9NQ09WUHcyL2ZlTWFRcGFrekFBQ0F6cUM0dlRVUEkrOGY4K0g1cVV1QXJpMHZpcTlsTVJyWVVRLzI3RGY2NXUyZW5mYlJwMUtIQUFBQUFLeGdZQWNBQUFEVWhXRXRENzZuSVZiL0gzdDNBcVZYV2RoLy9IbnVPMHNtQ1dGTlFCYUJCSGNGMFFBQ2FpaVFoYkRVSlMwVnNmcTNnbUJ0WlZjcklhTGlnb0xTVWdXU0lGUmJSSU1vcmlTUWlpZ0VNZ2xXeElyS0VsbEZDVnNDV1didTg3OFRMWW9ReURMelBqUHYvWHpzekwydlIrVjdlbktTekQzM2QrL3V1VHVnMHR1N3Nqdy9kd1FBQURDMHBSUituVUk0Y2RISnI3OGlkd3RBbnpzL1B1VUhZMCs5OHBicTlHVzVXNmk5R0dMcWU0dmQ1M0tIQUFBQUFQUXhzQU1BQUFBR2hmYlk5b2JjRGZCSDMvMzYyM2U3TTNjRUFBQXdaRDJhUWpyanNic2ZQK2ZXYzd3Wkd4Zzh5ckpNdTV3Mjk5OURpSi9QM1FJcFJBTTdBQUFBWU5Bd3NBTUFBQUFHaXpmbERvQStaUm0ra0xzQkFBQVlrc3JxNjZJVm9melF6U2ROdUQ5M0RNQXplWFRWaWkrUDZ1ajZaSFU2S25jTDlSWkQySGZiVTc0eDV0NHozL0JBN2hZQUFBQUFBenNBQUFBZ3U3ZCs1V2RieC9aaW45d2RVTG50OGw5OS9jb1FYcEc3QXdBQUdFcFMrR0ZQbVk2NzZmMnZ2eWwzQ3NDemVlQ1RoejIyeTJuekxxNU8veWwzQzdYWFNLbnpzT280SzNjSUFBQUFnSUVkQUFBQWtGMXNLLzY2T2hTNU95Q2tOTE9jTWFQTW5RRUFBQXdOS1lRbHNTeFBXZlNCL2I1V2xtWEszUU93TGxhWDRZTDJ3c0NPL0dKTWJ3d0dkZ0FBQU1BZ1lHQUhBQUFBREFaL25Uc0FLcXRXeFNjdXloMEJBQUFNZmltRTVUR0VNMzkzMy8yZlhuTFd0Q2ZDS1o3VEFRd2RTejQyOFdlN25EYnYrdXAwNzl3dDFGc004WUF4NzdwaWt3ZG1IZlpZN2hZQUFBQ2czZ3pzQUFBQWdLd09uL1B6a2UweDdKKzdBMEpJMy96RzMrMzEyOXdWQUFEQW9KWlNDUC9aazNvLytKT1RKOXlkT3daZ1E1VWh6U3hDTkxBanQ4NzJ6ZG9uVmNmTGNvY0FBQUFBOVdaZ0J3QUFBR1RWSHRPa0VPS3czQjBReW5oKzdnUUFBR0JRdXlHbDN1TzZUNTZ3SUhjSXdNWmFDeENOQmdBQUlBQkpSRUZVc1NKK2RmaXc4Tm5xZE5QY0xkUmJLdEpod2NBT0FBQUF5TXpBRGdBQUFNanQwTndCVVBuVm5DTjNteCtPS0hOM0FBQUFnMHdLNmQ2VTBnZHZPbVcvTDVWbG1YTDNBUFNIZTgrY3VIeVgwK2I5VjNWNmJPNFc2aTJHT0xVNGZFNmp2SFJhYis0V0FBQUFvTDRNN0FBQUFJQnNEcDh6cDlFZVgzcHc3ZzVJS2N4MG95d0FBUEFYVnFTVXpsNjV2UHpFelRNbUxBc25lU0FIMEZyS250NlpSVnZEd0k3Y3RucmU5c1AzcVk3WDVnNEJBQUFBNnN2QURnQUFBTWltS0YveW10QUlvM04zVUh1cnk5NTBjZTRJQUFCZzhFZ2hmTFhzNlgzLzR2ZFB1RE4zQzhCQXVmM2pVMjdhNWJTNTNTSEU4YmxicUxmVWlJY0ZBenNBQUFBZ0l3TTdBQUFBSUp2aUR6ZE9RRzdmdXV6SVhSL0lIUUVBQUF3S04vV21jUHlpazE1N1RlNFFnR1pJS2M2TU1SallrVlVNNmREcWNITHVEZ0FBQUtDK0RPd0FBQUNBYkdJSWgrWnVnSlI2WitkdUFBQUFja3NQbEdXYXZyajdnZG5scGRONmM5Y0FOTXRqcTUrNFpGUkgxMmVxMDAxeXQxQm44VVZqanIvaVJROTg5ckJiYzVjQUFBQUE5V1JnQndBQUFHUng1Q1UvZVVIbzZIaEo3ZzVxNys3THZ2SHJLOE5iWHBtN0F3QUF5Q0NGc0NxRzhLK3BkOVhIdWs4NTRKSGNQUUROOXNBbkQzdHMzR256dmxMOVhuaFU3aGJxcmIzUjF2Y3dOZ003QUFBQUlBc0RPd0FBQUNDTDFORitjTXdkUWUybGtDNzJkZ29BQUtpcEZLNG9RenBwMFVtdisxWHVGSUNzVXBvVllqU3dJNnRVaEVPcXcyZHlkd0FBQUFEMVpHQUhBQUFBWkJLbjVpNmc5bEpJcXk3TUhRRUFBRFJidWlXbGNNTENrMTQzTjNjSndHQncyMGNuM2JqTDlIay9Eekc4TkhjTDlSVkQzR2ZMWStacyt1QjUwN3hSRmdBQUFHZzZBenNBQUFDZzZRNmY4L09SN1RHOXZ1KzJDY2pvdjcvMmx2RzM1NDRBQUFDYVpta0s0ZlJGeThyUGx6TW05T1NPQVJoTVVpZ3ZEcUg0Vk80T2FxMjljK1R3U2RYeGE3bERBQUFBZ1BveHNBTUFBQUNhcmkyVkI0WllkT2J1b043S01sMlV1d0VBQUdpS25wVFM1MWNzZStMMG0yZE1XcG83Qm1BdzZsMjk4c3VOanE2UFY2ZU4zQzNVV0JHbkJnTTdBQUFBSUFNRE93QUFBS0RwWWl5bTVtNmc5aDViVm9hdjU0NEFBQUFHVmtwaGJobkQ4WXRPZk4zUGM3Y0FER1ozZnZLd2U4ZE5uemMzeEhCUTdoYnFLNFl3cFNoT0w4cHlScG03QlFBQUFLZ1hBenNBQUFDZ3FZcWlpRWQ4N1dkdTFDRzNPZDgvY3RmbHVTTUFBSUFCODZ2ZTNuVFNvcE5mZDBYdUVJQ2hJMTBjUW5UZGpweTIyZXI0UFY5VkhidHpod0FBQUFEMVltQUhBQUFBTk5YaFg3bDUxK3F3ZmU0TzZxMHN3MFc1R3dBQWdBSHhTQ3JUeDFZcy8rMi8zanhqMnFyY01RQkRTYnJudm0vRzdiZDlxRHJkUEhjTDlkVW8wdFJnWUFjQUFBQTBtWUVkQUFBQTBGUkZvNWdhUXNxZFFiM2QvdlVqZDdzMkhGSG03Z0FBQVBwUGJ3cHA5dXEwWXZwTkowMThJSGNNd0ZCMCs0VnZYekYyK3R4TFk0ekg1RzZoeG1Mc0c5aDlKSGNHQUFBQVVDOEdkZ0FBQUVCVHhSQ201bTZnN3RKL2xHVnA1UWtBQUswaWhXdEM2ajN1eHBNbS9DUjNDc0RRVjE0Y1FzUEFqbXhpQ0h0cytyNDVveDg1WjlydmNyY0FBQUFBOVdGZ0J3QUFBRFRONFhNV2I5b2V1MTZUdTROYVN5dDd3bi9ramdBQUFQckZIU21FVTI0ODhiVnpjb2NBdElyYlB6cGx3YmpUNXQxYW5iNG9kd3UxVlF6djZKcFVIZjh6ZHdnQUFBQlFId1oyQUFBQVFOTzB4ODREZ3VzUjVQWGpieDY1NngyNUl3QUFnSTJ5TElUMGlkODkxbnYyN1RNbXJNZ2RBOUJxVWdvWHhSZytrYnVEK29veEd0Z0JBQUFBVGVXR05nQUFBS0NKaXNtNUM2aTVNcmt4QndBQWhxNVUvZXRMUGVVVEgxeDA4b0gzNW80QmFGVTlxM3UvM043Uk9LTTZMWEszVUZkeFVsRVVzU3pMbExzRUFBQUFxQWNET3dBQUFLQ1pKdVVPb05aVzlmYXUvRnJ1Q0FBQVlJTXNLRk02YnVHSnI3MGhkd2hBcS92Tko2ZmNQZmEwZVQrTUlleVh1NFhhMm1iTWNkL2VyVHIrSkhjSUFBQUFVQThHZGdBQUFFQlRIRDduNWhlMXg3YWRjbmRRWitsN2w3MXRqd2R6VndBQUFPdmw3aktGOXk4NitYV1hlSXNOUVBQRUZDNEowY0NPZklwRzdIdFltNEVkQUFBQTBCUUdkZ0FBQUVCVE5HTGI1TndOMUZ0WnhpL25iZ0FBQU5iWkV5bUVUNjlPajU5NTA0a1RsNGNUeTl3OUFMWFM4M2lhMHpZaS9sdDEycEc3aFhwS01mUmRUejR6ZHdjQUFBQlFEd1oyQUFBQVFGUEVrQ2IxZllkTUhsbTZldW0zYzBjQUFBRFBLVlgvOTdYZXNQcVU3aFArYWtudUdJQzZXbkxXcEtYanBzKzdzam85TkhjTDlSUkQySGZiVTc0ODR0NHpqMXlldXdVQUFBQm9mUVoyQUFBQXdJQTcrTnp2ZDI3K3ZCMzN5OTFCZmFVUUxwdi85Z2tyY25jQUFBRFBhbEVad25FTFQzanRqM0tIQU5CM1BhVzhKSWJDd0k1Y09rUFlZci9xK0ozY0lRQUFBRURyTTdBREFBQUFCdHhtMnp4LzMrb3dJbmNIOVZXRzhpdTVHd0FBZ0xXNnYwemhROTJQWFhWUk9XTkdtVHNHZ0Q5WXNiSzRvcXN6TFFzaGpzemRRajJsRUNjRkF6c0FBQUNnQ1F6c0FBQUFnQUVYWXp3d2R3TzE5dHVIYm4zNHYzTkhBQUFBVDdPeStqcm5vVWNmTytQV0dWTWVEV0hmM0QwQS9KbDd6NXk0Zk55cDg2NElNUnlSdTRWNmlpRzRyZ3dBQUFBMGhZRWRBQUFBMEF3SDVBNmd2bElLYytiUG1OQ1R1d01BQUhpS2IvU3M2am01Ky8wVGZwMDdCSUMxSzBQNVgwVW9ET3pJNVNWai92bUtiUi80MThQdXpSMENBQUFBdERZRE93QUFBR0JBSFhuSnp6WVBIWTFYNSs2Z3ZzcFlmaVYzQXdBQThLU2JRMGpITHpqK3RWZm5EZ0hndVMzNS9XL203ang2cHdlcjB5MXp0MUJMc2VoczczdDQyNWR5aHdBQUFBQ3R6Y0FPQUFBQUdGQmxlOXl2Q0tHUnU0UGErczNsUjd6eXgrSHZ5dHdkQUFCUWF5bUUzNGN5ekZpNHJPZUMwaHVtQVlhTThyeWpWbytkUHZkck1jUmpjcmRRVDBVTUJuWUFBQURBZ0RPd0F3QUFBQVpVRVlvRGNqZFFYeW1FUzh1eVRMazdBQUNneGxaWGZ5SC93b3BWNGNQLzgvNTlIOG9kQThENml5RmVVaDBNN01qRjlXVUFBQUJnd0JuWUFRQUFBQU1yaGdOekoxQmZzYWZucTdrYkFBQ2d4cTdzVFQzSExUeGh3aTl5aHdDdzRlNDQ0N29mN2Z5aGZlNnZUcmZKM1VJdGJUL201RysvK0lGUEgrTHZFd0FBQU1DQU1iQURBQUFBQnN5MC83cDUrMkdkYlMvSzNVRnQzVEhuNzErMUtCeFo1dTRBQUlCNldoMU9YSGlLY1IzQVVGZVdNOHB4MCtkOXZUcDlUKzRXNnFrdHhiNjMyUGs3QlFBQUFEQmdET3dBQUFDQUFkUFozamdnZHdQMWxVS1lVNVpseXQwQkFBQUFNTlNWdmVHeW9tRmdSeVl4SGxoOS8vZmNHUUFBQUVEck1yQURBQUFBQmt3c2dvRWQyZlNtM2ptNUd3QUFBQUJhd1pMYkhybG01eGR1K3J2cWRIVHVGbW9vaGduRjRYTWE1YVhUZW5PbkFBQUFBSzNKd0E0QUFBQVlRSEcvM0FYVTFwSnZ2SFgzaGVFdFplNE9BQUFBZ0NHdmI5ZzBkdnE4eTJNSVIrZHVvWlkySDczZHNOMnE0K0xjSVFBQUFFQnJNckFEQUFBQUJzUVJsOTR5cm1ncmRzamRRVjJsT1dWWnB0d1ZBQUFBQUswaTl2WmVGaG9OQXp1eUtOcldQTXpOd0E0QUFBQVlFQVoyQUFBQXdJQW9Hc1YrdVJ1b3NaNzB0ZHdKQUFBQUFLM2tqcVYzL2ZmT28zZDZzRHJkTW5jTGRiUm1ZSGQyN2dvQUFBQ2dOUm5ZQVFBQUFBTWloYlJmRERGM0J2VjA5NXkvZitXTjRjZ3lkd2NBQUFCQXl5alBPMnIxdU9uenZsbWR2ak4zQy9VVFEzaGRjZmljUm5ucHRON2NMUUFBQUVEck1iQURBQUFBQmtTTWE1NG9ERTJYUXZoR1daWXBkd2NBQUFCQXF5bkwzc3VLb21GZ1J3NmJiZlg4NGErc2pvdHlod0FBQUFDdHg4QU9BQUFBNkhlSHovbjVMdTB4YnArN2czb3FRM2w1N2dZQUFBQ0FWclRrMTh1dTJ2bUZtejVjblc2V3U0WDZhWVMwWHpDd0F3QUFBQWFBZ1IwQUFBRFE3OXBEbkpDN2dkcDY4S0ZiSC9waDdnZ0FBQUNBVmxSZU9tM1Z1T2x6dnhWQ2ZGdnVGbXBwditycnJOd1JBQUFBUU9zeHNBTUFBQUQ2WFFwcHZ4aGk3Z3pxS0lWdnpaOHhvU2QzQmdBQUFFQ3JLa1A0WmhHQ2dSMU5GMk44WFhING5FWjU2YlRlM0MwQUFBQkFhekd3QXdBQUFQcGRqTjVnUng1bG1TN1AzUUFBQUFEUXlwNTQ2TkVyUjJ5KzZZcnFkRmp1Rm1wbjA5SGJEZHV0T2k3T0hRSUFBQUMwRmdNN0FBQUFvRjhkY2VuLzdGUzBkZXlRdTROYVdyYTBaK25jM0JFQUFBQUFyZXorYzZjdEd6ZDk3dndRNHRUY0xkUlAwWWl2Q3daMkFBQUFRRDh6c0FNQUFBRDZWU3c2WHB1N2dkcWFPLy90RTFia2pnQUFBQUJvZVdXOEloVEJ3STZtaXpIMERlek95ZDBCQUFBQXRCWURPd0FBQUtCZnhXTE5EUTdRZENtRmIrVnVBQUFBQUtpRG5tTFZ0OXRDUjZwT1krNFc2aVdsNkFGdkFBQUFRTDh6c0FNQUFBRDZteHNjeUtIMzhaVTkzOGtkQVFBQUFGQUhTejU2OEQzalRwM1hIV0xZSTNjTDlSSmoySHJyazc3eHd0OSs1ZzIvek4wQ0FBQUF0QTRET3dBQUFLRGZ2UFVyaTdlSzdWMHZ5ZDFCL2FRUUZuem5IYS84WGU0T0FBQUFnTnFJNFlycXU0RWRUZGVJN1gwUGVUT3dBd0FBQVBxTmdSMEFBQURRYjhyMnJuMGJmYmZXUUpQRmtLN0kzUUFBQUFCUUo2dFRlVVY3TEQ2YXU0TWFpdUYxMWZjTGMyY0FBQUFBcmNQQURnQUFBT2czUlZoell3TTBYVzlQejdkeU53QUFBQURVeVc4K052bW40NmJQdTZNNjNUbDNDM1VUWDV1N0FBQUFBR2d0Qm5ZQUFBQkFmM0pqQXpuOCtySWpkLy9mM0JFQUFBQUFkWk5TdWlMRytMN2NIZFRPTGx1ZmNQbnpmbnYyRysvTEhRSUFBQUMwQmdNN0FBQUFvRi84OWN6Rnd6ZlpvdXRWdVR1b254VENkM0kzQUFBQUFOUlJLdU1Wc1JFTTdHaTYyT2pZdHpyTXlkMEJBQUFBdEFZRE93QUFBS0JmRE4rMGZYeDFhTS9kUWYzRXN2ZTd1UnNBQUFBQTZtakowanV2M1huMFRvOVdwNk55dDFBdlJReDdCd003QUFBQW9KOFkyQUVBQUFEOW90Rm83SjI3Z1ZwYXRuenBmZGVFc0Z2dURnQUFBSURhS2M4N2F2VzQ2WE92RGlHK01YY0xkUk5kandZQUFBRDZqWUVkQUFBQTBFL2MwRUFXVjMvbnZWTlc1bzRBQUFBQXFLLzQvZXFiZ1IzTjlxcmlmZWQybHVlODE3VkJBQUFBWUtNWjJBRUFBQUQ5eGNDT3Brc3BmRGQzQXdBQUFFQ2RyZXhaK2YzT3RzN2NHZFJQNTVqMnNhK3VqdGZsRGdFQUFBQ0dQZ003QUFBQVlLTWRjZWt0NDRxMllrenVEbW9uVlF6c0FBQUFBREs2K3hPSC9HYmM5SG0zVktjdnk5MUN2Y1NZK2g3NlptQUhBQUFBYkRRRE93QUFBR0NqTlJwaG41UTdnanE2ZWM0UnI3Zzdkd1FBQUFCQTdhWDAvUkNqZ1IxTkZXUFlPM2NEQUFBQTBCb003QUFBQUlDTmxvcTRkN0N3by9tK256c0FBQUFBZ0JES1VINnZDSTBUYzNkUU45SEFEZ0FBQU9nWEJuWUFBQURBUm9zaDdtMWZSOU9WYVc3dUJBQUFBQUJDV1BKWStOSE9vOUt5RU9MSTNDM1V5clpibm56NWpnOSsrbzFMY29jQUFBQUFRNXVCSFFBQUFMQlJwbno1cHlOR0QyOS9SZTRPYW1mNThxWDMvQ2dFdi9RQUFBQUFjaXZQbWJKeTdLbHo1NGNZRHN2ZFFyMTBwbzdYVkFjRE93QUFBR0NqR05nQkFBQUFHMldMcnZaWFZZZEc3ZzdxSnYzZ08rK2RzakozQlFBQUFBQi9sTUwzRGV4b3VpTHNXWDIvTkhjR0FBQUFNTFFaMkFFQUFBQWJwUkhXM01BQVRSYXZ6RjBBQUFBQXdKK2sxZkg3c1ROM0JmVVRYWjhHQUFBQU5wcUJIUUFBQUxCeFl0cXorcGE3Z3BwWjNadm01bTRBQUFBQTRFL3VPSFBpSFdPbnovdGxkZnJDM0MzVXlxdUsvVTl2SytmUDZNa2RBZ0FBQUF4ZEJuWUFBQURBUmtraDdtbGVSNVBkZWZsYlgzRnI3Z2dBQUFBQW5pcUZjRlUwc0tPNWhvOTUxZmlYVmNmL3lSMENBQUFBREYwR2RnQUFBTUFHZS9PWGZ6cG0rUEQyblhKM1VEZnA2dHdGQUFBQUFEeURzcnc2Rk1WN2NtZFFMN0VJZXdZRE93QUFBR0FqR05nQkFBQUFHMng0VjJQUDNBM1VVSm11eXAwQUFBQUF3Tk9WSytJUEdzTkRXWjBXdVZ1b2tiUm1ZRGN6ZHdZQUFBQXdkQm5ZQVFBQUFCc3N4V0xQbUR1Q3VrbTl2V0YrN2dnQUFBQUFubTdKV1pPV2pwMCs3NmJxOU5XNVc2aVBHS01Id1FFQUFBQWJ4Y0FPQUFBQTJHQXhoVDJDaFIzTmRmTmxSKzc2UU80SUFBQUFBTlltWFIxQ05MQ2ptVjYyN1NsZkhuSHZtVWN1engwQ0FBQUFERTBHZGdBQUFNQ0dpMkdQM0FuVVMwcnBxdHdOQUFBQUFLeGQyVnRlWFRRYXArVHVvRllhWmRwczkrcjRvOXdoQUFBQXdOQmtZQWNBQUFCc2tMZjkxMDA3aG1IRHRzemRRYzJrZUhYdUJBQUFBQURXcm1kcHo0ODZSamRXVnFlZHVWdW9qL2lIdHlZYTJBRUFBQUFieE1BT0FBQUEyQ0NwcytQVk1YY0VkYlA2d1ljZi9HSHVDQUFBQUFEVzd1N3pEbmw4N1BSNTExZW4rK1Z1b1Q1aWpLL0szUUFBQUFBTVhRWjJBQUFBd0FaeHd3SVpkTTgvZHNLeTNCRUFBQUFBUExzVXd0WFJ3STdtZW5YdUFBQUFBR0RvTXJBREFBQUFOa3lLcnc1ZVlVZFRwUi9rTGdBQUFBRGd1Y1d5dkRvVXhVZHpkMUFyTHk2TytmYnc4cnhESHM4ZEFnQUFBQXc5Qm5ZQUFBREFob25CRyt4b3N2SUh1UXNBQUFBQWVHNTNYcjlnNFU3Nzd2Tm9kVG9xZHd1MTBSZ3pzbmhsZGJ3dWR3Z0FBQUF3OUJqWUFRQUFBT3Z0aUV0djJhSFJYb3pKM1VHdHJINTBkZnh4N2dnQUFBQUFubHM1ZjBiUDJPbnorb1pPVTNLM1VCOUZrZm9lQ21kZ0J3QUFBS3czQXpzQUFBQmd2VFhhQ20rdm84blN3dThmdWV2eTNCVUFBQUFBcktNVWZoaWlnUjFOOWVyY0FRQUFBTURRWkdBSEFBQUFyTGNVdzZ0ajdnaHFKWVh3Zzl3TkFBQUFBS3k3TXBiWEZxSEluVUd0UkErR0F3QUFBRGFJZ1IwQUFBQ3czbUlJdStkdW9GNWlLSy9KM1FBQUFBREF1dnZObzJuaGpxUENFekdFcnR3dDFNWkxpM2RlUEt5ODhPMHJjb2NBQUFBQVE0dUJIUUFBQUxEZVVnaTdlWU1kVGRUeis2VVBYNWM3QWdBQUFJQjFWNTR6WmVYWVUrZmVHR0tja0x1RjJtamJhc3ZSTDZ1T2kzS0hBQUFBQUVPTGdSMEFBQUN3WHQ3OHBZVmJEaDh4Y29mY0hkUkorc244WXljc3kxMEJBQUFBd0hyN1lmVmxZRWZUdElXMFd6Q3dBd0FBQU5hVGdSMEFBQUN3WG9aMWpkZ3Rkd1Axa2tLOE5uY0RBQUFBQU91dkRQSGFJbmNFdFpKaWNQMGFBQUFBV0c4R2RnQUFBTUI2aVc1UW9NbGlXZjRvZHdNQUFBQUE2Mi9GdzQ5Y1AzenpUWHVDZTVSb2toaWk2OWNBQUFEQWVuUHhDZ0FBQUZndk1icEJnYVpLdmIzQndBNEFBQUJnQ0xyLzNHbkx4azZmdDdnNjNUTjNDN1d4VzFFVXNTekxsRHNFQUFBQUdEb003QUFBQUlEMWs4SXJROHdkUVkzODhySWpkMzBnZHdRQUFBQUFHeWFsZEcyTUJuWTB6V2FiSFhmNWp0WHh6dHdoQUFBQXdOQmhZQWNBQUFDc3M4UG4vTHlqbzRndnlkMUJqYVJ3YmU0RUFBQUFBRFpjU3VtSE1jWVRjM2RRSDUyeDJDMFkyQUVBQUFEcndjQU9BQUFBV0dkRm1WNFNpdGlSdTRNYVNlRzYzQWtBQUFBQWJMamU4TVNQaXpBOFZhY3hkd3MxVVRUNkJuYmZ6SjBCQUFBQURCMEdkZ0FBQU1BNmF5dkNycmticUpjVXcvVzVHd0FBQUFEWWNIZWQ4WVlIeDA2Lzh0Y2h4QmZrYnFFMmRzc2RBQUFBQUF3dEJuWUFBQURBdW92eDVia1RxSk8wOUxJamRyczEvRjJaT3dRQUFBQ0FqUklYVk44TTdHZ1cxN0VCQUFDQTlXSmdCd0FBQUt5ekZNUExZKzRJYWlRdUtNc3k1YTRBQUFBQVlHT2xCU0hFdCtXdW9EYkdGU2ZPNlNyUG12WkU3aEFBQUFCZ2FEQ3dBd0FBQU5aWkRONWdSeE9sZEYzdUJBQUFBQUEyWGtwaFFmVGtMcHFuTWJyb2ZIRjF2Q2wzQ0FBQUFEQTBHTmdCQUFBQTYrVHdPWXMzN1NpNmRzamRRWjJrNjNNWEFBQUFBTER4bGx5MzRLYzc3YnYzNDlYcDhOd3QxTU1mSHhabllBY0FBQUNzRXdNN0FBQUFZSjAwWXVmTFF0OTlDZEFjdmVHaGgyN01IUUVBQUFEQXhpdm56K2daTy8zSzdoRGk2M08zVUE4eEZDL1AzUUFBQUFBTUhRWjJBQUFBd0RvcFluUkRBazJUUXJqbHE4ZE9XSmE3QXdBQUFJRCtFaGRVM3d6c2FJNFVYTThHQUFBQTFwbUJIUUFBQUxCT1lvb3Y5LzQ2bWlZRmI2OERBQUFBYUNubGdoQ0szQkhVUlRTd0F3QUFBTmFkZ1IwQUFBQ3dybDZXTzRENlNDRVoyQUVBQUFDMGtKVGlndWdCWGpUUERsc2VNMmZUQjgrYjlranVFQUFBQUdEd003QURBQUFBMW8wbi90SkVxYmZYd0E0QUFJQTFpcG1mbVJRYTVSYTVPOGlnTEphVjd6cnAyN2t6NkI5M2ZHenlmV05QdmZJM0ljYm41MjZoRm1MSDhLNlhWc2ZyYzRjQUFBQUFnNStCSFFBQUFQQ2MzdnlsaFZzT0h6RnlUTzRPNmlHRjhQalNYejl5Uys0T0FBQUFCb2xHK25nTXhhdHpaOUI4cVFoM1ZBY0R1NVlTRjFUZkRPeG9pcklSWGhJTTdBQUFBSUIxWUdBSEFBQUFQS2ZobmNOZm5MdUIrb2doTEo0L1kwSlA3ZzRBQUFBQStsZUtZV0VNNFc5emQxQVBSUWl1YXdNQUFBRHJ4TUFPQUFBQWVFNTlUL290Y2tkUUh5bmRtRHNCQUFBQWdBSFEyN3M0TkJxNUs2aVBsK1FPQUFBQUFJWUdBenNBQUFEZ09SV2g4S1JmbXFZTW9UdDNBd0FBQUFEOUw2NVl0VGlNNkVwOXA3bGJhSDNKd0E0QUFBQllSd1oyQUFBQXdITktNYjBrdXVlRkppbFhwMFc1R3dBQUFBRG9mN2VmL2RjUGo1MCs5L2JxZEZ6dUZscGZESEduNHAwWER5c3ZmUHVLM0MwQUFBREE0R1pnQndBQUFEeW5HS0luL2RJc2oxNSsrK1cvRG1IWDNCMEFBQUFBRElRVUZvVm9ZRWRUTkxiZWRJc1hWc2VmNWc0QkFBQUFCamNET3dBQUFPQlpIVDVuUVZkSHNlbU91VHVvalp2S0dUUEszQkVBQUFBQURJd3loTVZGQ0grYnU0TjZLQnRGMzhQakRPd0FBQUNBWjJWZ0J3QUFBRHlyOWpEcVJkV2h5TjFCYlN6T0hRQUFBQURBQUNyRG90RElIVUZkeEJCZm5Mc0JBQUFBR1B3TTdBQUFBSUJuRjlPTCsyNURnR1pJZlRkWUFRQUFBTkN5MHNxd09Bd1BLYmpvU0JQRUdBenNBQUFBZ09ka1lBY0FBQUE4cXhqakMzTTNVQis5dmF1OXdRNmduMDJjZmNQV3ZYZXZlSEQrakFrOXVWc0FBQUNXbkRWcDZjN1Q1OTRaUTlnNWR3czFrSUxyMndBQUFNQnpNckFEQUFBQW5zc0xjZ2RRRzhzdnYrMktXMFBZUFhjSFFFdlk5M01MdWthTmFqdTVMYmE5djIySGtYZE9ubm5qOFZjZXRlZmMzRjBBQUFBeGhMNkhMQm5ZTWZCaWVFRlJGTEVzeTVRN0JRQUFBQmk4RE93QUFBQ0E1K0FOZGpSSkNqZVhNMmFVdVRNQWhycStHd2NuejdyaExhTkd0WCt5K3JqREgvL3RseGFOeHBVSHpWNzA3ZFdyMDBsWEhUUCsxcHlOQUFCQXphVzBLTVQ0NXR3WjFNSW1vNCs3Ykp2cWVGL3VFQUFBQUdEd01yQURBQUFBbm9zMzJORVVLYVQveWQwQU1OUk52bURoK0NtenVqOVgvWjY2NzFyK0k0ZTB0OGRKQjgzdVBuZmxzdVVmbmYrK0NRODNOUkFBQUtEU0c4TGlSdTRJNnFQUjFuZU4yOEFPQUFBQVdDc0RPd0FBQUdDdDN2cVZ4VnNWSFYyYjUrNmdIbUlNQm5ZQUcyai9MM1J2TTZ5ek9LUFIxbmhIOWJGNGp2OTRSL1c3N2dtZEkwY2VPV1YyOS9TNWMrK2NYVjQ2clhmZ0t3RUFBUDZnK3FIbHA3a2JxSThpeEJkV2h4L203Z0FBQUFBR0x3TTdBQUFBWUsxU2UrY0xjemRRSHluMEd0Z0JyS2Y5VDc5bTJMRHROemx1V0dmeEw5WEhUZGJ6dno0bWhuaitwRWs3SHp0NVZ2ZHhWNzVyL0RVRDBRZ0FBUENYN3ZqWTVQdkdUcC83KytwMHE5d3QxRUh4Z3R3RkFBQUF3T0JtWUFjQUFBQ3NWU05HTng3UUxHVmMrb2dubHdPc2g2bXp1OTgwYklkTlBsMmRqdDJZLzUwWXdpdGpqRDg0YVBhaXIvZXVUaWZQUFdiODdmMlVDQUFBc0ZZcGhKdXJuMGYrS25jSHJTK2w0RG8zQUFBQThLd003QUFBQUlDMVNpRzhNT2FPb0JhcVgydTNmZlhZQ2N0eWR3QU1CVk5uMzdCcmlHMmZEYkhZdjUvL3A5L1VhSTlURDVxOTZPeVZxNVo5WXI3Zmx3RUFnQUVVUTdnNUdOalJCTld2dFJmbWJnQUFBQUFHTndNN0FBQUE0Rmw0Z3gzTkVVUHc5anFBNXpEaDNCK05IdDQxL0NNeHRoOVZmV3dNMEQ5bVdQWDFMNTBkSTk4eGVWYjNoK2JkODUzL0tHZk1LQWZvbndVQUFOUllTdW5tR0R6ZWl5YUlZVnhSbkY2VXBaOXZBUUFBZ0dkbVlBY0FBQUNzVlV4cFhJaHVjbUhncGJUbWllVUFQSU05Wmk1dUg5MUkvelJpZU5mMDZ1Tm1UZnJIYmx2RStNWEoyeDN5andmTjZuN2Y5OTQxL3JvbS9YTUJBSUNhNkUzbHpXMXhvSjRkQWs4eGJJc1RkdCt1T3Q2Vk93UUFBQUFZbkF6c0FBQUFnTFdMY1d6dUJPb2h4blJMN2dhQXdXank3RVZUUnpmaTJkWHZsQy9LRWhERCtPcmJqdzZhMVgxSldCMCs4TDFqeDdzWkVRQUE2QmVySGxsK1M5dG1vL3JlS0Zia2JxSDFOVkxSZDYzYno3UUFBQURBTXpLd0F3QUFBSjdSNFhOK3ZrVkhFWnYxbGh4cXJrenhaN2tiQUFhVEtUTVh2N2dvd3RtTkdBL0szUkw2Wm5ZeEhoRTZ3aHNPbXRYOXFVZVg5WHo2eDhlOTVvbmNVUUFBd05CMi83blRsbzA5ZGU0ZDFlbTQzQzNVd1pxSHlWMlR1d0lBQUFBWW5BenNBQUFBZ0dmVWlHbHMzLzMwMEFRckhyejF3Vi9uamdBWURGNS8zbzgzSDluUjllR2lFWTZ0UHJibjd2a0x3ME9NcDI4eXN2MWRrMll1L01CVjc5N3JrcklzVSs0b0FBQmdLRXMzaHhBTjdCaHdzUWhqY3pjQUFBQUFnNWVCSFFBQUFQQ01ZaXpjY0VDei9HTCtqQWs5dVNNQWN0ci85R3ZhaHUyd3lkRWoyN3MrVW4zY01uZlBzNHBoaHlJVy96bHA1c0wzVEw1ZzRYRlhIcjFIZCs0a0FBQmdxSW8zVjkvZWtMdUNHa2dHZGdBQUFNRGFHZGdCQUFBQWErRU5kalJMK2xudUFvQ2NKbCs0OElCaDIyL3kyZXIwRlVQc2o5NTlZNk80WWNxc1JSZXRXcDArTlAvWThmZm5EZ0lBQUlhV3NrdzNGOFhRK2tHSW9TbkdhR0FIQUFBQXJKV0JIUUFBQVBDTWl1Q0dBNW9qaFdoZ0I5VFNRUmN1MkNXbWpyTWFzWEhZRUJ2Vy9ibnFyd3poblIwZDhXOG16KzcrNU9xN2w1ODlmOGFFRmJtakFBQ0FvU0dXdlQ4TGhkdVhhQXJYdXdFQUFJQzFjb1VLQUFBQVdCczNITkFVTWFUL3pkMEEwRXg3bjN2anFNMkd0MzBvaG83M1ZiOEpkdWJ1NlNlYnhCRFBhTjkrNUQ5TW50MTk4cFgvTVA3cnVZTUFBSURCYjhrZGo5KzIwd3RHOVFUM01ESHd4b3g1MXhXYlBERHJzTWR5aHdBQUFBQ0RqNHRUQUFBQXdOb1kyTkVVWmRscllBZlVRbkg2NmNXVTdROTk1K2JEMno1V2ZkdzZkODlBaUd2Ky9oQXZteko3MGZ6ZTBIUDh2SC9ZNjZlNW13QUFnTUdydkhUYXFyR256cjJ0T24xUjdoWmFYMk9UdUhOMThITXFBQUFBOERRR2RnQUFBTURUN0gvNk5XM2J2V0xNRHJrN2FIMHBoSlVQL3ZLUk8zSjNBQXkwS1JjdWZQMlVIUTc5WEhXNmUrNldKdG0vRWRvV1Q1N2RQWFBGRXl0T3UrYTlyLzFkN2lBQUFHRFF1alVZMk5FTVJUQ3dBd0FBQUo2UmdSMEFBQUR3TktOZk5ucmI0TG9CVFJCRCtOWDhHUk42Y25jQURKUURMN3greC9iVWNXWVJHMzhUMXZ5MlZ5dU5HT0l4WGNPNi9tN0tyRVVmZlRBdC9yZUZSeDIxT25jVUFBQXd5S1R3aStxbnBjTnlaOUQ2eWhoM3pOMEFBQUFBREU1dWxBTUFBQUNlcHVGR0E1b2twZkMvdVJzQUJzS1VzK2FOYUd5K3hTbWRzZlBrRkVKWDdwN01OcXUrenRveXZPcm95UmNzT3VIS28xLzkzZHhCQUFEQW9QS0wzQUhVUTR6RjgzTTNBQUFBQUlPVGdSMEFBQUR3TkRFR0F6dWFvdnExNWdhbmVFOWJBQUFnQUVsRVFWUXFvS1VVUlJFUG1yM3diWTNOdC94NGlHRzczRDJEU2d3dnFuN2YvODZVV1l1dTdDMTdUNWgzOUo0L3o1MEVBQURrbDhwd2EyemtycUFPWW5EZEd3QUFBSGhtQm5ZQUFBREEweFJ1TktCSnlwUzh3UTVvR1ZObUx0N3JvTm5kNTFTbmUvWGR0Y2RhVFc0VWpmK1pQTFA3ODAvMHJ2endENC9aOTZIY1FRQUFRRDdscXZDTFJ0M2YrMDJ6dU80TkFBQUFQQ01ET3dBQUFPQnBVZ3JQajRZQk5FR1I0aTl6TndCc3JBUFBYN0JkWjBmSHh4dHQ0VzBobU5hdG83WVk0ejhQYnh2MjFpbXp1azliZGMveUMrYlBtTkNUT3dvQUFHaStKV2ROV2pyMjFMa1BWS2RqY3JmUThnenNBQUFBZ0dka1lBY0FBQUE4WFhTakFjMnhMRDMrcTl3TkFCdHEzODh0Nk5wc1ZNZkpuUjN0cDFRZlIrVHVHYUsyclA3aThlL3QyNDA0WnZJRkM0Ky84dWc5cnM0ZEJBQUE1SkIrVWYxc1lHREhRQnRkbkRpbnF6eHIyaE81UXdBQUFJREJ4Y0FPQUFBQWVKcm9TYjQwUmJyL08wZnMrV2p1Q29EMVZSUkZuRHk3KzI4MjI3VDl6TERtejB3dnJkdFlNY1JYaENKZU5YbldvaXRXcjE1OTR2eGpYL1ByM0UwQUFFQVRwWGhyOVlQQjYzTm4wUExpVm1YSDg2dmpyYmxEQUFBQWdNSEZ3QTRBQUFCNGlyN1J3RnZuM1BMODNCMjB2aFNpdDljQlE4N0JGeTdhL2FEWjNaK3JUbDl2V05mL3F2K1BIdGJSM2o1NThxeEY1enk2b3ZlTTY5OXJpQTBBQVBXdzVnMTJ1U09vZ2FJbytoNHVaMkFIQUFBQVBJV0JIUUFBQVBBVWYvUFZ4VnRWaCtHNU8yaDlNYVJmNW00QVdGY1RaOSt3ZFVkcy8xaUk4WjNWeHlKM1Q0dnJqQ0djTW1wWTQrMlRaeTQ4ZGQ2OTM3MnduREdqekIwRkFBQU1uQlRpTDgzcmFJWllCQStYQXdBQUFKN0d3QTRBQUFCNGl2YlFzVjN1QnVyQkcreUFvZURnYzcvZm1icEd2NjhqdG44b3hEQXFkMCtkeEJDMkRyR1lPV25iUTk1ejRBVUxqN3ZxNkQxK21Mc0pBQUFZSUwwOXQ0VTJ0ekV4OEZLSzIrZHVBQUFBQUFZZlY2WUFBQUNBcDRneGJiL21sbllZYUdWcFlBY01hbE8vMkgxWUdESDZyQmppTHJsYmFpMkczUnN4WGpOcFZ2ZFh5MVdyVDducVBYc3Z5WjBFQUFEMHIzTDE0M2MyMmtiMXZibmFHOE1aVURFR0Q1Z0RBQUFBbnNiQURnQUFBSGlLTWhUYnVZdUZab2pKRyt5QXdXblN6TVd2YUc5TG40MmhPQ0IzQzM4U1EvamJSa2Y3b1pObWRaL1ZzM3I1cCtZZk8yRlo3aVlBQUtCL0xEbHIyaE5qVDUxN1gzVnEvTVRBOGdZN0FBQUE0QmtZMkFFQUFBQlBFWU0zMk5FVUtUeXk5STdjRVFCL2J1TG5GMjdaM2xWOHBMMHRIbDM5V2VqNitlRFVWZjB0NWRTMjloSC9iOUlGTi83TFZjZTg1a3RsV2FiY1VRQUFRSDlJdDFVL2l4bllNYkM4d1E0QUFBQjRCbTRRQUFBQUFKNGl1b21GNW5qZ1VtOGVBZ2FKUFdZdWJoOWRoR003dWhvZnJqNXVucnVINXhiNzNtcFJGQmRQdk9ERzl4d3c4NGIzWFgzVVhqZmtiZ0lBQURaV3ZMMzY5dnJjRmJROGI3QURBQUFBbnNiQURnQUFBUGdMM21CSFU5eWVPd0NnejlSWml5ZHYzUmJPVGlHOE5IY0xHMlN2dHRpNGZ0S3M3aStWdlQzL2N0VzdYM05QN2lBQUFHRERwSlJ1aTlGMVNRYmM1c1V4M3g1ZW5uZkk0N2xEQUFBQWdNSER3QTRBQUFCNHF1Z05kZ3k4bEF6c2dMeW1mckg3UlRFMXppNGFjZW9mL3AyVU40aU4wWGNMN3Q4M0dtMXZuanlyKzh4bHkzbysvZVBqWHZORTdpZ0FBR0Q5eEJoZEw2SXBSby9zNlh1TDNTOXpkd0FBQUFDRGg0RWRBQUFBOEplMnp4MUE2NHZSd0E3SVkvOXpydGxzK0toTnBoZWg4VThoaHZiY1BmU3JFZFhYNlNPSHQ3MXowdmtMVDducTJMMitWcGFsNVNRQUFBd1ZQZVh0b2EzSVhVRU5wTkRSOTVBNUF6c0FBQURnU1FaMkFBQUF3SlBlK01Yck5obTU2ZWFqY25kUUN3WjJRRk1WaDg5cFRKMnk4MUhEUjQzNlNQVnhkTzRlQmxBTU84WVlMNTE0L28zL09Pbjg2NCtiKys2OWI4cWRCQUFBUExlVmpYQmJaKzRJYXFFUnduYTVHd0FBQUlEQnhjQU9BQUFBZU5Ld0VTT2ZsN3VCZXVqdFRRWjJRTk1jY3RIaS9RODZhTnhucTlOZGcvZVoxY25yWTlIZVBXbm13b3Q2ZXVLSDVoODcvdjdjUVFBQXdOcmRjOGFVMzQwOWRlNWoxZWttdVZ0b2JTa2wxOEVCQUFDQXB6Q3dBd0FBQUo3VUZ1STJ1UnVvaTU0bHVRdUExamZwaTkxak8yTGoweUhFTjhYY01lUlN4QkRmMmQ0V3BrMmV1ZkNNTzFjK2VNNnQ3NTJ5TW5jVUFBQ3dGaW5jSG1MWUxYY0dMYTRJQm5ZQUFBREFVeGpZQVFBQUFIOVNGRzRzWU1DbEVIcVcvdXJSZTNKM0FLM3JkVis4YnBOTnc3Qi82WWlONDZxUHczTDNNQ2lNQ2lGK2FxZU9yWTZhZkY3M2lWY2VNLzZLM0VFQUFNQXppT21PNnB1QkhRTXFldEFjQUFBQThCY003QUFBQUlBbnBhTFl4aHQrYUlKNzVzK1kwSk03QW1nOXhlbW5Gd2Z0Y05nN05pMjZ6cWcrdWxtT3A0dGhsOUFJMzV3OHMvdnFGSHFPbjN2VWEyN09uUVFBQUR6Rlhia0RxQVhYREFBQUFJQ25NTEFEQUFBQW5oVGRXRUFUeEJTVzVHNEFXczhoc3hmdE8zWEhRejlYblk3UDNjS1FjRUFNYllzblg5Qjl3ZXE0Zk1iOG95YjhQbmNRQUFBUVFqS3dvem1lbHpzQUFBQUFHRndNN0FBQUFJQS81OFlDQmw1TXY4bWRBTFNPZ3k3cTNxRVJHcDhNamVJdFljMVdITlpaVy9VcjVqMXRZY1JiSnM1YytPR0h3MCsrc1BDb28xYm5qZ0lBZ0RxTElkMlYvR2pId1BPZ09RQUFBT0FwRE93QUFBQ0FKNlVRdG5IN0NnTXVSVyt3QXpiYUhqTVhEeC9USHQvZkNJMlRxNDlkdVhzWTBqYVBJWjZ6ZVhqbHNSUFA2ejVoM2pIanY1YzdDQUFBNmlxbGRKZDlIVTJ3V2ZIT2k0ZVZGNzU5UmU0UUFBQUFZSEF3c0FNQUFBQ2VGRlBZeGcwc0RMUXlKQU03WUlNVlJSR256dXAreTlidDhaUFZ4eDF5OTlCSzRvdGpJM3gzMHN5RjN5MTc0d2xYSFRQKzF0eEZBQUJRTjZ2TDNydmFHNDNjR2RUQVpwdHQxdmNXdXp0emR3QUFBQUNEZzRFZEFBQUE4Q2N4YkpNN2dkWlhoSEJYN2daZ2FKbzZxM3VQcVJkMmY2NzZBMnVmM0MyMHNqaTFhSVNKRXkvby9yZmVKNVovZFA3N0pqeWN1d2dBQU9yaTNoc1czYnZqUG52M1ZxZFdkZ3lvenREMnZHQmdCd0FBQVB5UmdSMEFBQUN3eHVGejVqUTZpcGR0bGJ1REdpakRQYmtUZ0tGbDhoZXYyN1lqRHZ0RTBkWjRXd2pldFVwVHRNY1lUbWpyR3ZHMkF5OVllTnI4cTVmTUxDK2QxcHM3Q2dBQVdsMDVmMGJQenFmT3ZhODYzVDUzQ3kwdWxtTnlKd0FBQUFDRGg0RWRBQUFBOEVlN2JCRThHWm9tZUR6R3UzTTNBRVBEL3FkZk0yekU4MGVkMEJHN1BsaDlISm03aHhxS1lYUVI0aGNPT0dDbll3ODhmK0h4VjcxN2ovbTVrd0FBb0FaK0V3enNHR2hGSEowN0FRQUFBQmc4RE93QUFBQ0FOVHBDaHhzS0dIQXBoTWUvOVphWFA1UzdBeGo4RHIzb3BqZU4ySEhVWjZyVG5YTzNRSXhoMXhqajFaTm1kbjg5OUlhVDV4NHovdmJjVFFBQTBMSlN1cXZ2TCtFd2tNcGtZQWNBQUFEOGlZRWRBQUFBc0VZWnl0R0ZGOWd4d0dJSTNsNEhQS3REWjNXL01yUVZuNnQreDVpUXV3V2V3WnVxdnk1Tm5UU3orM05QUEx6cTQ5ZWV2TTlqdVlNQUFLRFZwQkR1TXE5am9NVVlET3dBQUFDQUp4bllBUUFBQUdzVW9YQkRBUU12aFh0eUp3Q0QwNVR6cngvVDNqbnNvNkd0OFEvVlI0dHZCck5oMWRjSHVqYnJlTWVrbVRkKzZLcDd2M2RST1dOR21Uc0tBQUJhUlF6aHJ0d04xSUEzMkFFQUFBQi94c0FPQUFBQVdDTVZjYlFuUXpQZ1l2SUdPK0FwWG5INm5JNGRkeGozM3ZiT1lhZFZIemZOM1FQcllac1FpdGtIYm52d3NRZWNmOE54Vjc5N3J4L25EZ0lBZ0phUTRqM0JoVW9HbURmWUFRQUFBSC9Pd0E0QUFBQllJNFkwT3JoemhRRVg3ODFkQUF3ZWgzNngrN0NkZGh6N21lcjBCYmxiWUNPTWI4VEd0WlBPNzc1a1ZSays4SU5qeDN2YkJnQUFiSXpZZTc4WG16UGdrb0VkQUFBQThDY0dkZ0FBQU1BYUtYaURIVTFRcHZ0eUp3RDVIWHpSalM4dFF2dG5RMnhNeXQwQy9TUlcvenFpb3hIZU9QR0NoWjkrK0w3ZmZtcmhqRU1lengwRkFBQkRVZXFKOThmMjNCVzBQRyt3QXdBQUFQNk1nUjBBQUFDd1JreHBkSWdtZGd5d0l0MmZPd0hJNTZBTEYyelJLRHBuRkxIOVBhSHYrblRLWFFUOXJpdUdlTnJtejl2bS8wMDZiK0VIcm5yUFhwZVVaZWxYT2dBQXJJY1Z5NWY5dG11elVia3phSDBHZGdBQUFNQ1RET3dBQUFDQVA0aHhxOXdKMUVBcURPeWdodlkvL1pxMnJoMUhIZFBXNlB4dzlYSEwzRDNRQkR1RUl2N24vbCs0OFIvLzZndmR4LzMzc2VNWDVnNENBSUNoNHY1enB5M2IrZFM1eTZyVGtibGJhR25EeHJ6cmlrMGVtSFhZWTdsREFBQUFnUHdNN0FBQUFJRC9zMFh1QUZwZnorcnl2dHdOUUhNZC9NWEZrMGJzTk9yczZ2Umx1VnVnMldJTSs3UTF3ZzBUTCtqKzBvclZxejU0N1QvdWMyL3VKZ0FBR0NMNkh0SzBTKzRJV2x2djVyMTkxOFFON0FBQUFBQURPd0FBQU9CSkJuWU11QldORmQ1Z0J6VXgrYUliWDlBUjJqNVRGUEd3M0MyUVdheSsvbjVZZThlYkpsN1EvWW5lKzVhZlBYL0doQlc1b3dBQVlEQkxJZjAyaG1oZ3g0QnE3KzNjdkRvc3lkMEJBQUFBNUdkZ0J3QUFBUHdmQXpzR1ZBcmg4ZThjc2VlanVUdUFnVFZwNXVKTk96dmlxUjJ4L1orcmp4MjVlMkFRR1ZsOW5kRjQzb2gzSFhqQkRTZGRkZlJlWDg4ZEJBQUFnMWYwa0NZR1hCbEsxOFFCQUFDQU5RenNBQUFBZ0xESHpNWHRMOTZ5YTVQY0hiUThOMFpCQ3lzT245TTRlTXE0Zitqc2lCK3RQbzdKM1FPRDJNNHhGSmROUFAvR2EzckxudVBtSDd2UFQzSUhBUURBWUJOZFI2SUppa1kwc0FNQUFBRFdNTEFEQUFBQXd2TzcyamJQM1VEcml5azhrTHNCR0JnSFg5UTlZZXBCNHo0Yll0Zzlkd3NNR1RGT2FEVGF1eWRlc0hEMkU2bG4rby9ldmJjL0p3RUE0UCtrZEgvMWQrYmNGYlM0R0F6c0FBQUFnRDh3c0FNQUFBRENzT0dGR3drWWVESDhMbmNDMEwrbVhuekRUa1hxK0ZRUkczK2J1d1dHcUViMWRYUlhiRHQ4NGdVTFAzTC9mVXZPdlhuR3RGVzVvd0FBSUwvNC85bTdFekM1cWdKdjNPZmNxdTdPUmdpckNDcktJNE4vV1pRMU93MkpMQityaEFDaWc4TUhJaENXTklHQUdLR0pHQkVpb1lGc2dDRElaZ0NaR1VZeGdFUUNXYnFUbUxDTWpuemp3NHlmeXlEN21yWDczdi90Nk9mb3VBT1YwK2w2WHlqT1BZVlA4bE1yVmJkdW45ODl2MHFkZ042dktJSWJ6d0VBQUFEcktkZ0JBQUFBb1NqaTVzRU5vYW01UXNFT2VvbFJzK1lQNk45djRJV1YwRGloL1B6b2t6b1A5QUtibG84cnQzbjM5cWQ5YkhiSGVkODdiZkI5cVFNQkFFQktSWjQvR3l0WjZoajBjakVHTjU0REFBQUExbE93QXdBQUFMcTNUckdRZ0EwZ0t0akJSaTdMc25qWWpjdFBHTkJ2MDh1S1VHeWJPZy8wUWp2R0xQdm5qMTIvOU1FWWluTWUrdXcrUDBvZENBQUFVaWlLN0ZmdUIwYnRGYTZMQXdBQUFPc3AyQUVBQUFBaEZHRXpPOWhSYTBVUkZPeGdJM2JvTFN1R0hQcjE1VzNsNGVEVVdhQzNLMC9MRGl6LytjUUIxeTJadVhKVlBubGh5NUNYVW1jQ0FJQU5LV2FkTDFqV1JPMUZCVHNBQUFCZ1BWZWlBQUFBZ080Vks0TlNSNkFPRklXQ0hXeUVEcjF4eVhzcTFZYkxLeUVlSDRJNk5teEExUkRqMmYzNlZUNzFzZXVXWEpJL3UycjJ2TmJtenRTaEFBQmdRM2p6emV5RkFadWtUa0VkMkRSMUFBQUFBS0JuVUxBREFBQUF1dXNTQTFOSG9BN1l3UTQyS3NQYjJ2dHVQcWpQeEVxMThmeHkyajkxSHFoalc4UVlyODIyNlhmYXgyWXRtZkM5MC9kNU1IVWdBQUNvdFJldlBlVDFBWitmdTdZOGJFeWRoVjZzS0JUc0FBQUFnUFVVN0FBQUFJQlM5MElDbXhKUlczbVJ2NUE2QS9DWFpWa1dEN2x4MlRGYmJOYm5pbks2ZmVvOHdLL0ZHSFlPbGZqQUFkY3R2VzlkTE01NzVMUDcvSHZxVEFBQVVDdDVuaGNmK01LREw1YUg3MDZkaFY0c1JqZWVBd0FBQU5aVHNBTUFBQUJDVWNSTm8zNGROWlpYdTE1S25RSDQ4dzYvY2NXZWgzMTllVnQ1T0NKMUZ1QlBpT0dJaGhBUC90ajFTNjU1OVpYWHY3VDAvTkd2cG80RUFBQTFVWVFYeXZOZkJUdHF5UTUyQUFBQXdIb0tkZ0FBQUVEM1FtMTM2cVhtMXVXTkNuYlFReDEreTdKdFFxaE9pZFY0WWpuTlV1Y0IvcUxHR09KNWd3WU4vUFRvNjVkYzlQMkgvKytOK1p5eFhhbERBUURBT3lxR0YxTkhvTmR6WFJ3QUFBQllUOEVPQUFBQUNOR2RlcW05L0R2LzUxdXZockJMNmh6QTd6aDArdHlteW9CM2pZK3hPaWxZVkFZYm82MnpFSzhiUFhyNzAwYlBiai9uNGRPR3pFOGRDQUFBM2tFdnB3NUFyOWMzTys2ZXhuek8yTFdwZ3dBQUFBQnBLZGdCQUFBQTNaUXFxTEhpbGJ5MU5VK2RBdmh2aDkrOFlreGxrMjJtbG9jN3BNNEN2RzI3WjFubGtRT3VYM0pYVjFGY01PL1V3ZitaT2hBQUFMeDl4Y3ZyYncwR05iVEorL3AwWHh0L0lYVU9BQUFBSUMwRk93QUFBQ0NFb3RnMFJJdFZxS0VpdnBRNkF2QnJoOTJ5Zk5jc1pHMHh4bEdwc3dEdnRIaHNGdUlSbzY5Yk9xM0lWMTQyNy9UbU4xSW5BZ0NBdHk3YXdZNmE2N3UyYTlPZ1lBY0FBQUIxVDhFT0FBQUFDQ0ZHTzloUld6RW8yRUZpbzI1WXZ1V0F4amc1QzltcDViU1NPZzlRTTMxaUNKK1BXYjhUUjg5YWN1SDN6eGh5YTU3blJlcFFBQUR3dHlxSzhKSjdnbEZyUmFXeWFlb01BQUFBUUhvS2RnQUFBRUEzQlR0cXF3anVPQTZKN0gzRDhvWnRHdU1aQTVxeWk4dnBaa0hOQnVyRnRqR0x0K3cvczJQY3FObExXdWFkdGs5NzZrQUFBUEEzY2oySjJvdGhrOVFSQUFBQWdQUVU3QUFBQUlCdS9WTUhvSmVMeGF1cEkwQTlPdUxteHc5NWQxTjJaWG40b2RSWmdEUmlESU5qaUl0R1g3ZjB6bUpkY2NHOE0vZjVlZXBNOUF4Wm5xOE5sU3gxREFDQVA2a29pbGVpTGV5b3RTSWJrRG9DQUFBQWtKNkNIUUFBQU5TNVE2ZlBiZHA4MiswYlV1ZWd0NHNLZHJBQkhYbkw4ZzhWTVY0WnNuaEk2aXhBajlDOUxQbVRzU0VlT1hyMmtpdFdyODZuTG13WnNpcDFLTkthZi9hSWpoRXpGbyt1Rk9HcThoV3lXK284QUFEL1U3YitoazBLZHRSWXpOMThEZ0FBQUZDd0F3QUFnSG8zWUp2M1dVQkF6UldoZUMxMUJxZ0hoODlldUZuV3I5L0ZJV1pueEJBYWl0U0JnSjZtZjR4eGN0KytsWk5HWDdmMC9PK2ZQdmp1UE0rOVZkU3hCV2NNblpjZGQ4OGVJL2JkN3VRWTRwZktwN1pLblFrQTRMOFZidGpFQmhCZEh3Y0FBQUFVN0FBQUFLRGVWYnFLL2lGekoyaHF6UTUyVUV2WmNmZFVEajlraDFPemZ2MG5sOU10VStjQmVyenR5N08vT2FObWRwdzFldmFTbG9kUDIrY0hxUU9SVGo1bmJGYzVYTC9IMWZQdkdsQnB2Q2pHZUZZNXQ4TTFBSkJjbm9mWHNrcnFGUFIyNVhjakJUc0FBQUJBd1E0QUFBRHFYV3dvTENDZzVtSnVCenVvbFNOdlhqN3E4RU0vMkZZZTdwbzZDN0NSaVdGRURISEo2T3VXM2x6a0t5Zk5PNzM1MmRTUlNHZjUrT1pYeXVIY2tkY3N1ajdMc21ubDYrT1ExSmtBZ1ByV0ZicGV6WUtHSFRXV3hRR3BJd0FBQUFEcEtkZ0JBQUJBblN1S09DRFl3STVheSt4Z0IrKzB3NysrYkljc3EwNE5XVFltZFJaZ285YTlsL0ZKTWVzM2R2UjFTNmY4Zk4yTFZ6OTk1c0ZyVW9jaW5jZk9IdlowT1J6YVBHUHhRU0hFYWVYeGgxTm5BZ0RxMDhvMVhhOXQyaTkxQ25vL042QURBQUFBRk93QUFBQ2c3c1dpNks5Z1IrMTFLZGpCTytUUTZVc0dWZ2MyVHNvcTFmSGx0Q2wxSHFEWEdGaWVFbDcrM29iTlQvM1lySTZKM3p0OThMMnBBNUhXL0RPR1BwQk5uditSa1ZzMGppdENiQzFmSDV1bnpnUUExSmRYZnJIdTlVMTM3RnVFNE9vbE5hVmdCd0FBQUNqWUFRQUFRTDJMV2NVQ0Ftb3V6eXV2cDg0QUc3dHM4dVRzc1BjZmNXSjFZT09VY3JwTjZqeEFieFYzQ0ZuODFzZXVXenF2cTdPcjVmdG5ESGtxZFNMU3lWdWJPOHZobWlGZm1YZDdZLzkrWHd3eGZEYjQrU0lBc0lIa2M4WjJmZUFMRDY0TUNsRFVVaEVIcEk0QUFBQUFwT2NIWUFBQUFGRG5paEFHdUFVMHRaYUY4R2JxRExBeE8vTHJ5MGNjOW9FajI4cjM2ejFUWndIcXhxaEt0YkppOUhWTHJpdmVYTlU2YjBMekM2a0RrVTc3NTBhOVdBNW43TnUyY0daUnlhNktNUjZRT2hNQVVEZTZyeWtwMkZGRGhkY1hBQUFBb0dBSEFBQUE5UzRXZVo4UXM5UXg2T1h5cUdBSGI4VmhONjNZdmxLTlY0Uktka3dzMzdKVDV3SHFUaVdHT0M3MjczZjh4Mll2K2VLcmp6OHhZK25zVTlhbERrVTZqN1lNLzJFNUhEanlta1ZIeEpoZFdYNHlmVEIxSmdDZ2R5dENlS1A4TXJ4MTZoejBackZ2NmdRQUFBQkFlZ3AyQUFBQVVPZUtrUFhWMktEbWl2Qkc2Z2l3TVRuNHlvZjZOMjIxNWZtVmFweFlUaTMwQWxMYkxNUjQxY0RkUDNycWZqT1huUHZJdUgzdVR4Mkl0QjQ3ZTloOXUwNitaKzZnemJkdGlUR2JWRDQxTUhVbUFLQjNpc0UxSldvcnhxSlA2Z3dBQUFCQWVncDJBQUFBVU9kaURCWVFVSFByN0dBSGY1VXN5K0xoWDE5MmZOT1dXMTFlVHQrVE9nL0EvL0NoU2lWK1ovUjFTKzh2T2p2UG5YZkcwQituRGtRNlQ3V09YVnNPVnd5N1p0NHRsYXp2bDJLSS83dWNWMUxuQWdCNkhRVTdhaXk2UGc0QUFBQW8yQUVBQUVEZEs0byszUzA3cUtXbWwxOVVzSU8vNExDYmx3OCsvT2JsYmVYaGtOUlpBUDZDUTJLMWVzQ282NWJPNkN6V2Z2SFIwNGEvbkRvUTZTdzZlOVN2eXVHVUVkTVh6OHlLMkJaaTJEZDFKZ0NnRnluQ0c4R2xTMnFvQ0c1QUJ3QUFBQ2pZQVFBQUFIYXdvL2FLdTU5N1pPV2MwSnc2Qi9SSUIzMzk4VzJiS3VHeVNwYWRFSUpsZzhCR282Rjh3MnBwaUExL1AzcFdSK3YzSC9uWmRmbWNzVjJwUTVIT2dqT0hyaWlINW4ydmJUKzJpT0dLOHZXeGZlcE1BRUF2RUl1VnZpcFRTekVVcm84REFBQUFDbllBQUFCUTcyS0lGaEJRYXl2ejF0WThkUWpvYVViZE1yOVAvekJ3UXA5S3ZMQ2NEa2lkQitDdGlWdVdKNVF6OXQvL2ZhZU5udGwrenNQamhqeWNPaEZwUFhyV2tMdUd0N1gvUzZWYW5GdStQaTRJUHVNQWdMZWppS3YwNjZpcHd2VnhBQUFBUU1FT0FBQUFLSW8rSVZxbFF1MFVJYXhPblFGNm1pTy9zZnpZVGJKTkx5Ly9nTHcvZFJhQWQ4aXVJY3UrTjNyMmtudlhoWFVUSHoxdCtET3BBNUhPd3BZaHE4cmhTOFBiMnI5ZXFZWXZsOGQyYVFVQTNwcFlySElhUVUzRm9HQUhBQUFBS05nQkFBQkEzYk9BZ05wYmxUb0E5QlNIM3ZxRDNhdWhjbFdJV1hQcUxBQTFNcVloTkJ3NmVsYkgxU3U3NHBURlorN3pXdXBBcExPd1pjZ3Z5dUVmaGwyellHWTFxN2FWeDBOU1p3SUFOamJSZFNWcXJIQjlIQUFBQUZDd0F3QUFnSHBYRkxHUERleW9wVmpZd1E0T3ZtN3gxazE5KzE1YWpaV1R5MmtsZFI2QUdtc0tNWjdmcnhvK1BYcm1ra25mZi82N04rZXRyWG5xVUtTejZPd1JIVm1XRFJ0eHphTHVuZXk2ZDdUYkxuVW1BR0RqVUJURnF1amlKVFVWRmV3QUFBQUFCVHNBQUFDb2R6R0dwdFFaNk9XaWdoMzFhOWZKOXpUdThJRVBudDJuWDc4dkZLSFlOSFVlZ0Exc201Q0ZHL2QvMS84YU4ycFdSOHU4MHdjdlNCMklkUEk4TDhyaEc3dGYrZEMzTm1rYWNINTVraml4blBkTm5Rc0E2T25peXRRSjZQVmNId2NBQUFBVTdBQUFBS0R1RmFFaHVBazBOVlNFUXNHT3VuVDROeDQvWW9jZGR2eHErUmE3WStvc0FJbnRHV044ZFBTc0pYZXZLYnJPWHpCdTZFOVRCeUtkRmVjZThHWTV0STZZdHZpbTJCaXVpQ0VlRTRKdkpBREFuN1FtZFFCNnZZYlVBUUFBQUlEMEZPd0FBQUNnM2tVTENLaXRHS0tDSFhYbHlHODhzWE9JeGJSS2pBZW16Z0xRZzVTbkJPSFlwbGc1ZlBUc2pxa3Z2Zm5hRmI4cFdsR25Ga3hZWDdROGJzUTFpMmRrV1d3cmozZFBuUWtBNkhsaVZMQ2o1cXBaZVVMNm14MlhBUUFBZ0RxbFlBY0FBQUIxcmdoRlE3UmhCTFZVQkFVNzZzSUJ0eTdkb245b3VDVEdlRm9JMGJWWGdEK3ViL2tlZWZIbS9UYzlhZlRzOWd1K1AyN1luUmF5MXJjRlp3OTlOSnM4ZWE4Uld4eDRZdm5hbUZJK3RVM3FUQUJBVDVLdkRTRkxIWUxlTFliUFh0ZDlIV2RkNmlBQUFBQkFPaFo1QUFBQVFKMkxSV2pRcjZPbVl1Rk80L1Jxb3liUHIyN3lnVTNIOVkrTnJlVjA4OVI1QURZUzd3a2h1MzIvbWUxbmpaN1owZkx3dU1FZHFRT1JUdDdhbXBmRFRVT256NzJub2RoMFVua0NPYjZjTjZYT0JRQ2tWK1JoVGRTdm8rYmUzUkFVN0FBQUFLQ3VLZGdCQUFCQXZZdDJXYUxXb3NVcDlGcEhmdU9KQXdmdU1PaXE4dkREcWJNQWJJeGlDRU5DRmhlUG50MXg2OXF1cmdzZk8yUFlMMU5uSXAzRlp4NzhXamxjTUx5dC9ZYXNVbHhadmtLT1NKMEpBRWdzaTJ0VFI2RDMyeXlzYmtpZEFRQUFBRWpMQWpvQUFBQ29jMFVJRFRhd281YUt3dDJmNlgyT3VQbnhIYk5LL0dxTXdjSi9nTGV2UEIyTm4yNnNWTWVNbnIza3N1SlhxNmJOYTIxZW5Ub1U2U3hzR2ZLVGNqaHkrTFh0bzdNaVhGVytRblpOblFrQVNNTU9kbXdJblp2MFViQURBQUNBT3FkZ0J3QUFBSFV1aG1EeEFEVVZZK2hNblFIZUthTnVlV0xRd0t5NEtLdkVNOHRwWStvOEFMM01nUEl4SmI2cjd5bWpaN1pmOFBDNElYZWxEa1JhQzg4YThuQTJlZjRld3paci9HeU1jWEw1MUphcE13RUFHMVlXaTNYcnIyQkNEZlZkbFZsREJ3QUFBSFhPeFFFQUFBQ29kMFhSME4yQWdscXhneDI5UVhiY1BaVWpEdDN4NUlGWnVEU0V1SFhxUEFDOTNQdERsczBaUFh2SnVMeXo2NXp2bnpsMFJlcEFwSk8zTm5mZnJHSG1SeTVmZU9jbWZTdVhsRjlkVGc5dUVnSUFkU01QUmFjTjdLaTF6ajZkemk4QkFBQ2d6aW5ZQVFBQVFMMkwwZUlCYWlxdXY5TTRiTHlPdlBueDVpTU8yN0d0UFB4bzZpd0FkYVk1Vml0TFI4MWVjdVBhTjdzdVduRHUwT2RTQnlLZEp5NFkvbkk1akI4eGJmR3NXQTNUeXBQTS81VTZFd0JRZTFtb2RLYk9RTy9YVUZSZEl3Y0FBSUE2cDJBSEFBQUFkYTRJSWJOL0hUV21ZTWRHNmZDdkw5dWhVcTFPalpVNEpuVVdnRHBXS1IrZmJleGYrY1Qrc3pxbXZQRGN6OXFlYWgyN05uVW8wbGt3WWVpUHkrR1FrZGN1T3FUOEtqT3RQTjRwZFNZQW9IYnlJblM2ZUVtdEZhSExSb2tBQUFCUTV4VHNBQUFBb003RkltVEJJaFZxcUNnVTdOaTRqSm8xZjhBbUF3WmRXS2syVENpbmZWTG5BV0M5Z1RIR3k3ZDgxL3Mrczkvc2p2TWVPVzN3ZmFrRGtkWmpadzI3ZisvVGJuaW9hZWRkemlxL3pseFVQalVvZFNZQTRKMVhmczdid1k2YUs2S0NIUUFBQU5RN0JUc0FBQUNvZDFHOWp0b3FYMko1Nmd6dzE4aXlMQjUyOC9JVEJnNFlkRms1M1RaMUhnRCtVSG5pdW1ONWJ2SFBvMll0ZWJDeldEZmgwWEhEZjVnNkUra3NuWDFLOTQwY3B1MzVsUVczOXV0ZitXSjVmRXI0OWE2SEFFQXZrWWVpcytMeUpUVld4S3FDSFFBQUFOUTVCVHNBQUFDb2QwV1JoV2lSQ2pVVWc0SWRQZDVSTno4KzdJaGJWclNWaDN1bnpnTEFYK1hBYW14NGZOU3NqdGtyaXpjdmFSODM2c1hVZ1VqbkI1OGI4WHc1bkQ3c21nV3pzbEM1cXZ4Nk15cDFKZ0RnblpIRjJKVTZBNzFmMFpXNVFBNEFBQUIxVHNFT0FBQUE2bDJNN3M1TGJSVkZrVG9DL0NsSDNienN2YUhhOEpWUWpjZUh3aTN4QVRZeTFmSms5c3grY2NBbjk1L1pNVGsrdjNybXZOYm16dFNoU0dmUjJTT2VMSWZSSTY5ZU5DWmtjV3A1dkVQcVRBREEyNVFYUmFqNHVrNXRGVEYzalJ3QUFBRHFuSUlkQUFBQTFMdnVRdTh3M0prQUFDQUFTVVJCVklrMUt0U1NIZXpvZ1lhM3RmZmRlc3MrRTBPMTRZSnkyaTkxSGdEZWxzMWpqRmVIcmZxZXV0K3NKZWM4Y3ZvK0Q2WU9SRnFQalI5Mjd3NlQ1OSsvM1dZTkUwS01ueXVmMmlSMUpnRGdyWWtodXE1RXpUV0VMZ1U3QUFBQXFITUtkZ0FBQUZEdllyQjRnSm9xTElTaUI4bXlMQjUreTRyanQ5Nnk3MWZLNlh0VDV3SGdIUlREaDhzVDJ3ZEd6ZXI0OXJwMVhlYzlkdmF3cDFOSElwMW5XcHRYbDhPWEIzOTEvazJOalExVFFvd25sblBmZlFCZ0k5T1pGVVhWM2NHb3RUenpJZ01BQUlBNnAyQUhBQUFBZGE0SUlWbzlRQzNGOVM4elNPK28yeDdmNjRodnJHZ3JYNVBEVTJjQm9KYmlZUTBOMVFOSHpWd3lQYXhiZGVtODhjMnZwRTVFT2gzbk5UOWJEaWVQYkZzMEsyU3hyVHc1ZFI0QUFCdVIyRlVVb2VycUpiVlZ4SW9iTVFBQUFFQ2RVN0FEQUFDQU9oZnQ0a0NORmFHd2d4MUpIWDdMc20wcWxlcVVHT0tKM3ZNQTZrWmplYUk3SVRUMi9mdjlaeXk1YVA2ai8vZkdmTTdZcnRTaFNPZXhsbUhMc2l3Yk9iVHRzZU5qek94a0N3QWJpMHJoeGszVVhGSHAwdUlFQUFDQU9xZGdCd0FBQUhYT0RuYlVtaDNzU0dYVUxmUDdiSnB0MmxLdE5IeStuRzZTT2c4QVNXd2RzM0RkZnZ1OTkvVG02ZTB0ODg4Y01qOTFJTkxKODd6N3ZQU080VzMzL0dQSXRwMFlZN3lnblBkTG5Rc0ErTk5pVjZXd3VvbWE2M0tKSEFBQUFPcWRTMUFBQUFCUTU1U2ZxTFZpL2NzTU5xeVAzN1ppektiWm9LbmxxMitIMUZrQTZBbmlSeXVWK01pb1dVdnU3Vnl6YnVLakxjT2ZTWjJJZEJhMmpGMVZEbDhjZk5Walg2OVdLMStKSVI0Zm5MTUNRSTlVaER5ekdUMDFaNmRFQUFBQXFIc0tkZ0FBQUlERkE5UlVMQ3hXWnNQNStLMHJkZ3N4dXlxR2JKUlhIZ0IveEpocVU4TWhvMloxVEhzK3JMN3NxZE9iMzBnZGlIUTZ6aG41czNMNDFQQnJINXNSUTdXdFBONDdkU1lBNFBkVllxWmRSODNGSXN0VFp3QUFBQURTVXJBREFBQ0FPbGVVZit1Z1VGTXhlb2xSYzRmZS9QaFdEZFg0eFJpelU4cHBKWFVlQUhxMFB1VUp5dWUzREgxUGJKN1ZNZW14NStaK0kyOXR0YUMyamkwOGErU2liUExrSVVNR0hmRHBMSXRUeXFlMlRaMEpBUGkxSWdzVkY1YW90ZGlWdXdrZEFBQUExRGtGT3dBQUFLaHowUTUyMUZnUjdDTkc3ZXg5dy9LRzdmckVzeHFyMlVYbGRGRHFQQUJzVkxiTlF2eDY4OVlIbjdIZnJQYnhqNXcrWkZIcVFLVHptNUxsemJ0T25uL1BwcHMxWGxpZXdVNEk2OHVZQUVCS1JjaXpHR3hpUjIydHM0TWRBQUFBMUQwRk93QUFBRURCamhvcjdDWkdUUngxMitPSHZLZHZaVnA1dUZQcUxBQnN6T0plTWNRRis4M3N1RFBFdFo5NzVQU1JQMHVkaUhTZWFtMStveHdtRFc1YmVHTkRsazB0ajhla3pnUUE5YXlJbVhZZE5SY2J1aFRzQUFBQW9NNHAyQUVBQUVDOUs4cS83QzlHRGNVUUxZVGlIWFhVelk5L09GVER0UExWZFZEcUxBRDBHckgweVJDYVByNy96Q1dYcjEyYlQxM1lNbVJWNmxDazA5RXkvSmx5T0hwNDI0TG1tRlhheXVPUHBzNEVkYTNJenl0aVpzZnFlbFNFTjFOSElLMUt5TE5nQnp0cXJhdnFKblFBQUFCUTV4VHNBQUFBb080VlhVSERqcHF5Z3gzdmpNTm5MOXlzT21EQUphRWFUeStuRGFuekFOQXI5U3RQalNjM05zWFA3RCtqL1hQenp4cDJaNTduRnR2V3NZVXRJK1pueDkyejE3Q2gyNTBjc25CcCtkVFdxVE5CUGNwUHZ1Q1IxQm1BTklvOFZOeTZpVnFMUmFjZDdBQUFBS0RPS2RnQkFBQkEzWXRkcVJQUTIwVUZPOTZXVVpQblZ6ZlpZZEJucXdNR2ZMR2NicEU2RHdEMUlMNDNaUEgyNXVudDQwYk9XTlR5MkJuRGxxVk9SRHI1bkxIZDM1bXUzK1BxK1hmMUM0MFhoUmpPTE9lTnFYTUJRRDBvUXBhNU5SaTFGaXR1cWdFQUFBRDFUc0VPQUFBQTZsME1uYWtqME92WmFZeTM3SWh2ckJpOTZRNkRyaXJmcTNaTm5RV0FPaFREOEdxc2R1dzNxK1BtVldIMXBJN1RtNTlOSFlsMGxvOXZmcVVjemgxOHphTHJxeUY4TllaNFdPcE1BTkRiWlRIUHluK21qa0V2RjR1S0hld0FBQUNnemluWUFRQUFBSGF3bzhZSzE2RDRtMzM4OWhVZmpIbDJaU1hMamtpZEJZQzZsOFVRVCtwWDlEbG0vNW50WC9ucDgydW1QZFBhdkRwMUtOTHBPSHZZMCtWdytOQzJSUWRXc25oVmVmemgxSmtBb0xjcThsQ0psZFFwNk8zV0ZybWIwQUVBQUVDZHM3Z0pBQUFBVUxDajF1eGd4MS90ME9sTEJqWU42ak1waTVYeFJTeWFVdWNCZ04rS1laUHlIMU8yMzdyUHlmdk42cGo0eU9tRDcwMGRpYlFXdHd4N01KczgveVBETm1zY1YwNWJ5OGZtcVRNQlFHOVR4RkNOcVVQUTYxVmlkVjNxREFBQUFFQmFDbllBQUFDQWdoMDFWUlJSd1k2L0tKczhPVHZ5ZzBlZTFMUlowNWZLNmJ0UzV3R0FQMk9IR01LMzlwdlpNYS9vRE9mTVAzdndrNmtEa1U3ZTJ0eTkyOGsxUTc0eTcvWnF2NzZYbE1lbkJUK0RCWUIzVGhiY2ZJZWFxK1oyc0FNQUFJQjY1NGM3QUFBQWdMdnpVbXVOcVFQUXMzMzhHeXYyUGZLRFI3WEZFSFpQblFVQS9sb3hobEd4SVN6ZmYwYkhEWG14N3VMNVo0NTRQblVtMG1uLzNLZ1h5K0dzSVcwTFoxZGpOaTNFY0dEcVRBRFFHOFFpTkFWYjJGRmpxN00xcnBFREFBQkFuVk93QXdBQUFDd2VvTFppb1dESEgzWFlUU3UyYjJ5cVhKRlZLc2VVVTh2bEFOZ1lWY3BQc05PeTJQQ0ovV2QyWFByR2swOWV1M1QyS2M2djYxaDd5L0FmbHNOQnc2NVpkRVFXNGxmTDR4MVRad0tBalpxQ0hSdEF3NnVOenVFQkFBQ2d6aW5ZQVFBQVFMMHJpblhkMjI5QURTblk4WHNPdnUzSi9uMURjWDVqVTJWaU9lMmJPZzhBdkFNR2xZOHJCK3k2MjJmM203bG93aVBqaHQyZk9oQnBMVHA3MkgyN1RyNW43aWFEdG0ySk1VNHFueHFZT2hNQWJJeGlGcHBTWjZEM2V5Ri9XY0VPQUFBQTZweUNIUUFBQUxBMmRRQjZ0Vi9HRUc1SUhZS2VJY3V5ZU9TdHkwL29GN012aHhDM1M1MEhBTjV4TWV3VVErVTcrOC9zZUNEUDEwMllmK2FJSDZXT1JEcFB0WTd0L3E1MXhlNVhMcjY1WDdXNE5NUjRjdWplOVJBQStCdGtidHhFN2IzWlg4RU9BQUFBNnB5Q0hRQUFBTlM1SW9aMTlxK2pCbGFYcjY1cDRhV1hMcHR6ZXZNYnFjT1EzbEczUFRuNHlGc2Z2N3A4dnhtY09nc0FiQUFIWlZuRDQvdk5iSitWdjk1MXlhTVhESDg1ZFNEU1dYSHUwT2ZLNGRSOXBpMmUzVkFwcmdveE5xZk9CQUFiaTZJSVRkSEZTMm9yeitlTTdVb2RBZ0FBQUVoTHdRNEFBQURxWExTREhlKzhlOEs2L1B3NWY3L2JmNlFPUW5wSGZPT0o3U3FWOE9VWTR3bGgvVnNPQU5TTmhoamkyWlZOcXAvYWYwYkh4Zk5mV0gxOTN0cmNtVG9VNlN5Wk1IUkZPZXczdkczaHNTR0xsNWVuUnU5UG13Z0FOZ3BOcVFQUTZ6bEhCd0FBQUJUc0FBQUFvTjRWSWRyQmpuZEVFY0tLV0lSejVueGlsL21wczVEZThMYjJ2bHR2Mlc5aXRSTFBMNmY5VStjQmdJUzJDREhNYU42cXoybk5NOXZQbVQ5dXlNT3BBNUhXd3BiaGQrMHdlZjU5Nzk2c1lVSUk4Y0x5cVFHcE13RkFqeFVWN0tnNU42QURBQUFBRk93QUFBQ2c3aFhGNmhCVjdIanJpaENlSzE5QkY4VjdmM3pqbkRsanUxTG5JYjB4dHo5eDdMdTI2bmRGZWJoOTZpd0EwSVBzR2tQODNuNHpPKzVidDdZNGQySExrSitrRGtRNno3UTJyeTZITCs4NWRkSE5mWnJDWlNIWTdSY0EvcGdZaWtZZmtkVFk2dFFCQUFBQWdQUVU3QUFBQUtET3hSRFdwTTdBUnF2NzdzNXRiM2F0blBLZFQrN3pXamh1bDlSNVNPemp0ejY1ZTR5aExjYTRiK29zQU5DREhkSFFHQS9hYjBiSDFXdUtsNmNzUHZQZzExSUhJcDBmVEJ6MnkzTDRoMkhYTEpnWmkwcGIrUVZ0U09wTUFOREQ5RWtkZ0Y1UHdRNEFBQUJRc0FNQUFJQzZGNk1GQlB6TmloRHV5L1BPOCs0Ky9xUC9uam9MNlgzOHhvNTN4VDU5dnBSbDhhUnltcVhPQXdBYmdhWVF3L2xOY2JOL2FKN1o4WVhIbnA5N1U5N2FtcWNPUlRxTHpoN1JrV1hac0tGdGp4MWZoSGg1RE9FOXFUTUJRRTlRZmk3MnQzOGROZWI2T0FBQUFLQmdCd0FBQUhXdkNHdUNWU3I4OVg1WUZPR2NPWi9ZNWFIVVFVanYwT2x6bTVvR3ZYdDgxcWZ2cEhJNk1IVWVBTmdJdmFzOEZiOWgzNjBPSHJmZnpNVXRqNHdiK21qcVFLU1Q1M2xSRG5mc2Z1VkQvOXkzMHUvOEdPUEVjdDQzZFM0QVNLeC82Z0QwZWdwMkFBQUFnSUlkQUFBQTFMMVlyQTRhZHZ4bEwrWkZjZkVMVDc5MC9ielc1czdVWVVqdnFOc2ZQNkp4czIydkxBOC9tRG9MQVBRQ3U0ZVFQYkxmekk2N08wTisvb0p4UTMrYU9oRHByRGozZ0RmTG9YV3ZhZCsvcWJIU2RFWDViZTJZNEVzYkFIVXFGcUcvVDBGcXFpZ1U3QUFBQUFBRk93QUFBS2gzUlJIV1JJdFUrTlBXbFMrU1dXL204WkovT1g3WGwxT0hJYjB4dHl6Zk5WUXJWMlVoRzEya0RnTUF2VXYzV2ZteDFaQWR2dC9NanFtdnJucnRpdDhVcmFoVHl5YnMzMTIwUEc3WXRJWFh4aXkybGErUVBWTm5Bb0FOclloaGdFdVgxRlNNQ25ZQUFBQ0FnaDBBQUFEVXV4aml5dFFaNkxHKzI1V0hDWGQvWXRjZnB3NUNla2ZmdW5TTEVKdStHS3ZWendiWEZRR2dsdnFXajRzMzdUdnc1SDJudDM5K3dkbkRiczN6WEsrOWppMmFNSHhCTm5ueVBvTUhmZXpFOGh2Y2xCakNOcWt6QWNDR1lnYzdhcTA4MFZhd0F3QUFBQ3lFQVFBQWdIcVhoM3hWRnJMVU1laFpmaHk2d3JuZlBINlgrMU1ISWIyOWIxamU4TDYrMWRORDFuUkpPZDBzZFI0QXFDUGJaVm04WmVUMHhlT2FaM2FNbno5dWNFZnFRS1NUdDdibTVYRFQwTWx6N3dtRE5wa1VRaHhmenB0UzV3S0Ftb3VoZitvSTlHNHhGQXAyQUFBQWdJSWRBQUFBMUx1c2lDdmRCWnJmZURrUDRZdi84ZXFhR1V0UDJXTmQ2akNrZDlTdFR4NzAzbjdWYWVYaGgxTm5BWUI2Vlo2cUR5Nkh4ZnZONkxoMTNicmk4d3RiaHZ3aWRTYlNXZHg2OEd2bGNNSGd0b1hYVldLY1doNlBTWjBKQUdxcEtNS0E2Tm9sTlJVVjdBQUFBQUFGT3dBQUFLaDNlUlpYMnIrdTduV0ZVRnkzS2wvYitzK2YyT09GMUdGSTc2amJsKzBVUStPMExBdUhwTTRDQUt3WHk3OCszZEFZajI2ZTJYNUY1OW93ZFdITGtGV3BRNUZPUjh2d1o4cmg2Q0ZYUHpZcUM1VzI4bmpYMUprQW9CYWlIZXlvdFNLc1RCMEJBQUFBU0UvQkRnQUFBT3BjVnVRclExU3hxMk1QRjUzNU9YTSt1ZXRUcVlPUTNwaGJuaGdVcXZHaUxEU2VWVTRiVXVjQkFQNUEveGppNUlhR2NOSysxN2FmdjJEOHNMdnpQQzlTaHlLZDl2RWo1MlhIM2JQN2tLSHZQalhFT0xsOGFzdlVtUURnSGFaZ1I2MjltVG9BQUFBQWtKNkNIUUFBQU5TNXJwQ3RxcVFPUVFMRlQwSWVKbjd6RTd2OFUrb2twSmNkZDAvbHFDUC83cFRZRUw4WWlyQlY2andBd0YrMGZaYkZPZnRldS9pTUVkTVh0eXc0YytpSzFJRklKNTh6dHFzY1p1NXg5Znc3K29UcVJTRkVOMHNBb0ZmSXhzOXQybjZUek5vbWFpc1diNlNPQUFBQUFLVG5JaFFBQUFEVXVhS3I4ODFRZFltZ2pyeVdoekRsemVkK2Z2VjN6ang0VGVvd3BIZjBiVStPT3VxSXY3dXFQTnd0ZFJZQTRHKzJielZteTVxbmQ5eTBMZzlmV0hUMjRGK2xEa1E2eThjM3YxSU81KzQ5YmY0TjFhemh5aGpESWFrekFjRGI4ZTRCWVdEcURQUitSUkh0WUFjQUFBQW8yQUVBQUFEdTBGc244dkwvNjV1S1Zhc3Z1dXNmOW5vMmhKMVQ1eUd4dzcrK2JJZkd4c2FwSVF0alVtY0JBTjZXTE1id21ZWktPTFo1UnNlVVo0dVhyMzdhalJUcTJ0SUp6VDh1aDBPSFhyWG9rSmdWVjRZUVA1UTZFd0M4RlpYT3JrR2hJVXNkZzk1UHdRNEFBQUJRc0FNQUFJQjZGNHRjd2E3M2U3UXI3MnE1K3hPN3JVZ2RoUFNPK3ZxaVRiTEcvcDlyYkdxY1VFNzdwTTREQUx4anVuZDR1WHlidU5rcEkyZDBuUHZZR1lQdlN4Mkl0QmFmTSt6K3ZVKzc0YUhxLzdmekdiRUlGNGNZTmt1ZENRRCtGckZTSFpRNkEzVWd1Z0VkQUFBQW9HQUhBQUFBZGErcmtyOVpTUjJDV3ZuUGtCY1hmUE1UdTl5Vk9nanBaWk1uWjBmdGVOU0pXZE9BS2VWMG05UjVBSUNhK1dBV3dqODNUKzk0dURNVzV5dzhZOGhUcVFPUnp0TFpwNndyaDdhOXA4Mi9yWnBWSjhjUVR5M252Z0lDc0ZFb1A3YzJUWjJCZWxEWXdRNEFBQUJRc0FNQUFBQ2VlU09FblZPSDRKMzFSaDdDNWZHWHIxODVwMlhJcXRSaFNPL2pkend4L0tnZGoyb3JEL2RLblFVQTJFQmlHRjBOY2ZtK005cXZYL3Y2eW92YlB6ZnF4ZFNSU0dmcGhPWVh5dUdNdmRzZW5kMFFxbGVWeDZOVFp3S0F2eVRHZkZBSVdlb1k5SHFaZ2gwQUFBQ2dZQWNBQUFEMWJzN1lzVjBuM1B0djNTV3N2cW16OExZVjVkKzNyaWs2TC96SDR6NzZ5OVJoU08rb201ZTlOMnRzL0VvbHhPTkQ5eko3QUtEZVZHT0k0NW8yNlg5ODgvU09TMWIrNjVPemZyT2pHWFZxYWN1KzNUc2FmbXpJdEFVZno3STR0VHhGL0dEcVRBRHdKOFU0S0hVRTZrQ2V2NUU2QWdBQUFKQ2VnaDBBQUFEUTdmV2dZTGV4YSs4cXVscnVPbTYzanRSQlNPL0lHNWIzcS9hdlhGQnBiSnhZK0xNTkFJU3dXWWpoNm42NzducHE4NHpGRSthZk1mU0IxSUZJcTMzQ2lIL2FhZnpjNzI2eC9jRHhJU3NtaFJBSHBzNEVBSCtnaUlQY0xvaWFLd283MkFFQUFBQUtkZ0FBQUVEbzN2ZnM5UkREMXFsajhKYjhQQy95Qys0Ky9pTjM1bmxlcEE1RFdsbVd4VEczclRpKzJxLzZsUmpDZTFQbkFRQjZtdmpoOGpHM2VYcjcvZVc1NDRUSHpoNzJkT3BFcFBQMDFRZXZLWWNyQm45MS9qZGlwV0ZLak9IRWNwNGxqZ1VBL3kwV2c0S0dIVFhXbVdldnBzNEFBQUFBcEtkZ0J3QUFBSFN2VTNrdGRRVCtacXZLeDlTWDEzWmRNZmZ2ZDN0enpuRjU2andrZHRSdGorODE1cmJIcnk0UGgwVnJ6d0NBUHlmR1E3Sktkc0MrMHhkZiswYlgya3VYajI5K0pYVWswdWs0ci9uWmNqaDU3Njh1bUZHcHhLdGlqUHVtemdRQXZ4WUhwVTVBNzFmRXdyVnhBQUFBUU1FT0FBQUE2TjdBTHJ5bWo3UFJLTXEvN2x4ZGhNLzk0M0U3L3l4MUdOSTc2dXVQYjF0cHpLWlVzdXpUd1k0akFNQmZyeUhHT0dHVGF0TUpJMmUwWDd6dzBaL2ZrTThaMjVVNkZPa3NQVy9FOGl6TDl0dG4ybVBIeEJDdktKL2FQblVtQU9wY1VRd0s3aUpFcmExYWJRYzdBQUFBUU1FT0FBQUFXTTlkZWpjT3kwSVJXdTQ4ZHVlRnFZT1EzcWhiNXZmWnZMcjVoRXBUNWNKeU9tQjlWUmJnRC8yc0NQbEZNY1E5UW9qamdwOExBSDlvcXl5RVdTTkhibmY2aUJtTHoxbHd4dEI1cVFPUlRwN24zU2VWZDIzZmRzKy9iQnUyblZnZW4xOCsraWVPQlVDZEttSWNwRjVIalJVdlgvL0QxOFBzc2FsekFBQUFBSW41UVRvQUFBRFFUY0d1WjN1MkNNV2t1Mzcwclp2ejF0WThkUmpTTy9xMko4ZHMzckQ1MVBKd2g5UlpnQjVyWlZHRXFTL20vM1hGMGxNT1cxbk9iem5nK2lYWFZTdVZhZVh4UWFuREFUMVFqTHRWUW5pNGVjYmllNHQxK2NSSFc0WS9rem9TNmZ5MFpleXFjdmppMEtuemJ3b04xY3ZLNDArVkR4MEhBRGFvR0lvdGZmeFFZNi9udWV1dEFBQUFnSUlkQUFBQVVJcEY4V3FJRnF2MFFLdUxFS1lWTDd4dzJaelRtOS80WnRnbGRSNFNHM1BMRXgrTjFkZ1dzOWljT2d2UVl4WGxaOGVkWVUzeHVibW43L1d6My8wWEQzMTJueCtWdzhFSDNmaURRN0x5ODZVODNpbE5SS0JuaTJOaVErV1FmYWN2bmxhc0tyN3kyTVJocjZkT1JEcUxKemIvdkJ4T0dIclYvQmtoVk50Q0RJTlRad0tnbnNRdFV5ZWcxM1BqT1FBQUFHQTlCVHNBQUFDZ0ZGOU5uWUQvcWJpM3N6Tk12UHY0WGV3Y1F2ZU9kVnZIR0M3TkdyS1R5MmtsZFI2Z3gxcldWUlF0RDV5ODU4SS85eDhxLy8zOWU5OXd3ME5ieEQzT0t0OWJMaXFmR3JTQjhnRWJqejR4eHMvSGZ2R2tmYWN2bnJUZ3hRZnRwRnpuRnAvVDNKNWwyZERCVno1MlFvaWhlMGU3YlZObkFxQXViSlU2QUwxY0VWd1hCd0FBQU5aVHNBTUFBQUJLK1NzaFpLbERFTHJYZEJTUEYxMmhaYzRuZHBtZk9ndnA3VHI1bnNhLysrRGZuUm16cUFBRC9EblA1cUdZOU9EUHZ2MVhGMkNXbm5MS3VuS1kxang5d2ExOSsvYjlVZ3hCZ1JmNFk3YUpNZDQ0Zkl1RFRoOTI5WUtXUmVOSC9Oa0NMNzFibnVkRk9YeGoxOG56N3gyd1NlV0NFT081NWJ4djZsd0E5RTdaY2ZjMGJyL2p3SUdwYzlDN0ZkRU9kZ0FBQU1DdktkZ0JBQUFBSWNUNGN1b0loT2Z5dkxnbzNQdmpHK2ZNR2R1Vk9nenBIWDNIazRmdHRPTk9YeTBQZDBxZEJlaXhWaGRGTVczTjJqY3VtM2Q2OHhzaDdQazMvd0x6enh6eGZEbWNlc0NOSFRNcW9YcFZER0hVT3g4VDJOaVY3dzE3VlN2VngwWmUyMzduMnM1MW4rczRaK1RQVW1jaW5hZGF1ejl6d2tWN1RmdisxeHBDd3hYbDk4bGpVMmNDb1BkNTN3Y2F0MHlkZ2Q0djJzRU9BQUFBK0EwRk93QUFBQ0FVUlh3bHh0UXA2dGJhVUlUcCthdHJ2ampubEQxZURjZnRram9QaVIxMXgrTWZyc1RLdEJqalFhRkluUWJvdVlwN085Y1dFeDg4YmE5bjNvbGY3YUdUQno5WkRxTVB1bkhabUN6RXFlWHhEdS9Fcnd2MEt1WHBTZmhrVTBQRFVmdE9YengxMVlzdlhyNjA5YkNWcVVPUnpySUorLyswSEk0Yk11MnhHVEZtYmVYeDdxa3pBZEI3NUxIUFZyYllwdVppY09NNUFBQUFZRDBGT3dBQUFDQVVSZGNyTVZxeXNzRVY0YjdPcm5YbjNYMzhSLzg5ZFJUUysxODN0Vy9lcjIvLzFrcXNqQXV1MndGL1V2Rmtuc2R6NW41bXozbTErTlVmT0htdmUwZE5ubjkvMDN2NlR3Z2hYbGcrTmFBV3Z3K3dVZXRidmo5YzNIZnpMZi8zdnRlMGYyNUJ5N0E3OHp4M1c0QTYxajVoNUtQWmNmZnN2Yy9nYmY1M2lQRkw1VlB2U3AwSmdJMWZwWkp2R1VLV09nYTlYcUZnQndBQUFLeG5vUTRBQUFBUThqeStrbG12c2lIOXNDc1BFKzQ2YnVjSFV3Y2h2VkdUNTFjSC9kMmcwL3IzN1g5Sk9kMGlkUjZncHlxZXo0dmlDdzgrK0o4MzVuUEdkdFh5ZDVyWDJyeTZITDQ4YXRheW14b2I0cFFZdzRuQnlsYmdmNHJodmVYajloSFhMRHBqeERXTFd4YWNQWFJwNmtpazg1dlBwcS90TkhudVhac04zR1JTZWR4U1Bob1R4d0pnSTVhSHNKVXZJZFJhRWNKTHFUTUFBQUFBUFlPQ0hRQUFBQkJpWVNIQkJ2Sml5SXRMZnZYakYyZlBhMjN1VEIyRzlNYmM4Y1NCbS8vZDV0UEt3NTFUWndGNnJIVkZFYTVkODhZYmw4NGIzL3hLT0htdkRmWWJ6enQ5cjJmTDRlU0RybDg2SzFheXRoakM4QTMybXdNYmsyRlpGdHYzbmI3NEc4V3FZdEpqRTRmOU1uVWcwbm02OWVEWHl1R0N2UzZmZjBPMXNYSmxkeE1UQU42S0xNKzJkSnNQYWkyRzZMbzRBQUFBc0o2Q0hRQUFBQkN5dkxDUW9MYTZ5M1F6dTE1L2ZmS2NrNGI0MzVwd3hKMlA3OWhZVkw2YXhleUkxRm1BSHUzK3NEYWY4TjNUOW5vNlpZZ0hQcnYzc2l6TFJoNTBYY2Z4SVdaZldiOXJGY0R2eTBLSUo4YStjZXpJNmUyWC9lTEZOZE9lK2ZWdW1OU3BaUmMwLzZRY2ppdy9QMkk0UDA4ZEI0Q05VSkVWVzBaRmJXck1EbllBQUFEQS82TmdCd0FBQUlRNy9zKzNYdjNVcnNkMmxZZVYxRmw2bXlJVUQrVHJPaWZNK2VSSGY1UTZDK2tkZXNlU2dYMURuMG1Oc2RJU1ltaE1uUWZvc1g0VThqRGgvcy9zOFVEcUlQOVBudWRGT2R5eDl3M2YvcWN0NHJ2UEw0OG5sbzkraVdNQlBjK0FHTUtVOTJ6UmRQTEk2WXNtUG5ibXNIdFRCeUt0MzN4K0FNRGZMSWI0cnRRWjZQMWlFVjVPblFFQUFBRG9HUlRzQUFBQWdKQzN0dVluM1B0djNZc0p0a3lkcFJkNU9nL0ZoRzhlczh2OXFZT1FYbmJjUFpXalA3N2p5WDFqMzB2TDZkYXA4d0E5MWt1aENKTlgvL3oxbWZOYW16dFRoL2xqbHA1eTJNcHl1R1MvV2N0dTdOTVF2aEppUEQ0RTIwb0FmMkNIR0xKdjdUdTlmWDdSbGJjOE5uN1k0NmtEQVFBYm5YZW5Ea0R2VjhUY0RuWUFBQURBZWdwMkFBQUF3SzhWeFVzaFJnVzd0KytWb2lndS9jbXJhNjlkZXNvZTYxS0hJYjJqYjN1OCtlZ2pkN3FxUE53OWRSYWd4K29zUDRpdlg3YzZ2L2loY1h1L21Eck1YK09SMC9mNldUbDg2cUFiZnpBekZLRXR4ckJYNmt4QWo5UWNLOW15ZmE5dHZ6RmZXMXkwNE55aHo2VU9CQUJzTkJUc3FMbXVvR0FIQUFBQS9KcUNIUUFBQUxCZUVlT0x0cDk1VzdyS3h3MWRiNjY3ZU02SkgzMCtkUmpTRzNQTEUrK3ZOR1NYWjVYS3NhbXpBRDNhUTBYZWRjNTNQN1AzRDFNSGVTc2VPSG5QaGRua3lZTVAyTzdRVDhjWXA1UlBiWnM2RTlEalZFSU1uODJhNHJFanJsMTg2YXN2L1dMNlU2MWoxNllPQlFEMGVBcDIxRnhsVlZYQkRnQUFBRmhQd1E0QUFBQllMNGF3VWV5WTB5TVZZZDY2dkRqbjdrL3M4bVRxS0tRM2F0YjhBVnNNMnZ6Q1NtTTJvWnoyU1owSDZLR0s4TytoeU0rNy96TjczWmM2eXR1VnQ3Ym01WEJ6K2Y1M1QwUGpnQXZMY3dydmY4QWZNeWlMOGNyTnRualBaNGRmMDM3ZXdyT0hmRHQxSUFDZ1o4cXlMRzcvK2JuYnBNNUJyMWM4OS94S0JUc0FBQUJnUFFVN0FBQUFZTDJpQ0M5RVc5ajliWXJ3VEZFVUUrODhkdWQ3VTBjaHZlN0ZYMk51ZitLRUxRWnRmbG13Z3hQd3A3MVdmdWhPK2RuUC82T3R0KzNnTk8vMDVqZktZZEtCczVmZG1EWEVxZVh4bU5TWmdCNXBwMG9XL21YZjZlMFByZ3VkNXl3K2M4U1BVZ2NDQUhxV2QxOTQvNWJsMEpBNkI3M2VhL21jM3ZXOUhBQUFBSGpyRk93QUFBQ0E5V0lzbmwrL2p4MS9qZGVLdkpqeTJuTS91L283Wng2OEpuVVkwaHQ3eDFORGpyN3RpYmJ5Y0hEcUxFQ1AxUldLNHNhOGMrMUZjMDhkK2x3SWU2Yk9Vek1QbnJiWE0rVnc5RUZmVzlZY1kreCtiL3hvNmt4QWozUmdRNmcrc2UvMDlwbGRuV0h5d3BZaGRnOEJBTmFyeFBqdTFCbW9DOCtuRGdBQUFBRDBIQXAyQUFBQXdLOFZ4UXZCRm5aL1NWNCtidTRLWWRLY1kzZCtOb1NkVStjaHNiRjNQUFdlOGsvTlplVWZuVThGRFZYZ1QzdTBNeFF0RDU2ODU0clVRVGFrQno2ejEvenN1SHYyT25EMCswOE9XYnkwZkdycjFKbUFIcWY3WjVWblY2ckZwMFpPYjc5azRZdHJadWV0eloycFF3RUFhY1VRRk95b3VVTEJEZ0FBQVBnZENuWUFBQURBZWtYSW50Y08rck1XZElXOFpjN1lYWDZRT2dqcERXOXI3N3Z0MXYwbXhoalBMNmY5VStjQmVxei96RU80NExzbjdYRlg2aUNwNUhQR2RwWEQ5YU91bm45WFEvLytGOFVRenl6bmphbHpBVDFOM0tMOExuTHRpTTJiVGhzNWZkR0V4ODRjOW1EcVJBQkFPZ3AyYkFoUndRNEFBQUQ0SFFwMkFBQUF3Sy9GNGdVYmNQMFJSZkhUUEJUbjMzWGNibmZuZVY2a2prTmFXWmJGbzI5ZGNjeTI3K3AvUlRuZFBuVWVvTWQ2b3lpS3kxOTliZDJWQzF1R3JFb2RwaWVZTjc3NWxYSTQ5Mk96bDExZnJjYXZsc2VIcGM0RTlFQXg3QnhEOXNESWF4ZmYxeGs2ejF0ODFzaC9UeDBKQUVoQ3dZN2FLeFRzQUFBQWdQK21ZQWNBQUFDc0Z6dTduZzlWbHdwK3g1dEZDRmZrOGZXcGM4WU9XZlhOWS9MVWVVaHN6SjByOWp6NjlpZmF5c01ScWJNQVBWWjNFZnZXenJENndnZE9HdmJMMUdGNm91K2R0dGZUNVhENGdWOWJlbEFXc21ubDhZZFRad0o2b25oRU5UUWNQUExhOW10V3IzcnpTMHZQSC8xcTZrUUF3QVpVeEczZEI0emFLNTVMblFBQUFBRG9PYXlhQXdBQUFOWXJxdkU1NjFiV0s4cS9idTJLNno0L1oreEhmcEU2RE9rZGZzdXliZm8wTlUycGhPcUo1VFJMblFmb3FZcjJyczdZTXZlVVBUcFNKOWtZUFBpWnZSOFlOWG4rUnhxMzdUY3V4S3kxZkdyejFKbUFIcWV4Zkp6WFZBcTgrQUFBSUFCSlJFRlVwMi8vVDQrNGR2RkZpeGI4NHNaOHp0aXUxS0VBZ05xTE1idzNkUWJxUUl4MnNBTUFBQUIrUzhFT0FBQUFXTytGbGZtdnR1cFhTUjBqdGZhaXE3UGxqdU4yVTQ0Z0hEcDlibFBmTGJjYjM2ZXBhVkk1SFpnNkQ5QmovYnpJOHd2bm5yTFA3WG1lRjZuRGJFem10VFozbHNNMUI4eGNlbnVsTWJ1a1BENHQrTGtGOEllMmppRmVOMnpFZTA0YjN0Wit6c0tXSWZOVEJ3SUFhcXdJNzdPREhUVlhCQVU3QUFBQTRMZjhvQm9BQUFCWWIrN2Y3L2JtQ2ZmKzJ4dmw0WURVV1RhNEl2dzhoUHpDTzQvYlRUbUM5WTc1NWhNZjc3ZmxkbFBMd3crbXpnTDBXS3RDVVV6dGV2bWxLK2FlZThDYjRlUThkWjZOMWtQajluNnhITTRhL2JXbHM2c2hUb3NoSHBnNkU5RHp4QkIyajVYd3lNaHJGOS9WbGErOVlOSDQ1djlNblFrQXFCRTcyTEVCRkxGUXNBTUFBQUIrUzhFT0FBQUErRjNQaGZvcTJLMEtvWmo2NHBxdUs3b0xocmNmb3h4Ujc4YmM4ZFN1bFJpdUNqRWJuVG9MMEdNVjVkOTNyeW5XbnYrOWs0YitOSFdZM3VUaHorejl3M0k0NktDdkxUc2lodmpWOG5qSDFKbUFuaWdlVzhtYWpoaHh6ZUpwcjc2ODlyS25XcHZmU0owSUFIam52T2UwYi9kcjJMSnh5OVE1cUFOZDhWZXBJd0FBQUFBOWg0SWRBQUFBOEZ0RkNMK0tJZXlRT3NjRzBMMUwzZDFyMXE0NS81NVA3cTRjUVRqeW04dTNiQXJWeWRVc25scStPQ3FwOHdBOTFvcXVvcXRsN2tsN1A1bzZTRy8yd0dmMnVtL1h5ZmZNM1hiYkQ3VEVHQ2FWVHcxTW5Rbm9jZnJFR0Q4L2FQT21FNGRmMDM3aDRwWmh0OXFKR2dCNmh6aW93ZTUxYkJDeDZQcXYxQmtBQUFDQW5rUEJEZ0FBQVBpdCtPc2Q3SHEzSWl3ci80dWVjL3ZZRHk5SUhZWDA5cjVoZWNNSE5tazRveWswWEZ4T04wdWRCK2l4bmcxRk1lbTdQL3YyelhscnErMU9ONENuV3NldUxZY3JEcjV1OGMwaGE3eTAvT3crT1NoQUEzOW8yeXlHVzRaZnZYRGN5S3NXdFR4MnpyRDIxSUVBZ0xlblVzM2Y1OVNmRGFEclY3OWM4MExxRUFBQUFFRFBvV0FIQUFBQS9JN2l2OWJYN0hxaElvUm5ZNUZQdXZOSDMxS09ZTDFqN256OGtBOXNVcjJ5UFB4UTZpeEFqN1dtL0FDNU9xenNuUEtkTS9kNUxZUTlVK2VwTzNOUEhkcGQvai8xd09zV3o0NlZocXZLNCtiVW1ZQWVhWENveGtVanIxMTBaK2ZxZFJjc250ajg4OVNCQUlDM0pndnh2YmFscGZhSzUvSTVZN3RTcHdBQUFBQjZEZ1U3QUFBQTRIZjlWK29BTmJBNmhLTHQxYlZ2WHZhZFQrN3oydTFobDlSNVNPeVlieTcvVUFqVksyT3NISkk2QzlDai9WTmVySjM0M1pPRy9DUjFFRUo0OE5TaEs4cGh2d08vdHZUWUdPTGw1Zkg3RTBjQ2VwNVkvdjNKYXAvR0kwZGVzK2lLUFAvbDFJVXRZMWVsRGdVQS9LM2krMUlub0M0OG16b0FBQUFBMExNbzJBRUFBQUMvdFg2WHQ5UWgza2xGdUhkdFp6N3g3dU4zZVNaMUZOSWJjOHNUZ3lwTjJVVXhOSnhWVGh0UzV3RjZyS2RDMFhYT2QwN2ErK0hVUWZoREQzNW03N3RHVFo1L1g4TzcrMDhJV2Jpd2ZHcEE2a3hBajlNL3hEZzVxMngzMHZCckY1Ni9lUHpJdS9NOHR4RU9BR3dreWcvdDk2Yk9RQjBvWW0rODBSd0FBQUR3TmlqWUFRQUFBTCtyZHl3c0tNS1RJWVp6YmovbXcvTlNSeUc5N0xoN0ttT1AydW5VYWxNMnVaeHVtVG9QMEdPOVVCU2hkZTREejF5WHp4bmJsVG9NZjlxODF1YlY1ZkRsZzJZc3VybG9hcndzaG5CQ1dMOXpGY0R2MlQ0TDJaemhWeTg4YStpMUMxc1duelg4QjZrREFRQi9XU3ppK3dwbjk5UmF0SU1kQUFBQThQc1U3QUFBQUlEZnlvdml2eXB4NDEzQlVvVHdmRGw4b1N2KzZNWTVZNVVqQ09Ib2J6NDVhdXhSSDdxcWZIWHNsam9MMEdPdEt6OUFacjIrZHRVbGo1NDIvT1Z3MGg2cDgvQlhldUNNWWI4c2gzOFlmVVBIekdxc3RKWEhRMUpuQW5xa0VkV1FMUmw1emFLYjE2NWRONm5qdkdhTHFRR2dKNHZoQTZralVCZWNFd0lBQUFDL1I4RU9BQUFBK0sydW92Ty9LckV4ZFl5M1ltMEl4ZlRWYjNaZWV1OC9mT1NWRUQ2Y09nK0pIWFBudis0UVk1aGFDZG1ZMUZtQW5xejRibWRubUREM2xEMStuRG9KYjkzRHB3enV5TEpzMk9qWlN6NlZaZUd5OHFuM3BNNEU5RGhaaVBHa2hxYkdzU092WFRUbHVaKzhkdlhUVngrOEpuVW9BT0QzWmFNbVY5OC9iT2o3VXVlZzk4c1Y3QUFBQUlEL1FjRU9BQUFBK0szbmYvaktyN2JiZGV2dW5kOHFxYlA4dFlvaWZMc3JkcDAzWit5dVQ2Zk9RbnFIM3JGa1lQK3MzNlFZdy9oeTJwUTZEOUJERmVISFJaR2YrNTJUOTd3L2RSVGVHWG1lRitWdzIrNVhQdlNQVzI4eTZQd1E0OFJ5M2pkMUxxQm5pU0VNTFA5NStWWWYzUFRVWVZjdm1yaG8vTEI3VTJjQ0FQN2I5bnZ0K2Q1eWFFaWRnOTR2RnZrdlUyY0FBQUFBZWhZRk93QUFBT0MzNXJVMmQ1NXc3Ny85cWp6Y05uV1d2OEtQaXE3aW5EdU8yL25CMUVGSUw1czhPVHQ2cDZOUDdCLzdUaW1uMjZUT0EvUllyNFFpWFBxcnJ1TGFwYWZzdVM1MUdONTVLODQ5NE0xeWFQM1l6TVUzWmRXR0sySU14NFQxblJxQTM3TkRsc1Z2amJobThid2lYOWV5c0dYZnAxSUhBZ0JLamRVZFVrZWdQblIxNVQ5UG5RRUFBQURvV1JUc0FBQUFnUC9wRjZGbkYreGVLa0l4K2RsL2ZXRm1keUV3ZFJqU0czdkhFOFBIN2pTbXJUemNLMFFkQ3VDUDZncEZ1RzVsWjlFNjc1UTlYa2dkaHRyNzNyaWhQeTJINHc2OG9lUGFXRlRhUWd4N3BzNEU5RUF4aklxVi81KzlPNCt6cTZvVHZiM1dQbFVaSWN5REtCZmt0ZzJDUUJJeWgxQVFVR2xVV2lFUW1RTTBNaXFWUUpnaWxvRkdJQ0VUTTNLeFVVUU1Sa0FRR2xBaW1STUNCQWlETkRaS3E0ZzRNSk9wYXU5M3gvYSt0MjBJelpEVTJsWG5lVDZjV251Zmo1THZIOFdwWFNmN2QxYmprdDB2VzNETmlsVXJXeGFQYWZJekFnQlNLckx0ZkR3RzdTSnYrMjNxQkFBQUFLQmFETmdCQUFBQWY2TUl4VzlqaVAxVGQ3eU4xcUlJVjdhRk1INzZpSjMrSEE1TW5VTnFJNzYzWkpzc2E3d295Mm9qZzkySmdEV2JtYmVGMFhjZDIrZXgxQ0cwdjN1UEd6ZzNHejkrd0Q1Yi9jT29HREs3bkFKdnAxWStUdXJhMk9XUW9kUG1uN2Z5cVNldVdIejFjWFk1QllBRVlpaTI4eFlQN2FEdFR5KzAvUzUxQkFBQUFGQXRCdXdBQUFDQXZ4RkRyTnluOXhZaDNOdFdoTkhUUit6NFpPb1cwdHYzdTQvMVhMOGhucEZsaldQTDArNnBlNERLZWpZUFlleGRvL3Jja2pxRXRQS1dsdkpiSVh4cjhPVVB6T2pWTlk0cnIzWk9MYys3cHU0Q0ttZWptTVVwWFhmNnhQR0RMNXQvMm9JdkQ3a3JkUkFBMUowWS8zZnFCT3JDQy9uMEVXMnBJd0FBQUlCcU1XQUhBQUFBL0swaS9MWTZIeFJkUEpNWDhmVHZqZGp4OXRRbHBKZGxXVHpncGtjUDZkV1lYVngrbjM0a2RROVFXYStXand1SzEzOC83YTVUOWwyUk9vYnFXSERLZ05YZkcyY092MnJodFkwTkRSUEw0OCtuYmdJcWFZZGFpSGZ1ZnRtQ3U4S3FjTnJjTVlOL25qb0lBT3BHRWJhcnp2dVNkR0svU1IwQUFBQUFWSThCT3dBQUFPQnZGZmx2UXN4U1Y3d2NpbkQrcWhBdm56NWl4NVdwWTBqdjRPbVBEVHp3ZTQ5TmpTRU1TdDBDVkZaZUZNWDF5NWJuNDJhZTJPK0YxREZVMTh3VEIvMmlYTDd3Nlc4dTNqdkVPS1U4M2psMUUxQkorNFhHOE1taGw4Ni80dlZseFhtUG5qbjBwZFJCQU5EWkZURnNaNzZPZHZEYjFBRUFBQUJBOVJpd0F3QUFBUDVHV3d5L3JpWDg0ME1vcmx1MnJPM2NIeDYreTR2cE1xaUtMMHgvWkt2R291SENFTE1qWXZRWjVzQWFGR0ZlQ0szTmR4N2QvOEhVS1hRYzkzeXAvMzNaeUJsOTlobSs3ZkVoQytQTHB6Wk4zUVJVVG1ONUNkcThmdmQ0K082WExtaVpQKyszMStUVFI3U2xqZ0tBem1qYmMrN2FLTXNhTmtyZFFSMG9DanZZQVFBQUFHOWh3QTRBQUFENFc2M2gxNkd4L2YvWUloUXp3NnBpOUkxZi9NUmo3ZituVXpYRHZ6MnIyNmJkTmg3VEdCck9EakdzbDdvSHFLem5panljOWEvL3ROdjBQTStMMURGMFBIOGRsTGx5ajZ2bjNkU3QxdVZySWNTVHkvTUVWMEpBeGEwZXdMMWk4TkN0VHRoOTJvTG11YWNPbnBrNkNBQTZteUxVL2k1MUEvV2hLSUlCT3dBQUFPQXRETmdCQUFBQWYrT1ZQL3o2Tnh0dnRjM3FJWVgyMmkzczJSQ0tzVGNldU5NdDdmVG5VWEVqcHk4ZHNWblhUU2FVaHg4MUxRT3N3UnRGS0NhOC9QTEtpZk9hQnkwTHgrU3BlK2pnWnA4dzlLVnlHVDM4MmdYWE5JU0dTZVZsMEg2cG00RHFpU0h1WEg2NWIvZExGOXl5S3MvSExtb2UrbXpxSmdEb0xMSXNiSis2Z2ZvUXMyakFEZ0FBQUhnTEEzWUFBQURBMzdqemxIMVhISEhMVXkrV2gxdXMyeitwZUswbzRqZCs5OFlmcHM0OHFtbjV1djJ6NkFoRzN2Um83NURWcG9ZUW05cHR2QlBvYUZiUDNkNVV0SzA2ODg1akI3Z2hqclZ1NW5HRGYxNHVuOW5ubXcvc2w4VzRldEJ1aDlSTlFDVWQwSmhsbjlsOTJvSnBiUysvY3NHQ2xuMWZUUjBFQUIxZExNTDIzZytpUFJSdGJmK1J1Z0VBQUFDb0hnTjJBQUFBd050WmZaUEJ1aHF3eTRzaVhOOGE0cmpwSTNaOFlSMzlHWFFnQjM3M3NjMGJHclB6UTFZN3RqeXRwZTRCS210UjBSYWE3enkyejhMVUlYUitQLzNTZ0x2NlgzdnRUellzZW44NWhIaHVqR0hEMUUxQTVYUU5NWnhSMjNDREkzZWZ0bURjL0pmdnZUNXZhYkdsS2dDOFh6SGF3WTUyMGRiVytsenFCZ0FBQUtCNkROZ0JBQUFBYjFHRThPc1lRdjkxOEMrZWw4ZTgrWHNqZG5wd3JmKzc2WEJHanAvUnBkaCtoeTgzTkdibmxxY2JwTzRCS3V2NXZNalAvdGRqKzkrUTUzbVJPb2I2c2ZpNDQxYVZ5K1RoMTg3NlRxM29PVDdHY0h3d0NBNzhkekZzV1g2OWJzaEduenBweUtYem11ZC9aZWpjMUVrQTBDRVY0ZS90WUVjN1dQV25GOXArbHpvQ0FBQUFxQjREZGdBQUFNQmJ4QkIrdFpiL2xjK0ZrSi8xdllOM25tNDRndFZHVGwrNmY3SEREcGVVMzJzZlM5MENWTmJ5VUlUSmJ5eC85Y0taSnphOUhvNjJLUkJwekR5dTZZL2xjdktucmwxNGRTZ2FwcFlYU3NOVE53R1Z0RnNXc3RtN1QxdndnOUFXenBnN1pyQ2RVUURnWGNxeThkbTI1d3oySGhIdDRkZjU5QkZ0cVNNQUFBQ0E2akZnQndBQUFMeFZFWjViUzU4WS9VWlJGQk5hdzZzVHA0OFl0T3k3dWVHSWVuZlE5eC9kS2Nac2NnenhVejZVSEhnSE0xYTF0cDV4OXovMS8yWHFFUGkvN2oxdTBOSnkyWHVmYno1NFFCYkR4UEo0dTlSTlFPV1VsN25oNE5BUVByZjdwUXNtdnJIcTlRbExUdnZrRzZtakFLRHFQblRhZ0szTHBVZnFEdXFDRDBFQUFBQUEzcFlCT3dBQUFPRHRmTkFiRFlyU2pTdFd0cDA5NDlDZGY3TldpdWpRUm41cjRjYWhaOCtXR0dzblJlOUpBV3YyU0I3YW11OGMxVzlXNmhCWWs1OStxZDh0MjE5Kzk1My9xK3NtcDhZUXg1VlA5VXJkQkZSTzkvTHh0WjZONngwejlOSjVaeTVvSG5hVG5id0JZTTBhRytQMnFSdW9HLytST2dBQUFBQ29KamN6QVFBQUFHL1IycGIvcXFFaGUxLy8zeUtFUlhsYmEvTk5CKys4Y0MxbjBRRU5IeityWWRNZE5qb3A5dXpaRWtMYzJLNTF3TnNxd292bDEzUHZ2UHZmcjh1bmoyaExuUVAvazZkUDJYZEZ1VXdZZnRXRDMybG9LQzRvZjhhTktzL2YzOFVUMEpsOUpJYnN4c0ZUNW4xNXlLVnptK2QvWmZkRnFZTUFvSXJLbjVkL243cUIrbERZd1E0QUFBQllBd04yQUFBQXdGdXNXTmI2WE1QNlhkN3IvKzIzSWVUbjNIVFF6amZZbllIVkRwNys2S2MyMjJHVEtlWGhqcWxiZ01wYVdUNHVYZEZhL1BPOXgvVjlKUnpkSjNVUHZDY3pUK3ozUXJrY3UvZlZEMXhaeTdLcDVmSHVxWnVBQ29waFVBeTFCVU12blgvRDhoWGg3SWZHRG5rK2RSSUFWRW1Nd1E1MnRJc2lGQWJzQUFBQWdMZGx3QTRBQUFCNGkxdU8ydlhsSTI1NTZ1WHljTU4zOFQ5ZlZoVEZwRlZGdUhqNmlKMWUvMjZlcitzOEt1NmdteDc1V0pZMVhCSkRiZi9VTFVDRkZjWHRLMFByNmZlTUd2Qk02aFQ0b080N1ljQkRXWmJ0c2M5Vml3NHFZcHdRUTlnbWRSTlFPZVZMUXp5eVc5ZHd3TkJMNTEvNHU1ZFdUWDYycFdsNTZpZ0FxSWdkVWdkUUg3TENEbllBQUFEQTJ6TmdCd0FBQUt6Skw4dkhPMjBsVkpULy9DQXNYM0hHZHcvdDQ4WUV3c2hySDk0Z3JOLzR0U3hyT0tVOGZjOWJJQUoxNDRrOEw4YmNlWFRmZTFPSHdOcjAxeDE4Yng0NmRlRWRQWG8wakkwaG5GR2U5MHpkQlZUT2VpSEVDejYwVWVOeFE2Zk9PM05lODlDYlV3Y0JRQVY4SW5VQWRhS0l2MHlkQUFBQUFGU1RBVHNBQUFEZ2JSVWgvREt1ZWNCdVNXaHRiYjdoNEoxbnQyc1VsVFJ5NUl4YU9HQ0hZNHRlWGM0dnYyYzJUOTBEVk5hZjhpSjhmZGx6cjE0OXM2V3BOWFVNckN2em1nY3RLNWZ6aGwvK3dMZHFqZG5GSVlaRHdsOTJyZ0w0citLMklZdlRoMDZiZjlLcXRqajZnVEdEbDZRdUFvQVV0aDUzMnlhTnNjZVdxVHVvQzYyL1g3TDRQMExZTDNVSEFBQUFVRUVHN0FBQUFJQTFLSjU5bTN2Qlh5Z2Y0MjVjZXZQMWVVdExuaUNLaWhuNS9jZWJ3Z0U3VEMwUGU1c2NBTmFndFNqQ2xXMzVpdkgvZXN5Z1A2ZU9nZll5ODVRQnZ5bVh3NFpmL2NCbHRTeGIvYk55WU9vbW9JSmliR3BzQ0l1SFRwdC8zWnV0OGR3bHB3MStNWFVTQUxTbkxPKzZVNmlscnFCTy9FYytzOFVIL2dBQUFBQnZ5NEFkQUFBQThMYUtvdmhsalAvL3lOU0s4b2xwWWNYckY5eHc2SUJYYnppZ0pXVWFGVER5dTQ5OU5EUm1FOHB2a1JGRjZoaWd1b3B3Yng1V2piNXoxSUFuVTZkQUtqTlBHTEF3eTdMQmUxMjk4SWdzWkJlV1QyMlZ1Z21vbkZxSThVczlHc1BJb2RQbS9mT3JMLy91MHFVdEkxYW1qZ0tBOWxDTDJTZFNOMUFmaWhDZVRkMEFBQUFBVkpjQk93QUFBT0R0RmZIWjFSdllGU0hjRWtMYjJPOGUrQWszSUJCR1hqVnJ2Ymp4eG1mSHhteE1lZG90ZFE5UVZjVXpJYzlQditQb2ZyZW5Mb0VxeVBOODlUejZkNFpmTmV1V1d0Ymo3UElheTg5UjRPMXNFR0kyY2YwTnQvclNrQ256VDU4L2VvaWZvd0IwZWtVV2Rvci84LzhNUHJpaStQZlVDUUFBQUVCMUdiQURBQUFBM2xacldMVzBJVy9jKzhZUk84NU0zVUo2V1piRkVUYytla1MyOFNaMjNnSGV5U3RGQ09jOTk2dG5MN2Z6RHJ6VnpCT2JYaStYY2NPdldYUnRMY2FMUTRnSHAyNENxaWVHOExHUWhSOE5uVGJ2M3JZaWpGbllQUFNKMUUwQXNLN0VFSGRLM1VDZGlIYXdBd0FBQU5iTWdCMEFBQUR3dHFhUDJQVzM1ZkxiMUIya2QvRDBSNFljL1AzSHBvWWk5RS9kQWxSV1cva2FjZDJxRmN2UHZmdjR3UytHMENkMUQxVGF6T01IL3FwY1J1NTk5Y0lyczZ3MkpmaVBCbmhiOFZPMUdCNFpNblgrMWZueTVWOWZlTmJ3UDZVdUFvQjF3SUFkN2NXQUhRQUFBTEJHQnV3QUFBQUFlRnNqdnJmMEk3V0dlSEVXR3c0SmY5bElBK0R0RkxOQ3lKdnZHTlh2a2RRbDBOSGNkOEtnV2RuSUdmMzMydnQvSFp1RmVINzUxT2FwbTRES2FZZ3huRkxyM3UzUUlWUG1qbC80YXR1VmVVdFRhK29vQUZnYnRqdnpyaTFEWThPbXFUdW9EMFZiWWNBT0FBQUFXQ01EZGdBQUFBRDhqWkZURjNZUFc2MDN0cUVobmxHZTlremRBMVRXczZFSVkrOFkxZmVXMUNIUWtlWFRSN1NWeXpmN1Q3aHYrZ1licnYvVkdPSlh5dk11cWJ1QXl0azRaTm0wZ1J0a3h3K2VPbi8wZ3VZaDk2WU9Bb0FQcW1qTWR2S0pUclNYVmFITmdCMEFBQUN3Umdic0FBQUFBUGlMTE12aWlPOHZIWmx0dGY1RklSVGJwTzRCS3V2MUloUVh2aEZlblR4elZOUHkxREhRV1N3K1krOVh5bVhzbnQ5ODRKdU5SYndreExCLzZpYWdlbUlNTzViTFBVT216Yis5V05WMitvTFRoejJUdWdrQTNxOGlaSjh3WUVjNytlT2ZKLy9qeTZrakFBQUFnT295WUFjQUFBQkFPSGo2RS8wTy92NWpVOHZEb2FsYmdNcktReWkrc3lLUDQrNDV1cy96cVdPZ3M3ci9Td05XRDh2ODR6NVhQZkNwa01YSk1ZYWRVamNCbGJSL2JLenRPMlRhdk11WGg5YnpIejYxeVEzakFIUTRXUWk5VXpkUUg0b1FmQ2dCQUFBQThJNE0yQUVBQUFEVXNaSGZmbkRMMkszN0JWa01vMEtJV2VvZW9KcUtFT1lYZVRqMXgwZjNlVEIxQzlTTG41NDQ0TjdoNDJmMXpyYnNma0tNOGV2bFU1dWtiZ0lxcDB0NURUK21XMmc4ZlBEVWVlY3VXdkM3Ni9McEk5cFNSd0hBdXhhTDNxR3doeDNyWGl3TTJBRUFBQUR2eklBZEFBQUFRQjM2ek9WM2QxMXY4NCtNanQyN24xMmU5a3JkQTFUV3IvT1FuM1hYMGYxdXl2TzhTQjBEOVdabVMxTnJ1VncrZE9yQzcvWG9ucldFR0U4Sy9tNEhlS3ZOWTR6WERCcXkxWWtEcDg1dFh0UzgrNnpVUVFEd1A4bEd6dWl5N2QvMzJqRjFCM1hqMzFJSEFBQUFBTlhtTDJFQkFBQUE2c3pCTno5eHdQcWJiejJ4UE53dWRRdFFVVVZZVm9SaTRndXJpb3NYSDlmM3pYQlVucm9JNnRxODVrRi9McGRUUC9uTkI2NHBRcHdTUS9oVTZpYWdrbnJYWW5iL2tHbnpiMmtyaXJHTG1vYyttem9JQU5aazI0LzFXRDFjMXlWMUIvVWhMM0k3MkFFQUFBRHZ5SUFkQUFBQVFKMDQ2UHVQNzVKbGNVb1d3dkRVTFVCbEZlVS9ONjBLYldmOTY2aCt2MDRkQS95dG4zeHB3SlBsOHVsOXJsNjBmOHl5Uzhyamo2VnVBaXJwZ0ZxTSt3MlpPbS95YTYrMFhyaTBwZW4xMUVFQThGYTEzcWtMcUNOWlljQU9BQUFBZUVjRzdBQUFBQUE2dVgvOC9zT2Jkcys2aks5bDhmanl0SmE2QjZpc0IvUFd0dVlmSDd2YnZOUWh3RHY3NlFrRGI5OTUvSXk3dC96UU5xZVVwMThySHh1a2JnSXFwMXVJOFp6MU4yZ2NOV1RhL0hFTFgvN0pkL0tXRmx2U0FsQWgwWUFkN2FXSXkxWVlzQU1BQUFEZWtRRTdBQUFBZ0U2cS83VVBOMjYzUVpjdmQ4KzZubHVlYnBpNkI2aXNGMElveHYzNFY3ZGY3OFo3NkRpV3RveFlXUzZUZDc5bXdYZTd4NGJ6eStOamcwRjY0TCtMWWF2eTY3OE0ydkNUSncrY011ZlVSYU9IelUrZEJBQi9aY0NPOXZLN0Z5NGZZVWRmQUFBQTRCMFpzQU1BQUFEb2hMNTQwK1A3L2U5ZVhTZVhoOXVuYmdFcWEza1Jpc2t2NThzdW1uUDBrTmRDNkpPNkIzZ2Y1aDQvK01WeU9YNzRWZk92cW1VTlUwT0lUYW1iZ0VycVY4dHFjNGRNblg5VFc5RjIxcUxSdzM2ZE9naUErcFZsV2R4MjNOMjdwdTZnVGhUQjduVUFBQURBLzhpQUhRQUFBRUFuY3REM0g5K2hsc1hKb1JiL0lYVUxVRjFGQ0xlRXZIWHNIVWYzZXpaMUM3QjJ6RHh4eUNQbHN1YytWeTA2SU1Uc2toRERSMU0zQVpVVHk4ZWh0VkQ3L09DcDh5OStQancvOGJubUVjdFNSd0ZRZjdZNS9mWnR5MlhEMUIzVWh5S0dwMU0zQUFBQUFOVm53QTRBQUFDZ0UvamNUWTl2MURPTFg2OWw4Y1R5dERGMUQxQlpqK1ZGUHZySG8vck9UQjBDckJzL1BYSGdMY1BIejdvcmJ0RjlUSXp4N1BLcDlWSTNBUlVUUTQ4WXd2Z1BoNjMrYWREVWVXYzlNR2JZVFhtZUY2bXpBS2dqalkyMlVLZmRsTmM5UDAvZEFBQUFBRlNmQVRzQUFBQ0FEbXpreUJtMTdNQ1BINzllTFk0dlR6ZDFWeXl3Qm44b1F2SFZPKy84OSt2eTZTUGFVc2NBNjliTWxxYmw1ZktOWVZmTXY3NUxyZkhDR01NUjRUOTNyZ0w0cjdiT1FyeHgwT1M1SncyYU9yOTVZZk9RQjFNSEFWQW5ZdXlYT29INlVlVGhxZFFOQUFBQVFQVVpzQU1BQUFEb29BNmV2blR2N0lDUFR5a1BkMDdkQWxUV3FsQ0V5MTRQcjV3Lzg2aW1sOE9STmdtQWVqTG41Q0hQbDh0UmUxMjE0UEphVnBzYVFoeVN1Z21vcEtFeGhFV0Rwc3kvdm1oYk5XN1I2VTB2cEE0Q29IT0xzZWpuOHg5b0w2dXlGUWJzQUFBQWdQK1JBVHNBQUFDQURtYmtqVXYrTGpaMG1WaUwyZWRUdHdEVlZZVGlydGEydGpGM0hkM3Y2ZFF0UUZvL08zSHc0aXpMZHQvcnlrV0h4Qmd1S3AvYU9uVVRVRGxaK2Zwd1RHeG9QR2p3MVBrWC9mNlZWWk9mL2MvZE1BRmdyU3F2UytNMjQrN3VaN3lPZHZMR1M1TU8vSTh3TVUvZEFRQUFBRlNjQVRzQUFBQ0FEdUl6MzN1ZzEvcU5QY1psWGJxY0dvclFOWFVQVUZsUEZuays1dlpSZmU5SkhRSlVSNTduUmJsOHIvLzRIOS9XYTRzdHpvd3hqQzNQdTZmdUFpcG4vZkp4d1JZYk5CNDdjUEw4c1l2R0RMa2xkUkFBbmN2V1o5Mzl2Mk1JRzZYdW9FNFU0ZW0vL2k0RUFBQUE4STRNMkFFQUFBQlVYRForZkhid2pnZU82dFhZODRMeWRNdlVQVUJsL2JsOGpIL3RsNjljT2JPbHFUVjFERkJOaTFzKysyYTV0T3g1MVp6L1U4dTZYUlJET0tROHQ0RUk4Tjl0bDJYaGg0T216cHZaMmxhTWZ2QzAzUjlMSFFSQTUxQ3JGZjFkZnRKZWlsRDhQSFVEQUFBQTBERVlzQU1BQUFDb3NFTnVYcnJIeUIxSFRDMFArNlJ1QVNxck5SVEZOOTk4by9WclB6bXAvNTlTeHdBZHcvMG5EdnQxdVJ5Mjl6V0xyb3doVzMydDBTOTFFMUE5TVlUaGpiWDQ4S0NwYzY5ZHRUeDg3YUd6ZHY5RDZpWUFPcllpeEg3RzYyZ3ZNWWFuVWpjQUFBQUFIWU1CT3dBQUFJQUtHdkc5SmRzME5IYVpFR04yVVBDeDNzQWFGVDhKb1hYMGo0N3EvMFRxRXFCanV1LzRnZk95OGVNSDdyWGxQNHlLSWRvdEYzZzd0ZkwxNFlRdTNjSVhCMDJaZTM3YjAwOWR0dmpxNDFhbGpnS2dZNHBGNk8rZEx0cExVUlFHN0FBQUFJQjN4WUFkQUFBQVFJWHMrOTNIZW03VXBYWkdZMk9Yc2VWcDk5UTlRRVVWNFJkNURLZmRjV1NmMjFPbkFCMWYzdEtTbDh1M2hrMmMvNE91dlJyT0NTRTJsK2ZkVW5jQmxiTmhqSEZTd3c0N2ZtbndsRGxqRm93ZWRsZnFJQUE2bG16a2pOcTJmOStyYitvTzZrZGJ6QTNZQVFBQUFPK0tBVHNBQUFDQUNzaXlMQjQ4L2JIRE51cGF1N0E4L1VqcUhxQ3lYaTFDY2NFdmYvWHZVNWUyakZpWk9nYm9YT2FNSGZKYXVaeTl4OVh6cm0wTWpSTmpqQWVrYmdJcWFmdnlONWc3QjAyWmQwOHNpakVMeHV6K1pPb2dBRHFHclQvVy9lUGwwak4xQjNWanhaOWUrLzB6cVNNQUFBQ0Fqc0dBSFFBQUFFQmlCMDkvYk9ESTZVdW5sb2VEVXJjQWxkVldGTVcvTEd0ZCtkV2ZIRHZ3OXlIMFNkMERkR0t6VHhqNmJMa2N1TTgxaTRlWDY1VHlzVXZpSktDQ1lnaWZEakUrTW5qS3ZLdmVYQm0rL3VpWlExOUszUVJBdGRXS3h2NnJmNEJBZXloQ2VEcS8rcmhWcVRzQUFBQ0Fqc0dBSFFBQUFFQWlYNWoreUZiZHNvWUxhMW50aUJEY1hnU3MwZXpXMXJibU80L1piVW5xRUtDKy9QVDQvak96a1RQNkR0OXptK05DRnM0cm45b3NkUk5RT1kzbDR5czl1b1REQms2YTk3WEZyN2QrTTI5cGFrMGRCVUJGWldGdzZnVHFTRkU4bmpvQkFBQUE2RGdNMkFFQUFBQzBzK0hmbnRWdDh4NmJqdW1XTlo1ZG5xNlh1Z2VvcGlLRTUyTEl6L2pSa1gxdlR0MEMxSzk4K29pMmNybDYrTFJaMzQ5ZHU1OGJZdnh5K00rQkdvRC9hcE9ZaFNzRzlHbzRZZENVdWFNWGp0Nzl2dFJCQUZSUk1kaG5UTkZlaWhBTTJBRUFBQUR2bWdFN0FBQUFnSGIweFI4OGZ2QVdQVGE5dUR6Y05uVUxVRm12RjZHNCtFOS9YakZwWHZPZ1phbGpBRmFiZVdyVHkrVnkyckNyNTMrelMyeWNYQjd2bDdvSnFLU2RRNGcvSFRSbDd1MnRLOXRPZS9ETXBsK2tEZ0tnR2pZNWU4WUdHelQwMmpGMUIvV2pLQXpZQVFBQUFPK2VBVHNBQUFDQWRuRFE5eC9yMDFDclRjMUMzS05JSFFOVVZWRytQdHl3b2kyY2ZjL1JmWjVQSFFQd2R1YWNNT1RwY3ZuTTN0Y3MvblM1cmg2MGM1TTA4RGJpL2cxZEdqNDlhTXE4YVMrOSt0b0ZUN2ZzKzJycUlnRFNXcSsyL3FCeXlWSjNVRDlhVnhVRzdBQUFBSUIzellBZEFBQUF3RHAwNEhjZjI3eHJsOXJDWDByc0FBQWdBRWxFUVZUNWpiWGFzZVZwTFhVUFVGa0wyL0s4K2NlaitpNUtIUUx3YnR4M2ZQOTcrcDl3YmU5ZWZYcWZXSjUrdlh4c2xEZ0pxSjZ1NWVPTWpYcXRmOVNneVhPLytzQnI5MzByYjJuSlUwY0JrRVl0aE1HcEc2Z3JyNzk4K2Y2L0NwZTY5QUFBQUFEZUhRTjJBQUFBQU92QXlQRXp1bVFmLzNoejE2NjFjZVZwcjlROVFFVVY0VGQ1VVp4OTV6RzczWmpudVEwdWdRNWw4ZFhIclNxWFN3ZGRPZlBHbm5HOTgwSU1Yd3IrN2dsNHF5MUNqTmNPNkxYUFNZTW16MmxlT0diWTdOUkJBQ1FRb3dFNzJ0TVQzbWNCQUFBQTNndC95UWtBQUFDd2xoMDZmZW4rdFIwL2ZrbDUrTEhVTFVCbExRdEZNWEhGSC84NDRlN1RQdmxHR09VVDFZR09hK0ZKdy85VUxpZnZkY1hDcTdOYU5xVTgzanQxRTFCSmZVTE1aZzJjUFBmbXRyRHFqQWZIN1BWYzZpQUEya2VXamMrMkhUZDRZT29PNmtnUkhrK2RBQUFBQUhRc0J1d0FBQUFBMXBLRHZ2L29UbzIxaHNraHl6NlZ1Z1dvck5XZm52NkR0bFhGR1Q4K3BvK2J5b0ZPNVdjbkQxcGFMdnZzZWZXaS9Xc2hUaXFQL3k1MUUxQTlNY2FERzBLWHp3MmNQSGZTbTYrMVhieTBwZW4xMUUwQXJGdGJuemxncDNMWklIVUg5U09QNGRIVURRQUFBRURIWXNBT0FBQUE0QU02OEliRm0zVHAydVByamJXR0U0TDNXNEExVzlKV0ZNMC9QckxQN05RaEFPdlMvU2NNdkgzN3krKys1eU8xalU0Tk1ZNHJuK3FWdWdtb25PNHh4cS8yN05WdzlJQXA4ODU1OExSaE4rUjVYcVNPQW1EZGlBME5nLy96ODJhZ3ZiUVpzQU1BQUFEZUV6ZDhBUUFBQUx4UHc4ZlBhdGh5eDAxUDZ0cXRSMHQ1dW5IcUhxQ2FpaEJlaUNFZmQ4ZXp0MStmdDdUa3FYc0Eyc1BUcCt5N29sd21ETGwwMGJlN2RZbi9IRU00cGp6UFVuY0JsZlBoOG9YaDJ3TW16VG1wMzVSWnpRK09ibHFZT2dpQXRhOThyUitTdW9HNlVyUyt0c0tBSFFBQUFQQ2VHTEFEQUFBQWVCKysrSU1uUDczbFRwdE5MZzkzRElWUDRBYmUxb3J5OVdGYTY2c3JMN2p6bEFHdmh0QW5kUTlBdTV2L2xZRy9MNWZqOXJwOHdaVlpMWnNhWXR3amRSTlFTUU1iUXNQOFFWUG0zYkJ5MmNwekhqNW5yOSttRGdKZzdTbEMyQ09tanFCdWxOOXZ2L3JUMVNOZVNkMEJBQUFBZEN3RzdBQUFBQURlZzVFemxtNWZLMnFYWkRGOE5uVUxVRjFGRVc2THJmblkyNDdwODR2VUxRQlY4TE5UQmkvSnNtelB2UzZmZjFESXNnbmxVOXVrYmdJcVovWHN4WkdOM2JvY09IRHkzQWt2L1BhRmljOU5HckVzZFJRQUg4elc1OTY3ZFdPSUgwM2RRZjJJUmJCN0hRQUFBUENlR2JBREFBQUFlQmNPK1BhakczYnQyWEJ1TGRST0NURjBTZDBEVk5iU3ZNaEgzMzVrbi90U2h3QlVUWjducTdmOXZYbm8xSVYzZE91V2pTMlB6eWdmUFJObkFkVlR2aTdFOFZ0K2VNdGoraythZDhaRFk0Zjk0Syt2SHdCMFFBM0JEc2EwczFnWXNBTUFBQURlTXdOMkFBQUFBTzlnNUl3WnRWclk4ZGh1UFJyUEwwODNUOTBEVkZRUi9sakUwSExIajUrNUpwOCtvaTExRGtDVnpXc2V0SHBIcXZPR1RsMTRYYmR1OFJzaHhDUENmKzVjQmZCZnhHMnlHS2IzdjJUT3lRTW16MjUrWU13ZVMxSVhBZkRlbFJkNUJ1eG9WM21iSGV3QUFBQ0E5ODZBSFFBQUFNQWFqSnp4ZUZNdDdEaTFQT3p0bG05Z0RWWVZSYmdpZi9QMTgrNDRZZWhMNFloZFUvY0FkQmp6bWdmOXRseU8ydnZLUlZlR0xFNHJqd2VtYmdJcWFZOFlhZzhPbUR6ditwaTNqbHQwZXRNTHFZTUFlRThNMk5HdVlvZ0c3QUFBQUlEM3pJQWRBQUFBd0g5ejBFMlBiOWZRa0Uyc3hleUExQzFBZFJVaC9HdkkyOGI4NktpK1AwL2RBdENSM1hmU3dFVlpsZzNlNjRxRlI0UVl2bEUrOWVIVVRVRGxaREdFWTBMV01HTEE1TGtYdlBMYzY5T2VucmJ2aXRSUkFMeXpEMzMxamkyNngyN2JwKzZncnJ6eSt5bWYvV1dZbEtmdUFBQUFBRG9ZQTNZQUFBQUFmelZ5eHBQcjFVSTR1MHRqTnFZSW9WdnFIcUN5ZnA2M0ZhZmRQcXIzWGFsREFEcUxQTS9MeTYvd25UNlRmdkxEalh2Mk9pT0VPTFk4NzU2NkM2aWNYakhFaXpmY1p2M2pCazZjYzlxaXNjTnVUeDBFd0pwMUs3b05XNzJkV09vTzZzcVN2LzV1QVFBQUFQQ2VHTEFEQUFBQTZsNDJmbnoyeFowT09ySWhoQXZLMDYxUzl3Q1Y5WElJK2ZtL1hWNWN0dmk0dnF0U3h3QjBSa3RPKytRYjVkS3krNVVMdnRVMTFpYUVHQTRxejkyVURmeDNmeGRxMlk4R1RwNTdYOTZhajE1OHhoNUxVd2NCOEZZeGhqMVNOMUJuaXZCUTZnUUFBQUNnWXpKZ0J3QUFBTlMxUTZjL01lU1FIUSthVmg3MlM5MENWRlpiRWNJMVlYbGJ5NCtPNi92SDFERUE5V0R1U1lPZks1ZVJlMTY1NElxWTFhYkdFUHFrYmdJcWFlK3NJWHQ0NE9RNTM4eEQzcko0VEpOck5ZQXFNV0JIT3l0aS9uRHFCZ0FBQUtCak1tQUhBQUFBMUtWRHB6K3hkYWlGaTJJdEhoTHNpZ0tzU1JGbWhwaVAvdEVSZlI1TG5RSlFqKzQvYWZEc2JQejRmbnR1c2U4eDVTWGJQNWRQYlpHNkNhaWNodkwxNGFRczFBN3BQMm51MThNelQxMjErT3JqN0RZTWtOZzJwOTI3Y2ExSDNEbDFCL1dsYlZWdUJ6c0FBQURnZlRGZ0J3QUFBTlNWa1RNV2RtOEl2Y2JHTEo1Wm52WkkzUU5VVXhIQ3M3RXRIM3ZicUQ2M3BHNEJxSGQ1UzB0ZUx2OW44T1VQM055OVZvd0xNWjVhbm5kTjNRVlV6a1paRE5PS3YvLzRpYnRObmozbW9URjcvR3ZxSUlCNmxuVXI5Z3doWnFrN3FDdXYvWEhha21mQ2xQMVRkd0FBQUFBZGtBRTdBQUFBb0M1a1dSYS9lUFBqaHpTRVhoZVZwMXZic3c1WWcxZERFUzVvZmZWMzArNDhaZDhWcVdNQStIOFduRExnMVhJNWMvaFZDNjhOUlRhcHZKNXo1eXp3RnVXdmVqdlVRbmJYZ0VsejcxcVpyeHJ6eU5pOW5rN2RCRkNYc216djFBblVtMkpKbnYvbHd6a0FBQUFBM2pNRGRnQUFBRUNuZCtqMEovb2RjdlBqVTh2RG9hbGJnTXJLUXlpdWI4dGJ4OTF4Vkw4WFF0ZzFkUThBYXpEenhFRy9LSmQvYkxweTRkNVp6S2JFRUhaTzNRUlVVQXo3ZGFrMWZyTC9wRG1YdGIyZW4vOXdTOVBMcVpNQTZrbDVqV2JBanZaVmhJZFNKd0FBQUFBZGx3RTdBQUFBb05NYU9lUEpMUnRDdUNEVzRxanlORXZkQTFSVEVjSzh0ancvOVk0ais3Z1JDNkFEbVhYU29QdUdqNS9WdDlpODI1ZGlpT2VWVDIyU3VnbW9uTVlZNDVpRzlXcEhESmc4NTJzUEx2cjl0Zm4wRVcycG93QTZ1MjNPdmZQRHRkQmwrOVFkMUpjaXhvZFROd0FBQUFBZGx3RTdBQUFBb05NWi91MVozYmJzc2VtWWhoRE9Dakd1bjdvSHFLem5pcENmZGZ1UnUwM1A4N3hJSFFQQWV6ZXpwYW0xWEs3YzQrSjVOelgwYXZ4NitXSitZZ3loTVhVWFVERXhiRlordWFyZmdDMVA3RDlwenVqRnB3MmJtVG9Kb0RPTFJlUGVxN2V3Zy9iVTJtb0hPd0FBQU9EOU0yQUhBQUFBZENxSDNQekVBUi9xc2RuRUVNTjJxVnVBeW5vamhHTENpMzljUG5GZTg2Qmw0ZkE4ZFE4QUg5RHNNNGUrVkM2bk5sMyt3RFcxckpnY1l2eDA2aWFna25hSklkNDNZTkxjVzFhMHJoajc2Smw3UDVzNkNLQXp5a0xjTzNVRGRlZlZQMDFkL0hTWXZGL3FEZ0FBQUtDRE1tQUhBQUFBZEFxSGZmL3hYVUpEbkpKbGNYanFGcUN5VnU5U2Q5UEtGU3ZPdlBQWUFiOUpIUVBBMmpmcmxBRlBsc3UrZTE3NXdINVpESlBMNCsxVE53R1ZkRURYaHE3NzliOWs3dFEzaWo5LzQ4bXgrNytXT2dpZ2svSCtITzJxQ01XRGVkN2lFNVFBQUFDQTk4MkFIUUFBQU5DaGpaenh5R2ExME9XODJKQWRWNTdXVXZjQVZWVXNLdHFLNXR1TzZyTXdkUWtBNjk3OUp3MjRxLzhKMS81a3ZWMTIrWEtNOGR6eXFRMVROd0dWMHkzR2NOWjZjZU5SQXk2WlBlN0JOMzUyZmQ3aXhueUFEMnJycys3WnZyRXgrMGpxRHVwTUVSNUluUUFBQUFCMGJBYnNBQUFBZ0E2cC83VVBOLzdkUnQyKzNGQjBPVGRFTjB3RGEvUjh5SXV6ZnpTcTd3MTVuaGVwWXdCb1A0dXZQbTVWdVV4dXVuenVEYlZhNDNraFJCL0lBTHlkTFVQTXJ1dTMzdDRuRHJoa2J2TURwKzgrTDNVUVFFZlcySmp0bmJxQitsUGtCdXdBQUFDQUQ4YUFIUUFBQU5EaGZQRUhqKy8zOXh0M214eUtzSDJJcVd1QWlscGV2a1pNZnVYMWx5K2NlV0xUNitGSW01RUExS3RacCt6K2gzSTVzZW5TUlZmVkdzS1VFT1B3MUUxQUpmVXJmNytjMDMvUzNKdFdyQ2pPZXV5Y1liOU9IUVRRRVJXaDJDZDZ3NDUyMXRhNmNuSHFCZ0FBQUtCak0yQUhBQUFBZEJnalp6eTVZME1JazJ0Wjl1blVMVUNGRmNYTksvSjQ1bDFIN2ZxcjFDa0FWTWVzcnd4OHJGejIzdk9xUlFka0lVNHNqN2RMM1FSVVRvd2hITnF0YS94Q3Ywdm1USXh2dkhMeDRwYlB2cGs2Q3FDanlFNjR0bkhiemJhMWd4M3Q3ZmsvVFB2Q2IxSkhBQUFBQUIyYkFUc0FBQUNnOGo1MzArTWJyZCtZZmIwaGhoUEwwOGJVUFVCVkZVdnlFRWIvNklqZXMxS1hBRkJkOTU4NDhKYmg0MmZkRlRiclBxWThQU3ZFc0g3cUpxQnl1c2NZdnhiVzIvRG8vcE5tbi9YUTJEMXZ5dk84U0IwRlVIVWYzV3pid2VXTFphL1VIZFNaSWp5UU9nRUFBQURvK0F6WUFRQUFBSlUxZlB5c2hnOTlZdE12OWVvU3p5dFBOMG5kQTFUV2kwVUk1OTUreHkrdXk2ZVBhRXNkQTBEMXpXeHBXbDR1M3hoNDFheHZkUS9kTG9naGppclBzOFJaUVBWc1hiNDAzTGpiaE5rbjk1MDB1L25oMC9aWW5Eb0lvTktLWXQrLzdBVUs3U2tXQnV3QUFBQ0FEOHlBSFFBQUFGQkpoLzV3NmQ1YmZXS3pLZVhoenJZSkFOWmdaU2pDcFc4c2Ivdm5lNC9yKzBvNGZOZlVQUUIwTUl0T2JIcWhYSTRkZHNYOHF4cGl3OVFRdzlEVVRVQUZ4VENrRnJKRi9TZk51U0hQVjV6OTBOaDluaytkQkZCSk1YNDZkUUwxcDhqdFlBY0FBQUI4Y0Fic0FBQUFnRW9aT2VQSnYydUl4YVFzMVBaUDNRSlVXQkZ1YjJzclRyOTlWTzluVXFjQTBQSE5PWG5JZzFtV0RXdTZiUDRoSVlzWGhSQzNUdDBFVkU0cy96a3lpOTBPNkhmSjNBdi8vRWJiNUdmL2N6ZE1BRW9mK3VvZFcvU0kzZnFrN3FEdXRMVzkzR2JBRGdBQUFQakFETmdCQUFBQWxmQ1o3ejNRYThPdTY0MXJqTVdwSWNTdXFYdUFhaXBDZUtMSXc1Z2ZIYm5ydmFsYkFPaGM4anhmdlhIeTk0Wk9YWGhybHk1eGJJamh6UEs4UitvdW9ITFdpeUZjc0VuUDJqLzFtempuOUFmSERyc2xkUkJBRmZTSVhUNFYvaktNRE8yb0NJKy8rSC8yZnkxMUJnQUFBTkR4R2JBREFBQUFrc3JHajg4TytjU0lZemJxdXQ0L2w2ZGJ1QThIV0lNL0ZYbjQrcXUvZlBucW1TMU5yYWxqQU9pODVqVVBXbFl1NSsxNTFaeC9DVVdYaTJLTWh3UVhxY0JiZmJSOGZmaGgvMHZtem1vTGJjMFBuOTcwU09vZ2dLU0tiRjlYVENTd0lIVUFBQUFBMERrWXNBTUFBQUNTT2VUbXBYc2M4b2tSVTJPSWZWSzNBSlcxZXBqdXl1VXJsNDMvMTJNRy9UbDFEQUQxNC80VGgvMjZYQTdiODZxRlY1VFhxOVBLNDM2cG00QkthcXFGMm9QOUxwbHpYZHNieTg5ZDB2TEpGMU1IQWJTM0xCdWZmWFRja0UrbTdxRCs1RVZod0E0QUFBQllLd3pZQVFBQUFPMXV4UGVXYk5PMVM5Y0p0VnJ0b0dBM0VHQk5pdUxlMEJaRzN6cXE5NU9wVXdDb1gvZWZPR2grTm43OHdHR2I3M3RrRnNJRjVWTmJwVzRDS3FkVy9tTDdwWWFlM1ViMm16RDd2QlhMWHJ4OGFjdUlsYW1qQU5yTDFtY04ycTFjTmt2ZFFSMHE4dm1wRXdBQUFJRE93WUFkQUFBQTBHNzIvZTVqUFRmcDFuaEd0NjVkeDVhbjNWUDNBQlZWaEdlS21KOSs2eEc5YjArZEFnQ3I1UzB0ZWJsY3YvTlZzMlpzRXJxZEhVTVlVNTUzUzkwRlZNNEdNWXVUdXZYYzRvVGRKczQ1L2FHeHcxelBBbldobHNYOVVqZFFsLzd3NHBSLy9QY3dLVS9kQVFBQUFIUUNCdXdBQUFDQWRTN0xzbmpvRDVZZXNXbjN4bStVcHg5TzNRTlUxc3Q1Q09mLys3Ly9teDAvQUtpa3BTYzJ2VjR1NC9hWU91KzZyR3ZEeEJqQ0FhbWJnRXI2V0JiRGovcGZNdWZldkhYVjZJZk9HbTVIWnFCVGl6RitMblVEOWFjb3dvSTh6NHZVSFFBQUFFRG5ZTUFPQUFBQVdLY08vZUZUQXcvNXdSUFR5c09CcVZ1QXltb3JIOWU5V1lSejd6NThseGREMkNWMUR3QzhvOW5OUTU4dGx3T2JMbC9ZbEdWeGFubmNPM1VUVUVtZmlnMk5qL2FiT09mS0ZXOHVHNyswNVZOL1RoMEVzTFp0ZTlidFc5VWF1L2ROM1VIOWlTRXNTTjBBQUFBQWRCNEc3QUFBQUlCMVl1U01Sei9jR0x0OEl3dmhpUENYK3gwQTN0YXMwRm8wMzNMVXJvK2tEZ0dBOTJyV0tZTm1aU05uOUd2YTQ4UEhocGlkWHo2MWVlb21vSElheXQrSXY5SzFaL2ZEK2syYzgvV0gzOHl2emx1YVdsTkhBYXd0dFZxM3p3VHYvWkZBVzJpYm43b0JBQUFBNkR3TTJBRUFBQUJyMWNnWkM3czNoRjVqRzJPWE04clRucWw3Z0tvcW5zMkxPUGEydzNlNUpYVUpBSHdRK2ZRUnEzZGkvV2JmYWJOdTd0WFk3ZHdZd2lubGVaZlVYVURsYkJKaXVLeHZ6K3lFdnBmTUdmUHc2Y1B1VFIwRXNEWVVNWHpXZEIwSnJQaER2bUp4NmdnQUFBQ2c4ekJnQndBQUFLdzFoODk0ZkxmR3VNRVB5OE50VXJjQVZWVzhYbjY1OE9YV2x5ZlBQS3BwZWVvYUFGaGJIajYxNmVWeU9XM1lwZk8vMmRCUXU2UTgvbXpxSnFDU2RzcEN1R2UzUytiY1hoNmYvdERwdzU1SkhRVHdmbTF6Mm96dURUMDIyQ2QxQjNXb0NBL2xrMFlzUzUwQkFBQUFkQjRHN0FBQUFJQzFwaTB2R21zMXczWEEyOHJMeDNlS2xjVzRXNC91L1h6cUdBQllWK1o4WmNqVDVmSzVQUytmLzZtWVpWTkNpRHVtYmdLcUo0YXdmN25zMisrUzJaZStuSy82NTErY3NmY3JxWnNBM3F1cysvckR5NlZINmc3cVR4SERuTlFOQUFBQVFPZGl3QTRBQUFCWWEzN3h5cXFIdHQrNDRZM3lzR2ZxRnFCUzVoZEZmdXF0aC9kK01IVUlBTFNYKzA4WmNtODJmdGF1VFp0MU82azhiU2tmRzZkdUFpcW5Td2p4OUEyekxrZjJtemo3M0ljZmZQRzZmUHFJdHRSUkFPOVdqTkdPdlNRUmd3RTdBQUFBWU8weVlBY0FBQUNzTll1UDY3dnE4QmxQTGdneDdwTzZCYWlFWDRlOE9PdTJvL3JjbE9kNWtUb0dBTnBiM3RMVVdpNlhEcnB5NW8zZGk1NWZEekdjRVB6OUhQQldtNWUvUjEvVHQ5OFdKKzUyMGYzTkQ1MjE1NnpVUVFEL2t5ekw0a2ZQdWVlenF5ZWRvSjNseTk0STgxTkhBQUFBQUoyTHY4QURBQUFBMXE0WVpwZGZEZGhCZlZ0V0ZNWEVmRm5ieFQ4NnJ1K2I0WWc4ZFE4QUpMWHdwT0YvS3BjdjczSGx2S3V6b2pZNXhQaXAxRTFBSmZXT3RkcjkvU2JPbnRHMk1wNnhaTnl3WDZZT0FsaVRiYys2cTNlSTRTT3BPNmhMajc5MHhYNHZwWTRBQUFBQU9oY0RkZ0FBQU1CYTFkYldOcXRXODVZRDFLbWlLTUpOb1hYbFdiZU82dmZyMURFQVVEV3pUeHI2UkxsOGVzOHJGdTBmWXJpa1BQNVk2aWFnaXVLSVdwZncyWDRUNWt4ZXNTeS9jR2xMMCt1cGl3RGVvcFo5UG5VQzlhcVltN29BQUFBQTZIemM3UVlBQUFDc1ZiOWY5dWNIdGxwdjgrWGxZYmZVTFVEN0tVSjRzR2dybW04N2N0ZDVxVnNBb09ydVAzbmc3VHVQbjNIM3hwdHUzUnhqR0ZjKzFTdDFFMUE1M1VJTTUzVHRrWTNhYmNMc3M1ZWN0ZWNOZVo0WHFhTUEvcThZNGdHcEc2aGJjMUlIQUFBQUFKMlBBVHNBQUFCZ3JacDVWTlB5dzJjOCtVQ0ljWS9VTFVDN2VDSFB3N2pibjczMStyeWxKVThkQXdBZHhkS1dFU3ZMWmNMdWt4WmMzOUE5bmg5Q1BMWThyNlh1QWlwbnEvTDM2Mi8zdWVqK2szcFBuTlg4eU5pbWhhbURBUDdYbVhkK3JMRkxsMCtrN3FBK3JWcXgwZzUyQUFBQXdGcG53QTRBQUFCWSsyS1lYWDQxWUFlZDIvSWlGSlBEeWpjdXV1M29JYStGc0V2cUhnRG9rT2FlTnZqRmNqbCs5OHNYWEYyTDJaUVlRMVBxSnFDQ1loeFlDM0YrM3dsemJzcGpmdVlqWTV0K2t6b0pxRitOWFJxK2tMcUJ1dldMUDB6N2dwK0JBQUFBd0ZwbndBNEFBQUJZNjRvaW54Mmp6VGVnRTd0bDVjcVZZKzg0dXQrenFVTUFvTE9ZZThyZ0plV3k1eDVYTGp3NEsrTEZJWVp0VXpjQmxSTmpESWZXUXZhUHUwMllQZUdQdjM5eDRuT1RSaXhMSFFYVW55TEVMOFRVRWRTbG9panVUOTBBQUFBQWRFNEc3QUFBQUlDMXJqVmtDeHBEV0ZVZU5xWnVBZGFxeDBJUlJ2L3c4RjFtcGc0QmdNNXE5a21EYnQ1dS9LemJ0OTZzNjVnWTR0bmxVK3VsYmdJcXAyZUljZnltVzI1eFRKOEpzODU2OUt5OXB1ZDVYcVNPQXVyRE51ZmUrZUdHMEdWZzZnN3ExdjJwQXdBQUFJRE95WUFkQUFBQXNOWk5IN0hqNjRmOThLbUhZd2h1dG9ITzRROUZVWHoxdGp1ZXVTNmZQcUl0ZFF3QWRIYlB0alF0TDVkdkRMdGkvdlcxVUxzd3hIQkVlVzZqR09DLzJ5YUwyVTI5TDc3L2xGMHZ2di9VUjgvYzg2SFVRVURubHhVTm55K3ZTbHlYa0VScmJzQU9BQUFBV0RjTTJBRUFBQURyUmxITURqRWFzSU9PYlZVUndtV2h0VGovbHFOMmZUa2N2bXZxSGdDb0szTk9Idko4dVJ6VmRPV2lLMk5SVEMydnJ3ZWxiZ0txSjRZNHRDR3JQYkRiaERuWHIxeVdqMXZhMHZSQzZpYWc4OHBpL0VMcUJ1cldNMytZOUpuZnBvNEFBQUFBT2ljRGRnQUFBTUE2a3M4S29UWTJkUVh3L2hRaDNGV0VsV051UGF6ZjA2bGJBS0RlelRwcDRLSXN5NFlNdTJ6QllUR0dDOHVuUHBLNkNhaWNMTVJ3VEpmdTJZaStFMlpmOE1adjM1ejI5TFI5VjZTT0FqcVhiVTY3ZCtPR0hyRXBkUWQxNi83VUFRQUFBRURuWmNBT0FBQUFXQ2ZlZk8zVjJUMTdiYlNxUEd4TTNRSzhlMFVJVHhaNUdIUHJFYnZjazdvRkFQaC84and2ZjB5SDcvYVo5Sk5iTitqYTY0d1F3K29QcytpZXVndW9tQmg2eFJBdVh1OGpQWTd2TS9Gblk1ZU0zZXVXMUVsQTUxSHJGdjR4dU5lSVJJcVEzNSs2QVFBQUFPaTh2T2tGQUFBQXJCTzNIajNrdGNOblBQVkFpR0ZvNmhiZ1hmbHorUmovOGk5ZXVuSm1TMU5yNmhnQTRPMHRPZTJUYjVSTHkrNlRGM3lyb1VzMm9iemVQaWlzSHFrQitGdmJaYUgydzkwbXpKclpGbUx6STJmc3NUUjFFTkFKWlBIZzFBblVyN2JsQnV3QUFBQ0FkY2VBSFFBQUFMQXV6U3dmQnV5ZzJsWVAwMzB6dEszNDJnK1A2UCtuMURFQXdMc3pkOHpnNThwbDVCNlhMcm9zcXhWVFE0aTdwVzRDS2lqRzRiVVFsdlM5ZU5ZMXk1YUhscWRhbXY2WU9nbm9tTFllZDlzbVhiS2VlNmZ1b0c3OTI0dVg3djk4NmdnQUFBQ2c4ekpnQndBQUFLd3pSV2k3TDRiYXVhazdnRFg2U1d0ck1mcEhSKzc2Uk9vUUFPRDltZjJWZ1hPejhlTUg3TDdKcDBiRkdDOElJVzZadWdtb25GcUk4YVR1M2NLaGZTYk1Qdi9SWjUrK0xMLzZ1RldwbzRDT3BTRjIvMEs1TktidW9HN2Rsem9BQUFBQTZOd00yQUVBQUFEclRHdklGalNHOEVaNTJETjFDL0EzZnBFWCtXbTNIdGI3OXRRaEFNQUhsN2UwNU9YeXJjR1gzejJqTVc0MExvWndhbm5lTlhVWFVERXhiRmkrUGt6cXZkMzJ4KzE2MGM5T2UvU3N2ZTVLblFSMEhGbk1EazdkUVAzS2kvRFQxQTBBQUFCQTUyYkFEZ0FBQUZobnBvL1ljZVhoTTU2YUcyTDRkT29XNEM5ZUxVSnh3VFBQUEROMWFjdUlsYWxqQUlDMWE4RXArNzVhTG1jT25icncyb2JHT0xFOC9uenFKcUNTZHFobHRUdjdYanpycnJZaW5QYm9XVTAvVHgwRVZOdUh4OTI5V2Jlc3RsZnFEdXBXMjRvM3c4OVNSd0FBQUFDZG13RTdBQUFBWUYyN3Izd1lzSU8wMmtJby9xVnQyZkt2M25ic3dOK0hzR3ZxSGdCZ0haclhQT2dYNWZLRnBzc1c3aDJ5T0tVODNqbDFFMUJCTWU1WGkrR1RmUytlZlVWYmVQMjhSOC9jNzZYVVNVQTFkUXUxQTRKN2pFaG55VXRYK0JrRkFBQUFyRnZlL0FJQUFBRFdxYmE4OWI1YXpWc1FrTkRzdHJiUWZOc1J1eTVKSFFJQXRLOVpYeDUwWHpaeVJwL2Q5OWo2K0JqQytQS3BUVk0zQVpYVEdHSm9yb1gxRHU5NzhleVdSeDUrOFpwOCtvaTIxRkZBeFdUaDROUUoxSzhpRlBlbGJnQUFBQUE2UDNlM0FRQUFBT3ZVOUtkdWVlVFFUeHo4cC9Kd2s5UXRVR2VleTR2aWpGc08yL1htMUNFQVFEcC9IWlM1Y28rTDU5MFVlelo4TGNSd2NsZzlVQVB3dHpZdFh4K3U2TDNiNWlmMHZ2RCswWStjdmFkaEJ1QXZQdlRWTzdib0ViczFwZTZncnYwMGRRQUFBQURRK1Jtd0F3QUFBTmFwdktVbFAyekdVL2ZIR0E1TTNRTDFvWGk5L0hMeDcxNWNObWxlODZCbHFXc0FnR3FZZmViUWw4cGw5TzVYTExpbVZzUkpJWWI5VWpjQmxiUnpWc3QrMnZmaTJiZXRDc1hZcFdjMi9TSjFFSkJXOTlodDlYdDZ0ZFFkMUszbHYyOTdjMTdxQ0FBQUFLRHpNMkFIQUFBQXJITXhoTldmZkcvQUR0YXRvblJEdnJJNCs5YWpleitmT2dZQXFLYTVKdy8rZWJsOFp0aGw4L2ZMc214U2VieEQ2aWFnZ21MNGZHT0kvOUJud3F4cGJ5NWJkc0hUTGZ1K21qb0pTQ09HY0VqcUJ1cFhFY0w4Zk5JSUh5QUZBQUFBckhNRzdBQUFBSUIxcmkxZmRWK3QxcGc2QXpxemhXMTVhTDcxOEYwWHBRNEJBRHFHT1Y4ZWNsZi9FNjc5U1krZFB2SGxrTVZ6eTZjMlROMEVWRTdYR09JWlBidjNPTExQeGJQSFBicjhaOWV2M3FVK2RSVFFmclk3NTU1dFl5MGJtcnFEK2hWRCtHbnFCZ0FBQUtBK0dMQURBQUFBMXJtYkR0N2wzdzcvNFZQUGxZZmJwRzZCVHVZM1JWR2NmZXNSdlcvTTg3eElIUU1BZEN5THJ6NXVWYmxNN2o5NTFuZTZkKzA2UG9ad2ZIbGVTOTBGVk02V01ZYnJlbmZmNjZRKzM1alZ2T1NjcHJtcGc0QjJVb3VIaHIvTU9FRWFiYTF0OTZSdUFBQUFBT3FEQVRzQUFBQ2dYUlFoM1AzWEczYUJEMjVaK2QvVXhEZnlZc0xkaCsveVJqak1KaElBd1B1M2VFelRIOHZsNUtaTDUxNFRhZzFUeXVQaHFadUFTdG90MU9Mc1BoZk4rc0hLUEQvamlYUDJlaTUxRUxCdXhSQVBTOTFBWFh2eEQxUDNYeEltZTk4TEFBQUFXUGNNMkFFQUFBRHRJdzkzaDh5QUhYeEFxM2VwKzBFSXJXZjg4TkErYm1ZRkFOYXFXVi9aL2JGeTJYdlk1Zk1QeUVJMk1jU3dYZW9tb0hKaWlQSGdMclhhNTNwZk5HdGkvUFBLQ1VzbWZQS04xRkhBMnJmZE9YZjNpUTIxSGYveVRnU2tVQlEveWZQY2R5QUFBQURRTGd6WUFRQUFBTzNpemRkZnVxOW5yNDFXbFllTnFWdWdnMXBTUHBwbkhMcno3TlFoQUVEbk51ZVVJYmRzZi9uZGQyNFplcDBhUWphdWZLcFg2aWFnY3JySEdMOFdOdWw2VEo4TFo1Mzk2TGk5YmpRRUFaMUxiTWpzWGtkU2VZajNwRzRBQUFBQTZvY0JPd0FBQUtCZDNIcjBrTmNPLytGVDg4dkRwdFF0ME1HOFVJUmkzSzNQM0hwOTN0S1NwNDRCQU9yRDA2ZnN1NkpjSmd5OFpOWjN1bmJyZWtGNVBLcDhaR21yZ0FyNlNNamlEYnRjZVAvSmZTNjZ2M25KV1hzdVNoMEVmSERaeUJtMWoyNi93UmRUZDFEWGl0amFlbS9xQ0FBQUFLQitHTEFEQUFBQTJrMVJGSGZIR0EzWXdidXpvdnl2WnRxeXNQeUNPdzhkOEdvSXU2VHVBUURxMEtMVG0xNG9sMk9IVFoxL1ZXeUlVME9JUTFNM0FkVVRReGdVWXJhZzk4V3pibGk1Zk5YWlQ3YnM4M3pxSnVEOTIrWmo2KzFaTGg5TzNVRmRlL1IzVXo3Mys5UVJBQUFBUVAwd1lBY0FBQUMwbXhqQzNlVnlZZW9PcUw3aXR0YThiZXh0aC9YNVJlb1NBSURWNWpRUGVURExzbUZEcHMwYkdXTzhxTHkyM3laMUUxQTVNWVo0WkpkdVhRN29mZEhzQzE5ZFVVeCt0cVZwZWVvbzRMM0xzdHBocVJ1b2IwVW83a25kQUFBQUFOUVhBM1lBQUFCQXUvbmV3Wjk0OU5BZlBQRzc4dkJEcVZ1Z29wYm1SUmg5eTZHNzNKYzZCQURndjh2ejhrb2xoTzhQbmJyd1IxbERHQnRET0tNODc3N2JrNnNBQUNBQVNVUkJWSm02QzZpVzhyVmh2ZkxMQlJ0MGk4ZnRldUhzTXg4OWU0K2JVemNCNzk1SFR2aHhqNjZiZHowd2RRZjFMZWJCZ0IwQUFBRFFyZ3pZQVFBQUFPMW05UTI1aDgxNDZ0NFl3MUdwVzZCaS9oankwSExMN1U5ZmswOGYwWlk2QmdEZ25jeHJIclNzWE00YmZQbXNielVVWFM4dXIrOFBDWCtacVFINEc5dG1XWmplNStMWko1WEhvNWVjdWNlUzFFSEEvNnh4czY3L0gzdDNBbWRsV1RmKy83cnVNOE11b3BhVlpZdmxob0JJbW9yWTVHNW1ibzBoNEZabW1ma0VvcWlJZWh3RlJSQUVUVE45TkRjMGNNQmNRd1dFM01QYzBGR3JuMDgrbWRyaWtpa2l6Sno3ZjAvWi96RnpBUVN1TTh6N2JXZSsxemttZk9yRmF6d3pjNzduM3JjWTNWTjMwSzc5L1lVL0xMdzdkUVFBQUFEUXZsaXdBd0FBQUZhcEdDc3ppNDhXN09DZmx1UWgvSGh4ZVBYVUc0ZHM5M0lZMGp0MUR3REFVcnYzcUxwbml6RmsreC9kYzE3TTQ2VGl5ZjdXcVp1QXFsUlgzT1p2Y2RhOFM4S2l4U2MvVk43bHo2bURnUGVXeFhCbzZnYmF1M3hXWldyOTR0UVZBQUFBUVB0aXdRNEFBQUJZcGQ1WXVQRDJ6bDI2dGw2aHE1UzZCVkxLUS82TDVzWE53NjgvcE4rVHFWdWdQY2dtTi9RSVhic2NrTHFEVkNxL3Juem4rUG1wSzJCMWRlZFIvZS9Mc216YkFlZmVjMUJ4OTh6aXRsN3FKcURxbEVLSTN3MmRPaDdRZCt6Y01TMXYvblhTZ3JMbENhZzJueHA1MDZjNzFuYmNNWFVIN2Q3TnFRTUFBQUNBOXNlQ0hRQUFBTEJLVFQ5b3F4Y1BiR3lhSDJMWUpuVUxwSkUvMlJJcXgxdzNxTzh0cVV1Z1hlblk1V014aXo5T25VRWFlU2lOTG9ZRk8xaUpLcFZLWG93cmVqZk1tN0hXT2gxR2hqd09MNTd6ZDByZEJWU2Q3aUhHczBvZFAvS2R2bVB2T1BiaEUzYTRJWFVROEg4NjFuUTh1QmhaNmc3YXRieDVVZk12VWtjQUFBQUE3WThGT3dBQUFDQ0ZtY1hOZ2gzdHpTdDV5RS8vMzllYXo1dC9lTDhscVdNQUFGYUdCZVc2MTRveGFwc0pkLzUzaDQ2MTQ0cHpmZW9tb0FyRnVHSHg0ZnErWjgyN3JYbEpQdnl4azc3eWVPb2thTyt5TEl1ZkczWHJJYWs3YVBjZS92TzVlejJYT2dJQUFBQm9meXpZQVFBQUFBbFViZ29oT3pWMUJhd2lMWG1lLzJUSjY4M2w2dy92OTlmVU1RQUFxOEo5eDJ6L1A4WFlmN3NmM1ZlWDVXRlNqS0Z2NmlhZ0t1MWFVeHNmM3Z5c2VSYzI1eTJuUG43Q2ppK21Eb0wyYW9PUk13ZmtNWHdoZFFmdFd4N0NMYWtiQUFBQWdQYkpnaDBBQUFDd3lsMzl6VDRQRHI3MnNkWjNJbDR2ZFF1c1RIa2U1c1NXNXFNYkQ5cmkwZFF0QUFBcDNIM1VOdk95Z1kxYkRoand5Y05DaUtlSEdOWk4zUVJVblpvWXdsRzFvVFM0ejlpNURZKzlHUytvbE91YVUwZEJ1NVBGUTFNblFCNHFONmR1QUFBQUFOb25DM1lBQUFEQUtsZXBWUElEcHo5K1V3anh1NmxiWUNWNXVoTHlFZE1IOTVtUk9nUUFJTFhLMVBxV1lseTAxYmpaVXp0MTducFNqT0dIeGYwT3FidUFxck4yRnVMa1BoM0Q5M3FmT1hmNGdwRmZ1VFYxRUxRWDZ4MTNlOWN1bmNMK3FUdG85Lzc2cDJmZStGWHFDQUFBQUtCOXNtQUhBQUFBSk5FU3dvMmxFQ3pZc2JwNU5jL0RtRGRlK3VQa200L2EvYzNVTVFBQTFXVCtjVHY5clJnanRqM3Z6b3RxUXMzWk1jYTlVamNCVmFsbktjYVpmY2ZPdXltMFZJNTllTlFPVDZVT2d0VmQ1dzc1TjBLSWE2VHVvSjNMODF2ZmVtTUdBQUFBZ0ZYT2doMEFBQUNRUkNYLysreFM3TDZ3T0haSjNRSXJRQ1hrNGJKRlM5NGNkZU1oVzc0UVF1L1VQUUFBVmV2ZS85cit0OFhZZS9zZjNiTnJ6TE9KSVliTlVqY0JWV25QVU1wMjdUdDIzbzllZlRPYy9uUzU3cFhVUWJEYXl1SjNVaWRBbnVjM3BtNEFBQUFBMmk4TGRnQUFBRUFTVSt1M2VlUEF4cWJaSVlhdnAyNkJEK251NXBhV1lkY2QyUGVCMUNFQUFHM0puVWYxdnkxcm1OZTMvem9kam93aGxtTUlhNmR1QXFwT2grSTJ2SHVIY09EbVo4dzllY0VqZjczRTFZMWd4ZHBnMU8yYlpLVXdJSFVIN2Q2U04xOTdZMmJxQ0FBQUFLRDlzbUFIQUFBQUpKUG40Y1pvd1k2MjY1bEt5RSs0YmtqZnFaVktKVThkQXdEUUZsWEtkYzNGT0hlN1NmZGRWYW9KNWVKOFpQQXpUT0NkWWxnM3h2aVRQbHQ4OVB1Ymo1MDc3SkVUdmpJdmRSS3NMbUtXSDE1OGpLazdhUGZtdlhoaC9kOVNSd0FBQUFEdGx4OU9BUUFBQU1ua2xjVTN4NnhENjJLU0YvSFFscndlOG56Y2MzOWVPUDd1WWR1OEVRWlZVdmNBQUxSNXhmT3FsNG94ZE5zZjNmV1RVcWc1cC9nQ1lkZlVUVUJWNmh0RG5OdDM3THdaK1p2Tkl4NHA3L1IwNmlCb3k3S2hNenR1c0dicDROUWRrT2Y1RGFrYkFBQUFnUGJOZ2gwQUFBQ1F6TlVEK3o0M1pIclRyMk1JVzZadWdhV1E1eUcvSnVUeCtNYkJmWjVOSFFNQXNEcTY5NmdCVGNYWWJmdHo3OWtyeEhoMkNISEQxRTFBVmRvdmRLelpvOC9ZZVJQek44T1pDOHAxcjZVT2dyYm9zMnVVOWkzR1IxSjNRR2haY21QcUJBQUFBS0I5czJBSEFBQUFwSldIRzBPMFlFZlZ1ei9QdzdER3dYM3VTeDBDQU5BZTNQbkQvamYwYm1pY3VlYmFuendxaG5oSzhkQ2FxWnVBcXRNcGhuQmk3QmdPM2Z6TWVhTVdMSjU3UmFWY2RvbHhXQVpaRmc1UDNRQWg1STgrTjNIdjM2ZXVBQUFBQU5vM0MzWUFBQUJBV3MzTk40YmFtb2JVR2ZBZW5zdnpNSExHa00ydnJGUXFlZW9ZQUlEMlpFRzVmbkV4Smc2WWNPOVZzVU04dlRnZlZ0eEtpYk9BNnJOZWlPR252VHArNVFkOXhzNGQ5dWdKWDdrN2RSQzBCWjg1OGJZdjFOYkVIVkozUUI2aXE5Y0JBQUFBeVZtd0F3QUFBSks2Wm5EZmh3ZGYrOWl6eGZGVHFWdmdiUmFGUEV4ODhaV1h6cHp6L2JyWHdpQVhRUUFBU09XdVk3YjljekcrdC8za2UzNGNzbXhTY2E1TDNRUlVueGpDbHNYSE96Y2ZPKythdlBMbUNZK2V1T3NmVWpkQk5hc3R4ZGJGOVppNkEwSkw1WWJVQ1FBQUFBQVc3QUFBQUlDa1dxOEtObVI2MHcweGhDTlR0MENyUE04Ymw3U0U0NjQvc00vL3BHNEJBT0QvM0RtMC84UEYrTXFBeWZmV3h5eU9LODZmUzkwRVZKM1daYUhCTWV1NHorWmo1NTcxeWwvK092NlpDZlZ2cEk2Q2FwTWRjWEh0NTliOTdLRzI2NmdDejc5d3pnTVBoQWxmUzkwQkFBQUF0SE1XN0FBQUFJRGtZcVZ5WGNneUMzWlVnNW1OZy9yc256b0NBSUQzZHRmUWJSczNhSmgzMHlmWDZqZzh4REN5ZUtoYjZpYWc2blFKSVRiMCtPaEh2dFA3ekxrblBENXF4MnRhMytBbmRSUlVpODk5OU5QN3hCQStucm9EOGp5L3ZsSXBWMUozQUFBQUFGaXdBd0FBQUpKN3J1bkZ1Wi9vOWRHWFlnaHJwMjZoM2R1cGZzcURuMmdjMHUvNTFDRUFBTHkzcDh0MWk0cHh4dmJqNzdrc2RBeG5oaGdQQ3YrOGNoWEEyOFQxc3hpbTlCNXp4NUY5enBnMzdORVQ2eDVJWFFUVklFWnZkRVYxeUVPY2tib0JBQUFBb0pVRk93QUFBQ0M1T2VXNjVnT25QMzVEQ1BIUTFDMjBlN1doVlBQZFlqYWtEZ0VBNElQZE9hTC9jOFU0Wk1DNTkvNG94bnhTOFRWRi85Uk5RRlhhTHNad2Y1OHo1MTJXTHc2akZwVHJYa2dkQktsOGJ0VE1ucVZTcVM1MUJ4UmUvdFBmbjUyYk9nSUFBQUNnbFFVN0FBQUFvQ3BVOG5oZEZzT2hxVHNnaHZqZHJTNSs4SXo1aC9kYmtyb0ZBSUNsYzljUHQ1MmZaZG1BYlNmZE9TaUwyZGppb2ZWVE53RlZKNHNoZkR0MnlQZnZjOGJjc2E4dGlSUGZ1aG9tdEN0WjZSOVhyM1BWVjVMTDgzQlQ1Y0xEZmY4TkFBQUFxQW9XN0FBQUFJQ3E4TUxyZjdsdHZXNGZmYTA0ZGt2ZFFydTMzcWU3bGZZcDVyV3BRd0FBV0hxVlNpVXZ4dFZiVExqOStxNjEzWTZMTVl3bzduZE8zUVZVbTdoRzhmbGh6Qm9kd21GOXh0d3g0dEZSTzh4SVhRU3J5cm9uM0xCRzl3NmREMDdkQWEySzUyN1hwVzRBQUFBQStCY0xkZ0FBQUVCVm1ITkkzYUloalUyM3hCaSttYm9Gc3ZDUGQzTzNZQWNBMEFZOWRNd3VyeGVqUEdEaXZaZUcyakEyaGpBd3VGSVA4SjgyQ0ZtYzN2dU11WE9hWStYb0owYnUrR2pxSUZqWnVuZm9kR0F4MWtqZEFZV0ZmMzQ5dnpWMUJBQUFBTUMvV0xBREFBQUFxa2FNK1hYRlJ3dDJwQmREM2I1WFA5enp1c0Y5bTFLbkFBQ3dmTzRhdnUwenhSalVmL0pkUHlyRjBxVGlPZDZXcVp1QTZoTmoyTEUyWkEvMk9YUHVKVysrdHVpa3A4YnMvcGZVVGJEeXhDTlRGOEEvNWJkV0x0eHpZZW9LQUFBQWdIK3hZQWNBQUFCVWpaZmZmUDJXdFRwMmZUT0UyREYxQysxZXJJbi91SXJkVWFsREFBRDRjTzRaT3VEdXJLRmg2LzQ5ZGowMFptRk04ZERIVXpjQlZhZFUzTDdic1Z1bmIvWStZKzdwai8vdmI4K3JYSGo0a3RSUnNDSjlmdFRNdWxncTlVcmRBZjlRaWRlbFRnQUFBQUI0T3d0MkFBQUFRTlc0ZWZDWFhqMXdldFB0eFhIUDFDMFFZang0MzUvZU0vSzZiL1gvZStvVUFBQStuRXE1WENuR3BkczJ6R3pNMXU0K01vWjRkSEhmRzNzQTc5UWp4akNoMTJjMi9HNnZNWGNNZjJ6VURyZWtEb0lWSlpaS3JsNUh0Vmk4Y0dGK1Urb0lBQUFBZ0xlellBY0FBQUJVbGJ4U3VTNW1tUVU3cXNFYXBjNXJIRlRNQzFLSEFBQ3dZdHhiM3YzVllvemNldExkRjlkbTJmZ1F3MzZwbTRDcXRIR1d4WnQ3bnpuMzFyQzRNbnhCZWNlbTFFSHdZWHoyaEJ2V3ErblFlZC9VSGRBcUQvbXNsOC9mNCtYVUhRQUFBQUJ2WjhFT0FBQUFxQzR0aTI4SVdhZm00UHNXVklFWXdnK3lMUHR4cFZMSlU3Y0FBTERpM0Q5c3U2ZUw4WTBCaysvZE1XVGhuT0xjSjNVVFVIMktyd2wzQ3gyeVIvcWNNZmVDVjE5YmVPcnZ6N0FRUXR0VTZ0QzU5ZXAxdGFrNzRCL3kySmc2QVFBQUFPQ2R2RkFOQUFBQXFDcFREdWozMXlIVEgvOWxESEhIMUMxUTZQbU5LUS92V3N4YlU0Y0FBTERpM1RWMDJ6blp3TVorL2JmNzVQZENEQTNGUXg5SjNRUlVuWnJpODhNUHUzZnJNcVRQR1hOUGVXekp2SXNxNVhKejZpaFlXcDg1cHJGemJkYzF2NWU2QTk2eTVJM1g4NStuamdBQUFBQjRKd3QyQUFBQVFCWEtwd1VMZGxTSlBNWmh3WUlkQU1CcXF6SzF2cVVZRi9TYlBPL3FMbG1IazR2emZ3VlgrUUgrMHpyRjdmeGV0WFZIYm5iNm5LTWZQM25IMjFNSHdkS283YnpHa0dDQm5Pb3grK1h6WFEwVUFBQUFxRDRXN0FBQUFJRHFzMlR4OUZEYjZVZkI5eTZvQWpHRTNiNXgxVU9iVGo5d2l5ZFN0d0FBc1BJOE9MVHVsV0ljcy9XNTkxeFVHK1BFNHJ4SDZpYWdLbTFXS21XMzlSa3o5NGE4ZWZFeEM4cTcvaTUxRUx5WExNdmlCaWZkT2pSMUIveExIaXJYcG00QUFBQUFlRGRlcEFZQUFBQlVuU2tIOVB2cmdZMU5zME1NdTZWdWdVS01OVFd0TDBZN0luVUlBQUFyMy8wLzdQOVVNYjdXZi9MZFg4MUNOckg0dW1TVDFFMUFGWXBocjFqYlliZmVaOHlkdkhqSm9qRlBsWGQvTlhVU3ZOTUdKODNjcVJpOVVuZkFXNWE4MGZ6R3oxTkhBQUFBQUx3YkMzWUFBQUJBVmNyenlyUVlNd3QyVklVWXdrSGZ1SEwrcU9rSGJmVmk2aFlBQUZhTmU0WnU5NHV0anJoNFZzZWV2YjVmM0QyMXVLMlZPQW1vUGgyTDIzRWRhanNkc3Rub09TYzlzZUNsbjFhbTFyZWtqb0oveVVNY0dsTkh3TC9rWWM3TEUrcGZTcDBCQUFBQThHNHMyQUVBQUFCVktUYUg2MEtIOE9QaTJDRjFDeFM2eEZMSDd4Ynp6TlFoQUFDc092TXZQSHhKTWM3ZGF1SzhxenZXZEdnb3pxM1BDZjJNRlhpbmoyVlpkbkhQelQ5eTVHWm4zREhzOFJOMytHWHFJUGowS2JNMjdCRENIcWs3NEYveWtGK2J1Z0VBQUFEZ3ZmamhEd0FBQUZDVnJoclU2K1VoMDV0dWp5RjhMWFVMdElveC9tQ3JpeDg4ZS83aC9aYWtiZ0VBWU5XYVA3enVyOFg0d1hhVGZubGh5R3JPaVNIdWxMb0pxRDR4aEMyS3p3L3plbytaTzYwUzgrTWVQM0dIWjFJMzBYN1Z4dnlISVE5WjZnNTR5K0kzV2haZWx6b0NBQUFBNEwxWXNBTUFBQUNxVnA3blUyT01GdXlvRnAvOFROZmEvWXQ1ZGVvUUFBRFN1SHZZbHhjVVkrY0JrKy9kSjhRd3ZqaC9JWFVUVUlWaStHWVc0dGQ3bjNISGhMRGt4Yk1XbE90ZlM1MUUrN0xCOE90N1pHdDBQYlQxbW1GUUpXNTdlVUw5UzZrakFBQUFBTjZMQlRzQUFBQ2dhdjF0OGV2WHI5V3gyNkxpMkNsMUM3U0tNUXdMRnV3QUFOcTl1NFp1Ky9PTmg4Nzh4VG9iZEIrYXhUaXFlS2g3NmlhZzZuUXV2b284S2RSKzVGdWJqWjU3NGhPbjdIaGxwVkt4N2NRcWthM1I1WWhpZEV2ZEFmOVNmUDc3V2VvR0FBQUFnUGRqd1E0QUFBQ29XamNQL3RLckJ6WTJ6UXd4N0pPNkJkNnkxWDVURm13L1kwanZPMU9IQUFDUTFsT1RkMyt6R09PMlBudmVGVFVkYXNmRUVBOHQ3bWVKczREcTg4a3NDNWYzUEgzT2tadWRNV3ZZNHlmdWZGL3FJRlp2MmRDWkhUZm9VZlBEMUIzd05ndGJYbTY1SVhVRUFBQUF3UHV4WUFjQUFBQlV0NWhQTFQ1WXNLTnFsTEp3WERFczJBRUE4QS8zSDF2M1FqRU9HekR4M2grRm1qQ3BPSDg1ZFJOUWZXSU1XOGRRYzAvdk1YT3ZYQkx6RTU4OGNZYy9wbTVpOWJSQmo5S1FZbndpZFFmOFN4N0N6WC8rNzczK25yb0RBQUFBNFAxWXNBTUFBQUNxMnBJODNsUVR3OExpMkNWMUM3emxhL3RmOGNobTF4NjgrZU9wUXdBQXFCNTNEZC8yb1N6THZyTHR4RHYzanpFYkYyTDRUT29tb09yRTRxK0RhMFA4UnU4ejVvNTc5Y1cvam45bVF2MGJxYU5ZZlJUL0hvb2JuSHpyTWFrNzRPMWlKZjlaNmdZQUFBQ0FEMkxCRGdBQUFLaHFVK3Q3dmpaayt1TTNoeEQzVDkwQ2I0bDViVHkybU45S0hRSUFRSFdwVkNwNU1hWnRONm54eGhEWEd4RkRiTDM2Y2RmVVhVRFZhZjI4MExER09oLzVkcS9SYzQ5ck9tWEhhOS82L0FFZnl1ZEczYnBuQ0xGbjZnNTRtMWVmZi9FdnQ2U09BQUFBQVBnZ0Z1d0FBQUNBNmxmSnJ3NlpCVHVxUnd4eGNQM1ZDMDV1SE56NzJkUXRBQUJVbjd1SC9lT0tWS2R0TzM3ZXBWbkhEbWNXNXlHaDlXa2t3TnNVbnhRK0U3SXdkYlBSYzM3UWEvVHNZWStkdE5ORHFadG80K0kvM2hBSXFrWWU4cDlYTGoxa1Vlb09BQUFBZ0E5aXdRNEFBQUNvZXMweHU2VW1oSmVLNDlxcFcrQXRIWXJic09MbWhXc0FBTHluZTBmVXRiNGh3MEhibm5QUCtiRVVKOFVRdGs3ZEJGU2xMOGVZUGRCNzlKekxRc3VpVVF2S2U3eVFPb2kyNS9QbDI3ZU9NWDQ1ZFFlOFhmSGM1NXJVRFFBQUFBQkx3NElkQUFBQVVQV20xdmRjUExpeGFWcU00WWpVTGZBdnhaL0h3L2U3L0pIUk13N1ovSlhVTFFBQVZMZDdqKzUvWDVabDIyNDc2YzZEUXNoYXIyaTNYdW9tb09wa3hSZWEzdzQxbmVzM0d6MW5UUE5mRms5K2F2THViNmFPb3UySUlZeEkzUUR2OEtmbjU4K2ZGY0llcVRzQUFBQUFQcEFGT3dBQUFLQk5pQ0ZNS1lZRk82cEo5MUpOYlAwek9UWjFDQUFBMWE5U3FlVEZ1S0ozdzd3WjNkZXFQYjc0S3VlWTRuN24xRjFBMWVtZXhYaFdoNDkyT0x6bm1EdU9hUnExd3cycGc2aCtuem54dGkvVTFtYjdwTzZBZjVmL3JES24zSnk2QWdBQUFHQnBXTEFEQUFBQTJvUnJ2dG5yN2tIWFB2WS94ZkZ6cVZ2Zy81ZkZvVHRlUG0vU25FUHFGcVZPQVFDZ2JWaFFybnV0R0NmM256enZraEE2bkJWaitHYnFKcUFLeGZpRkxJVHJlNDJlTTdzUzhxT2JUdHBwUWVva3FsZE5iWFo4TVVxcE8rRHQ4cnd5SlhVREFBQUF3Tkt5WUFjQUFBQzBDYTFYZXhnOHZXbEtET0drMUMzd05oOWZwM2J0ZzRwNWNlb1FBQURhbG51RzF2MitHQU8zT2ZmZTgwc2hUQ3JPV3lST0FxcFJqRHRsSVQ2NDJlZzVGMVZhRnBhZktPLzUxOVJKVkpkUG56RHpVeDA2MWh5Y3VnUCtYZjdVYytQMm5KKzZBZ0FBQUdCcFdiQURBQUFBMm95NHBESWwxR1lXN0tndU1ZeklCalplV3BsYTM1STZCUUNBdHVlK0gyNzd5K0w1NUZaYmIvdkp3N0lzbkY0OHRHN3FKcURxMU1RWWp5elZkQjNVYS9TY1U1dWUvWDgvcmx4NCtKTFVVVlNIRGgxTHg3U08xQjN3Yi9MbzZuVUFBQUJBbTJMQkRnQUFBR2d6cGh6UTY4a2gwNXNlS0k1YnBtNkJ0OWx3djcwM0hsak1xMU9IQUFEUU5yMzFaZzBYYmRzdzgyZXh4eHFqWW9qRGdtVUo0RCt0RldLYzNQTlRuLzkrcjlQbkRIL3M1QjEva1RxSXRENDE0cWFQZE83UzZmQThkUWo4dTd6U2tsdXdBd0FBQU5vVUMzWUFBQUJBbTFMSjg2dXlHQzNZVVYxaUdKazFOUHlzVWk1WFVxY0FBTkIyM1Z2ZS9kVmlITC90MlhmK2Q2d3RuUjFEMkN0MUUxQ0ZZdHlrK0RyMGxzM0czSEZMSHNMd3BsRTdQSlU2aVRRNmQrN1l1cERkTlhVSHZNTzl6MC9ZNCtuVUVRQUFBQURMd29JZEFBQUEwS1premZuUFFtMDhPL2krQmxVa2h0QnIzNDMyM2FjNHpramRBZ0JBMjNmdnNkdi90aGg3OTU5NHp5NnhGTTRwenB1bGJnS3FUL0cxNkI3RmJaZGVvK2VjdDdEbDc2Yy9YZDc3bGRSTnJEb2ZIVHF6ZTQ4ZU5UOUkzUUgvS2I4cWRRRUFBQURBc3ZKQ05BQUFBS0JObVhKQXJ6OE5tZjc0ckJEaTdxbGI0TzJ5RUU3TXN1eTZTcVdTcDI0QkFHRDFjTS93L3JkbkRmUDZick5telhkRGpLY1ZENjJUdWdtb09yWEY1NGZoWFdxNkg5UnI5QjJuTkMxNDhlTEsxUHFXMUZHc2ZHdjJLQjFaakI2cE8rQWQzbHpZdkhCcTZnZ0FBQUNBWldYQkRnQUFBR2h6S2lHL0tyTmdSOVdKWDl6M3FrZGEvMXorSW5VSkFBQ3JqMHE1cnJrWUYvU2VkTnZQdW9XdTVSaGo2MEtGbi9NQzcvVFJFTU9QZS9aWjUvdWJqcm5qNkNkRzdUQW5kUkFyejJlT2FleGMyNjNIc05RZDhFNTVudC80OG9UNmwxSjNBQUFBQUN3clAzZ0JBQUFBMnB5WDM2ajhmSjNPMmF2RnNYdnFGbmk3TElTVGdnVTdBQUJXZ2dYRGRtMTlzZnJRYlNmZTlaTllpaE5EaUx1bGJnS3FVcDlTQ0xON2paa3pvN2s1SC9Ga2VhZW5Vd2V4NG5Yb3V1WjNpdkd4MUIzd0gySzhQSFVDQUFBQXdQS3dZQWNBQUFDME9UTVA3UFA2a09sTjA0cmpkMUszd0wrSm9mLysxenk2dzdXRCt0eVJPZ1VBZ05YVHZjTUhOQlZqOTIzUHVXZVBtSVdKeFhuajFFMUFOWXI3MWRURVBYcU52bU5TNWJXL245RTBkcSsvcHk1aXhkamcyNWQzS3EyLzN2R3BPK0JkL09tRitiK2FHY0pYVTNjQUFBQUFMRE1MZGdBQUFFQ2JsSWY4cHpGRUMzWlVuVHlQclZleHMyQUhBTUJLZGUvUi9XL1o2b2lMYjYvZGROUC9DaUU3dVhpb1Irb21vT3AwQ2pHY0VMdXRjZWltbzJlUGVxcmxyc3NxNVhJbGRSUWZUbHovazYzZkQvdGs2ZzU0cHp3UFV5cHp5czJwT3dBQUFBQ1dod1U3QUFBQW9FMzYyZjY5N3gwMDdiR25ncXMxVUdWaUREdnVPK1hoL3RjTjZYdFA2aFlBQUZadjh5ODhmRWt4Sm41eDdGMVhkdWljalk0aEhGYmNMNlh1QXFyT3g3T1FYYkpwOXVYdmJ6cDYxckFuVHRyNTd0UkJMSjlzNk15T24rOVJPaUdFbURvRi9rTWVtaTlQM1FBQUFBQ3d2Q3pZQVFBQUFHMVNwVkxKaHpRMlhWWWN6MHpkQXU5VWs1WEt4ZGd0ZFFjQUFPM0RyMDhZOEpkaWZLLy9oTHZPRHpYeG5CRGlqcW1iZ0NvVXc1WlpLTjI1MmVnNTF5eDVzL21FMzV5KzZ4OVNKN0ZzTmxpenh0WHJxRXA1Q0E4K1ArN3JqNmJ1QUFBQUFGaGVGdXdBQUFDQU5pdHZXWHhGTEhVWUhWeWhnZXF6YS8zVmoyelhPSGh6VndVQUFHQ1Z1ZWVZQWEwdmJOK3AvK1I3OWl2bStPSzJRZUlrb1ByRTRqK0RhenZXN3R0ejlKenhyN1lzUE92WjhwNExVMGZ4d2Y1NTlicWFFMUozd0x1SmVYRDFPZ0FBQUtCTnMyQUhBQUFBdEZsWEQrejczSkRHcGx1TDR4NnBXK0EvWmFjVkgzWktYUUVBUVB0eno5RCtNelpvbUhmTHg5YXNIUjVqR0ZrODFDMTFFMUIxT3NjUVQxbXoxUFZiUFVmUFB1SEpVM2E1cGxLcDVLbWplRzl2WGIzdVU2azc0RjBzenQ5OC9aclVFUUFBQUFBZmhnVTdBQUFBb0UzTFEvaHB0R0JIRllveDdQaU5xeDZ1bTM1ZzMzbXBXd0FBYUgrZUx0Y3RLc1laVzU4OTc5SlNiZTJZNG54b2NjdlNWZ0ZWYVAwWXNpbWJOTXord2Fhalp3OTc0cVNkNXFjTzRqKzVlaDFWTGM5ditPUGsrcitremdBQUFBRDRNQ3pZQVFBQUFHM2EzMTc0M3h0N2ZHejlGME9NNjZSdWdYZktTdis0aWwxZDZnNEFBTnF2KzQrdGU2RVloMjB6Nlo0Zlp5Rk1LczdicFc0Q3FrK01vWDhNMmYwOVI4KzVNclJVUmphVmQzNHVkUlAvWjRNZXBjT0NxOWRScGZJWUxrbmRBQUFBQVBCaFdiQURBQUFBMnJTYmo5cjl6Y0dOVFZOaUNEOU0zUUwvS1g1NXY2c1g3RFJqY08vWnFVc0FBR2pmN2h2Vy80RXN5N2IvMHNRN0IyVWhqaTBlV2o5MUUxQjFZZ3p4NEZBcTdkZHo5Snd6RjdYOFllTFQ1VU1XcFk1cTd6YjQ5dVdkU3V0L2NtVHFEbmdQZjNqKzl3dHZUeDBCQUFBQThHRlpzQU1BQUFEYXZOamNmRm1vcWJGZ1IxVXF4ZEJRREF0MkFBQWtWNmxVOG1KY3ZWWERUVCt2N2I3V2NjVlhVeU5DREYxU2R3RlZwMXNNY1V6bjBxZS9zMW5ESGNjK1h0NWhSdXFnOXF6MHFVOStMN2g2SGRVcXp5K3JUSzF2U1owQkFBQUE4R0Zac0FNQUFBRGF2Q2tIOUhsb1NHUFR3OFd4YitvV2VCZmI3WC9Obzd0ZE82alByYWxEQUFDZzFmenluZ3VMY2VyVzU5eDVTU21VV3E5bU42aTR4Y1JaUVBYNVhDaUY2VDFIejVsWGFha01lN0s4ODhPcGc5cWJqeC9WMkcyTmRYcWNtTG9EM2tPbEVpby9UUjBCQUFBQXNDSllzQU1BQUFCV0Mza0lsOFFRemt2ZEFlOHFqNjFYc2JOZ0J3QkFWYm4vNk8zL1VJd2hYenI3cmd1eW1teFM4VFhWbHFtYmdPb1RRNnpMc3V5Qm5xZk51V1JKM25MeWI4dTcvRGwxVTN2UmJaMGVQeXpHdXFrNzROM2xkenczYnMvL1NWMEJBQUFBc0NKWXNBTUFBQUJXQzR0ZVgzSlY1eTYxWjRVWXVxUnVnZjhRdzliZnVQclJQYWNQN25OVDZoUUFBSGluWHgwNzRPNnNvV0hycmJydmNuQVd3NWppb2ZWU053RlZwMVI4YmZ2ZDJsZ2F1RW5Ebk5OK0UxNzZVYVZjdnpoMTFPcHNnK0hYOXlpdDBmWFkxQjN3bmlyaGt0UUpBQUFBQUN1S0JUc0FBQUJndFREamtNMWZHZHo0K0xRWTRxR3BXK0RkdEw1UU9XdG91S1ZTTGxkU3R3QUF3RHU5OVR6MXN0NE44eHE3cmxrenN2amFhbmh4djFQcUxxRHFySmxsWWNJbVllMGplamJNT3JhcHZQTU5xWU5XVjZWdVhWcVg2OVpLM1FIdjRhWG5YdnpMZGFrakFBQUFBRllVQzNZQUFBREFhcU1sNUJmVldMQ2phc1UrKzI2MHo2RGlNQ1YxQ1FBQXZKY0Y1YnJYaWpGcTYwbDNYNUxsK2ZnUTQzNnBtNENxdEdISXN1dDduamI3dHBZOEh2MVVlY2VtMUVHcmt3MlB1MzNkMERrT1RkMEI3eVVQK1pXVlN3OVpsTG9EQUFBQVlFV3hZQWNBQUFDc05xYlc5N3AzU0dQVGd1TFlPM1VMdkp1WVp3MWJYZnpndFBtSDkxdVN1Z1VBQU43UC9jTzJlN29ZMzlqMm5GL3VFRUpwVW9paFQrb21vQXJGdUdzcGhrYzJQVzNPQlF2ejVvWm55cnUrbERwcGRaQjNEaU5qQ04xU2Q4QjdxalJmbERvQkFBQUFZRVd5WUFjQUFBQ3NWdklRTG9vaG5KZTZBOTVWREovL2ROZmE3eGFuODFPbkFBREEwcmozNkMvZmtRMXM3TGYxdHA4NHJMZzd1cmg5TkhVVFVIVnFZZ3cvN0Jwcmh2UnNtSFhxaytIdUN5dmxjblBxcUxacS9aTnZXNzlUbGgyUnVnUGVTeDdDblg4Y3Y1ZXJWZ0lBQUFDckZRdDJBQUFBd0dwbDBldExydXJjcGZhc0VFT1gxQzN3Ym1JTUorMSsxYU9YelR5d3ordXBXd0FBWUdsVXB0YTNGT09pZmczenBuWHNYbk55Y1Q2cXVIVkluQVZVbjNWQ2xwMjNTUmh3Uk0rR1djT2J5anZmbGpxb0xlcVVaYWUwanRRZDhKN3kzTlhyQUFBQWdOV09CVHNBQUFCZ3RUTGprTTFmR2R6NCtMUVk0cUdwMTdmTDN3QUFJQUJKUkVGVVcrQTlmTHhiS1E0dDVobXBRd0FBWUZrOFdLNTdwUmpIYkQzK2pvdGlUWWV6WXdoN3BtNENxbEhjTEdUeDFrMVBtM05EYzNQbDJOK2V0dk52VXhlMUZaODdaZGFtTlRFY21yb0Qzc2VMei8vMUw0MnBJd0FBQUFCV05BdDJBQUFBd0dxbkplUVgxVml3bzdxTitPcWw5MTM0aTI5djgxTHFFQUFBV0ZiM2o5amhxV0o4Zlp1SmQrMFdZNXhZbkh1bWJnS3FUNHhocjlyYWJQZE5UNXQ5N3BJM3d1amZuYm5UMzFJM1ZidWFtSjlaL0QvbnRUeFVzeXNxbHg2eUtIVUVBQUFBd0lybW0zSUFBQURBYW1kcWZhOTdoelEyTFNpT3ZWTzN3SHZvMGFWVGx4T0tlVnpxRUFBQVdGNzNEUjl3YTlZd2IvTXZkUzhkV2R3dGh4RFhUdDBFVkowT01jWmpPM1FKQjIvU01QdmszelM5ZkVsbGFuMUw2cWhxdEdGNTFuYkY1OUc5VTNmQSs4aERwZVdpMUJFQUFBQUFLNE1GT3dBQUFHQzFsSWR3VVF6aHZOUWQ4RjVpakVmdGRjVWprMjg0ZVBNL3BtNEJBSURsVlNuWE5SZmozRzNHenBrU09uUTR0WGlpZTBUd2MyamdQNjBicy9pVGpYdXQvZjJOeTdPR1BkV3c4N3pVUVZYb3JOUUI4UDd5WHo0N2ZzOG5VMWNBQUFBQXJBeCtzQUVBQUFDc2xoYTl2dVNxemwxcXp3b3hkRW5kQXUraGMyMU5kbG94RDBzZEFnQUFIOVo5Sit6NFlqSCthNXR4ZDE4WWFzUEU0cnhyNmlhZ0t2WE5hcks1bTU0MnB6RTB0eHozeEdtNy9FL3FvR3F3NFNtMzd4TmkzQzUxQjd5dlBMOHdkUUlBQUFEQXltTEJEZ0FBQUZndHpUaGs4MWVHTkRiOXJEaCtPM1VMdkpjWXd5SDdYUG5RNUo4ZnRNV2pxVnNBQUdCRnVPKzQ3UjR2eG01Ym4zUG5YakZrWnhmbkRWTTNBVlVvaHZwUVc5cHowOVBtVEh3NWYrbk1GOHIxcjZWT1NpWGJzYUhtODl0dmQyYnFEdmdBTHp6M3pCc3pVa2NBQUFBQXJDd1c3QUFBQUlEVlZxWFNjbjZXbFN6WVVjMUtOVFUxNDRxNWUrb1FBQUJZa2U0L2V2c2JlamMwenV5NnhzZUhoUmhIRlE5MVQ5MEVWSjFPSVlZVDF3cHJIN3BKdyt5UnYyblk1Y3BLcFpLbmpsclZQcjk5LzlidlhXMlN1Z1BlVng0dXFVeXRYNXc2QXdBQUFHQmxzV0FIQUFBQXJMYXUrV2J2QjRjME50MWJITGROM1FMdlk3ZDlyM2wwdCtzRzliazFkUWdBQUt4SUM4ci9lQ0grdUMwbTNINVp4OWpsOUJERFljWDlVdW91b09xc0YyTzhmT1B5ckNNM2JwZzE3S255enZlbERscFYxanZ1OXE1ZE84ZHk2Zzc0QUMxaFNjdEZxU01BQUFBQVZpWUxkZ0FBQU1CcXJWS3BuSjlsbVFVN3Fsb3B4UEhad01aWmxhbjFMYWxiQUFCZ1JYdm9tRjMrWEl6dmZXbmlMeStNc1hST0RLRXVkUk5RaFdMWU9ndlpQWnVlTnVlYVNyNzQrS2ZLdXorYk9tbGw2OW81SGxPTTlWSjN3UHZKUTM3akg4L1o4MzlUZHdBQUFBQ3NUQmJzQUFBQWdOVmFKY3V1elVLWVVCdy9scm9GM2tmdmZmYlo2TkJpWHBJNkJBQUFWcFpmRGYveVE4WDR5allUN3Y1bXlNSlp4Zm16aVpPQTZoT0wyK0FzZE5oNzA0WTU0eGErK3RMNFp5YlV2NUU2YW1YNDdBbXoxdXZRS1l6STg5UWw4UDVpSlY2UXVnRUFBQUJnWmJOZ0J3QUFBS3pXcHRiM1hEejQycWFMWXd3bnBXNkI5eE5EUEczM3F4NzkyY3dEKzd5ZXVnVUFBRmFtKzQ3WmJ0b0dEZk51K09nYXBlRXh4cEhGUTkxU053RlZKb2F1eGNlR0x0M1gvdlltRFhOTytFM0R6bE1ybGNwcXRZcldvVk0rdXZnZjZ2TWYxUzBQdjNsdXd0ZG1oZkdWMUNVQUFBQUFLNVVGT3dBQUFHQzF0M2hKeTA4NjFwWk9DTkgzUXFoZU1ZVDF1bVhoMk9MWWtMb0ZBQUJXdHFmTGRZdUtjY1lYeDgrNnJMYW04NW5GK2FEd3p5dFhBZnlmR0Q1VGZHSzRadVB5cktNMkxOOCs5TGNOdS93NmRkS0tzRUY1NWhZMXNlYVExQjN3UWZLUS8zaDFXMjRGQUFBQWVEZGVWQVlBQUFDczlob0g5MzUyU0dQVDljWHhHNmxiNEgzRmVHejlsQWN2YWh6UzcvblVLUUFBc0NyOGVzVE96eFhqa0swbTNIVkJLWXVUaXZNMnFadUFLaFREZGpXbDBxODJQVzNPWlcvbWkwWTlYZDdqaGRSSkgwWk5MRTBzUnBhNkE5NVBIc0xyQzE4UGw2ZnVBQUFBQUZnVkxOZ0JBQUFBN1VKTEhzNHZSUXQyVkwxdUlhczl2WmpmU1IwQ0FBQ3IwdnhqQnR5ZlpWbi9yY2IvY2tpSXNmV0tkcDlLM1FSVW5kYUZ0RzkzaUIzck4yNllOU2E4MUR6NXFjbTd2NWs2YWxsdGVNcnQrOFFzZmlWMUIzeVFtT2RYdlh6K0hpK243Z0FBQUFCWUZTellBUUFBQU8zQ3RJRzk1ZzZhdXVEeEVPTm1xVnZnQTN5cmZzcUNDeHFIOUg0d2RRZ0FBS3hLbFVvbEw4WlZXMHk0L2JyYTJPVzRHTUtJNG43bjFGMUExZWtlWXp3cnJGUDd2VTBhWm8xNHNyenpqTlJCU3lzYjJOamg4NXYyR0plNkE1WkNYbWx1T1M5MUJBQUFBTUNxWXNFT0FBQUFhQmRhWDZnNXVQSHg4Mk1JRjZSdWdRK1E1Vm1ZbkdYWmw5OTZnVEVBQUxRckR4Mnp5K3ZGS0c4NThZNUxTNkYyWEFoeC8rSitUTjBGVkowTlFvelROemx0OXB6bWxqRHNkdzA3TFVnZDlFRytzT21hUHlqR2hxazdZQ25NZVc3Q25vK25qZ0FBQUFCWVZTellBUUFBQU8zR0czLy8yMVZkMXVneHRqaDJUOTBDN3llR01HRGZLUThQTEk0L1M5MENBQUNwUERCOGgyZUtNWENyaVhlZmw0VXdxVGgvTVhVVFVKVjJyTW5DUTV1Y051c25yK1dMeXMrVzkveHI2cUIzcy82b242L1R1YmJieWFrN1lHbTBoTXE1cVJzQUFBQUFWaVVMZGdBQUFFQzdjZDIzK3Y5OXlMVk5sNFlZaHFWdWdhVXdidStMSDd6aCtzUDdMVXdkQWdBQUtjMGZ2dDFkV1VQRGw3WmNZK2REWXdoamlvYytucm9KcURJeGxJb1BSM2FMblFadjBuRDc2Yjk1L3ZmblZTNDhmRW5xckxmclhOdjE5R0tzbGJvRGxzTFRmeG8zLzZZd2RvL1VIUUFBQUFDcmpBVTdBQUFBb0YxcGpzM24xb1NhL3lxT3BkUXQ4SDVpaU92WGRLMDl2amlXVTdjQUFFQnFsWEs1VW94TE4yNlkyYmptR211TWlpRU1MZTUzVE4wRlZKdllJOFE0WWFQMU5qaDhrNFpaeHp4WjN2bVcxRVd0TmpocFZ0K2FtdmpkMUIyd05QSktmbjZsOG85Lzd3SUFBQUMwR3hic0FBQUFnSFpsYW4yZi94bHliZFAxSVliOVVyZkFCNGtoak5qN3lnY3Z1ZjZnZnYrYnVnVUFBS3JCVStYZFh5M0c4VnVlTmUvaVVtMXBmSEhlSjNVVFVKVTJDVEhldkVuRDdGc1doOG94VDVkM2VUSlZTSlpsOFF1bjNIWnU4R1pQdEEydnZkRzgrTkxVRVFBQUFBQ3JtZ1U3QUFBQW9OM0pLeTJUWXFsa3dZNjJvSE50cWJiMVJjTURVNGNBQUVBMWVlRDR1dDhWWTk4dHg5KzFVNmtVemluT3ZWTTNBVlZwanc0aDIyV1RodG5uTDNyenpkTitmOFllTDYvcWdNK2ZjdHNCeGRoK1ZmKytzSHp5SzE2YXVQY3JxU3NBQUFBQVZqVUxkZ0FBQUVDN2MvWEEzbmNPdWJicGdSRERscWxiWUNsOHMvN3FCZWMzRHU3OXk5UWhBQUJRYlI0WU1XQjJOckJ4aTYyK3RPNzNRc3dhaW9jK2tyb0pxRHExeFcxWXA0NGREOXlvWVhiNWQwMHYvNlF5dGI1bFZmekc2eDEzZTlkdVhlSzRWZkY3d1FwUVdSeVduSnM2QWdBQUFDQUZDM1lBQUFCQXU1VEhjRTRNWVVycURsZ2FlUWlUczRHTlc2NnFGd0FDQUVCYjh0Yno1QXMyUCt1V2F6cldkRDhseFBDRDhNK0ZHb0MzKzBnV3d2a2I5VnpyaUExUG5YWDBiMC9kZWZiSy9nMjdkbzRuRnVOVEsvdjNnUlhrNWorUDNldXAxQkVBQUFBQUtWaXdBd0FBQU5xbDM3Njg2TnFOZW5RNkswUXZjcUw2eFJENjdydjN4a2NVeC9OVHR3QUFRTFY2NVBnOVhpN0cwVnROblBlVG1KY21GRStrOTBqZEJGU2wzbG1Nc3padW1QWHpQRlJHL0thODYrOVd4bS95MlZObWZyNURWblBNeXZpMVlXV29oTW81cVJzQUFBQUFVckZnQndBQUFMUkw4dy92dDJSSVkxUHJzdEtacVZ0Z2FjUVFSdTl6eWYyTlB6OXM2eitsYmdFQWdHbzJmM2pkazhYNDJwZk92bk9Qa01VSnhYbVQxRTFBTllyN3hGRDY2a1lOc3liSDBEem1xZkx1cjY3SVg3MURWdE82ck5SeFJmNmFzQkk5OU56WVBlNUlIUUVBQUFDUWlnVTdBQUFBb04xcUR1R2ltaEJPS281ZFU3ZkFVdWhSNnR6NXJHSWVtam9FQUFEYWdsOGR1LzB0V3gxeDhlMzVocHY4SUl2eGxPS2h0VkkzQVZXbll3enh1QkJxRDk2NFlmYW8zNGE3THF1VXk1VVArNHR1ZU1xc1BXSVd2cjRpQW1GVnlFUHU2blVBQUFCQXUyYkJEZ0FBQUdpM3B0YjNmR2xJWTlNVnhmSDdxVnRnYWNRUUQ5NXZ5b0pMWmd6cGZXZnFGZ0FBYUF2bVgzajRrbUpNMm1yaXZLdGl5QnFLWjlYZksrNlhVbmNCVmVmanhlMlNEY09BSTcvUU1Idlk3OG83M2JXOHY5Qm5qbW5zM0hHTkh1ZXV3RFpZdWZMd3grZC8vL3JVMUJrQUFBQUFLVm13QXdBQUFOcTM1c3E1b1NZN0lyVHVMa0gxaTFrTTUrM1lNRy9MT2VXNjV0UXhBQURRVnN3Zlh2ZlhZdnhncTNHL3ZEQ1dza25GZWNmVVRVQlYrbUlwaEY5dTNERDcydWJteGNmOXY5Ty8rc3l5L2dJZDErZ3hzaGlmWHdsdHNGTGtNVCsvTXJWK2Nlb09BQUFBZ0pRczJBRUFBQUR0MnBRRGVqMDVwTEhwbHVMNHRkUXRzSlEyWDN2RHRZOHE1cVRVSVFBQTBOYk1QKzdMQzRxeDA1Ymo3OXd2aTNGOGlHR0QxRTFBMVdsOUU2WnYxdFIwK1BwR0RiUEd2L1o2UHU2NWNidTh2alQvNElhbnpOb3dadUc0bGR3SEs5THJyeTk1L1NlcEl3QUFBQUJTczJBSEFBQUF0SHQ1UzM1MkxFVUxkclFsRGZWVEhwemFPS1RmODZsREFBQ2dMWHBneFBZek5oNDY4K1kxMSs4Mk5NUXdxbmlvZStvbW9PcDBqaUdlc2tiWCtPMk55cmVQL04zcHUwMnBWQ3I1Ky8wRE1Rdm5GNlBqS3VxREQ2MzRBLzNUbHlmVXY1UzZBd0FBQUNBMUMzWUFBQUJBdTNmMXdNM21EbWxzK2xWeC9GTHFGbGhLM1VPc09idVlRMUtIQUFCQVcvWFU1TjNmTE1hNDNtZlB1Nkp6eU1hRUdBOHQ3bWVKczREcTg2a1lzeXUvY01ydFA5aTRmUHV3cHhwMnVmL2Qva3NibFcvN1pvalpMcXM2RGo2RTVrcWxlV0xxQ0FBQUFJQnFZTUVPQUFBQW9GVWV4b1VZR2xObndOS0xnL2FiOHNqRk00WnNQamQxQ1FBQXRHVUxqcTE3b1JpSGJYblczQXRpVFdsU0RIRkE2aWFnK3NRUXRna3h1M2ZqOHV3cjMzd3pIL243c1RzLzk2Ky85OUdoTTd1dnRWYk5PU243WUZubElVeC9idHllLzVPNkF3QUFBS0FhV0xBREFBQUFLRnpUZE8xMWczclcvemJFdUdIcUZsaEtNWXZ4eDEvNzBjeStOeC8xanl0dkFBQUFIOElEeDMvbDExbVdmZm1MNCtmdW40ZHNYQXpoTTZtYmdLb1RpNzhPN3RncDdyZFJlZGFaelgvNDQ4U25MejFrMFZwcmxVNHQvdDU2cWVOZ21lVE40MUluQUFBQUFGUUxDM1lBQUFBQWhVcTVYQmt5N2JFSkljWUxVN2ZBMG91YmRGNTd2Uk9LUTBQcUVnQUFXQjFVS3BXOEdOTStjMHpqamV0KzR1TWo4aGlPaXlGMFRkMEZWSjF1TWNZeE5aLys1T0VibFc4N1A4VHN2MUlId2JJby9tVTMrOW16OW53d2RRY0FBQUJBdGJCZ0J3QUFBUENXNTk5NDhmSlBkUDFvNjZMU3gxSzN3TktMSS9lKy9NR3AxeC9TNzhuVUpRQUFzTHA0WmtMOUc4VTRyZS80ZVpmV1pxV3ppdk9nMEhybEtvQi85OWtRcy9HcEkyQ1p0YlQ0Y3dzQUFBRHdOaGJzQUFBQUFONHk1NUM2UllPdmZmemMxbmNnVDkwQ3k2QmpUVTNOaFZtVzdmRFcxVFlBQUlBVjVPRVJkYzhXWThpVzQrZWRGN1BTcE9LOGRlb21BUGlRSG5sdXd0ZHZDK01ycVRzQUFBQUFxb1lGT3dBQUFJQzMrWHR6L3VQdXRYRmtjZXlXdWdXV1ZveXhidCtySHY1V2NidzBkUXNBQUt5T0hoaFJkMStXWmR0dU1XN3VRVEhFTTR2YmVxbWJBR0I1NUNHTTl5Wk5BQUFBQVAvT2doMEFBQURBMjl3NHFOZkxneHViTGk2T1I2ZHVnV1VSUXhqM2phc2V2V242Z1gzK25Mb0ZBQUJXUjI4dEkxelJ1Mkhlakk1ZHM1RXh4T0hGL1U2cHV3QmdHVHp6M0N0L21KWTZBZ0FBQUtEYVdMQURBQUFBZUtlVy9KeFFpa2NWcDlyVUtiQU0xZ2t4VEN6bWdhbERBQUJnZGJhZ1hQZGFNVWIxTzJ2ZXhWbFdPaXZHOE0zVVRRQ3dWUEo4Zk9YQ3c1ZWt6Z0FBQUFDb05oYnNBQUFBQU43aDZvR2IvV0hRdFUzWHhCZ09UdDBDeTZMNE16dGt2NnNmdVdMRzRNMXZTOTBDQUFDcnV3ZVByL3Q5TVFaKzhleTdMc2p5Y0U2SVlZdlVUUUR3UHY3MHgrYlhMMDBkQVFBQUFGQ05MTmdCQUFBQXZKdThlWHlJTlFjVnA1ZzZCWlpGRnVJRjIwMjZyL2ZkdzdaNUkzVUxBQUMwQjc4K2RzQzhiR0RqVnYyMlhQZXdHT1BweFVQcnBtNENnSGZLUXo2NU1xSGU5NHNBQUFBQTNvVUZPd0FBQUlCM2NjMDMrencydUxIcCt1SzRUK29XV0VhZi8vaEhPNTlXekJHcFF3QUFvTDJvVEsxdktjWkZXNDJiUFRYUGFrOEtJZjR3aHRBaGRSY0EvRlArdHpkZWVmMkMxQlVBQUFBQTFjcUNIUUFBQU1CN2FjbkhoRkswWUVlYkUyTTh1bjdLSTlNYWgydytQM1VMQUFDMEovT1AyK2x2eFJqeHhiUHZ2Q2lHY0haeDNpdDFFd0NFRUM5NDhjTDZ2Nld1QUFBQUFLaFdGdXdBQUFBQTNzUFZBemQ3WUhEajR6TkRpTHVuYm9GbFZBb3hYdHE3b2ZHTEM4cjFpMVBIQUFCQWUvUHJZN2YvYlRIMjduZjJuYnRtSVV3c3pwdWxiZ0tnM1hxanBiSm9VdW9JQUFBQWdHcG13UTRBQUFEZ2ZiU0VPS1lVZ2dVNzJxSmVHMjI0NGFoaWxsT0hBQUJBZS9YZ3NkdmZsalhNNjl1dlMzWkVpT0hVNHFGMVVqY0IwTDdrSVZ6eTNMaDkvcHk2QXdBQUFLQ2FXYkFEQUFBQWVCOVQ2M3ZlTmJpeGFWNXhyRXZkQXNzcWhqaHlyeWtQejdoaFNOOUhVcmNBQUVCN1ZTblhOUmZqUjcwYmJydTZZNWZPNWVLSitwSEJ6K29CV0RXVzVDMzUyYWtqQUFBQUFLcWRiOW9EQUFBQWZJQktYaG1keGN5Q0hXMVJiVzNNTHRteFlkNDJjLzc1b2w0QUFDQ1JCZVZkWHlyRzBDK09uZk9UV0ZON1RuSGVOWFVUQUt1Ny9Jby9qdi9xTTZrckFBQUFBS3FkQlRzQUFBQ0FEL0N6L1h2Tkd0VFlkRjhNWVp2VUxiQWN2cmpXRjlZNnRwaGpVNGNBQUFBaC9QcUVIWnVLc2RzV1o4L2JzeFN5MXFzS2JaeTZDWURWVXZPU1BKNlpPZ0lBQUFDZ0xiQmdCd0FBQUxBVThqeWNFV080SVhVSExKY1l5bnRmL3VEUHJ6K2szNU9wVXdBQWdIOTY2Tmk2bTNvM05ON1dzZk82UjRVc25sdzgxQ04xRXdDcmtUeGMvY0padS8rLzFCa0FBQUFBYllFRk93QUFBSUNsTUcxZ3I1c09tUGJZSThWeDg5UXRzQnc2MWRUVy9IZlcwUERsU3JsY1NSMERBQUQ4MDRKeS9lSmlUTnlpNGZhclNsMDZuVjZjRHl0dXBjUlpBTFI5TGFFbEg1TTZBZ0FBQUtDdHNHQUhBQUFBc0JRcWxVbythTnBqWTJLV1RVdmRBc3RwdTMyL3NPK3dZazVNSFFJQUFQeTdoOHE3L0xrWTMrdDM1cndmeDVvNEtZWllsN29KZ0xZc24vYUhzNy82bTlRVkFBQUFBRzJGQlRzQUFBQ0FwVFQxaWVuVEQ5aHMveWVLNDZhcFcyQzV4RERtRzFjOTlJdnBCMjd4Uk9vVUFBRGdQejA0c3U3aFlueGx5L0YzN2hkQ1ByNTRFcjlCNmlZQTJweEt5NUlXVjY4REFBQUFXQVlXN0FBQUFBQ1dVcVZjcnJ4MUZidXJVcmZBY3VvVXN0TGxPemJNNnorblhOZWNPZ1lBQUhoM0Q0ellmc1lHRGZOdVdidHpHQjVpSEZrODFDMTFFd0J0eG96bkp1ejVlT29JQUFBQWdMYkVnaDBBQUFEQU1xaGtULzZzRkhxT0NxNWlSOXUxVlk4dnJOWDZBdDNUVTRjQUFBRHY3ZWx5M2FKaW5QSEY4Yk11eS9NT1kyS01CeGYzczlSZEFGUzFmRWxvR1owNkFnQUFBS0N0c1dBSEFBQUFzQXltMXRlM0RKcjIrR2t4aTlla2JvSGxGV000ZVo4ckg3M3A1d2YxZVNoMUN3QUE4UDUrUFdMbjU0cnhyUytPbjNkK0NObms0dHcvZFJNQTFTcS83b1V6di9aSTZnb0FBQUNBdHNhQ0hRQUFBTUF5bXZwRTQ3UURldGFmRkdMY0xIVUxMS2ZhckpSZi9yVWZ6ZHpxNXFOMmZ6TjFEQUFBOE1GK1BhTHVnU3pMQnZRZE8zZFFESEZzaUdIOTFFMEFWSlZLYzB0elErb0lBQUFBZ0xiSWdoMEFBQURBTXFxVXk1VkIweDVyaURGT1M5MEN5eXVHMkx2VDJwODR0VGlPVE4wQ0FBQXNuVXFsa2hmajZrODEzUFR6ZFR1dmVYeU1ZVVJ4djNQcUxnQ3F3b3pueDMzOTBkUVJBQUFBQUcyUkJUc0FBQUNBNVREMWllblREK2k1LzZNaGhqNnBXMkQ1eFJIZnVQS2hHNllmdE1XOXFVc0FBSUNsOTJ4NXo0WEZLUGM1NDg3L3Jxa0pZMk1NZzBMcisyZ0EwRjVWV2xwYVhMME9BQUFBWURsWnNBTUFBQUJZRHExWHNUdmcycWJUc2hBYVU3ZkFoMUFLcGRKbGUxLzg0QmJYSDk1dlllb1lBQUJnMlR4NjR2Wi9LTWFRZm1QblhoQkxwVW5GZWN2VVRRQ3Nlbmtlcm4xdTNOY2VTOTBCQUFBQTBGWlpzQU1BQUFCWVR0TUc5cHB4d0xUSEhpNk9mVk8zd0lld1VhbEw2ZXhpSHBrNkJBQUFXRDRQbnZDVnU3T0docTAzNzdURG9Wa1d4aFFQZlR4MUV3Q3JUQ1Z2Q2FlbGpnQUFBQUJveXl6WUFRQUFBQ3luU3FXU0gzRHRZdzFaaU5lbGJvRVBJOFo0eEg1WFBmcUxHUWYydVRGMUN3QUFzSHhhcjdSZWpFdDdqci9oMms3NW1pY1V6L09IRi9jN3BlNENZQ1hMODZsL0hQL1ZwdFFaQUFBQUFHMlpCVHNBQUFDQUQySGF3RDdYSHpCMXdZUEZzVi9xRnZnUVlzekNKVisvL0lFK054Nnk1UXVwWXdBQWdPWFhOR0t2dnhkajFPWm56YjZrSnFzWlh6emQzeTkxRXdBclRVdmUwdUxxZFFBQUFBQWZrZ1U3QUFBQStQL1l1L01vdTZveTRjTjduMXVWZ1RBUGpueWlDSTJFVkNabnV6VVNoSVRNUUpGS0lCQVFJcUlvQ2kzSW9HVkpKb0lNMnFnTURTUWhRQ29KaEJEQUtDUWgyb29LcGpLS3RncUVxUlVCWlJJeTFEM2ZpZDNmMTNZN0Fhbkt2dmZXODdCcTdYZlhYNzgvcUxWeWF0MjNEbXlELzN5TDNab3ZaYUYwVytvVzJFWjcxZGQxdXliTHNoRmIvNzlPSFFNQUFHeWIxV2NmOG1CeEhEWGd3dVdEWThndURUSDJUZDBFUU1mSzgzek9ZeGVOK0ZucURnQUFBSUJxWjhFT0FBQUFZQnZOYStwL2UxUHJtdnRpaU85TzNRTGJJc1l3Yk16MWJaOHN4c3RUdHdBQUFCMmo3ZXlEbDJWTkN3YjJHN2pYcEJqajFyY2M3Wlc2Q1lBT3NhbTkzTjZTT2dJQUFBQ2dGbGl3QXdBQUFOaEdXOS8yMVRSMzNYbWxVdmhPNmhiWVZqSEVHVWZNWExWczRRbjlmNXE2QlFBQTZCamwxc2IyNHJoaVlNdUt1WG5QOElYaTMvMmZLdTcxcWJzQTJBWjUvcTlQekJqeFVPb01BQUFBZ0ZwZ3dRNEFBQUNnQTdTTzYzUFgrUG5ybHNjUUQwN2RBdHVvWjFhWDNkRFFzdUM5YTVzYk42V09BUUFBT3M3SzVrRy9MNDR6KzA5WmZsWHg3LzVMUW96RFVqY0I4SnE4OUhMWVBDVjFCQUFBQUVDdHNHQUhBQUFBMEVGaXVYeE95RXIzYmgxVHQ4QTJpYUgvUCt5My85WVBhWDB1ZFFvQUFORHhWcDEzOE0rTFkvaUFHZmNNaVNHN3BKaDdwMjRDNE5YSXYvN2s5RkZQcEs0QUFBQUFxQlVXN0FBQUFBQTZ5STFOZlg4MGZ2NzYyMklJbzFPM3dMYUxaeHc1dTIzSkxjY1BXSnE2QkFBQTZCeHRaMzM0MjFuTGluNzl1c2RQeEN3MEY5L2FQWFVUQUgvWGMrVXQ3UmVtamdBQUFBQ29KUmJzQUFBQUFEcFMzbjUraUtXUnhaU2xUb0Z0bE1WUzZmcWo1cXpwZi9PRXZrK21qZ0VBQURwSHVYblFsdUw0MmtIVGw5M1FQWmErSEdMOFdQQlpBb0JLZHRsakY0MTRLblVFQUFBQVFDM3hTM0VBQUFDQURuVFQyTDdyanBtMy9vWVF3M0dwVzZBRHZESEVmRmFXWmNQSzVYS2VPZ1lBQU9nODZ6OC8rT25pK09UQUdmZDhJNFRzMG1JK05IVVRBSC9tNlJmREM1ZWtqZ0FBQUFDb05SYnNBQUFBQURwWSs2YjI1bEwzVWxNeGRrdmRBdHN1RGozaStyWi9Mb2FMVXBjQUFBQ2RiK1ZaSDE1ZkhJZjFuNzU4VkphVkxpN20vVkkzQWZDZjhqeE1lM3A2NDdPcE93QUFBQUJxalFVN0FBQUFnQTdXT3FIdlE4Zk1YM2QxQ1BHVHFWdWdZOFFwUjh4Wjg5MkZFL3IrS0hVSkFBQ3dmYXo2L01HM0hYRDZrbS8zZXZNT3B4Zlg4NHF2blZNM0FYUnhqenorNUcrK25qb0NBQUFBb0JaWnNBTUFBQURvQkpzMmJaclNyVnYzRTR0eGg5UXQwQUhxc3hodU9uTFc2b0czVE96Mys5UXhBQURBOXZIenJ3N2RXQnd6K2sxYk5xdVUxVTB1NXEzUHVhWEVXUUJkVXA3blh5cGZPL0hsMUIwQUFBQUF0Y2lDSFFBQUFFQW5XSERzd1A4WVAyLzkxMklNbjAvZEFoM2tiYkV1WGxXY1kxT0hBQUFBMjlmcWN3Yi9wamdtRGJqd3U5OElJYjhzaFBpaDFFMEFYVXUrL3ZHSFhweWR1Z0lBQUFDZ1ZsbXdBd0FBQU9na0w3VG5NM2FxaTZjVTQyNnBXNkNESEgzRURXdE9XWGhzM3l0VGh3QUFBTnRmMjlrZmFpdU9RZjJtZlhkc2xvVVp4YnhQNmlhQXJxQWN3bm5sMXNiMjFCMEFBQUFBdGNxQ0hRQUFBRUFuV1R5K3orL0d6MXMvTGNZL2Z1Z1Fha0lXd3FWSHpscjVnMXNtRGx5YnVnVUFBRWhqOVRrZm1yZlBtUXNXNzdiWFhtZUdHTStPSWV5WXVnbWdodjNnc1dtSEwwb2RBUUFBQUZETExOZ0JBQUFBZEtMZnZQVFV2N3hoaHowL0dmeFZmMnBIejFoWDF6cjRteXZlcyt6VVFTK2tqZ0VBQU5MWWNISGpTOFV4K1IxVGwxL1hvNVJOalNFZVY5eGo2aTZBV3RNZThuTlNOd0FBQUFEVU9ndDJBQUFBQUoxbzJjUkJMNCtmdCs2OEdPT2MxQzNRZ1E3Y2RlZGRyeXJPWTFLSEFBQUFhZjNzM0lNZkw0NkpBNmJmODQwOFpwZkZFTjZYdWdtZ1Z1UjV1UDN4NllkL04zVUhBQUFBUUsyellBY0FBQURReVZvZnVQbW1jYjBienlqR2dhbGJvS1BFRU1jZmVjT3E3OTF5YlA5dnBtNEJBQURTYS92OGgzK1VaZGtIK2s2NTU3aVloYW5GdDk2Y3VnbWd5bTBwdDRlelUwY0FBQUFBZEFVVzdBQUFBQUE2V2JtNXVkdzBkODNuU3FYUzB0UXQwTEd5UzQrWXMrcStoUlA2MzUrNkJBQUFTSzljTHVmRk1YdkFXWGZkbk8vZTdhd1k0K2VLZTgvVVhRRFZLQS81Tlk5ZmRQaFBVM2NBQUFBQWRBVVc3QUFBQUFDMmc5WnhmWmNkTTMvOW5jVTRMSFVMZEtEdUlXYnpSbDd4L1hjdS92Zy8vaTUxREFBQVVCbmFaaHo2WW5FMEh6UjErYlhkc214R2lQSG9zUFZGMkFDOFVpOXNMdWRmU2gwQkFBQUEwRlZZc0FNQUFBRFlUdks4L2V3WVMwT0tzWlM2QlRwS0RPRnQ5VHZ0T0N2THN0SC85YllLQUFDQVAxcC83c0ViaXFPcC85VGxYNCtsMG1YRlBDQjFFMEExeUVPNDZOY1hEdnQxNmc0QUFBQ0Fyc0tDSFFBQUFNQjJjdFBZdnV1T21iZCtab2pocE5RdDBMSGl5TkhYcnpxckdDNU1YUUlBQUZTZVZlY2UvTjJzcGVWZC9Yb2NmRUp4blZKOHZTRnhFa0FsZTZLOS9hbUxVMGNBQUFBQWRDVVc3QUFBQUFDMnAzenpGME9zSDFkTXZWS25RRWVLSVV3ZU03dnQzbHVQSC9EZDFDMEFBRURsS1RjM2w0dmoyZ05hbGl6bzBiM25lVEdHMDR0Nzk5UmRBSldtSE1wZmZHTEdoQmRUZHdBQUFBQjBKUmJzQUFBQUFMYWpHNXY2UHpGdS9ycExZb2hmU04wQ0hhd3V5MG8zalp4MS96c1hUM3pYcjFQSEFBQUFsZW5uelVPZks0NnpHeTVjY1hVV3drVXhoREdwbXdBcXlOb25IdnpEek5RUkFBQUFBRjJOQlRzQUFBQ0E3V3pqQzg5ZDFHUEhYVDVXaks5UDNRSWRLb1kzMWRmVnozdjMxU3NQdVcvU3dNMnBjd0FBZ01xMTl1eEJ2eXlPSS9wUHUrZVFrSVZMaXdlS2h0Uk5BS20xbDl2UEtyYzJ0cWZ1QUFBQUFPaHFMTmdCQUFBQWJHY0xUL3pBODAydDY3NllaZkhLMUMzUThlSUg5KzVaZDNFeGZEcDFDUUFBVVBsV25mUGhwVm5MaW9GOTYvT1BoUmhiUWd4N3BtNENTT1JiajE4NGJFbnFDQUFBQUlDdXlJSWRBQUFBUUFxMy9PeWEwSGpnSjR1cGIrb1U2R2d4aGs4ZGNjUHhPYzk5QUFBZ0FFbEVRVlNxK3hjZTIzOTI2aFlBQUtEeWxac0hiU21PYi9RNzk4NmI0czY5dmhSQ2ZtcnhaRkdmdWd0Z085clNucmVmbVRvQ0FBQUFvS3V5WUFjQUFBQ1FRR3RyWTN2VDNEV2Z6VXFscGFsYm9EUEVrRjB4K29hVjZ4WWRPM0JsNmhZQUFLQTZySjQ2N0hmRmNYcS82U3UrR1VKK1NReng4TlJOQU50Rm5sL3grUFJoRDZUT0FBQUFBT2lxTE5nQkFBQUFKTkk2cnUreWNmUFgzeHBER0pPNkJUcEJ6MUtvdS9uUTYrOTcxMTNIdmZ2cDFERUFBRUQxV1AzNVFUOHJqbUg5cGk4ZkZ2UHNraEREQWFtYkFEclI3L0lYWC81UzZnZ0FBQUNBcnN5Q0hRQUFBRUJDK2FaTm40dmR1bTM5aS96ZFU3ZEFKM2pyVGxuM203S21CWWVYV3h2YlU4Y0FBQURWWmZYbkQ3NHorL2pWZHpXOGRmOVB4UkMvVUh4cjE5Uk5BQjB0TDRjTEh2MlhNZjQ0RVFBQUFFQkNGdXdBQUFBQUVtbzlkc0F2eDg5Yjk3VVE0K2RTdDBBbk9YVE15SCtZV3B4bnB3NEJBQUNxVC9tS1NadUw0NUlEVzFiTTd0WXR0TVFZVGludXBkUmRBQjNrRjQ4Ly9QelhVMGNBQUFBQWRIVVc3QUFBQUFBU0t6KzdhVXEyYS9lSnhmaTYxQzNRS1dMNDNKZzVxKysvZFVLLythbFRBQUNBNnZSQTg2Q25pdU9UL2FZdHV6TEcwcVhGUERoMUU4QzJLb2Z5NThxdGpadFNkd0FBQUFCMGRSYnNBQUFBQUJKcm5UVHcyWEh6MTU0ZlEzWlY2aGJvSkRHTDRkcFJONno2OTl1TzdiODZkUXdBQUZDOVZwOHplRTF4SE5KMyt2SWppK2ZvaTRwNTM5Uk5BSy9SM1k5Tk8zeFI2Z2dBQUFBQUxOZ0JBQUFBVklSOHdjK3ZEWTN2K0VRTXNYL3FGdWdjY2NlNkVCY05uYlBtUFVzbTlIMHlkUTBBQUZEZDFueis0RnNPT0gzSkhUM2UyUE96eGZXYzRtdm4xRTBBcjhLV0xXSHpaMUpIQUFBQUFQQ2ZMTmdCQUFBQVZJRFcxc2Iyc2EzclAxdkt3dkxVTGRDSjl0a2g1Z3NhV2haOFpHMXo0NmJVTVFBQVFIWDcrVmVIYml5TzZRMHRLMmJHYm1GS2pPR0U0cDRsemdKNEpiN3h4TFFSNjFOSEFBQUFBUENmTE5nQkFBQUFWSWg1VFFmZE0zN2Urb1VoaGlOU3QwRG5pUi9jZjcvOXYxRU1KNmN1QVFBQWFzUGE1a0cvTG82VCtrNWQ4YzJZaGN1SytSOVROd0g4RFU4OUY5cS9sRG9DQUFBQWdQOW13UTRBQUFDZ2dteHB6Lys1cmk0ZVhvdzlVcmRBNTRrbmpibGgxZHBiaiszLzFkUWxBQUJBN1ZoejdxRDdzeXo3WUo4cHk1dGlETk9MYisyVHVnbmdmOHZ6Y1A3dnBnMzdYZW9PQUFBQUFQNmJCVHNBQUFDQUNqSi9mSjhIeDg5YlB5UEU4TVhVTGRDWnNwQjlaY3ljMVQrOWRVSy91MUszQUFBQXRhTmNMdWZGTVhlZk14Y3Mybld2UFQ4WFFqeXJ1UGRLM1FYd1g5b2VlL0Q1ZjAwZEFRQUFBTUQvWk1FT0FBQUFvTUtVbjNoK2V2Ym1uWTR2eHJlbWJvRk9WQmRqYkIwMWM5VjdienVoL3k5U3h3QUFBTFZsdzhXTkx4WEhsdzlvV1hGdGoyN2h3bUllWDN6RnhGbEExNVp2YVc4L3ZkemEySjQ2QkFBQUFJRC95WUlkQUFBQVFJVnAvY3o3WGhvM2Y5MW5ZNGdMVTdkQVo0b2g3RlpYSHhjZk9XdjErMjZaMk8vM3FYc0FBSURhOC9QbVFZOFZ4N0Y5cHk3L2VvenhzdUpKNU4ycG00QXVLZyt0ajE4NDdIdXBNd0FBQUFENGN4YnNBQUFBQUNyUTNLUDczRHArL3Jwdmh4Q0hwRzZCemhVUHlPdkMzTUV0SzBZc2F4NjBKWFVOQUFCUW05YWNlL0FQc2l4N2I1OHB5NDZMZVp3V1luaFQ2aWFnUzNraGJOcnl6NmtqQUFBQUFQakxMTmdCQUFBQVZLcTgvT2tRUzJ1S3FYdnFGT2hNTVlRaHUrNjM2OWVLOFJPcFd3QUFnTnBWTHBmejRwamQwTExpbGxnZnppa2VSczRvN2oxU2R3RmR3cGMzWER6ODhkUVJBQUFBQVB4bEZ1d0FBQUFBS3RSTlkvdisrL2g1Nnk4Tk1YdytkUXQwdm5qcUVYTlcvMkxoaEg2WHBpNEJBQUJxMjlybVFTOFV4M2tIVHJuclgrdXp1aG5GODBoajZpYWdwajN3NkRPUFhKWTZBZ0FBQUlDL3pvSWRBQUFBUUFVclAvM1VsR3pQUFNjVTQ5NnBXNkN6eFJndk91S0dWYjlhZUd6LzIxSzNBQUFBdGUrQjh3NTlxRGlPUG1qeVBZT3lVbjVaRExGLzZpYWc5cFRMK2FmS1YwemFuTG9EQUFBQWdML09naDBBQUFCQUJXczlkZEFMNCthdk96T0cySnE2QmJhRFV2SC8rZzFqcmwvem9WdVA2OXVXT2dZQUFPZ2ExcC8vNFJWWjA0SjNIZFJ2ejVOaURCY1UzM3BkNmlhZ1pyUStPbjNvMHRRUkFBQUFBUHh0RnV3QUFBQUFLdHpjby92TUd6OXYvU2toaHNHcFc2RHp4UjJ6TEN3ZU5YdjFlMjg3dnQvanFXc0FBSUN1b2R6YTJGNGNWKzEzenRMV0hYYkt6Zzh4ZnJxNGQwdmRCVlMxRjhMR0xXZW1qZ0FBQUFEZzc3TmdCd0FBQUZBRnRwUzNmTHF1VkxmMWpWNzFxVnRnTzNoenFSUVhELzdtaWc4dE8zWFFDNmxqQUFDQXJ1T1gwdzU1dGpnKzEyZkszVmRsV2QxWGlubFU2aWFnYW4xNXc4WEQvZkVnQUFBQWdDcGd3UTRBQUFDZ0Nzd2YxMi85K0huckxnc3hmaTUxQzJ3UE1ZUUJ1K3kwNjQxWjA0SWovdXRORWdBQUFOdk51dk0rOG92aUdOMTN5dkxEUWhZdktlYURVamNCVmVXbmp6N3p5R1dwSXdBQUFBQjRaU3pZQVFBQUFGU0ozMjBxdCt6V3ZUUzJHUGRKM1FMYnljalJJL2ZmK2tIVzAxT0hBQUFBWGRPYTh3NytUdGJTMHI5UC9hQlBGTmZtNG12MzFFMUF4Y3REWGo2MWZNV2t6YWxEQUFBQUFIaGxMTmdCQUFBQVZJa2xFL3ErMk5TNjl0TlpsaTFLM1FMYjBhZkh6Rm4xeUswVCtsK2NPZ1FBQU9pYXlzM05XNHJqYXcwdDM1a1Q2N3R0WGJMYnVtem44eGJBWHpOcnc3VER2NXM2QWdBQUFJQlh6aTk4QVFBQUFLcElhMVBEYmVQbXI3ODFoakFtZFF0c0x6SEVHVWRjMy9iWXd1TUd0S1p1QVFBQXVxNjF6WWM5VXh5bk43UXN1ekxXWjVjVzgyR3BtNEFLazRkbnR2d2hQeXQxQmdBQUFBQ3ZqZ1U3QUFBQWdDcXpzUncrM1NPR2p4VGpqcWxiWUR2SlFzeG1qWnExK2plM1RleDNUK29ZQUFDZ2ExdmJQUGlueFRHa1ljcnlVWG1NWDRraDdKKzZDYWdNZWNnLy8vaFhoLzQyZFFjQUFBQUFyNDRGT3dBQUFJQXFzN0Rwb0VmSHoxdlhIRUs4T0hVTGJFZmRTNld3Y05TY24zend0Z252WEpjNkJnQUFZTzE1QjkvVzBMSmdTYWpmODdUaStzWGlhNWZVVFVCSytROGV1L0JIMTRScFExT0hBQUFBQVBBcVdiQURBQUFBcUVLL2VlRHByNzN1SFhzY0YyUHNuN29GdHFOZFM2SDByZUhYL1BqOWQ1ejBuc2RTeHdBQUFLeHRidHhVSEpmczMzTFhuTzcxOVJmRUVFNHE3cVhVWGNCMnR5WGZFazh0bDV2THFVTUFBQUFBZVBVczJBRUFBQUJVb1dYTmc3YU1uN2YyMUJEaTk0dHJscm9IdHArNGQ3ZHUzZThjUEd2MWg1Wk43UGY3MURVQUFBQmIvYUw1MENlTDQ1U0dscnUvR2VycUxnc3hERXJkQkd3L2VjaS8rc2lNb1d0U2R3QUFBQUR3Mmxpd0F3QUFBS2hTTjQxdCtPRzQxdlZYeFJnK25yb0Z0cXNZR25ZdWhac2JXaFljL2w5dml3QUFBS2dJYTVzL3NxbzRQdHd3WlZsamlObU1ZbjViNmlhZzAyM1lzdVdwNXRRUkFBQUFBTHgyRnV3QUFBQUFxdGltbDdlYzA3MW4zWmhpZkVQcUZ0aWVZZ2lEMy83Mi9XZGxMUzNIbHB1Ynk2bDdBQUFBL3RUYTh3WXYyTGRsMXUwNzFPOXpSdkg4Y2s3eHJSMVROd0dkSTIvUFAvSEVqQWt2cHU0QUFBQUE0TFd6WUFjQUFBQlF4VzZaMk8vM1RhMXJ6OHhpZGtQcUZ0amVZZ2pqUnI5OTlOUEZlRnJxRmdBQWdQL3R3ZWFKTHhmSDFONHRkODhzMWRWTkt4NWlqZ3QvZkpRQmFranJJeGNPdlROMUJBQUFBQURieG9JZEFBQUFRSlZyYldxNGNmeTg5VnMvcERjMGRRdHNmL0dUUjh4WjllVENDZjIvbkxvRUFBRGdML2xwODBlZUtJNkpCMDVlZW5sZFZycXNtRCtRdWdub0VML2IyTjcrbWRRUkFBQUFBR3c3QzNZQUFBQUFOV0JqdnVYVTdyRnViVEh1bUxvRnRyL1lNdnI2MVU4dE9xN2ZOMUtYQUFBQS9EVVBuSC9JZlZtVy9kTkJYMTQyUG1SaGV2R3QvNU82Q1hqdDhoRE8rdldGdzM2ZHVnTUFBQUNBYldmQkRnQUFBS0FHM05MVTcrSHg4OWFmWDR5WHBXNkJGTElZL3VXSTY5dWVYbmpjZ05iVUxRQUFBSDlOdVZ6T2krUEdONTExMTZMZGQ2MC9LNGJ3dWVMZU0zVVg4S3A5OTdIcGgxOFRwcFpUZHdBQUFBRFFBU3pZQVFBQUFOU0kxZ2NXL012WUF4dkhGZVA3VXJkQUFsbUkyZXd4YzFZL2MrdUVmbmVsamdFQUFQaGJucGh4Nkl2RjBYelExT1hYWnZrZjMyYlhWSHpGeEZuQUs3T3hmZlBtVS81cllSWUFBQUNBR21EQkRnQUFBS0JHbEp1YnkwZk5Xek9wUHBSK1VseTdwZTZCQkxyRlBOeHl4SnlWSDFrNFllQ1BVc2NBQUFEOFBldlBQWGhEY1l3L2NQTGRsOWZGMHRhMzByOHJkUlB3dCtWNVB2V3hpMGI4TEhVSEFBQUFBQjNIZ2gwQUFBQkFEYmw1Yk45MVRmUFdUNDhoZkRGMUN5UVJ3NDRobE80WU9hZnRnNHNuREhnZ2RRNEFBTUFyOGNENUgvbCsxdEx5M3Q2bGZ6b2h4bXhLOGEwM3BHNEMvcUsxano3NHd2VFVFUUFBQUFCMExBdDJBQUFBQURYbWhTY2ZuYnJUWG5zM2hoaDdwMjZCUlBhb0MvRTd3MmF0L3VDZEUvczluRG9HQUFEZ2xkajZadnJpdUxiMzUyK2JuKzI0MDdraGhzOFU5eDZwdTREL3J6MFA0YVJ5YStPbTFDRUFBQUFBZEN3TGRnQUFBQUExNW83VGhtNGMyN3ArVWhiQzk0cHJscm9IMG9oN2R5K0Z1NCs0YnRXSEZwN1kvNG5VTlFBQUFLL1VUNmVQZXI0NHpubEh5OUtyNityaVJjWHp6WkdwbTRBL3VtVEQxQ0gzcFk0QUFBQUFvT05ac0FNQUFBQ29RZk9hRHZwQjA3ejEzNGdobkphNkJSSjZlNmlMZDQyK2V1V2dSWk1HUHBVNkJnQUE0Tlg0V2ZNaER4YkhVUWRPV1Q2NEZNS2x4ZHczZFJOMFdYbjRSYjdwK2ViVUdRQUFBQUIwRGd0MkFBQUFBRFZxMDR2UG50dTkxODZqUW9odlNkMEN5Y1RRTyt0Wit2YmdXYXNQV1RheDMrOVQ1d0FBQUx4YUQ1eDM4TEtzYWNIQTNnMTdUQ3FlY2I1Y2ZHdXYxRTNReGVSNU9aKzA0ZUxHbDFLSEFBQUFBTkE1TE5nQkFBQUExS2lGSjM3ZytYRTNyVHMxbE1JZHFWc2dzWUc3RkQ4SGc3KzVZc2l5VXdlOWtEb0dBQURnMVNxM05yWVh4eFg3dGl5YXUwTnBweStFR0Q5VjNPdFRkMEZYa0lmOHlnMFhEbDJSdWdNQUFBQ0F6bVBCRGdBQUFLQ0d6UjNmNTg1eHJldG1oUmducG02QnhENnc4MDY3TGhvOGE4WHdaUk1Idlp3NkJnQUE0TFY0c0huMDFqZHpuOWw3eXZLcllnaVhGRi9EVWpkQmpYdjBEeStHczFOSEFBQUFBTkM1TE5nQkFBQUExTGhOTDdkL3BsdlB1bzhVNDV0VHQwQktNWVRCdTVSMm5mZnVxMWNlZGQra2dadFQ5d0FBQUx4V1B6M3Y0SjhYeC9BK0Z5dzd2SGpZdVNURStJN1VUVkNEOGp5MGYreTNYeDMyWE9vUUFBQUFBRHFYQlRzQUFBQ0FHbmZMeEg2L2I1cTc3cFNZeGR0VHQwQUZHTGwzajJ4TzFyVGdtSEpyWTN2cUdBQUFnRzJ4N2d1RHY1VjkvT3E3ZSsvOTlsTkRqRjhxdnJWYjZpYW9JZGR1bURwc1Nlb0lBQUFBQURxZkJUc0FBQUNBTHFCMVhKODdtdWF0bnhsRE9DRjFDeVFYNDlqUkkvWi9PV3RwT2JIYzNGeE9uUU1BQUxBdHlsZE0ydnFHN3E4ZDJITDdqVmxwaDVZWTQ4ZUN6NFBBdG5ycytmTHpaNmFPQUFBQUFHRDc4QXRWQUFBQWdDNWk4MHRiUHR1dFo5Mmh4ZmptMUMyUVhBekhqOTUzZEh2VzBuS3lKVHNBQUtBV1BOQTg0cW5pK0dUdnlVdXZ5RUs4Tk1SNFNPb21xRko1bnJkUGVucGE0N09wUXdBQUFBRFlQaXpZQVFBQUFIUVJ0MHpzOS91eDg5Wk95a0oyWitvV3FBZ3huamg2M3pGYmwreE9zV1FIQUFEVWlwK2VmOGphNHZoSTd5bkxSMlY1Zm5IeDhMTmY2aWFvS25tNGJzUFVZVXRTWndBQUFBQ3cvVml3QXdBQUFPaEM1bzF0K05hNDF2WFhoaGcrbXJvRktrSU1KLy94VFhaWmRtcTVYTTVUNXdBQUFIU1VuNTUzOEcwSG5MN2syM1Y3ZFR1OWVQZzVyL2pXenFtYm9Bbzg5bnorL0JtcEl3QUFBQURZdml6WUFRQUFBSFF4K1hNYno0aTdkRCtzR1BkTzNRSVZJY1pUUnM5dTI3cGtkNW9sT3dBQW9KYjgvS3RETnhiSGpIMWI3cHpkczlSalN2RUFkRUp4enhKblFhWEs4N3g5MHRQVEdwOU5IUUlBQUFEQTltWEJEZ0FBQUtDTGFaMDA4Tm1tdVdzbnhTeTdNMng5ZnhldzFTZEd6VnBaenJMczA1YnNBQUNBV3ZOZzg3QmZGOGRKQjB4ZWVubGRubDBXWXZoUTZpYW9RTmR1bURwc1Nlb0lBQUFBQUxZL0MzWUFBQUFBWFZEcnVJWWxUZlBXWHh0RE9DbDFDMVNPZU5xb1dXM3R4ZkNaMUNVQUFBQ2Q0ZWZuSDlMV3UyVnBjeXhsM3ltdTlhbDdvSUk4L0lmMmpaOU5IUUVBQUFCQUdoYnNBQUFBQUxxcVp6ZWVHWGJwL3BGaTJpZDFDbFNRMDhkY3Y2cjkxdVA2bjVrNkJBQUFvS01kMkxKOGNGYktGZ2ZMZGZDbnRyN0wvc1FucDQ5NlBuVUlBQUFBQUdsWXNBTUFBQURvb2xvbkRYeDIzRTFyVGd5bDB0M0ZOVXZkQTVVam5qSG0rdFdsMnlZTytHeDU2MGZzQUFBQWFzQTdMcmo3a0ZLcGRGc3g3cEM2QlNwSjhlRC90VWVtRHJrbmRRY0FBQUFBNlZpd0F3QUFBT2pDNW83dnU3eHAzdnJMWWdobnBHNkJDblA2cUpsdDNiTXMrNFFsT3dBQW9OcjFibGwrV0tsVXVyVVllNlp1Z1lxU2h3ZkN4dWZQVFowQkFBQUFRRm9XN0FBQUFBQzZ1TisrOU5SNXIrdTU1MkhGMkNkMUMxU1VHRDQrYWxaYlhkYlNja3E1dWJtY09nY0FBT0MxT0xCbDZkQ3NsQzBzeGg2cFc2RENiTWxEbUxqaDRzYVhVb2NBQUFBQWtKWUZPd0FBQUlBdWJ0bkVRUzhmUFhmTjhhV3M5TVBpMmkxMUQxU1lrMGZ0TzZaYjFyVGdvK1hXeHZiVU1RQUFBSzlHN3d1V2o4eEsyZnhpN0o2NkJTcFBQblhEMUtIM3BhNEFBQUFBSUQwTGRnQUFBQUNFK2VQNnRvMmR0KzVMV1loVFU3ZEFCVHArNUlqOTZ3ZTNyRGgrV2ZPZ0xhbGpBQUFBWG9uZVU1WTFabG04TWM5RGZlb1dxRHo1VHg1NSt0SEpxU3NBQUFBQXFBd1c3QUFBQUFENG8zanp6MmFFb3c0Y1VZd2ZTTjBDbFNhR01IN25mWGV0Zi9mVks0KzViOUxBemFsN0FBQUEvcGJlazVjZWs4VnNWdkM1RVBoTFh0cmNYajZ1Zk1Va3ovY0FBQUFBL0pGZnBBSUFBQUR3UjYydGplMUh0cTQvdmxzTXE0cnJqcWw3b0FJMXZxbDdxYTZoWlVIVDJ1YkdUYWxqQUFBQS9wSStVNWFmbU1YczZtSXNwVzZCU3BUbitWbVBUeC8yUU9vT0FBQUFBQ3FIQlRzQUFBQUEvcjlibWc3NlZWUHJ1ak5qREZlbWJvRktWUHhzak5sMzMvMXZIWDMxeXNaRmt3YitJWFVQQUFEQW4rb3paZm1weFhGNThaV2xib0ZLbElmdzdVZW5EL3Q2bUZwT25RSUFBQUJBQmJGZ0J3QUFBTUQvTUg5ODM2dVBucnQ2VkF4eGVPb1dxRVF4aE1ORGo5SzNobC8rNDVGM25QYWU1MUwzQUFBQWJOVm55ckl6aXllV2k4SWZIMXVBUDVPSHAxNStPWnhZTHBmejFDa0FBQUFBVkJZTGRnQUFBQUQ4RDFzL1pOUTA2LzZUUTg4ZWE0cnJYcWw3b0VKOXFINlg3a3NQdmY2K29YY2Q5KzZuVThjQUFBQmRXNS9KeTFwQ2pGOU0zUUdWTEEvbGovM21rcUgva2JvREFBQUFnTXBqd1E0QUFBQ0FQOU02OFYyL2JtcGRlM0tNOGRiZ0w5L0RYL091WHFIYmlpSFhyVHJzMnlmMmZ5SjFEQUFBMFBWa1dSWVB2R0RwcGNYeisrbXBXNkNpNWZtMUc2WU9YWmc2QXdBQUFJREtaTUVPQUFBQWdMK290YW5odG5IejFuMnpHRCtSdWdVcTJFRTk2dUwzUmw1My82R0xUM3pYZzZsakFBQ0FyaU5yV2xEcWZjSFNxNHZ4eE5RdFVNbnlFSDcxVW5ualoxSjNBQUFBQUZDNUxOZ0JBQUFBOEZmbFQ3end6L0ZOT3c0cXhvTlN0MENsaWlIc1c2cXIvOTdvMmFzUFczUjh2L1dwZXdBQWdOcVh0U3pvZG1EZjNhOHZ4ckdwVzZEQ2JjbmJ5eE9lbkQ3cStkUWhBQUFBQUZRdUMzWUFBQUFBL0ZXdG4zbmZTMDAzcmgwZjYrS1BpMnVQMUQxUXdkNFVRN2huNU95Mm9ZdVBIL0NUMURFQUFFRHRldE5aZC9YcXZmUHVONGNRaDZSdWdVcVg1K0ZMajB3ZitzUFVIUUFBQUFCVU5ndDJBQUFBQVB4TnJjYzByQjA3YjkxWldRaGZTOTBDRlMyR1BVc2hXelo2NXFwUmkwN292eUoxRGdBQVVIdjJhZm5PN3J2dlVuOTdNYjQvZFF0VWdSV1AvdXE1NmFrakFBQUFBS2g4RnV3QUFBQUErTHNXak90NytkRTNyUjRTUXh5ZXVnVXEzTTZ4RkplTW1kbDI3SzBuRExnbGRRd0FBRkE3ZXJmYy9hWWQ2K3EvWFl4OVVyZEFGWGltZldNNHJ0emEySjQ2QkFBQUFJREtaOEVPQUFBQWdMK3JYQzduUjgxWjg5SDYrckE2aFBpRzFEMVE0WHFFVWpadjlQVnRuMXgwM0lBclU4Y0FBQURWcjgrVXUvZVBkZGwzWWdodlRkMEMxYUJjTHAvODZGZUdQcHE2QXdBQUFJRHFZTUVPQUFBQWdGZms1Z2w5bnh4MzA1b1RRaGEvVlZ4ajZoNm9jS1VZc2l0R3oxNzEra1hIOS85eTZoZ0FBS0I2OVptOGRFQ0lwVzhWRCtLdlQ5MEMxU0FQK1ZVYnBnNWRtTG9EQUFBQWdPcGh3UTRBQUFDQVYyenUrTDdmYnBxNzl0SVk0eG1wVzZBYUZEOHJMV05tcjNyZGJROHQrblM1dWJtY3VnY0FBS2d1ZlM2NCs1Q1FsVzRweHAxVHQwQ1ZlR0RMVTVzL216b0NBQUFBZ09waXdRNEFBQUNBVitXRnB4NC9kNmU5OWo2NEdBZWtib0dxRU9NblI3MXR6T3VHWDc3a3VEdE9HN294ZFU2WDlmS3ZIOG5yMy9EKzFCa2tzbW56NDZrVEFBQmVyZDZUbHg2VFphWHJpckZiNmhhb0VpKzN0NGZ4ajEweDRnK3BRd0FBQUFDb0xoYnNBQUFBQUhoVnRpNElOZDJ3ZG55c2kvY1gxeDFUOTBCVmlPSG91cDNmc01md3kzOTh4QjJudmVlNTFEbGRVZmt6Rjc5VUhEOU0zUUVBQUs5RXcrUmxaMlF4dTZnWXM5UXRVQzN5UEp6eHlMVERWcWZ1QUFBQUFLRDZXTEFEQUFBQTRGVnJQYmJoNStQbXJqczF4SEI5Nmhhb0dqRU1ydHU1Mi9LUnMrNGZ2bmppdTM2ZE9nY0FBS2c4V1V0TDFydjB3WXRpakdla2JvRnFrb2R3ODhOVER2dG02ZzRBQUFBQXFwTUZPd0FBQUFCZWs3bmorc3daMTdyMjRCRGlSMU8zUU5XSVlXQVc2KzRkZVUzYnNNVW5EWGdnZFE0QUFGQTVEamg5U2ZlRFh2ZWg2NHB4Zk9vV3FESVBQZmVIbDA1T0hRRUFBQUJBOWJKZ0J3QUFBTUJyOXRKem16L1ZmZWR1NzQwaEhKUzZCYXJJVzdOdThmc2pacmVOdWYzNEFkOU5IUU1BQUtUMzFuUHYzRzJuMS9WWVdJeURVcmRBbGRuY25yZVBmK2FTMGI5UEhRSUFBQUJBOWJKZ0J3QUFBTUJydG1qU3dEOGNQWGQxVTRpbEg4Y1Fka2pkQTFWa3QxS00zeGsxcSsyRTJ5WU9tSnM2QmdBQVNLZWhaZWxiZHV6Vjg4N2dqOWZBcTVlSGN4K1pjdmlQVW1jQUFBQUFVTjBzMkFFQUFBQ3dUZWFQNjdkKzdFM3JUZ3RadURaMUMxU1o3akhHRzBmUFd2WFdSUlA3VDA4ZEF3QUFiSDk5Smk4ZEVPdEx0OGM4ZjFQcUZxZysrYmMyVER2ODRqQ2xuRG9FQUFBQWdDcG53UTRBQUFDQWJUWnZmSi9ybWxyWEhoeENQQzUxQzFTWldQdzNiZlRzdHJjc3Z1TlhueXEzTnJhbkRnSUFBTGFQaGlsTGg0YXNOSzhZZDByZEFsWG84VTE1UHJGY0x1ZXBRd0FBQUFDb2ZoYnNBQUFBQU9nWXp6enppYkQ3SHU4cHBnTlNwMEQxaWFlT0hMN2ZtNGRlZk5jeFM4NDg5TVhVTlFBQVFPZHFtSHJQeDBJc2ZUMzYzQWE4Rmx2eVBJeC9mTXJRMzZZT0FRQUFBS0EyK0VVdEFBQUFBQjJpOWRSQkx6VGR1UGJvVUlvL0txNDlVL2RBRlJyVmZhODlseDk2elk5RzNuWFNlMytUT2dZQUFPaDRXVXRMZGxEOW9HbkZlRmJxRnFoYWVYN2V3MU9HZkM5MUJnQUFBQUMxdzRJZEFBQUFBQjJtOVppR3RVMnQ2ejVUakZlbWJvSHFGTi9kczc3N2owYk1Xam55OW9rRDE2YXVBUUFBT3M0K1p5N29lZEFlZzY0dnhxTlN0MEMxeXZOdyt5UFREcjhvVENtblRnRUFBQUNnaGxpd0F3QUFBS0JEdFRiMXVhcXBkZDJnWWp3bWRRdFVveGpDUHFXWWZYL2s3SlhqRng4LzhJN1VQUUFBd0xiYjcveGxyOTlwOXowWEZlTjdVN2RBOWNvZnlWK09FOHZsY3A2NkJBQUFBSURhWXNFT0FBQUFnSTczek5PbmhOMzM2RjlNdlZPblFKWGFLUXZab3BHejJ2NTU4Y1FCbDZXT0FRQUFYcnVEV3U3cTAyT0grdHUzL2pHTjFDMVF4VGEzYjhtYkhybDR5RE9wUXdBQUFBQ29QUmJzQUFBQUFPaHdyYWNPZXVIb3VldU9pakg4T0lhd1Urb2VxRktsTE1aTFI4MWVkY0FMRHozN3FXWE5nN2FrRGdJQUFGNmRneTY0WjNoV1gzOWpNZTZjdWdXcVdSN3lzeCtaUHZTSHFUc0FBQUFBcUUwVzdBQUFBQURvRlBQSDlmblowWFBYblJ4amFFM2RBdFVzaHZEeG5kNjI4OXNIejFveGR0bkVRYjlQM1FNQUFMd3lEVlB2T1NNcmhSbkZXRXJkQWxYdWxrZW1IbjVabUZ4TzNRRUFBQUJBamJKZ0J3QUFBRUNubVQrdXo3eW11ZXMrRUdJNFBYVUxWTGQ0NkU1eGwzdUh6MTQ1NG83akIvNHFkUTBBQVBEWFpSKy91djZndCt6LzlXS2NsTG9GYXNDL3YvQjgrY1J5dVp5bkRnRUFBQUNnZGxtd0F3QUFBS0JUUGZqOHBzKzliZWY2ZDhjUVA1QzZCYXJjTytwQzlzTVJzOXVPdXYzNEFkOU5IUU1BQVB5NWhwYnY3SDdRVy9aZlVJd0hwMjZCR3ZCaU9Xdys2cmRmSGY1YzZoQUFBQUFBYXBzRk93QUFBQUE2MVgyVEJtNXV2SEZ0VTFZS1A0a2h2QzUxRDFTNVBVc2gzalY2WnR1bkY1MHc0TXJVTVFBQXdIOXJhRm5XTzlSM1cxU00rNlZ1Z1ZwUUR1RmpHeVlQWDVlNkF3QUFBSURhWjhFT0FBQUFnRTYzNEppR3g4YTJyajBtaFBqdDRscEszUU5Wcmx2STRoV2pacS9xL3g4Ynk1L2V1c1NhT2dnQUFMcTZocW5MUjRiNmJFNHg3cHk2QldwQm5vZkxOMHc1N01iVUhRQUFBQUIwRFJic0FBQUFBTmd1NWpVMUxCM2J1dmFMTWNRcHFWdWdGc1FRUHY3Rzd0bEJRNis4dDNISktlOS9NblVQQUFCMFJWbVd4ZDZUbDUxVFBPdGVzUFdhdWdkcXhBOGUrZVZ6WjZhT0FBQUFBS0Ryc0dBSEFBQUF3SGF6WUh5L2FZMDNyWDUvREhGRTZoYW9CVEdFRDNidjJmTys0ZGYrWk13ZEgzMW5XK29lQUFEb1N2WnV1WDJIZ3k1WWVrMHhqa3ZkQWpYa3lmWXQ1YVp5YStPbTFDRUFBQUFBZEIwVzdBQUFBQURZYnNybGNqN3lwblhINzVEbDk0VVEzNTY2QjJyRVcrcnFTdjgyYWxiYlNiZE5IREEzZFF3QUFIUUZEUzFMMzdKNy9ZNEw4eEFHcG02QkdyS2wrQnIzeVBTaGo2VU9BUUFBQUtCcnNXQUhBQUFBd0hhMWVIeWYzeDA5ZDkyUldRdy9LSzY5VXZkQWpkZ2h4bmpqcU5tcit0MyswS0x6eXMzTjVkUkJBQUJRcXhxbUxCOGM2MHRiLzdqRlhxbGJvS2JrK2RrUFRobXlQSFVHQUFBQUFGMlBCVHNBQUFBQXRydjU0L3FzT1hydXVvOW1NV3o5UUdKTTNRTTFJaFkvVEo4ZitiWlJEWU5uclppd2JPS2czNmNPQWdDQVd0TXc5WjR6WW93WEJwKzNnQTZWNStHbWg2WU11U1IxQndBQUFBQmRrMS80QWdBQUFKREUvSEY5NWpXMXJodFlqR2VuYm9IYUVvZnZGSGE1YjlnMWJVZmRlZEtBTmFsckFBQ2dGdXpkY3ZzT3U5ZnRlSFdNNFpqVUxWQ0QxbXpjL09TazFCRUFBQUFBZEYwVzdBQUFBQUJJNTVhZm5aY2ZlY0NBR09KaHFWT2dwc1N3WDMxOXZIZlU3SlVmdSszNGdUZWt6Z0VBZ0dwMjRKUzczclpiZmE5YmlyRi82aGFvUWMrVXkxdU9lR0xHaEJkVGh3QUFBQURRZFZtd0F3QUFBQ0NaMXRiRzlxWnJmemcrNzdYamZUR0VmVlAzUUkzWklZUnN6c2hacTk3MzhNTy9QSE50YytPbTFFRUFBRkJ0K2t4WlBxdytxNzgrNUdIMzFDMVFnOXBET1J6NzhOUmhENllPQVFBQUFLQnJzMkFIQUFBQVFGS3RIMzNmTTBmUFhYZEVqT0VIeFpLUFN2NEFBQ0FBU1VSQlZMVlg2aDZvTmNYUDFtbHZlK3QrL1lkZHZYTHNuWk1HL2tmcUhnQUFxQVpaUzB2V3A5dUh2cGhsOFF0YnI2bDdvQ2JsK1JjZW5EcGtTZW9NQUFBQUFMQmdCd0FBQUVCeTg4ZjFXZFBVdXVha0VMS2JpbXRNM1FNMUo0Wi9xdXVlL1dUa3JMYW14Uk1IZkM5MURnQUFWTEtHbHUvczNxZmJvRG5GZUhqcUZxaFplYjdnNGFtSFR3K1R5NmxMQUFBQUFNQ0NIUUFBQUFDVm9iV3BiK3ZZMW5VRFl3aG5wVzZCR3ZYR0dPUFNrYlBhemxvOGNjQmxxV01BQUtBUzlabThkRURXcmR2TnhmaTIxQzFRdzFhL3ZPbTNKNVRMNVR4MUNBQUFBQUJzWmNFT0FBQUFnSW9SYi9uWnVmbVJCL1NQSVI2V3VnVnFWSDN4ODNYcHFGbXIzdGYrL0thUDNYSGFlNTVMSFFRQUFKV2k3N1JsSjJlbDByOFVZNC9VTFZERG5zbzNianJpaVJrVFhrd2RBZ0FBQUFEL2p3VTdBQUFBQUNwR2EydGplOU8xUHh3ZmV2WDZjUWp4N2FsN29JWTFsWGJxTm5Ea3JQdkhMcDc0cmxXcFl3QUFJS1UzblhWWHJ6MTJxLzlHRE5ueHFWdWd4bTBPN2ZuUkQ4MFk4VkRxRUFBQUFBRDRVeGJzQUFBQUFLZ29yUjk5M3pOSHpXa2JXVmRmZjI5eDNTVjFEOVN3L1dPb3UzZmtkVzJuTHo1eHdGV3BZd0FBSUlXR2xtVzk5OWl0Zm40TW9YZnFGcWg5K1djZW5EcmtudFFWQUFBQUFQQy9XYkFEQUFBQW9PTGNQR0hBQTAxejF4MGJZbGhVWEV1cGU2Q0c5WWhadkhMVXpGVWZldUdsWnorKzdOUkJMNlFPQWdDQTdhWFAxSHVPemJwbFZ4VGpqcWxib0F1NCtzRUxobndqZFFRQUFBQUEvQ1VXN0FBQUFBQ29TSzNqK3R3eGR1NjZzME1NWDBuZEFqVXZobU4zM0dHWGQ0Nll0WExzN1JNSHJrMmRBd0FBbldtZk14ZjAzSFdQUGIrYXhUQXBkUXQwQ1huNDNzTy9lTzYwMUJrQUFBQUE4TmRZc0FNQUFBQ2dZczBiMStmaXNhM3IraFRqQ2FsYm9BdDRSeGF5SDQ2Y3RmS1RpeWNPbkprNkJnQUFPa1BmS1hjZnVPc2VlN2FHR0J1MmJ2MEFuU3dQajd5OEtUU1dXeHMzcFU0QkFBQUFnTC9HZ2gwQUFBQUFGZTNGM3o3MjhSMzIzSHYvR01NL3BtNkJMbUNIR0xMclJzNXErL0NMZjNqdXRHV25Ebm9oZFJBQUFIU1VmdFB1K1dqTTZyOVdqTDFTdDBEWGtMK3dKZVFqbjVneDVNblVKUUFBQUFEd3QxaXdBd0FBQUtDaTNYSGEwSTFIelZselpLaysrM0Z4M1NkMUQzUUZNY1NKdlhiWStmM0RacTRjZitjSkExZW03Z0VBZ0czUjBMSml4OWd0ZkxQNGQrNkUxQzNRaFpUTDVmellSNllNV1pNNkJBQUFBQUQrSGd0MkFBQUFBRlM4bXlmMGZiTHhobFdqczdxNjd3ZHZHb0R0SW9iNEQzVXgzanRxVnRzNXQ1LzR6a3UzZmpJeWRSTUFBTHhhZlNZdkhWRHFWamUzR1A4aGRRdDBKWGtvbi9Qd2xDRzNwZTRBQUFBQWdGZkNnaDBBQUFBQVZXSEJzZjFYTjdhdVBpNExwUVhGTlV2ZEExMUV0eERpeFNPdVhmbVJvVmZlZThLU1U5Ny9aT29nQUFCNEpiSXNpMzJtTGorOVZGYzNQZVNoZStvZTZGTHlNUHVoeVVObXBNNEFBQUFBZ0ZmS2doMEFBQUFBVldOQlU3K0ZSODlkKzhVWTR1VFVMZENseEhCNHR4NDlWNCtZOVpQamI1LzR6cnRTNXdBQXdOL1NiOXF5MXpkTVhUNnpHSWVtYm9FdTZOOGVmcjc5WTZrakFBQUFBT0RWc0dBSEFBQUFRRlc1K1poK1V4dHZYSE5nTVI2YnVnVzZtRGRrb2JSazVNeFZYL24xNXZMNTkwMGF1RGwxRUFBQS9HOTlwaTA3dkJSTDF4WGo2MU8zUUZlVDUrSGhsemVGbzhwZkhib3hkUXNBQUFBQXZCb1c3QUFBQUFDb0t1VnlPUjkrK1pLVGV1Mng5MXRDREI5TTNRTmRUQlpqT091TjNlTEJoMS9iZHN5M1BqcmdsNm1EQUFCZ3F3Tk9YOUs5eHh0N1RpL0YwdWxoNnp1WWdlM3R1ZllRUmo0eDQ5QW5VNGNBQUFBQXdLdGx3UTRBQUFDQXFuUEhhVU0zSG5YOWZVZVU2bnZlVzF6M1Q5MERYVTk4ZDEwcGJ4dDVYZHVaaTA4Y2NGWHFHZ0FBdXJiZWs1YzI5SGhqenpuRjJEZDFDM1JSVzBKZUhydGg4cEIxcVVNQUFBQUE0TFd3WUFjQUFBQkFWYnI1dUhjL2ZkVDFhMGFVNnVPOUljVGRVL2RBRjdSanlNS1ZJMmV1SEw1NTQ4WkpTMDU1djdjVUFBQ3dYV1V0TFZsRDkwR2ZxYStybTFKY2U2VHVnUzZySEU3NzFaUWgzMDZkQVFBQUFBQ3ZsUVU3QUFBQUFLcld6Y2YxL2ZmR0c5Y2VrV1hoTzhXMWUrb2U2SkppSEZYZm84ZDdSOHhjZWZMdEp3eThQWFVPQUFCZHd3RXRLL1p1NlA3aG1jVjRTT29XNk5MeS9PSmZUVG5zeXRRWkFBQUFBTEF0TE5nQkFBQUFVTlVXSE5QdzNjWWIxMHpLc214V2NZMnBlNkNMZW4yTWNmSEltVzFYYlg3NnFUT1duSG5vaTZtREFBQ29YZjJtM1RPMmUvZjR6V0wwTm5OSUtsLzQwTlI3endxVEQwc2RBZ0FBQUFEYnhJSWRBQUFBQUZWdndURjlyejk2N3RyOVlvaGZUTjBDWFZvTUg2dmZjNCtEUjh4Y2VkenRKd3o4VWVvY0FBQnFTNzl6Nzl3dDd0VHJhekhHQ2FsYmdQeitsemJHNDhybDVuTHFFZ0FBQUFEWVZoYnNBQUFBQUtnSk54L1Q3MHVOTjZ6Wkw4UndUT29XNk5yaS9qR0dmeHN4cTIzS0h4NStidkt5NWtGYlVoY0JBRkQ5K2s1WmZsaTJjNjlyaW5IdjFDM1E1ZVhoa1hMSVJ6MHg0ekJ2THdjQUFBQ2dKbGl3QXdBQUFLQW1sTXZsZlBqbFN6N2FhNCs5LzArSTRZT3BlNkNMcTRzaE5QZDY2ODRqaGw3N2t4T1dmUFNkNjFJSEFRQlFuZDUwMWwyOVhyZGJ0NjlrcGV5VXNQV2R5VUJxdjk4U3d2QU5rNGY4UitvUUFBQUFBT2dvRnV3QUFBQUFxQmwzbkRaMDQraTVLNC9zSHJyZFcxejNTOTBEaEhmV2w3TDdSODVxKy9LTER6ODN3OXZzQUFCNE5mcE92K2NmWDdkN3Q1bkI4eDFVaWszbDluRFVocW1IK2lNcUFBQUFBTlFVQzNZQUFBQUExSlJGNHdZK05lYUd0c083bGVxL1gxeGZsN29IQ04yTHJ5bTk5dGw1OU1ocjJrNVlmTktBQjFJSEFRQlEyZlp0V2RGanArNmhKUXZ4ek9KYVN0MEQvRkZlenNOSkQwMDlkRm5xRUFBQUFBRG9hQmJzQUFBQUFLZzV0eDQ3NEpkSDNyUjZaRjBzYmYzUVY2L1VQVUFoaHZlRXVyQnl4TXkyNWp1LzlhdUx5NjJON2FtVEFBQ29QUDJucm5qZlR0M0RkVEdFZDZSdUFmNWJIdkx6SDVwODJKelVIUUFBQUFEUUdTellBUUFBQUZDVGJobmY3OGVOYzljMVpTSGNHdndlRENwRmp4akRoY01QMzNmTWlIKzk3NFRiVDM3M3Y2Y09BZ0NnTXZ5L3Q5YkZMSndadmJVT0trb2V3bFVQWG5EWTFOUWRBQUFBQU5CWmZMQUlBQUFBZ0pxMVlGeWZPOGJPWFh0cU1WNmR1Z1g0RXpHK1A5YlZyUm81cysyOE96YmM5dFZ5YzNNNWRSSUFBT2swVEYzK25wMjdaOWNWWSsvVUxjQ2YrZGJEMy8vQkowTTROSFVIQUFBQUFIUWFDM1lBQUFBQTFMUjU0eHIrOWVpNWEvOVBET0dMcVZ1QVB4RkR6NUNIUzRhOVpkUlJJNjlwbTdUNHBBRVBwRTRDQUdENzJ1Zk1CVDEzMjJ1dkw1ZEsyV2VMZnh0NmF4MVVucFV2L3U3WnNlVmx6VnRTaHdBQUFBQkFaN0pnQndBQUFFRE5teit1b1huc1RXdmZIR0k0S1hVTDhEL0ZHUDR4bEVMYnlKa3JwejY4NGNIcGE1c2JONlZ1QWdDZzgvV2JmcytnM2ZiYTgrcmlPVzMvMUMzQVg1RG5EK2FidGd6LzllV05MNlJPQVFBQUFJRE9ac0VPQUFBQWdDN2hxWDkvNXVON0hMRGJHMk9JdzFLM0FIK21ld2l4NWEzN3ZQMm9ZZjk2LzhsM252eXUrMUlIQWZ4Zjl1NEVRTXVxM2gvNE9jODdDNnU1YTJhYkxYYTdzZ3BLV3BIc2l5QXFab0tLdVdTYXR5eXo3czMrallNYVdsZXpWUk5SRk1GTXdDMFVsMURjcnl3Q2xxSW9hbll0TFpjU1pabVo1L2svZzlwMnRWeUFNOHZuSTJmTzgzdG1xQzhqdkx6anpIY09BQnZIenZWek4rdllvZU1aTWNhalEvTzV4a0JMOUhSRGJCajJtek5HL2o1MUVBQUFBQURZRkJUc0FBQUFBR2dYNXRYMWJ4eHd6dndEdDk1aXk1dkxzVS9xUE1CcjZsNnBxdHcxYXVxOTMvdDlRMUczNEtqZUw2VU9CQURBaHRQcjlQbDdkK3pROFp6eWNzZlVXWURYOVdJb2lsRy9PV1hraXRSQkFBQUFBR0JUVWJBREFBQUFvTjJZZDB6L1ZXTis5ajk3MTRST2Q1YmpUcW56QUsrcFVxNnZibGNkOTkxNzZ1TFAvZUt3M3ZOU0J3SUE0TzNwVmo5LyswcHQvRjZNOFRNaEZLbmpBSyt2b2NqREFTdFBIWEpQNmlBQUFBQUFzQ2twMkFFQUFBRFFybHo1bWQyZk91RFNKY05pck54ZWp0dW16Z084dGhqQ0I4cVhONDJhdXZpQ3NHYjFpZGQ4ZnMvblVtY0NBT0ROeWJJc2RwOTA4eEZWdGZHTThnbmVscW56QVA5VUVmTGl5SlduRHJrdWRSQUFBQUFBMk5RVTdBQUFBQUJvZHk0L3FPZUtzZFB2RzU1VndzM2x1Rm5xUE1Ecml1V1BJMEp0cDFHanB0NTd3aldIOWJva2RTQUFBTjZZWHFmUCszQ1BTYmY4dEx6OFZQT3pPcUJsSzBMeFg0K2NPdVRpMURrQUFBQUFJQVVGT3dBQUFBRGFwWm5qdXkwKzROSmxZMktNMTVaamg5UjVnSDhpcmo5dGN0cmVVeGRQYUFpTngxNS8yRzRyVWtjQ0FPQzFkYXVmV1ZPcDNlWnJNVmFkRkh5c0JhMURFYzUrNUpRaFo2U09BUUFBQUFDcEtOZ0JBQUFBMEc1ZGZsRDNtOGZPV0RvdXk3TEx5N0dTT2cvd3I4UkIxYUg2dnIwdnZQZjA0c1duSnMwNWJ0amExSWtBQVBpclhwTnUzYXVxdzdZL0tTOC9ram9MOE1ZVW9aajI2R25EdmhKT3lWTkhBUUFBQUlCa0ZPd0FBQUFBYU5kbWp1dHh4UUdYTGpzNnhqZzVOSitUQmJSMHRlV2YxTHJRWmJ2UERMOXc4VEhYZmJiM3pha0RBUUMwZDczcWI5eTI2RkR6M1pqRlE0S1BxNkQxS01LY1IvL3crQkY1bmhlcG93QUFBQUJBU2dwMkFBQUFBTFI3bHgvVWZjcW5MMTIyZFlqeDlOUlpnRGNtaHJCekpjWmY3bjNodlJlOTFGaWNPTytvM245TW5Ra0FvTDNKNnV1emJoMzJPaktycloxVVBqL2JNblVlNEUyNXZlR2xQeDJRbjN0VVErb2dBQUFBQUpDYWdoMEFBQUFBbEg1K1VQY3pEdmpaZmR1V2wxOUpuUVY0dzJMNXoyR2RxdVBva1Jjcy9zL3JucmhtU2w1WGw2Y09CUURRSHZTY05LOTM5dzU3L1RpRzBNK1pkZEM2RkNFc0sxYTlOT3J4czhhdVRwMEZBQUFBQUZvQ0JUc0FBQUFBZU1Xc2NUMit1dC8wSlZ2R0dBOUxuUVY0VTdhTVdUeHYrSHRISHpYOGdrWEhYWGY0cnZla0RnUUEwRmIxT09QYUxiTFErZFNZVlIxZGpwWFVlWUEzN1pGaWJjUFFsV2Z0ODN6cUlBQUFBQURRVWlqWUFRQUFBTUFyOGp3dkJ0VFBQMnFybmJmY3FoeEhwYzREdkRreGhMNlZMTHRyNzZuM1hsQ0VGNzh4NTdDUC95RjFKZ0NBdGlLcnI4KzZkL2pVNFZubzh1MXkzQ1oxSHVBdCtWMWphQnI2MkJramZwODZDQUFBQUFDMEpBcDJBQUFBQVBBMzV0WDFiOXp6N0xzUDNHSDdUbk5EaUo5TW5RZDQwN0p5SFJsRDUvMUhUcjMzVzlkZDk4ZzUrV1ZqbTFLSEFnQm96WHFjY2N1dVBUdnU5YU9pQ1AxU1p3SGVzbWNiOGpEazhWT0hQWkk2Q0FBQUFBQzBOQXAyQUFBQUFQQVA3amkrMytxUk0rNFoxU25yK010eTdKTTZEL0NXYkJGRCtPR0k0VHNkT2VMQ3hjZGQrOW5ldDZjT0JBRFEydXg4K3R4dE9zV09wMVppZG1SNCtSc1pBSzNUQzBWUkRILzgxQ0cvU2gwRUFBQUFBRm9pQlRzQUFBQUFlQTF6eHUzMjUvMm5MUmlXVlhlNHVSeTdwYzREdkZXeFJ4YkRyWHRQdlhkNjNsQjg3ZHFqZXY4dWRTSUFnSll1cTU5ZjFiTTJITmM1ZHFvTE1XeWVPZy93dHF6T1F6NTY1U2xENzBrZEJBQUFBQUJhS2dVN0FBQUFBSGdkc3c3cCs4elk2WXVIeGtyMXJlWDR3ZFI1Z0xjc2x1dmdyRHJ1TS9MQ2UwOWYvWnMvbnpXdnJ2K2ExS0VBQUZxaTNwTnVIZHl6WXp5N3ZQeG82aXpBMjlZUVF2SHBsUk9IM3BJNkNBQUFBQUMwWkFwMkFBQUFBUEJQekJ6ZiszZjdURnM4c0thcStyWnlmRS9xUE1EYjBqV0djRnFuOTJ4MnhNZ3BpNzQrNTRoZFo2WU9CQURRVW5RLzdlWVBWRlZWL2p0VXdwalVXWUFOSXMvemNPaktVNGY4SW5VUUFBQUFBR2pwRk93QUFBQUE0Ris0NnBEZXY5bC8yckxCV1ZXY1g0N2JwODREdkcwN3hTeTdmT1NGaStlSG92anluTU4zdlRkMUlBQ0FWSGF1bjd0WnA0NGRUNnFxcm55cEhHdFQ1d0UyaUtJbzhzK3ZQSFhJejFJSEFRQUFBSURXUU1FT0FBQUFBTjZBV1lkMGYyaS9HZmNOcWNSd2N6bHVsVG9QOFBiRkVQdUhHQmVPdkhEeDFOVnI4cFBtSGRQbjk2a3pBUUJzS3RtQk15czllbTl6Vk9lT25lckxjZHZVZVlBTnFDaE9lR1Rpa01tcFl3QUFBQUJBYTZGZ0J3QUFBQUJ2ME94eDNlNGJPMzNwOEpobE41WGpacW56QUJ0RUZrTTh2R050Tm5iRWhZc25yZm5OQzJmUHErdS9KblVvQUlDTnFlZWtXd2IyN0wzTldTSEc3cW16QUJ0WUViNzU4TVRCMzBzZEF3QUFBQUJhRXdVN0FBQUFBSGdUWm83dnNXRHNqUHRHeFJpdUs4ZE9xZk1BRzBnTW04VVFKblY4VDlmUERiOWc4VGV2UDdMUHBYbWVGNmxqQVFCc1NMMG16ZDhsWnVHTXJKS05TSjBGMlBDS1VKejZ5TVRCcDZYT0FRQUFBQUN0allJZEFBQUFBTHhKTThkMXUvV0FTNWZ0RjBLOHFoeHJVK2NCTnFqM1p6Rk1IejVsNFplSFg3ajRhOWQ5dHZmTnFRTUJBTHhkL3o3cCtuZldaQjFPanBWNFJEbFdVdWNCTnJ5aUNHYytNbkh3LzB1ZEF3QUFBQUJhSXdVN0FBQUFBSGdMTGorbysvWDd6N2p2d0N5R3k4dXhPblVlWUlQcms0VXdiK1FGaTY5dENzWFg1eDYrNjY5U0J3SUFlTE82MWMvdlV0MHhuRmhiNlhoQ09YWk9uUWZZT0lwUS9PalJVNGVlR0NibXFhTUFBQUFBUUt1a1lBY0FBQUFBYjlHc2NkMnUydi9TWlovSlF2eFpVTEtEdGltR0VaVVFoNDY4Y1BGRmE5ZXQrOVpOUi9mNzM5U1JBQUQrbGV6ems2dDc3YlR6a1RXZFlsMDVibGNVcVJNQkcwc1JpZ3NlUFdYb0YvTTg5eWNkQUFBQUFONGlCVHNBQUFBQWVCdG1IZFI5OWdIVGx4NGNzbXg2OE4vYm9LMnFsT3Z3MnBxYXo0eThjTkhaNGNXbU0rWWN0OXVmVTRjQ0FQaEhXWmJGbnFmZmNrQ3ZEK3g4YWpsK0tIVWVZQ01yd3ZTVnA5NTVsSElkQUFBQUFMdzl2dUFIQUFBQUFONm15OGYzK1BrQjArK3JoQ3hNQ3k4WGNZQzJxVk1JOFJ1aGMrV280UmNzUGkxNzZlbHo1eHczYkczcVVBQUF6WHArOTVhQnZjNllmM29JUlovVVdZQ05yeWpDcFNzZmZINUNudGZscWJNQUFBQUFRR3VuWUFjQUFBQUFHOERsNDd0ZE9uYkdzcW9ZNDlSeXpGTG5BVGFtdUUwV3c5bEY1MjFQR0RGbDhjUTF2MzFoNnJ5Ni9vMnBVd0VBN1ZQUFNmTjZWeXJWa3lxeE1pUjFGbUJUS1g2Kzh2WTdEODNuMVRXbFRnSUFBQUFBYllHQ0hRQUFBQUJzSURQSGRaOTJ3S1ZMS3lGa1U0S1NIYlI1TVlSM2wzL1NKM2Q4VDljVFIxNndxTzY2SjM3eDg3ek82UkVBd0tiUi9idTMvVnRWS0NaV3FxcjNEK3VmbWdEdFFSR0tXU3R2dTNOOFBxL09OL2tBQUFBQWdBMUV3UTRBQUFBQU5xRExEK294ZGV6MCs2cGlGczRMdnNnVjJvc1BoeGd2SGY2ZVVmODUvUHpGMzd6dXlONi9TQjBJQUdpN2VwOHgvMzNsYzQrNjZoZ1BLVC9rcUtUT0EyeFNWNjU4NnJHRGxPc0FBQUFBWU1OU3NBTUFBQUNBRFd6bStHN243ejlqV1ZVVzQwK0NraDIwSnoyeVNyaG01SVdMN3l6eTRxUnJqOWoxbHRTQkFJQzJvMXY5L08xck9zV1RZcFo5cmh4clV1Y0JOcmxySGxuKy9JSDVaVWMxcEE0Q0FBQUFBRzJOZ2gwQUFBQUFiQVN6eG5VL2QvOFo5MVd5R0g0WWxPeWd2ZGtqWnZIbWtSY3V2aUhralhWemp0anQ3dFNCQUlEV3ExZjlqZHZHanJVbjFuVEtqaTNIVHFuekFKdGVFY0sxSzU5dlBDQy9iT3k2MUZrQUFBQUFvQzFTc0FNQUFBQ0FqV1RXdUc0L0hqdGpXUlpqL0g1UXNvUDJhRWpJcW9ZTXYyRFIzTHhvcXI5ZTBRNEFlQk9haTNXVmpyVW5acDA2SEZPT25WUG5BWkw1eGNybkc4Zm0zeCsyTm5VUUFBQUFBR2lyRk93QUFBQUFZQ09hT2E3N0Q4ZE92NjhwWnVGSFFja08ycVVZNHJCS3JCcldYTFNMSVo5NDdlRjk3MHFkQ1FCb3VmNnRmdjdXblRyR0V5cWRPaHhYamwxUzV3R1N1dnFSNWM4N3VRNEFBQUFBTmpJRk93QUFBQURZeUdhTzcvYVRBeTVkMmhoQ2RrNDVacW56QUdrMEYrMUNxQ2phQVFDdmFkZlQ1MjRUc2s1ZjZkd3BVNndEUWhIQ0ZTdVhQLzhaNVRvQUFBQUEyUGdVN0FBQUFBQmdFN2o4b0I3bjdYZnBzcVlzeFBPQ2toMjBhNHAyQU1EZjZqRnAzbmJWMVZWZmpaWE94NVJqNTlSNWdQU0tVTXhhK2RSakIrV1hIZFdRT2dzQUFBQUF0QWNLZGdBQUFBQ3dpY3crcVB1VS9TNWQycFNGN1B4eXJLVE9BNlQxYXRGdXhBV0xid2hGTWVuYUkzYTlKWFVtQUdEVDZmbmQrVHRXaGV6RTZ1cnFvOHF4WStvOFFFdFIvSHpsYlhlT3orZlZOYVpPQWdBQUFBRHRoWUlkQUFBQUFHeENzdy9xTVhYc2pHVk5JY1lMZzVJZDhMSWg1V1BDa09GVEZ0OFppakRwK3MvMW1aUG5lWkU2RkFDd2NmUStZLzc3c2l3N3NTcG1oNWRqaDlSNWdKYWpLTUtsSzIrLzgxRGxPZ0FBQUFEWXRCVHNBQUFBQUdBVG16bXUrN1N4TSs1ckNqRmNGUHczT3VBVk1ZWTl5c2VGYTRhZXYzRHBzQXNXblg3RDlZOWVubDgydGlsMUxnQmd3OWoxOUhrZkRWWFZYODhxMmJqZzR3RGcveWd1WHZuZ253N1A1OVg1R0FBQUFBQUFOakgvMFI0QUFBQUFFcGc1cnR1TXNUT1dyZzR4KzFrNTFxVE9BN1FjTVlRZU1jUkxodzNaYWVLSUtZdS84OFJ2VjE1OFg5M1lkYWx6QVFCdlRlL3YzclpiRm92L2lsWFZvOHN4UzUwSGFJR0tZdklqcDk3NStUeXZ5MU5IQVFBQUFJRDJTTUVPQUFBQUFCS1pPYTdIRldPbkw5MHZaTm5NY3V5UU9nL1F3c1R3b2ZMbDVIZS9lNmR2RForeThLemkrZWNtenoxaDhJdXBZd0VBYjh5dVo4d2ZGQ3JaMTdNWUJxMnYwQU84bHFMNDRTT25EdjFTbnVkRjZpZ0FBQUFBMEY0cDJBRUFBQUJBUWpQSDk1aXo3NlZMUmxWQzVhcHk3SlE2RDlBaXZUdkc3SHR4ODYyK09meUNSVDh1R3RiOWVPN1JIM3M2ZFNnQTRQL0s2dWRYOWU0WXhwWi9kMzh0cTJTOXRHV0FmNjQ0WThYRXdmOFpKanE0RGdBQUFBQlNVckFEQUFBQWdNU3VPS2puVFdObjNEYzh4UENMY3V5YU9nL1FRc1d3VlF6eFc3RzY5bXNqcGl5Nk9EUVVaMTM3K1Q0UHBvNEZBSVRRNjJzM2RxN2FwdmFJWFR0bng1ZmorMVBuQVZxRG92Nmhrd2VmbkRvRkFBQUFBS0JnQndBQUFBQXR3c3h4M1c3ZDk1SmxneXVWZUYwNWJwRTZEOUNpZFFneGZpN1V4Q05IVEZuOGl6dzJuVG4zOEw2M3BnNEZBTzFSajBuenRxdXVyajYyYXRzT1h5akhyVkxuQVZxSElvVC9YSEh5NEROUzV3QUFBQUFBWHFaZ0J3QUFBQUF0eEJVSGQvK2ZzZFB2R3hTeU1MY2N0MG1kQjJqeHNoREQ2Q3hVUm8rNFlQRmRvY2ovZSs0TmoxMlZYemEyS1hVd0FHanJlazJhdjB0VmRmYmxtdXFhOGVWWXU3NHVBL0N2RmFYalY5UVAva0hxSUFBQUFBREFYeW5ZQVFBQUFFQUxNbk44dDhYN1gzSnYvMWlwdXFFY2QweWRCMmcxUGhaaU5tdlkwSjBlR1RGbDhRK2VXOTA0OWE3amR2dHo2bEFBMEpaa1dSWjdmK2Ztb1RGVXZseFZYUmxjM29xcE13R3RTbE5SaENOWDFBK2Vtam9JQUFBQUFQRDNGT3dBQUFBQW9JV1pkWEN2Qi9hN2FPa25zdXJzcG5MOFFPbzhRS3Z5Z1JERDl6ZnZWRGxsMkpSRkY4VFk4T1ByRHUvM2NPcFFBTkNhOWEzL1JhZWkwMllINy9yZCtWOE1SZnozMUhtQVZtbGRIdkp4RDljUG1aVTZDQUFBQUFEd2Z5bllBUUFBQUVBTE5IdENqOGYydlhESkp5czFsUnRDREw2SUYzaXpOb3N4SEI5QzlSZUhUMWwwYlo0My9mREdvL3ZkbU9kNWtUb1lBTFFXZmI1OTgzdGpUZFd4b2N2bVI4WVF0a3lkQjJpMVhncDV2di9ERTRmTVRSMEVBQUFBQUhodENuWUFBQUFBMEVKZDhkbWVUKzQvYlVIL1dPbHdYVG4yVFowSGFKV3lFTVBlV2FXeTk5RHpGOXcvL1B4RlB5eis5T3kwdVNjTWZqRjFNQUJvcWZwODU3WlB4a3I4ajFoYlBTYjRuRHJ3OXZ3cEwvSlJEMDhjY2x2cUlBQUFBQURBNi9QSkFBQUFBQUJvd1dZZDB2ZVpmUys4YzJCVzArV2FHR1AvMUhtQVZ1MmpJWVp6NHVaYmZudjRsSVVYTkRXRW45encrVDRyVTRjQ2dKYWcxNWszZHE3a3RlT3pHSS9OS3JHSEkxK0JEZUFQb2JGcDJNT25EbDJjT2dnQUFBQUE4TThwMkFFQUFBQkFDM2ZGWi9kNFljK3o3eDcrem0wN1gxNk9JMVBuQVZxOUxVS0lKMVNxdzVlSFQxbDBRMTRVNTl4NDQyTno4c3ZHTnFVT0JnQ2JXcy92M3J4emRWWjFiSFhvT0NGazRSMnA4d0J0eG04YjhqRGswVk9IUHBBNkNBQUFBQUR3cnluWUFRQUFBRUFyY01meC9WYjNuYng0My9kMnJyNmdIQTlPblFkb0U3SnlEY3RpSERaa3lQdC9NK3o4UlpQWE5SVG56enVteis5VEJ3T0FqU21ybjEvVnUxTTJPc3ZDTVRWWjljRHlWa3lkQ1doVEhteHFhaGo2NkNuREgwOGRCQUFBQUFCNFl4VHNBQUFBQUtDVldIQlU3NGFzdm43Q3ZoL2M3OWtZd3hkVDV3SGFqaGpDZThvWHA5VFd4RzhObjdMb2lxWVF6cm5wcUw3ejh6d3ZVbWNEZ0EybCs3ZHZlM2VIMm5CRW55NlZJOHB4eDlSNWdMYW5mUEs4NktXR3h1SC9lOXJ3UDZUT0FnQUFBQUM4Y1FwMkFBQUFBTkNLNUhWMWVibDlhZjhaeTU2SklkYW56Z08wT2RYbCtuU2xYRU1uTDNoZytQa0xmL3BpNDlxTGIvMzhucytsRGdZQWIwVjI0TXpLcm4yM0h4Nno0dWdPdFhGNGVhdVNPaFBRTmhWRm1QZW50UytOZWZyMDBTK2t6Z0lBQUFBQXZEa0tkZ0FBQUFEUUNzMGExMzNpMk9uTG5nb3gvamo0SW1GZzQvaTM4akhtN003VkhVNGZmdjdDMlVVb3B0end1ZDF2ZHFvZEFLM0IrdFBxT3NURCsreSsvWkZoL1dsMU1YVWtvQzByaXRsTlR6dzUvdWtMSnF4SkhRVUFBQUFBZVBNVTdBQUFBQUNnbFpvNXZ2dFA5NzlrNmJNeHk2YVZZMjNxUEVDYjFTSEVPQzZHT0c3bzVBVVBENTJ5OE1Ld1p0M1U2Nyt3eDVPcGd3SEEzK3BXUDdPbVk5ZnRSNGNpZkxaRGh6ZzArRVlVd0tZeDVlSGxmem82djJ4Q1Urb2dBQUFBQU1CYm8yQUhBQUFBQUszWXJJTjdYTDcvSlV1ZmoxbWNWWTVkVStjQjJyd1B4aEJQQ3gxcTY0ZE9XWFJ0S0lvcERmLzc0clh6NnZvM3BnNEdRUHZWK3p1My9IdDFwWEo0cHk3YkgxS08yeFFPcXdNMmxhSTQvZUZUaG43REtjOEFBQUFBMExvcDJBRUFBQUJBS3pmcjRCNDNqcDIrK0ZNaFZxNE5JVzZYT2cvUUxsVEZFRWFIR0VmWDdOamx5YUZURmswTlRVMVRyLy9jYml0U0J3T2dmZWhkUDMvenFxN1paOHEvanlaVVYxWDFTNTBIYUhmeVBJVGpWOVFQL21Hb3oxTm5BUUFBQUFEZUpnVTdBQUFBQUdnRFpvN3Z2WGkvaXhmdm1WVlZ6UzNIRDZiT0E3UXJPOFFRdmhFcWxmOGFObVhSWGFFb3BqZXRLeTY3OGRpK3o2UU9Ca0Ria2gwNHM5SzM3enNIRjFtWVVOMjFha3dJUllmVW1ZQjJhVzFSaEVOWDFBLzhlZW9nQUFBQUFNQ0dvV0FIQUFBQUFHM0U3RU43UDdML0pjdjJqRm1ZVTQ1OVV1Y0IycDFZcmoxQ2pIdFVhdU5adzZZc21oUHlmTnIvUHZuNHRmZlZqVjJYT2h3QXJkZXVaOTMrMGFvUUR1bTcrenNQS2NkM3hkU0JnSGFyQ09GUElROWpIcG80OEpiVVdRQUFBQUNBRFVmQkRnQUFBQURha0ZrSGQzOTZ3RG56OTlweXN5MW1oaGlHcHM0RHRGdTE1ZG92Wk5sKzczclgrNThaZHY2aVN4dWJ3clNianQ3MW50VEJBR2dkK2s2Ni9aMnhKaHdVUXh4ZkZXUHYxSGtBU2s4MkZVMGpIcGs0WkducUlBQUFBQURBaHFWZ0J3QUFBQUJ0ekx4aitxL3FPM254cVBkMnJrd0pJUjZTT2cvUTdtMVZydU9xS3VHNFllY3ZjZFh1NFFBQUlBQkpSRUZVV2w0VTRaS21zUFpuTngyMXh5T3Bnd0hRc25Tcm45K2xZK2VxL1dJTTQ3UGFPTEM4VlVtZENlQVZ5eHViMWcxNzVKVGhqNmNPQWdBQUFBQnNlQXAyQUFBQUFOQUdMVGlxZDBPV1pSUDJuYmJreVJERDExUG5BWGpGUjJJTXAxYUYybE9IVFY1MFQxRVVsNGFHZFQrLy9ndDdQSms2R0FCcDdQeWx1YlZidkxmTDhCRGlnWjAzcXhwVkZLRno2a3dBLytET2x4cGVHUDNFYVdPZVNSMEVBQUFBQU5nNEZPd0FBQUFBb0kzSzg3d290Ly9jZjhheXg4cjlSOEVKSUVCTEVzTnVNY2JkUW0zdG1jTW1MN3ExaU9HeWhtTFZ6SGxIOWY5ajZtZ0FiRnhaL2Z5cXZwMnJCcFhQVGcvYzRuMWR4NVMzTmsrZENlQjF6Rjd6NStjT2Z1TE1zYXRUQndFQUFBQUFOaDRGT3dBQUFBQm80MmFONjM3dS9qT1cvYmE4L0ZtNW5BZ0N0RFJaaU9GVE1ZUlAxY1F1UHhoMi9xTHJRMTVjOXVLZjFsMTEyNGw3dkpBNkhBQWJSbFpmbi9YcE11aVRNUXVmM20yenFySGxyVzFTWndMNFo0b1F6bjQ0M0g1Q2ZtWmRuam9MQUFBQUFMQnhLZGdCQUFBQVFEc3dhMXozWCt3emZlbGVsUml1aVNGdWx6b1B3T3VvTHRmZUlZdDdkOTZpZHZXd3lZdXVDMFZ4eGJyVkwvNWkzcGY2UDU4NkhBQnZ6bDlLZFRFY3NOdG1nL1lyYjIyZk9oUEFHNUNYejBHLzh0REpnNzRmd3NEVVdRQUFBQUNBVFVEQkRnQUFBQURhaWF2RzkxZ3c2c0tGZTFUWFZsOGJROXc1ZFI2QWY2RmppR0cvRU9OKzFaMDdyeHM2ZWNGTlJTaG1GUTN4cWh1UDdmdE02bkFBdkxic3dKbVZYZnR0Kzhtc3FJeFZxZ05hb2RWNUtBNWVjZktnMmFtREFBQUFBQUNiam9JZEFBQUFBTFFqMTN5Mno4cjlweTNZTTJTMVY0WVlQcDQ2RDhBYlZCTmlIQkZEdVdyQ3VVUFBYM2h6a1lkWkx4VU5WOTUrOU1lZVRoME9vTDNicVg1K2gyMDNxd3dxUXRobnQzN3ZIRjNlMnJaOHJnblEydnl4eUJ0SHI2Z2ZlbGZxSUFBQUFBREFwcVZnQndBQUFBRHR6S3hEK2o0ejRLTDVnN2VvMnZ6Q0VPTm5VdWNCZUpPcXl6VWtabUZJNTFEOWs2SG5MN3lqbkdldkRjWFZ0eHpaOTlIVTRRRGFpNC9Wejkwc2RPa3lvbncrdWM5Mm0xV05LRUxZVEtjT2FNVlc1RTNGeUJVVGg2NUlIUVFBQUFBQTJQUVU3QUFBQUFDZ0habzNvZithTE12RzdUdnQzcFVoeG0ra3pnUHdGbFhLOWNubVZSdmkyVU1uTC94VkNNWFZvYW00NXNhbnJyc25yNnZMVXdjRWFFdDIvOTV0N3c0eEc1VVZZVlRZck90ZTVhM2ExSmtBM3I3aXRwZldyZHIzaWRQR1BKTTZDUUFBQUFDUWhvSWRBQUFBQUxSVGVaNFg1WGJTL2pPV1BCUkNkbDU1WFpNNkU4RGJFc011b1lpN2hFcjh4dUFkUmo0MWRQTENhMEpUdU9iWnl1OXZXbkRVM2krbGpnZlEybVJaRm5mOXpxMjlLcFU0T3NZd0tvdFpyOUQ4YUF2UVJwUWZGRjhTbjIwODhvbnZqMW1iT2dzQUFBQUFrSTZDSFFBQUFBQzBjN1BHOWJ4b3YrbExINDh4emlySExWUG5BZGhBdGl2WGthRVNqdHd5Ykw5NjZIa0xmMWtVNGVwMWVaaDd5ekY5bmtnZERxQ2w2blhtaloxcnNzNERzeGhHN243bWJTTkNERHVtemdTd0VSVGxqNU1mcmg5eXlpdmZmQVlBQUFBQWFNY1U3QUFBQUFDQU1IdDhqMXYybmI1d2p5elV6Q25IRDZUT0E3Q0JkUXd4N0IzTFZadUZNSFR5d2w4VlJaZ2I4bkQ5NDQxL3ZPM0I0NFk1c1FSbzEvcDk3L1lQeDVDTkNMRVkzcUhTdVg5NXEzYjlLNXhWQjdSTmEwT1JIL0hneVlPbmg3bzhkUllBQUFBQW9BVlFzQU1BQUFBQTFydGlmSjhIUjA1ZDhyRU9WZGtWSVlZOVUrY0IySWgyaVRIc0VpcmhxKyt0YlAzQzRNbk5wOXNWMStkRlBuZmUwYnMvbGpvY3dNYldmRXBkYmRaeHJ5eG1RME1vaHNXWWZmRGwxMmpVQVczZU15RnYydmZCK2lHM3BRNENBQUFBQUxRY0NuWUFBQUFBd0YvTU9hem5IMGIrYU83QTJzM2ZPVG5HZUVqcVBBQ2JRTmNZd3BqeU1XOU1GaXRoeU9RRnk4dDdjNHVtZU1NZlgzenUxbnRQR1B4aTZvQUFiMWVXWmJIdjkyN3ZVU21LWWVVNHVHT2xjL00zVTNqNWxEcWxPcUQ5ZUNBUFRhTWZxaC95Y09vZ0FBQUFBRURMb21BSEFBQUFBUHlkT2NjTlc1dGwyWVF4MCs1ZEhrTThwYnlWcGM0RXNPbkVqNVF2UGhJcjRmaHR1bTZ4YnNqa2hYY1hSZmhsMFJSdXlwOSs4WjU1ZGYwYlV5Y0VlQ1A2ZnVlTzkxVFZoa0d4aUFOMy85N3RBMklJMnl2VEFlMVhNYmR4VGZ6TXc1T0cvQ2wxRWdBQUFBQ2c1Vkd3QXdBQUFBRCtqenpQaTNMNzl2NlhMRnNlWXJpNHZPNmNPaFBBSmhkRFRmbnlrekdXcXlyVVp6dDAvdk9ReVF0dUtSOGdmeG1LNHFaZmZyN2ZBNjg4WGdJazEvZXMrVnRYc3FvQldZeDdsZU9BNnRyNDRmV3ZpR3AxUVB0V2hPSUhLOElkSitTVDZueWpCQUFBQUFEZ05TbllBUUFBQUFDdmE5YkIzV2Z2ZDlIU2xiRXFYbDJPNzA2ZEJ5Q3h6VUtJbzJNSW8wT01ZZEJQNy9uOWtNa0w1eFZOeGMwaEQ3ZmVlR3pmaDFJSEJOcVBIbWZjc1VYSERrWC9MR1Q5eS9GVDFaWHE3c0hKd3dCL1ZZU0dJaFJmZkxCdTBMa2hERXFkQmdBQUFBQm93UlRzQUFBQUFJQi9hdmFFSGt0R1RGKzhlOGVpNnNvUXcyNnA4d0MwSU51WGExek00cmptU3N1UTh4YjhyaWpDL0JqaWJZMmg0ZFpianRuejEwNjRBemFVYm1mZnNHV24wSG5QU2d5ZkNpRU82TndoZGk5M2hUcUExL1pzVThnUFdGRTNlRjdxSUFBQUFBQkF5NmRnQndBQUFBRDhTOWVPNy8yN0FSZk43Nzk1MWVZWHhCQVBTcDBIb0dXSzc0d3hmS2E4K0V4VnFBNER6NzNuRDRQUFczaGJFY0p0ZVZPNDVaYW41eXpMNityeTFDbUIxbUgzNzkzMjdxcVlmYUs4M0xPSThlTmRZNWRkZ2hQcUFQNjFJanpZR05hTmZyaHV1Tk9GQVFBQUFJQTNSTUVPQUFBQUFIaEQ1azNvdnliTHN2SDdUbHV5ckJ4UEM3N0FHK0JmMmFaYys4VnlWU29oREh6bnlPY0huN2Z3N3FJby9pZmt4WjB2Tm9XNzd6cHV0eituRGdta2x4MDRzOUozangyNlZSV2hYNGhoai9MV0o2cXl5dnRlZlgzNU9CSWNod253aGx5N0xxd2F2N0p1bitkVEJ3RUFBQUFBV2c4Rk93QUFBQURnRGN2enZQbHJ1MDhmTTMzcGZWbUkwOHZyZDZUT0JOQ0tiRjZ1WVRHR1lhRVNRNWRLeUFlZmQ4LzlJY1E3UTVIZjFkU1kzMzNMZit6NTRDdVB0VUFiMXUvMGVWdFZPdFY4TElSczl5TEVmaC9iODEyN2w3ZTd2dHlrOHhBQThCWTBQM2llOGRDdm4vdG1mdG5ZcHRSaEFBQUFBSURXUmNFT0FBQUFBSGpUcmh6Zlk4NCtGeTN1VjZtcVhCbEMzRGwxSG9CV0tpc2ZRM2NwOTExQ3pENVhxYzdDZ0hQdi91UGc4eGJjSFlwd2Q1RVhDMklSRjkxNGJOOW5VZ2NGM3JxZHZ6UzNkc3YzYmRZclZ1SnVNWVMrNWEzZEtwMDZmaWk4ZkREZHl5OEFlT3VLc0xvbzhxTWVQSG53OU5SUkFBQUFBSURXU2NFT0FBQUFBSGhMcnByUWUvbCtGeTN0RnlwaFJvaGhlT284QUcxQkRISHJjdHU3dk5nN1ZsNnUzUXcrYjhGaklSU0x5OHRGUlZOWXVIcHR2dkNPNC9zOW16SW44TnF5K3ZsVi9iYW9mRFFyS24zS1A4ZTdscmQyMi9vRDcraGU3aldwc3dHMFJVVUl2ODFEc2UrS2t3Y3ZUSjBGQUFBQUFHaTlGT3dBQUFBQWdMZHM5b1FlejJjSHpoeTF6K2dQblI1RC9HcnFQQUJ0MVB0Q2lPVUsrOFZLQ0owNlZZckI1OTN6YURrdkRFVmNsTWV3cUZqMTB0SjVYK24veDVRaG9iM3BWait6cHV2bTIrOFNRdFk3aTdGWFVSUjk5dGlpcHJsTTE4R3hkQUNiUUJIdWFBaHJ4NjZzRy9INzFGRUFBQUFBZ05aTndRNEFBQUFBZUZ2eXk4WTJsZHVKKzAxYmVtL0k0dVR5dWxQcVRBQnRYQ3gvN0ZUdU81VlhuODZhNzNUcDFIelMzVytMSWl3SlJiRWtMOExTcGlJdXUrMFAxejZjMTlYbGlmTkNxOWZqakR1MjZOd2g5SWdoOW93eDlpaHY5WHpIRnUvNmFQaWJrK25LKytrQ0FyUTNSWmo4VUhqdXVMeHU3THJVVVFBQUFBQ0Exay9CRGdBQUFBRFlJR1lmMG1QR2ZoY3R2YitvaXJOakNPOVBuUWVnSGRweC9ZcHg3Nng4SUc0dTNnM1lmc1NMZzM2NjRMNnd2bmdYbG9iUXRDeGZ0L2IrZVYvcS8zenFzTkFTN2Z5bHViVmJmYURMempIRVhXTEkvcjBJUmZmbVVsM1hqdG1PcWJNQkVKcUxkV3ZMbDE5Y1hqZnd2TlJSQUFBQUFJQzJROEVPQUFBQUFOaGdaay9vc1dUd3RBVjl1MmExbDViajROUjVBQWlkeTlVdnhQV3JWQWxaaDA1aDBFOFhQQmxDY1g4Und2MHhqdytFSXR5L0tvUmYzMzFzMzJjUzU0Vk5vcmxJdDgwSDMvR2hrSWVQRkxINGFJengzOHZidTVUM1Boeis1bk9vc1hBcUhVQUw4bVFlOHYwZnJCdDBkK29nQUFBQUFFRGJvbUFIQUFBQUFHeFFOeDdTOTVuc3dKbkR4NHo2OExkRERDZVd0M3hsT2tETHMwUDU4THhEK1FBOWFQMVJkNlV1NVJyMDB3VlBsOXY5UlNqdWowVmNuaGROS3hwajAwTlZUelgrWmw1ZC84YVVnZUd0K1BpWmQyMWIxRFIrTU1zckh5NnkrRzh4RkI4dFF2eklOaDk4Ui9OcHU1WG0zLy9SVXhXQWxxOElkNndOYThhdXJCdngrOVJSQUFBQUFJQzJSOEVPQUFBQUFOamc4c3ZHTnBYYjEvZWR0bXh4ek1LVThQSUpTZ0MwZk5zMnJ4amlwNW83UjFtc2hKcFFDV0g3bW9hQlAxM3dhUG02aDRzUUhvb2hYOUdVeDRmejJQRHc3VGYvN3ZGWEh2Y2hpVDNQdm1ITExIVFpxYWpFRDhhaStIQVI0NGRpS0Q0Y1FyblhoQzFpODZkRXMxY2IvOHAwQUsxTitkempKdytGWjcrYzE0MWRsem9MQUFBQUFOQTJLZGdCQUFBQUFCdk5GWWQwdjJ5L2l4YmZINnFxcmlqSEQ2VE9BOEJiVmwydUR6ZXZHTUtJNXJaU0pXcysvcXNtN0xYWGU5WU5QUGVlUjRzUUhnMmhlQ3dVNGZGUXhNZktOeW12Vno5Mnl4ZjJlaXJQOHlMMUw0RFdxMi85THpyVmR0M3FQYUVxdkxjY1B4QmpmSC81RytwOTVlL0ZuWnJuck5MMUhjMXZ0NzQ2RjZNaUhVRGJzU1lVeFJlVzF3MjhJSFVRQUFBQUFLQnRVN0FEQUFBQUFEYXEyUk42MzdmZlJVdjdoS3B3Y1FoeFZPbzhBR3h3TmVYYU9aWnJmYW1wdWRmMGFyY3BkZ3g3L2VUdTFRUFB1ZWZ4SW9iSG1ndDQ1YXVhOXllS3B2aGtVMng0OHFVL1BQL2JCWFY3djVRc1BVbGxCODZzN05sbmgrM3lqdG1PV2NoM2pFVjhkeDdDZThyZlBPK0pSWGhmK1h2cGZSMjIzSHJyZi94NTZuTUFiZDVqalVWK3dJcTZRUXRUQndFQUFBQUEyajRGT3dBQUFBQmdvNXM5b2NmeldaYnRNK2JpZTA4S01aNGNtZzg5QXFDOTZCaGkrRWdNNFNOLzA3d0xzZEw4aWFxYXNObDIyNGFCNTl6emJCSERrK1Zybnd4RjhkdnkxYjh0MytaL2l6eC9Ncy9EMDFsVGZIcHRVVHgxeC9IOVZpZjlsZkNHWmZYMTJSNWRobXdkcTRvZFlwWnRYOFI4KzVqSDdVTVczMW1FWXNmeWQ4Q09JUlE3ZlB3VE8yNWZ2bm5WeTA4TXNwYzdtcStlZDZoRkI5QStGZUg2VmV2QytDZE9HL1JNNmlnQUFBQUFRUHVnWUFjQUFBQUFiQko1bmpkL3VmeXArMDViY25mTXNobmw5VGFwTXdIUVFzU3daUXhoeS9KcWx4RC9wbFdWWmMwLzFuOUdxN1o4b3dIbjN2UG5jbm82Rk9VS1JibkM3OWRmeC9pSElzK2ZLa0x4VEpZVno0WjFsZWRYVitLei8vUEZmaSs4OHZjUGI5Tk85Zk03dkt0VDlaWkZoN2hsak1VVzVhMXRZaEczTG1Kc1BsMXVtL0xmdzdibHY3cXR5MzNyRUl0dFA3N1YwTzNLKzlXdnR1UmljM2t1QzY5Yy83Vm9DUUIvSXkrSzRwU0h3dTBUODlQcTh0UmhBQUFBQUlEMlE4RU9BQUFBQU5pa3JqaWs1MDM3VGwyNGE2aXV1VHlHc0h2cVBBQzBLcHU5c2o3NGwzTFdxMXVXL2JXdVZkTjhiRjRJbi9yeDNZMER6cm5uK2ZMeStWQ0VaOHMzZUxiY24yL2U4MUE4SDR2NFlnakZxdkpubHl0ZjFSVERuN01RL2x3MHhGVkYzcmdxYjhwV3JWMzF6S3BGOWFOWHQ4YWlYcFpsY2RlNnF6dUdybDA3ZGF5cTZoU3pva3RqcU9wU2liRlRrVGQxS3Q5am0rVlozRHlHWXZQeS9kSTF4dWIzYmR5OGZKKzhzamVYSG92Tml5SnN1ZU5XdFoyYS96ZGZyY3U5dXYzbGZmNTNuVG5GT1FEZXRHZERIZzVlZnZMQTYwSVltRG9MQUFBQUFORE9LTmdCQUFBQUFKdmNGWWYxZVdMa2orYjJyOWw4aDdOaURNZW16Z05BbTlYOHViQ3QxNjkvT0RRdC9xVWQ5dW9yc2xCNTlVMnFtMTlXcjUrck8yMGIrdi80N3FhOXp2bWZ0ZVc0TG9SaVRma1c1UXJyVjFHRWRURVU2MEpSM292Tjk4clhGN0doM0p1S0VQUFlmQnBQREhrNU54WkY4MXprNisvSG9yd1h5M3RGZVIyejRwWHozY3JYWitYYlpldjNVTzZ4S08vSHFsQ1V2NVlZcW9wUTFNUWkxb1NpS09mMVNadFhwL0xuTnhmZ092enQrc1FQNzJydUdiNzZ5L3JMTzJUOS8wK1d2ZktyZnVWOThIZWR1UGc2MXdDd1VTeGNXelFjc1BMa29ZK2xEZ0lBQUFBQXRFOEtkZ0FBQUFCQUVuT09HOVpjVlBqQ21Pbkw3c3BDY1U0SXNVdnFUQUR3T3BwTGFwMWVYbjlmT1B2TGlXNS9lNVRiSzhXOStKcHZFLy91RkxnWS8rNU11SmRmL3hwdjkzZkZ3SmQvNHR2OEpRRkFDMUNFODlZV1QzeHBaZDJFTmFtakFBQUFBQUR0bDRJZEFBQUFBSkRVbGVPN1g3THYxQ1dMWTNXOHZCdy9tam9QQUFBQUc5MnFQSVRQUC9pdEFkTlRCd0VBQUFBQVVMQURBQUFBQUpLNzRyQ2U5dys3Wk5sdUhXUHhreGppb2FuekFBQUFzTEVVdnk0YWlnTWVuRGpvZ2RSSkFBQUFBQUNhS2RnQkFBQUFBQzNDM0lPN3YxaHVFL2FkdnVTMkdMSWZsTmNkVTJjQ0FBQmdnN3JvVHkva1gzanlPNE5mVEIwRUFBQUFBT0JWQ25ZQUFBQUFRSXR5eGZpZTU0K2V2bVJCSmNUTHkvRkRxZk1BQUFEd3RxME9lZmppQTNVRHprOGRCQUFBQUFEZ0h5bllBUUFBQUFBdHp0WGpleTRkK2FONyt0UzhvMlp5aVBIVHFmTUFBQUR3VmhVUGhzWnd3QVAxQSs5TG5RUUFBQUFBNExVbzJBRUFBQUFBTGRLYzQzYjdjN2tkdU84bFMyNE9JWjVWWG5kTW5Ra0FBSUEzbzVqMmJQN2NzYit2SDdzcWRSSUFBQUFBZ05lallBY0FBQUFBdEdoWEhOenozREhUN3Iwenh1eG41Zmh2cWZNQUFBRHdMNjNLOCtJTHkrc0dYcHc2Q0FBQUFBREF2NkpnQndBQUFBQzBlRmNlMG12WnNFdHU3TnNoYlBPREdPTGhxZk1BQUFEdzJvb1Fsb1c4NmNEbGRZT1hwODRDQUFBQUFQQkdLTmdCQUFBQUFLM0MzSU1IdjFodVIrd3piZWt2c3hqT0xhKzdwczRFQUFEQTN5akNUOVlXVDV5d3NtN0NtdFJSQUFBQUFBRGVLQVU3QUFBQUFLQlZ1ZXFRSGpOR1QxMnlvRklWTGdzaDlrcWRCd0FBZ1BCY251ZEhMcThiTkR0MUVBQUFBQUNBTjB2QkRnQUFBQUJvZGE0K3JPZUtidlV6KzMxZ3B3OU9pakYrdWJ3VlUyY0NBQUJvcDI1ZnUyN3R3WStjTXZ6eDFFRUFBQUFBQU40S0JUc0FBQUFBb0ZXNnIyN3N1bkk3WWN4Rjk5NFlzMnhxaUdHNzFKa0FBQURha2NZUWl0T1cvK3E1VS9MTHhqYWxEZ01BQUFBQThGWXAyQUVBQUFBQXJkcVZFM3JOSFRQbGYzckUyZzRYbHVQdzFIa0FBQURhZ2NlTHhuejhBL1dEN2tnZEJBQUFBQURnN1ZLd0F3QUFBQUJhdlN1UDJQMnBMTXRHanI3NDNpL0ZFRTR2YjlXbXpnUUFBTkJHWGJZbWYrSHpLK3YzZVQ1MUVBQUFBQUNBRFVIQkRnQUFBQUJvRS9JOEw4cnQ3TkVYTHJtNVVoVm5oQmcrbWpvVEFBQkFHN0lxNU9FLzdxOGJNRFYxRUFBQUFBQ0FEVW5CRGdBQUFBQm9VNjcrYk0rbCsweGUzRGZyV1BsdU9SNVRycGc2RXdBQVFDdDNUME5EZnZDS2lZTldwQTRDQUFBQUFMQ2hLZGdCQUFBQUFHM09WVWYxZnFuY3ZyRHZKVXZtaENKZUVHTFlMblVtQUFDQVZxaXhDTVczbCtlM25aSlByR3RNSFFZQUFBQUFZR05Rc0FNQUFBQUEycXdyRHU1NTdjaXBTN3JWVk9MNUlZYlJxZk1BQUFDMElvK0VVQnh5L3pjSDNCWENnTlJaQUFBQUFBQTJHZ1U3QUFBQUFLQk5tM05ZenorVTJ6NWpMbG42dVJqQ1dlVjE1OVNaQUFBQVdyYmlnbUxWcXVQdlAzMzBDNm1UQUFBQUFBQnNiQXAyQUFBQUFFQzdjT1hCUGM0YlBYWEp6WldxY0VrSWNiZlVlUUFBQUZxYUlvUS94cVp3OUsvckJzeE9uUVVBQUFBQVlGTlJzQU1BQUFBQTJvMnJEK3U1WWtEOS9EMDMyMm56YjhZWXZsSGVxazZkQ1FBQW9JVzRMcTVaZDhTdlR4MzZ1OVJCQUFBQUFBQTJKUVU3QUFBQUFLQmRtVmZYdjdIY1R0NzNraVcvQ0NGZVhGNy9XK3BNQUFBQUNiMVFoUHlyeTc4MWVIS2U1MFhxTUFBQUFBQUFtNXFDSFFBQUFBRFFMbDF4Y00rRmU1NTk5NjdiYk5YaDFCamo4ZVd0TEhVbUFBQ0FUYW9JdCtZTmpZYzlNSEh3bytHYmVlbzBBQUFBQUFCSktOZ0JBQUFBQU8zV0hjZjNXMTF1SjR5NStONnJRb3hUUTRqdlQ1MEpBQUJnRTFoVGhQRC9sdWUzbnBWUHJOT3NBd0FBQUFEYU5RVTdBQUFBQUtEZHUvTFFYcmQrNHNJN2UyeFYxZm1zY2p3eWRSNEFBSUNOcGdpTEcyTERvUTk5YzhpdlE5Z3JkUm9BQUFBQWdPUVU3QUFBQUFBQVNyZDlkbzhYeXUybzBWT1hYSkZWNG5ubDlidFNad0lBQU5pQUdvcFFuTGI4ZngvNWRuN3VVUTJwd3dBQUFBQUF0QlFLZGdBQUFBQUFmK1BxdzNwZU8rcmNPN3BWT25jNXV4d1BUWjBIQUFEZ2JTdkNrcWE4NmJQTDZ3WXRDV0ZBNmpRQUFBQUFBQzJLZ2gwQUFBQUF3RCs0NXZON1BsZHVFOFpjdlBUbklZYWZCcWZaQVFBQXJWUHpxWFdUbHVmUG5wYlhqVjJYT2d3QUFBQUFRRXVrWUFjQUFBQUE4RHF1UExUSEhLZlpBUUFBcmRUU3hzYW13MTQrdFE0QUFBQUFnTmVqWUFjQUFBQUE4RS84dzJsMjU1WFhPNlRPQkFBQThFODBoS0tZZEgrVFUrc0FBQUFBQU40SUJUc0FBQUFBZ0RmZ2xkUHNkcWwwN3ZLOWNweVFPZzhBQU1CcnVEY1UrUkcvK3ViQWUxTUhBUUFBQUFCb0xSVHNBQUFBQUFEZW9GZE9zenRzbjR1WHpvZ3gvTFM4ZmwvaVNBQUFBTTNXaEtJNDVmN2ZQdkxkL055akdsS0hBUUFBQUFCb1RSVHNBQUFBQUFEZXBLc083WEhEZ0hQbWQ5dXN5enNtaFJDUExXOWxxVE1CQUFEdFZYRkhVMlBUa1EvVURWNGV3b0RVWVFBQUFBQUFXaDBGT3dBQUFBQ0F0MkRlTWYxWGxkdC9qTGw0NmM5Q0RPZVgxeDlKblFrQUFHaFhWdVZGK0svbFRiZjlKSytyeTFPSEFRQUFBQUJvclJUc0FBQUFBQURlaGlzUDdYSEhnSXZtOStxYWJmNy9ZZ2dubHJlcVUyY0NBQURhdkJ2eXhuVkgzMTgzOUxFUTlrcWRCUUFBQUFDZ1ZWT3dBd0FBQUFCNG0rWk42TCttM0U0YWRkSFN5eXRaT0srODdwczZFd0FBMENiOXNTanlFMzc5ellFWHB3NENBQUFBQU5CV0tOZ0JBQUFBQUd3ZzEwem9zU1E3Y09iSFJvLzQwSCtFTEV3c2IzVk5uUWtBQUdncmlvdWJHbDg2NFlHNnZmK1lPZ2tBQUFBQVFGdWlZQWNBQUFBQXNBSGxsNDF0S3Jlejk1bTJlSFlJMlk5amlIdW56Z1FBQUxSaVJmRndpTVV4dnpwcDRFMnBvd0FBQUFBQXRFVUtkZ0FBQUFBQUc4RlZoL1QrVGJtTkdqMXR5ZGdzeE8rWDF6dWt6Z1FBQUxRcURhRUlaNzd3M0xNVEh6OXo3T3JVWVFBQUFBQUEyaW9GT3dBQUFBQ0FqZWpxUTNyT0hIRFIwcHU2eERBcHh2QzU4bGFXT2hNQUFORGkzWjBYK2VmdS8rYkErMUlIQVFBQUFBQm82eFRzQUFBQUFBQTJzbmtUZWp4ZmJzZU1tcnBrV2xZSjU1VFgzVk5uQWdBQVdxVG44eUkvNllHbTI4L042K3J5MUdFQUFBQUFBTm9EQlRzQUFBQUFnRTNrbXNONjNqbWdmdjZ1WGQvL2p1TkRESFhsclM2cE13RUFBQzFERVlvWnNYSE5DYit1Ry9IN0VBYW1qZ01BQUFBQTBHNG8yQUVBQUFBQWJFTHo2dm8zbHR0L0Q1KzY4TEthclBLREVPS1kxSmtBQUlDa0hpelhzYjg2YWNDODFFRUFBQUFBQU5vakJUc0FBQUFBZ0FTdU82elBFK1cyNytpTDdoMFZZdnhoRE9HOXFUTUJBQUNiMUpweVRWcjMxSm96SHZ6K3NMV3B3d0FBQUFBQXRGY0tkZ0FBQUFBQUNWMDlvZGMxdzg2OGNWN3ROdHQ4cXh5L1hLN3ExSmtBQUlDTjdvYWlhRHp1VnljTldwRTZDQUFBQUFCQWU2ZGdCd0FBQUFDUTJOd1RCcjlZYmw4Zk5lWGVxYkY2L1dsMkExTm5BZ0FBTm9JaS9DYUUvSVQ3VGhvd00zVVVBQUFBQUFCZXBtQUhBQUFBQU5CQ1hITkVyd2ZLYmRBK0Z5LytkQ2l5TTBNTU82Yk9CQUFBYkJEcnl2WGZ6eld1T3UyM2RYdS9sRG9NQUFBQUFBQi9wV0FIQUFBQUFORENYSFZvNzU4UE9HZit0VjA2ditPa0dNSlh5bHMxcVRNQkFBQnYyZlY1US83Rlg5Y05lQ2gxRUFBQUFBQUEvaThGT3dBQUFBQ0FGbWplTWYxWGxkdC83WFBSNG90Q3lINFlZaGlVT2hNQUFQQW1GT0UzZVNpKy9PdVQ5cHFkT2dvQUFBQUFBSzlQd1E0QUFBQUFvQVc3YWtMdjVlVTJlUFRVSldOREZ2NDdodkRlMUprQUFJQi9hblVvd244LzE3anE5Ti9XN2YxUzZqQUFBQUFBQVB4ekNuWUFBQUFBQUszQTFZZjFuTG5uMlhmUDJYckxEaWVXNDlmTDFTbDFKZ0FBNEI4VVlYWmphUGpxQXljTmZqUjFGQUFBQUFBQTNoZ0ZPd0FBQUFDQVZ1S080L3Y5Zi9idUJVcXZzcndYK1BQdVNVSWdVQ2dnSWlvaXg3WnF2VUM0bGt1SEJJSUJFckE5c2RpalJ5cVlvMVJjWWhFUTBFNkh0dHJscFlCeWs0QUNDNjBvdFphYlhDTkJvWUdFSkJCQWJsSUY1RzRJbDF4blpyL24vY0pnS1ZXNUpka3pzMysvOE9UWisvMW13ajloUWxoODY3LzJzcktPUDJER3ZMTmpuZXBMNWZvdm1zNEVBQUNzc2pCeVBuemhjUk5tTmgwRUFBQUFBSUNYUjhFT0FBQUFBR0NZK2ZmcDQrOHI2OEFwNTg0L3BTdmlwSWkwVGRPWkFBQ2dwWjdJRVg5M2U5K3NVK3VlbnY2bXd3QUFBQUFBOFBJcDJBRUFBQUFBREZNWGYyamJhNnNETDloKzZyNWJmelJTMVZ1T05tMDZFd0FBdE1SQXpuRkd2YlQrM0czL09QRlhFWHMwblFjQUFBQUFnRmRJd1E0QUFBQUFZQmlyejU4MlVOYXBFOCtaOWUzMVk4UFBwUlNIbGZzeFRlY0NBSUNSSzEvVlg5ZC9jL3RuOTF6WWRCSUFBQUFBQUY0OUJUc0FBQUFBZ0JGZzVrSGRpOHM2WXYrekY1eWVxdnpGaVBUZXBqTUJBTUFJYzBmaytzaGJqcHQ0Y2ROQkFBQUFBQUJZZlJUc0FBQUFBQUJHa0F2L2FwdTd5L3F6L2MrZHYyZEUra3E1Zm5mVG1RQUFZSmhiRkpILy90Yjc3am1sUG4xNlg5TmhBQUFBQUFCWXZSVHNBQUFBQUFCR29Bcy90TzNWMVlFWGJMZnZQbS81Y0ZYRjM1ZWp6WnZPQkFBQXcweGY1RGd0OTYzc1hkaXo5NktJQ1UzbkFRQUFBQUJnRFZDd0F3QUFBQUFZb2VyenB3MlVkZVorSjkvNDNXcUQwVWVubEE0djkrczFuUXNBQUlhQkMvdFc5aDM5MDU1SmR6UWRCQUFBQUFDQU5VdkJEZ0FBQUFCZ2hMdmtzQjJmS3V1NC9jK2RmV3FPc2NlbmlJUEtmVmZUdVFBQVlLakpFVGZXT1I5NTI3RVRybTA2Q3dBQUFBQUFhNGVDSFFBQUFBQkFTMXo0b1oxL1dkWWhVODZaZDJLSzZvc3BZbkxUbVFBQVlJajRXUjF4N08zSFRmeGVYZGU1NlRBQUFBQUFBS3c5Q25ZQUFBQUFBQzF6OFVIakY1YTF6NVJ6YnByMGJORXViZE4wSmdBQWFNaXZjbzdQcjN4aytTbDNualI1UlJ4VE41MEhBQUFBQUlDMVRNRU9BQUFBQUtDbExqNW91eXVyM3Q3dHBteDV3QWVqaXVQTDBadWF6Z1FBQUd0SFhwWnpmRzFKMzVOZnVMZm5nTVZOcHdFQUFBQUFvRGtLZGdBQUFBQUFMVmIzOUhRZTBYSHVmaWRmZG43WEJxLzllRVE2dHR4djBuUXVBQUJZUS9yTG5MMThaZXE5czZmN2dhYkRBQUFBQUFEUVBBVTdBQUFBQUFEaWtzTW1yeWpybi9lZU1lK3NzV09xVDVmclQ1VVoxM0FzQUFCWVhYS1pmNjlYRGh5M3NHZmk3VTJIQVFBQUFBQmc2RkN3QXdBQUFBRGcxNjZZUHY3SnNqNDM5Wnk1cDZSNjRTck5BQUFnQUVsRVFWVG8rbHhFbWw3dVJ6ZWRDd0FBWG9WWi9UaytjOXV4M2JPYkRnSUFBQUFBd05DallBY0FBQUFBd1A5dzBVSGJQMXpXeC9mNXh2d1RSbmVsZnlqWDd5dFROUndMQUFCZXNoeHhjNHI2Mkp1UG1YQnAwMWtBQUFBQUFCaTZGT3dBQUFBQUFQaXRmbmp3dHZlVTlmNzl2N25nQzFGRnAyZzNwZWxNQUFEd0l1N0tPWHB1WFhuTmQrdWVucnJwTUFBQUFBQUFERzBLZGdBQUFBQUF2S2dMUDd6TnpXVk4zZjhiOC84a1Yra2ZJOFdFcGpNQkFNQUwvQ0p5UG43aHluUnUzZFBkSDlIZGRCNEFBQUFBQUlZQkJUc0FBQUFBQUY2eUN3L2U5ai9LbWpqMW0zUDNpcXFyODBTN25ack9CQUJBdStXSWg4djNYMWp4MFBLdjMzblM1QlZONXdFQUFBQUFZSGhSc0FNQUFBQUE0R1c3Nk1QYlgxVlYxZFg3blhYajFLaXE0eVBTdTV2T0JBQkF1K1NJUlNuaVM0dFdQUDNWQjNxbUxHMDZEd0FBQUFBQXc1T0NIUUFBQUFBQXIwaGQxN21zQzZ2ZTNvdjNlZE9VUDY5UzliZmwvcDFONXdJQVlNUmJWUDVEOUlRVks1Wjk5YzZleVU4MUhRWUFBQUFBZ09GTndRNEFBQUFBZ0ZlbDd1bXB5N3FnNnUzOS9yNWJUcDBXVmZTa1NHOXZPaGNBQUNQTzRoejVoT1VybHArb1dBY0FBQUFBd09xaVlBY0FBQUFBd0dveFdMVDdidFhiZThFK1crMy9GeW55NXhUdEFBQllEUlpIanBPZVdoa24zdHV6eCtLbXd3QUFBQUFBTUxJbzJBRUFBQUFBc0ZvTkZ1MitVL1gyZnJkVHRLdHkvRzJrZUZ2VHVRQUFHSGFlakJ3blBsdXM2MWFzQXdBQUFBQmdqVkN3QXdBQUFBQmdqZmdmUmJ1STQ4cjlPNXJPQlFEQWtMY29SejdwNlJYcHE0cDFBQUFBQUFDc2FRcDJBQUFBQUFDc1VjOHYydTMzcHYzZm15TSttMUpzMjNRdUFBQ0dtQnlQUjhvbkxGdXgvT1E3ZXlZLzFYUWNBQUFBQUFEYVFjRU9BQUFBQUlDMVlyQm85LzJxcXY1dHY3TnVuQnFwNjdQbGZvZW1jd0VBMExoSHluejUwU2RXbnZiZ0Z5Y3RhVG9NQUFBQUFBRHRvbUFIQUFBQUFNQmFWZGQxTHV2Q3prejl4dnpKVWVYUFJhUmRtczRGQU1CYTk4dkk4ZVVuSG52czY3LzR5clJsVFljQkFBQUFBS0NkRk93QUFBQUFBR2pNUlFkdmUxbFpsKzE3MWsxN2RIVlZ4NVRydlp2T0JBREFHcGJqWnpubEx5NS9jUGs1ZDU0MGVVWFRjUUFBQUFBQWFEY0ZPd0FBQUFBQUduZnBJZHRkVTlZMVU4K2F2MTEweFdmSzlaK1hxWnBOQlFEQWFuWnpYY2MvM2JyZ3NlL1Y1MDhiYURvTUFBQUFBQUIwS05nQkFBQUFBREJrWEhUSXRqZVY5YjZwWjgxL1c2N2lxSlRpQStWK2ROTzVBQUI0TmZMMWtlTUxOeDg3NFpLNnJuUFRhUUFBQUFBQTRQa1U3QUFBQUFBQUdISXVPbVRibjViMTRTbmZtUDkzcWNxZmprZ0hsL3YxbXM0RkFNQkxsc3UzS3daUy9xZGJqdTYrWnRYSlorcG1Fd0VBQUFBQXdHK2dZQWNBQUFBQXdKQjE4Y0hiL3FLc1QweWNNYTkzM2RIeDF5bW5qMGVLelpyT0JRREFiOVZYNXZ5Njd2L1N6Y2RNdktYcE1BQUFBQUFBOEdJVTdBQUFBQUFBR1BKbVRoLy9lRm5IN3pCajNwZGYweFYvVlZYcFUrWCtMVTNuQWdEZzE1Nk9uR2YwcitnL2FXSFBudmMxSFFZQUFBQUFBRjRxQlRzQUFBQUFBSWFOT2RQSEx5M3IxT3JBQzc2K3p6NXYvck9JNnFnVXNVUFR1UUFBV3V6aG5PTnJPVDF6MnMyZjJmZUpwc01BQUFBQUFNRExwV0FIQUFBQUFNQ3dVNTgvYmFDc0N6cXozOWx6dTFOMGZicGM3MXVtYWpZWkFFQnIzQmE1UG1IcFE4dlB1L09reVN1YURnTUFBQUFBQUsrVWdoMEFBQUFBQU1QYUpYKzEvYXl5WmsyZU1lK3RYYVBpa3ltbEQ1WDc5WnJPQlFBd0F1WHkxNVhsdXhOdU9XYkM1WFZkNTZZREFRQUFBQURBcTZWZ0J3QUFBQURBaUhEWjlQRjNsSFhvUHQrWWZWeVYxdmxZU3ZIeGNyOUYwN2tBQUVhQUZUbnl0NktPRStZZjAzM3JxcE9qNjRZakFRQUFBQURBNnFGZ0J3QUFBQURBaVBMRGczZGVWTmJuMzlsN3daZTMzUExONzArcCtsUzUzNmJwWEFBQXc5QmpFZm0wZ1lHQlUyOCtadUlqVFljQkFBQUFBSUExUWNFT0FBQUFBSUFSYVdIUHRKVmxuZHVaZmMrNmFZK3FxL3BFdVQ2Z1RGZXp5UUFBaHJnY0MzTEUxNTVjbnI5OWIwLzM4cWJqQUFBQUFBREFtcVJnQndBQUFBREFpSGZwSWR0ZFU5WTErMzc5aHEzUzZOR0hwcFErVXU0M2JqZ1dBTUJRMGwvbUIzVU1mRzNCMFJPdWJUb01BQUFBQUFDc0xRcDJBQUFBQUFDMHhxVWYzZW5uWlIyOXc0eDV2WnVOU2g5TUVaMm4ycjJqNFZnQUFFMWFsQ09mdWJLL1B2VzJZeWY4b3Vrd0FBQUFBQUN3dGluWUFRQUFBQURRT25PbWoxOWExaGxWVmMxNHoxazM3cG1pK2tTSzJLK2NkVFdkRFFCZ3JjajVsb2gweXFQTG56cnZnWjRwUzV1T0F3QUFBQUFBVFZHd0F3QUFBQUNndGVxNnptVmQxWm05Wjh6YmN2U28vTkVjNlNNcFlyT21zd0VBckFFcnkzeS9qb0hURmh3OTRkcW13d0FBQUFBQXdGQ2dZQWNBQUFBQUFNVVYwOGZmVjlaeCs1MTgyZkY1M1UzZmw2cnEwSEsvUzlPNUFBQldnL3NqOGhsOXkrTE1oVDNkRHpjZEJnQUFBQUFBaGhJRk93QUFBQUFBZUo1TERwdThvcXp6T3ZPZU0rZHUwOVdWRGswUkg0aEk0NXJPQmdEd011VHk3ZW82RFp4Mjg3THF3cnFudTcvcFFBQUFBQUFBTUJRcDJBRUFBQUFBd0c5eCtVZTJYMURXUnllZU5Pdm9kVGRZLzRPUjBrZkwvVHVhemdVQThEczhubk9jWGFlQk14Y2NOZUhPcHNNQUFBQUFBTUJRcDJBSEFBQUFBQUF2WXVZbnV4ZVhkWEpuOWpsejdpNnBLMDFQa1E0czkrczJIQTBBb0NQbmlGbmwreG1MbCtYdjM5dlR2YnpwUUFBQUFBQUFNRndvMkFFQUFBQUF3TXZ3dzQ5c2YzMVoxLy9wNmRmOXpmcWoxLzIvcVlycDRhbDJBRUF6ZmxYbW5MNklNMjg1Y3ZlZk5oMEdBQUFBQUFDR0l3VTdBQUFBQUFCNEJhNzkySzVQbFBYVnp1ejd6WG03cFZoVnRKdFdacjFta3dFQUk5eXpUNnVMT0hQeDB2cGZQYTBPQUFBQUFBQmVIUVU3QUFBQUFBQjRsUzc5OFBpZmxQV1QvVTYrOFJNeHJucC9SSFZJdWQreDZWd0F3SWp5WU01eGRsK3V2N253Nk81N21nNERBQUFBQUFBamhZSWRBQUFBQUFDc0pwY2N0dU5UWlozUm1YM1B1dUZka1VZZkVqaytFQ2syYVRvYkFEQXM5Wlc1cUI2b3YzbnppcmlzN3VudWJ6b1FBQUFBQUFDTU5BcDJBQUFBQUFDd0JseDZ5RTYzbFBYSlB6cjVzcU8ySHJ2WkFhbktCMGVrdmNwWlY5UFpBSUFoTHNjZDVidHY5ZzMwbjNQek1STWZhVG9PQUFBQUFBQ01aQXAyQUFBQUFBQ3dCdDE1Mk9RVlpYMjNNeFBQdXZFTlkyUFVCM09LZzFMRVc1dk9CZ0FNS1Uva3lPZW55T2ZNUGFwN2R0TmhBQUFBQUFDZ0xSVHNBQUFBQUFCZ0xabDV5STRQbFBWUG5YblBXVGZ1WE1Xb2cxTEs3NDlJR3pXZERRQm94RUNaSzZPdXoxbTBMSDV3YjAvMzhxWURBUUFBQUFCQTJ5allBUUFBQUFCQUF5NC9aTWZPazJsbVQreWQ5YWt4YjF6L3ZTazZUN1ZMazhwWlY5UFpBSUExN3JhSWZHN09LOCs3NmNpOUhtdzZEQUFBQUFBQXRKbUNIUUFBQUFBQU5Ham1zMCtxK1U1bjlwMHg3M1hSbGY4eWN2cEFwQmpmZERZQVlEWEs4VkNPK0plQjFQZXRCWitlT0svcE9BQUFBQUFBd0xNVTdBQUFBQUFBWUlpNGRQcjRoOHI2NTg1TU91UEd0NC9xNnZwQWl2Ui9Jc1ZXRFVjREFGNlpaM0xFOTh0OGE4SGNSNjZ1ejU4MjBIUWdBQUFBQUFEZ3YxT3dBd0FBQUFDQUllaksvN2ZqN1dVZFYxWFZaL2MrODRiZHExeDlJRko2WHpuNy9hYXpBUUMvVTMrWks2TE8zM3A0MlZNL2VLQm55dEttQXdFQUFBQUFBTCtkZ2gwQUFBQUFBQXhoZFYzbnNxN3R6RHQ3TC9qRUcxKy8xZVNvcXIrTXlGTWowcmltOHdFQXE5U1I0eWQxeEwvRXdKSi92ZWt6a3g5ck9oQUFBQUFBQVBEU0tOZ0JBQUFBQU1Bd3NiQm4yc3F5THV6TTVLOWNPUzUrZitPcFZhUUR5LzArWmRacE5oMEF0TkxjaUh6K2lwVngvaTNIN241LzAyRUFBQUFBQUlDWFQ4RU9BQUFBQUFDR29jdU9tTFNrck85MFp1SkpzellhTzI2RDkwWVZmMW51SjRiLy93OEFhMUMrTFhmK0RCNm92elAzNk81N21rNERBQUFBQUFDOE90NWdCd0FBQUFDQVlXN21KN3NYbDNWMlo3cFAvc2xyMWwxMzdKK2xGUDg3SWluYkFjRHFjWHZPK1lLQnZ2cDc4NC9wdnJYcE1BQUFBQUFBd09yalRYVUFBQUFBQUJoQlpoMjIyMk5sbmRHWkY1VHRKcFN6MFEzSEE0RGg1TmJJOGIyNlB5NjQ2VE83M2Q1MEdBQUFBQUFBWU0xUXNBTUFBQUFBZ0JIcStXVzdTYWZPMmFScmRIVkFxdUo5NWI3elpMc3h6YVlEZ0tFbjUxaFkxZ1U1NSsvTlBYTDNuemFkQndBQUFBQUFXUE1VN0FBQUFBQUFvQVd1L09zZGZsWFdOem96OGFSWkc0MVpmOXlVaUhSQWl0aW5uSTFyT0I0QU5LV09ITE56NUgvTEEvVVA1aDdkZlUvVGdRQUFBQUFBZ0xWTHdRNEFBQUFBQUZwbTVpZTdGNWQxWG1kMlBYSDJ1aHVNNjNwUHFxb0Rjc1RVRkxGSjAva0FZQTNySzMvbS9TalYrZDl5Zi9yM09jZnM5bERUZ1FBQUFBQUFnT1lvMkFFQUFBQUFRSXRkZC9qT3k4cjZRV2NtOXM0YXRjN3J4KzNSZWJKZFRyRi9pdGl5NFhnQXNMbzhYZWFLdXZ4NVZ6OHpjUEc4bmxWbGN3QUFBQUFBQUFVN0FBQUFBQURnV1RON3V2dkx1bXB3UHZHZU0rZHVVMFhzSDVHbVJvcnR5bGxxTmlFQXZDejNSK1NMNnJxKzZPbjdsLzNvenBNbXIyZzZFQUFBQUFBQU1QUW8yQUVBQUFBQUFML1I1Ui9aZmtGWm5UbitQYWRjdjBXMXpqcjc1eFJUVThURWNqYTI0WGdBOEVLNWZKdmZLZFhsbkM2ODZhZy9uVi9YZFc0NkZBQUFBQUFBTUxRcDJBRUFBQUFBQUMvcThvL3Y4bUJacDNkbTRtbXoxaDh6YXIyOW9xcjJLZmY3bFhsOXMra0FhTEVsT2VMcWlQekR0RHd1dWVIWTNlLy85U3Vmcmh1TUJRQUFBQUFBREJjS2RnQUFBQUFBd01zeTg5RHVaOHI2UVdlcXFrcVR6cmp4M1pGaTM1UmpuMGhwNS9EK0F3QnJVSTc4czVUVEpYWE9sengxLzVKWmQ1NDBlVVhUbVFBQUFBQUFnT0hMRzl3QUFBQUFBTUFyVnRkMUxtdkI0SHgrMXhObmJ6eHVYTmZrcXFyMkxmZVR5bXpXYUVBQVJvSVZPZksxS2VkTFYvYWxTK2QvWnJlN21nNEVBQUFBQUFDTUhBcDJBQUFBQUFEQWFuUGQ0VHN2S3V2Ym5hbDZlNnRKcjl0M2ZFVGFPNlUwS1ZMc1dzNUhOeHdSZ0dFZ1I5d1JPVitXY3JxOFh2TEV0WE42cGl4dE9oTUFBQUFBQURBeUtkZ0JBQUFBQUFCclJOM1RVNWMxZDNBK3YvdVhydDlndmQ4Zk15RkY2anpaYm5LWnR6UWFFSUNoNUluSWNYVWQrZkpxZWI3OHhtTjN2Ny9wUUFBQUFBQUFRRHNvMkFFQUFBQUFBR3ZGajQvYzVlbXlMaHljMlB2MHVWdFhWZXdWVmRxejNIWm1reWJ6QWJCV3JTd3pPK2Q4OVVBYXVHTGU3TWZtMU9kUEcyZzZGQUFBQUFBQTBENEtkZ0FBQUFBQVFDT3UrTmoyOTVaMVJtZXEzdDVxenkwbWIxUEZxTDBpNVQxVHBOM0wrYm9OUndSZzllazgxWFJCbWF2eVFQeG9aVnI2NC9sSFRGclNkQ2dBQUFBQUFBQUZPd0FBQUFBQW9IRjFUMCtuZURGdmNMNDRzWGZXMkRHdlgyK1huS3M5SThYRWNyWmRtZEdOaGdUZzVib25SL3dvMVhIVlFPcWZPZWR2dWg5dk9oQUFBQUFBQU1BTEtkZ0JBQUFBQUFCRHpzeWU3dVdkTlRneDhiUlo2NC9xR3JkYnBPaE9LZllvUjl1SDl6a0FocHA3Y3VScnlwN1Z0Nnp2Ui9PT25mRExwZ01CQUFBQUFBQzhHRzg4QXdBQUFBQUFROTdNUTd1ZktldXl3WGxoNFc1Q09Sb2ZubkFIc0xiZEhaRm4xUkd6VnZRUFhMUGd5TzRIbWc0RUFBQUFBQUR3Y2luWUFRQUFBQUFBdzg0TEMzZmJmdVhLY1p0c3VORk9YVGwxU25lN2xxTS9LYk5Ca3hrQlJwaUJNamVYK1VtdTQ3cUJsZm5IYzQ3WjdhR21Rd0VBQUFBQUFMeGFDbllBQUFBQUFNQ3dOLytJU1V2S21qazRVUjE0UWRlZWU3M3gzVlh1K3RPY1l2Y1VzVXM1M3J6UmtBRERTWTZsNWQrZnM4dlZUMUxVMXozWjk4Ui8zSDdrL2s4M0hRc0FBQUFBQUdCMVU3QURBQUFBQUFCR25QcjhhWjBuTGMwYm5CTTdaM3VmUG5mclhNVXVLZVdkVXFSTzRlNWQ0YjBTZ09mOFBDTFB6am4vUjZUcStvRTdiN3Q1enVuVCs1b09CUUFBQUFBQXNLWjUweGdBQUFBQUFHaUZLejYyL2IxbGRlYTh6djIyWDdseTNDYnJiN1JUbFdLWEhHbW5sR0xuY3J4cG95RUIxbzdsWmVibEhOZEhybTlZT1ZCZGY5T1J1eno0M3o5a2wwYUNBUUFBQUFBQXJHMEtkZ0FBQUFBQVFDdk5QMkxTa3JKbURrNVVWWlgyT09YNi96VnFWTmVPNVhhSGlOVFoyNVpadDhHWUFLOVduWFBja1ZLK3NWelBxU1BkdU9USkIyOVoyRE50WmRQQkFBQUFBQUFBaGdJRk93QUFBQUFBZ0tLdTYxeldQWVB6N2M3WkRqTm1qTjRvM3ZYT25Lc2RxN1NxZEZjbTNoYmVZd0dHcmdmS3pJMmNiNmhUZmVQQWlwVTN6VGxxenllYkRnVUFBQUFBQURCVWVmTVhBQUFBQUFEZ3Q1Z3pmWHBmV2ZNRzUvVE8yUTR6TGw1dncvN050NGxSOWZncTByWTUwdllwNHUzaGZSZGc3YnN2bmkzVHpjODV6VXZMbDk5MC9URVRIMms2RkFBQUFBQUF3SERpalY0QUFBQUFBSUNYWWM3MEtVdkx1bjV3VnRuMXhObnJyak8yZXZlb1ZJM1BLY2FuaUhlWDQzZVVHZHRVVG1CRXFTUHl2VGxpUWVRMHY0NDhiK1hBMG5uemo1ajBhTlBCQUFBQUFBQUFoanNGT3dBQUFBQUFnRmZwdXNOM1hsYlc3TUZaWldMdnJGR3grWmkzZHFYUjIrUm5DM2Z2R2l6ZXZiYXBuTUN3c0tUTXdtZkxkSGxoMUhITDRvRjA4KzFIN3ZwMDA4RUFBQUFBQUFCR0lnVTdBQUFBQUFDQU5XQm1UM2QvV2JjT3publBuVTg4YmRibTBiWE9ObDI1NjEyUjRvL0wwZHZMdkszTXVHYVNBZzBaS1BPelBQanZpVlRYdDYyc3ExdHV1dUhCdSt2enB3MDBIUTRBQUFBQUFLQXRGT3dBQUFBQUFBRFdvcG1IZGo5YzFtV0RzMHJWMjF2dDl0cTl0aG9Ubzk2UnF2U095T21QSThVN3kwdC9XR2FkcHJJQ3EwVWRrZStMU0xmbkhMZW1WTitXYzc0MTVZZC9ldDNoMDVZMUhRNEFBQUFBQUtEdEZPd0FBQUFBQUFBYVZ2ZjAxR1hkT3pnWFBuZGVIWGhCMXg1N3ZPSE5WVXB2anhSbDBoK2xTRytOWjU5NHQyRkRjWUhmcksvTTNaSGo5cHp5SGVYMzZwMTFIcmk5Yi9IaU8rYjBURm5hZERnQUFBQUFBQUIrTXdVN0FBQUFBQUNBSWFvK2Y5cEFXZmNNem44Vjc2b3E3ZkhWMmErUFVmVmJVMHAvbUtMNmcwaXJubmIzbGpKdkxqTzZtY1F3NHVVeUQwWG45MlNPdStySWQxZVI3b3FCdUdQRlhiZitiTTdwMC91YURnZ0FBQUFBQU1ETG8yQUhBQUFBQUFBd3pOUjEzU241UERBNFZ6My90UjArTm1QMGV1L2E1czJqSTc4bHF2akRuT0lQVXFRL0tKL3c1aFN4WmZtUU1VMWtobUhrdVJMZHZUbnl2ZVgzejkyNXJ1L0tLZCt6ZUdWMTkrMUg3dkwwYi82MFAxbWJHUUVBQUFBQUFGaE5GT3dBQUFBQUFBQkdrTUVuYU4wMU9KYysvN1dKdmJOR3hlWmozMUJGdFhXZFkrdVVPays3eTI5SmtiYU9aNTk4dDBrRGthRUpTOHY4ZkZXQkxxZDdjODcvbVZQY20vdnJlNnJxNGYrODd2QnB5NW9PQ0FBQUFBQUF3TnFoWUFjQUFBQUFBTkFTTTN1Nis4djYrZURNZk9IckUwK2J0WDVVWTdhcUJycTJqSlMyakNxL0tTSnRGWkczakZ6dVUyeFJQcXhhaTVIaGxWb2NuYS96bkgrZUk5MlhVMzEvcXF1ZnAzSWZBK20rNjQvYzliSEJKMEVDQUFBQUFBRFFjZ3AyQUFBQUFBQUFyREx6ME81bnlycDFjUDZIZC9aZU1PWTFtNzl4aTdyT1czUlZYVytJSEc4b3g2OWZ0ZE9xNjg2OHJzem90WmVhbHVtVTRoNHI4MEM1ZkNCSGVpRGwvTXU2WEVjZEQ1YXZ6UWRIRFZUMy8vaklYWjcrblQvS0VmVmFDUXNBQUFBQUFNRFFwMkFIQUFBQUFBREFTN0t3WjlySytLOG40UDFHVlc5dnRjY0dlMnc4c043WUxicHkzaUlpYlY2T040OFVyMTExbldQenRPbyt2NjdjYjdpV29qUDBMU3Z6U0ptSHk5Zkl3K1hyNCtGYzdsT2tjbDgvMkNuUDlmZjFQZnpNMHNjZUhmdzZCQUFBQUFBQWdOVkN3UTRBQUFBQUFJRFZwdTdwNlR3YTdQSEJ1ZVYzZld6bmlYZ2JiYnJGcHFPcjJLeU9VWnQxcFhyVEhOVm1LZWZYUkVxYjVoeXZTWkUzS2RjYmx3OS9ic2F1K1o4RnIxSi9tY1ZsRm5VbVIzNGlSWHFzL1BOOHRIeUZQSlpTZW55Z1RvOUdGWTkyOVE4OC9zU1QvWTh1N0ZuMTlFUUFBQUFBQUFCWTZ4VHNBQUFBQUFBQWFNVGdrOGdlSEp5WFpJZmVpOWZiWUpQTk5oNm84OFpkWGJGeFhjWEdxVTRicGhRYjVvamZLM3VEeUxGUnBQaTk4dUcvbmh4NXd4UnBYTGxldjh5WU5mSVRHaGtHeWl3Wm5LZkxQQldSRjVkZjI2ZlNxdXYwMUtyckhFK1c4ODc5NHZKcnZTajMxNHRUNUVYUHBQNUZDejQxNGNtNnJuT3pQdzBBQUFBQUFBQjRhUlRzQUFBQUFBQUFHRGJtOUV4WldsWm5IbmlsUDBibnlYbS90K0ViMXUrcUJ0YXZ1NnIxdWxLMVhvcDYvWWl1OVhPSzlhTE9ZeVBGMkpSUzUybDVZMU11Wnltdkd6bXRPdStjNVJ4anl2V295R1U2Ty9LcTYvSTVZNTU3TFVWVXVjeHp1N3hlZGY3K09lVnlscDcvV2wxMnZlcTF5SFhLcVM2ZjM3bXZCeU4zOWtCNXNhK2NkNTRPMTErdVY1YnJsWVBYL1ozenZPckpjWGw1K2Z5bEplL3lIR2xGZVgxNXpubDVlWDE1bGRQeThzTXZ6eWt0S1grVEpUbW5aMFpGL3pOOUF3TkxxLzR4UzFjODg2dG5idXJkZjltckxzZDlzbjd4andFQUFBQUFBSUFoUXNFT0FBQUFBQUNBVmhsOGN0Nml3ZUg1ZXBUakFBQUFBQUFBYUJjRk93QUFBQUFBQUFBQUFBQUFBQUJhU2NFT0FBQUFBQUFBQUFBQUFBQUFnRlpTc0FNQUFBQUFBQUFBQUFBQUFBQ2dsUlRzQUFBQUFBQUFBQUFBQUFBQUFHZ2xCVHNBQUFBQUFBQUFBQUFBQUFBQVdrbkJEZ0FBQUFBQUFBQUFBQUFBQUlCV1VyQURBQUFBQUFBQUFBQUFBQUFBb0pVVTdBQUFBQUFBQUFBQUFBQUFBQUJvSlFVN0FBQUFBQUFBQUFBQUFBQUFBRnBKd1E0QUFBQUFBQUFBQUFBQUFBQ0FWbEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1ZGT3dBQUFBQUFBQUFBQUFBQUFBQWFDVUZPd0FBQUFBQUFBQUFBQUFBQUFCYVNjRU9BQUFBQUFBQUFBQUFBQUFBZ0ZaU3NBTUFBQUFBQUFBQUFBQUFBQUNnbFJUc0FBQUFBQUFBQUFBQUFBQUFBR2dsQlRzQUFBQUFBQUFBQUFBQUFBQUFXa25CRGdBQUFBQUFBQUFBQUFBQUFJQldVckFEQUFBQUFBQUFBQUFBQUFBQW9KVVU3QUFBQUFBQUFBQUFBQUFBQUFCb0pRVTdBQUFBQUFBQUFBQUFBQUFBQUZwSndRNEFBQUFBQUFBQUFBQUFBQUNBVmxLd0F3QUFBQUFBQUFBQUFBQUFBS0NWRk93QUFBQUFBQUFBQUFBQUFBQUFhQ1VGT3dBQUFBQUFBQUFBQUFBQUFBQmFTY0VPQUFBQUFBQUFBQUFBQUFBQWdGWlNzQU1BQUFBQUFBQUFBQUFBQUFDZ2xSVHNBQUFBQUFBQUFBQUFBQUFBQUdnbEJUc0FBQUFBQUFBQUFBQUFBQUFBV2tuQkRnQUFBQUFBQUFBQUFBQUFBSUJXVXJBREFBQUFBQUFBQUFBQUFBQUFvSlVVN0FBQUFBQUFBQUFBQUFBQUFBQm9KUVU3QUFBQUFBQUFBQUFBQUFBQUFGcEp3UTRBQUFBQUFBQUFBQUFBQUFDQVZsS3dBd0FBQUFBQUFBQUFBQUFBQUtDVkZPd0FBQUFBQUFBQUFBQUFBQUFBYUNVRk93QUFBQUFBQUFBQUFBQUFBQUJhU2NFT0FBQUFBQUFBQUFBQUFBQUFnRlpTc0FNQUFBQUFBQUFBQUFBQUFBQ2dsUlRzQUFBQUFBQUFBQUFBQUFBQUFHZ2xCVHNBQUFBQUFBQUFBQUFBQUFBQVdrbkJEZ0FBQUFBQUFBQUFBQUFBQUlCV1VyQURBQUFBQUFBQUFBQUFBQUFBb0pVVTdBQUFBQUFBQUFBQUFBQUFBQUJvSlFVN0FBQUFBQUFBQUFBQUFBQUFBRnBKd1E0QUFBQUFBQUFBQUFBQUFBQ0FWbEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1ZGT3dBQUFBQUFBQUFBQUFBQUFBQWFDVUZPd0FBQUFBQUFBQUFBQUFBQUFCYVNjRU9BQUFBQUFBQUFBQUFBQUFBZ0ZaU3NBTUFBQUFBQUFBQUFBQUFBQUNnbFJUc0FBQUFBQUFBQUFBQUFBQUFBR2dsQlRzQUFBQUFBQUFBQUFBQUFBQUFXa25CRGdBQUFBQUFBQUFBQUFBQUFJQldVckFEQUFBQUFBQUFBQUFBQUFBQW9KVVU3QUFBQUFBQUFBQUFBQUFBQUFCb0pRVTdBQUFBQUFBQUFBQUFBQUFBQUZwSndRNEFBQUFBQUFBQUFBQUFBQUNBVmxLd0F3QUFBQUFBQUFBQUFBQUFBS0NWRk93QUFBQUFBQUFBQUFBQUFBQUFhQ1VGT3dBQUFBQUFBQUFBQUFBQUFBQmFTY0VPQUFBQUFBQUFBQUFBQUFBQWdGWlNzQU1BQUFBQUFBQUFBQUFBQUFDZ2xSVHNBQUFBQUFBQUFBQUFBQUFBQUdnbEJUc0FBQUFBQUFBQUFBQUFBQUFBV2tuQkRnQUFBQUFBQUFBQUFBQUFBSUJXVXJBREFBQUFBQUFBQUFBQUFBQUFvSlVVN0FBQUFBQUFBQUFBQUFBQUFBQm9KUVU3QUFBQUFBQUFBQUFBQUFBQUFGcEp3UTRBQUFBQUFBQUFBQUFBQUFDQVZsS3dBd0FBQUFBQUFBQUFBQUFBQUtDVkZPd0FBQUFBQUFBQUFBQUFBQUFBYUNVRk93QUFBQUFBQUFBQUFBQUFBQUJhU2NFT0FBQUFBQUFBQUFBQUFBQUFnRlpTc0FNQUFBQUFBQUFBQUFBQUFBQ2dsUlRzQUFBQUFBQUFBQUFBQUFBQUFHZ2xCVHNBQUFBQUFBQUFBQUFBQUFBQVdrbkJEZ0FBQUFBQUFBQUFBQUFBQUlCV1VyQURBQUFBQUFBQUFBQUFBQUFBb0pVVTdBQUFBQUFBQUFBQUFBQUFBQUJvSlFVN0FBQUFBQUFBQUFBQUFBQUFBRnBKd1E0QUFBQUFBQUFBQUFBQUFBQ0FWbEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1ZGT3dBQUFBQUFBQUFBQUFBQUFBQWFDVUZPd0FBQUFBQUFBQUFBQUFBQUFCYVNjRU9BQUFBQUFBQUFBQUFBQUFBZ0ZaU3NBTUFBQUFBQUFBQUFBQUFBQUNnbFJUc0FBQUFBQUFBQUFBQUFBQUFBR2dsQlRzQUFBQUFBQUFBQUFBQUFBQUFXa25CRGdBQUFBQUFBQUFBQUFBQUFJQldVckFEQUFBQUFBQUFBQUFBQUFBQW9KVVU3QUFBQUFBQUFBQUFBQUFBQUFCb0pRVTdBQUFBQUFBQUFBQUFBQUFBQUZwSndRNEFBQUFBQUFBQUFBQUFBQUNBVmxLd0F3QUFBQUFBQUFBQUFBQUFBS0NWRk93QUFBQUFBQUFBQUFBQUFBQUFhQ1VGT3dBQUFBQUFBQUFBQUFBQUFBQmFTY0VPQUFBQUFBQUFBQUFBQUFBQWdGWlNzQU1BQUFBQUFBQUFBQUFBQUFDZ2xSVHNBQUFBQUFBQUFBQUFBQUFBQUdnbEJUc0FBQUFBQUFBQUFBQUFBQUFBV2tuQkRnQUFBQUFBQUFBQUFBQUFBSUJXVXJBREFBQUFBQUFBQUFBQUFBQUFvSlVVN0FBQUFBQUFBQUFBQUFBQUFBQm9KUVU3QUFBQUFBQUFBQUFBQUFBQUFGcEp3UTRBQUFBQUFBQUFBQUFBQUFDQVZsS3dBd0FBQUFBQUFBQUFBQUFBQUtDVkZPd0FBQUFBQUFBQUFBQUFBQUFBYUNVRk93QUFBQUFBQUFBQUFBQUFBQUJhU2NFT0FBQUFBQUFBQUFBQUFBQUFnRlpTc0FNQUFBQUFBQUFBQUFBQUFBQ2dsUlRzQUFBQUFBQUFBQUFBQUFBQUFHZ2xCVHNBQUFBQUFBQUFBQUFBQUFBQVdrbkJEZ0FBQUFBQUFBQUFBQUFBQUlCV1VyQURBQUFBQUFBQUFBQUFBQUFBb0pVVTdBQUFBQUFBQUFBQUFBQUFBQUJvSlFVN0FBQUFBQUFBQUFBQUFBQUFBRnBKd1E0QUFBQUFBQUFBQUFBQS9qOTdkdzhjMVpYbUQvZzlwNFZoa2FrbHBHcE5MZG1RTFk1V0U0MGNEWTRHUjRPakVSOHU0d2hjSlFhSTVJNEFxNnN3a1V4WmtuRUVHOEZHWnFPUm8yRWpzOUd3R1ZQanFTSmthOGIrZTJiZzN2KzlWKzBQeHZhWUQwbTN1Ky96bFB1cXV4SHlpOVE2ZlU3My9aMFhBQURvSkFFN0FBQUFBTU5rRnEwQUFDQUFTVVJCVkFBQUFBQUFBQUFBQURwSndBNEFBQUFBQUFBQUFBQUFBQUNBVGhLd0F3QUFBQUFBQUFBQUFBQUFBS0NUQk93QUFBQUFBQUFBQUFBQUFBQUE2Q1FCT3dBQUFBQUFBQUFBQUFBQUFBQTZTY0FPQUFBQUFBQUFBQUFBQUFBQWdFNFNzQU1BQUFBQUFBQUFBQUFBQUFDZ2t3VHNBQUFBQUFBQUFBQUFBQUFBQU9na0FUc0FBQUFBQUFBQUFBQUFBQUFBT2tuQURnQUFBQUFBQUFBQUFBQUFBSUJPRXJBREFBQUFBQUFBQUFBQUFBQUFvSk1FN0FBQUFBQUFBQUFBQUFBQUFBRG9KQUU3QUFBQUFBQUFBQUFBQUFBQUFEcEp3QTRBQUFBQUFBQUFBQUFBQUFDQVRoS3dBd0FBQUFBQUFBQUFBQUFBQUtDVEJPd0FBQUFBQUFBQUFBQUFBQUFBNkNRQk93QUFBQUFBQUFBQUFBQUFBQUE2U2NBT0FBQUFBQUFBQUFBQUFBQUFnRTRTc0FNQUFBQUFBQUFBQUFBQUFBQ2drd1RzQUFBQUFBQUFBQUFBQUFBQUFPZ2tBVHNBQUFBQUFBQUFBQUFBQUFBQU9rbkFEZ0FBQUFBQUFBQUFBQUFBQUlCT0VyQURBQUFBQUFBQUFBQUFBQUFBb0pNRTdBQUFBQUFBQUFBQUFBQUFBQURvSkFFN0FBQUFBQUFBQUFBQUFBQUFBRHBKd0E0QUFBQUFBQUFBQUFBQUFBQ0FUaEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1RCT3dBQUFBQUFBQUFBQUFBQUFBQTZDUUJPd0FBQUFBQUFBQUFBQUFBQUFBNlNjQU9BQUFBQUFBQUFBQUFBQUFBZ0U0U3NBTUFBQUFBQUFBQUFBQUFBQUNna3dUc0FBQUFBQUFBQUFBQUFBQUFBT2drQVRzQUFBQUFBQUFBQUFBQUFBQUFPa25BRGdBQUFBQUFBQUFBQUFBQUFJQk9FckFEQUFBQUFBQUFBQUFBQUFBQW9KTUU3QUFBQUFBQUFBQUFBQUFBQUFEb0pBRTdBQUFBQUFBQUFBQUFBQUFBQURwSndBNEFBQUFBQUFBQUFBQUFBQUNBVGhLd0F3QUFBQUFBQUFBQUFBQUFBS0NUQk93QUFBQUFBQUFBQUFBQUFBQUE2Q1FCT3dBQUFBQUFBQUFBQUFBQUFBQTZTY0FPQUFBQUFBQUFBQUFBQUFBQWdFNFNzQU1BQUFBQUFBQUFBQUFBQUFDZ2t3VHNBQUFBQUFBQUFBQUFBQUFBQU9na0FUc0FBQUFBQUFBQUFBQUFBQUFBT2tuQURnQUFBQUFBQUFBQUFBQUFBSUJPRXJBREFBQUFBQUFBQUFBQUFBQUFvSk1FN0FBQUFBQUFBQUFBQUFBQUFBRG9KQUU3QUFBQUFBQUFBQUFBQUFBQUFEcEp3QTRBQUFBQUFBQUFBQUFBQUFDQVRoS3dBd0FBQUFBQUFBQUFBQUFBQUtDVEJPd0FBQUFBQUFBQUFBQUFBQUFBNkNRQk93QUFBQUFBQUFBQUFBQUFBQUE2U2NBT0FBQUFBQUFBQUFBQUFBQUFnRTRTc0FNQUFBQUFBQUFBQUFBQUFBQ2drd1RzQUFBQUFBQUFBQUFBQUFBQUFPZ2tBVHNBQUFBQUFBQUFBQUFBQUFBQU9rbkFEZ0FBQUFBQUFBQUFBQUFBQUlCT0VyQURBQUFBQUFBQUFBQUFBQUFBb0pNRTdBQUFBQUFBQUFBQUFBQUFBQURvSkFFN0FBQUFBQUFBQUFBQUFBQUFBRHBKd0E0QUFBQUFBQUFBQUFBQUFBQ0FUaEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1RCT3dBQUFBQUFBQUFBQUFBQUFBQTZDUUJPd0FBQUFBQUFBQUFBQUFBQUFBNlNjQU9BQUFBQUFBQUFBQUFBQUFBZ0U0U3NBTUFBQUFBQUFBQUFBQUFBQUNna3dUc0FBQUFBQUFBQUFBQUFBQUFBT2drQVRzQUFBQUFBQUFBQUFBQUFBQUFPa25BRGdBQUFBQUFBQUFBQUFBQUFJQk9FckFEQUFBQUFBQUFBQUFBQUFBQW9KTUU3QUFBQUFBQUFBQUFBQUFBQUFEb0pBRTdBQUFBQUFBQUFBQUFBQUFBQURwSndBNEFBQUFBQUFBQUFBQUFBQUNBVGhLd0F3QUFBQUFBQUFBQUFBQUFBS0NUQk93QUFBQUFBQUFBQUFBQUFBQUE2Q1FCT3dBQUFBQUFBQUFBQUFBQUFBQTZTY0FPQUFBQUFBQUFBQUFBQUFBQWdFNFNzQU1BQUFBQUFBQUFBQUFBQUFDZ2t3VHNBQUFBQUFBQUFBQUFBQUFBQU9na0FUc0FBQUFBQUFBQUFBQUFBQUFBT2tuQURnQUFBQUFBQUFBQUFBQUFBSUJPRXJBREFBQUFBQUFBQUFBQUFBQUFvSk1FN0FBQUFBQUFBQUFBQUFBQUFBRG9KQUU3QUFBQUFBQUFBQUFBQUFBQUFEcEp3QTRBQUFBQUFBQUFBQUFBQUFDQVRoS3dBd0FBQUFBQUFBQUFBQUFBQUtDVEJPd0FBQUFBQUFBQUFBQUFBQUFBNkNRQk93QUFBQUFBQUFBQUFBQUFBQUE2U2NBT0FBQUFBQUFBQUFBQUFBQUFnRTRTc0FNQUFBQUFBQUFBQUFBQUFBQ2drd1RzQUFBQUFBQUFBQUFBQUFBQUFPZ2tBVHNBQUFBQUFBQUFBQUFBQUFBQU9rbkFEZ0FBQUFBQUFBQUFBQUFBQUlCT0VyQURBQUFBQUFBQUFBQUFBQUFBb0pNRTdBQUFBQUFBQUFBQUFBQUFBQURvSkFFN0FBQUFBQUFBQUFBQUFBQUFBRHBKd0E0QUFBQUFBQUFBQUFBQUFBQ0FUaEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1RCT3dBQUFBQUFBQUFBQUFBQUFBQTZDUUJPd0FBQUFBQUFBQUFBQUFBQUFBNlNjQU9BQUFBQUFBQUFBQUFBQUFBZ0U0U3NBTUFBQUFBQUFBQUFBQUFBQUNna3dUc0FBQUFBQUFBQUFBQUFBQUFBT2drQVRzQUFBQUFBQUFBQUFBQUFBQUFPa25BRGdBQUFBQUFBQUFBQUFBQUFJQk9FckFEQUFBQUFBQUFBQUFBQUFBQW9KTUU3QUFBQUFBQUFBQUFBQUFBQUFEb0pBRTdBQUFBQUFBQUFBQUFBQUFBQURwSndBNEFBQUFBQUFBQUFBQUFBQUNBVGhLd0F3QUFBQUFBQUFBQUFBQUFBS0NUQk93QUFBQUFBQUFBQUFBQUFBQUE2Q1FCT3dBQUFBQUFBQUFBQUFBQUFBQTZTY0FPQUFBQUFBQUFBQUFBQUFBQWdFNFNzQU1BQUFBQUFBQUFBQUFBQUFDZ2t3VHNBQUFBQUFBQUFBQUFBQUFBQU9na0FUc0FBQUFBQUFBQUFBQUFBQUFBT2tuQURnQUFBQUFBQUFBQUFBQUFBSUJPRXJBREFBQUFBQUFBQUFBQUFBQUFvSk1FN0FBQUFBQUFBQUFBQUFBQUFBRG9KQUU3QUFBQUFBQUFBQUFBQUFBQUFEcEp3QTRBQUFBQUFBQUFBQUFBQUFDQVRoS3dBd0FBQUFBQUFBQUFBQUFBQUtDVEJPd0FBQUFBQUFBQUFBQUFBQUFBNkNRQk93QUFBQUFBQUFBQUFBQUFBQUE2U2NBT0FBQUFBQUFBQUFBQUFBQUFnRTRTc0FNQUFBQUFBQUFBQUFBQUFBQ2drd1RzQUFBQUFBQUFBQUFBQUFBQUFPZ2tBVHNBQUFBQUFBQUFBQUFBQUFBQU9rbkFEZ0FBQUFBQUFBQUFBQUFBQUlCT0VyQURBQUFBQUFBQUFBQUFBQUFBb0pNRTdBQUFBQUFBQUFBQUFBQUFBQURvSkFFN0FBQUFBQUFBQUFBQUFBQUFBRHBKd0E0QUFBQUFBQUFBQUFBQUFBQ0FUaEt3QXdBQUFBQUFBQUFBQUFBQUFLQ1RCT3dBQUFBQUFBQUFBQUFBQUFBQTZDUUJPd0FBQUFBQUFBQUFBQUFBQUFBNlNjQU9BQUFBQUFBQUFBQUFBQUFBZ0U0U3NBTUFBQUFBQUFBQUFBQUFBQUNna3dUc0FBQUFBQUFBQUFBQUFBQUFBT2drQVRzQUFBQUFBQUFBQUFBQUFBQUFPa25BRGdBQUFDWllYaHJzaVJjZTdWKy8xWnVKS0hjODlna3BmbElkOXp6K3Q5S2VGTkg4blRMaWZuVzgrd05mL243MUNmLzd6YzFpcmZudzV5L3ZGQ2NYSG14QStRQUFBTEFwSGw4dkQ2VzBKOHEwL3dmK1NyMkd2aE5sOGZoNjF4b1lBQUFBQUFER25vQWRBQUFBakxsOHViODdYdHh4SU1yZXZraGxkVW4vVnQxZGgrUm0wdmI2TTNyZit1ejBWRjg3TmVHN3RPY2ZmY0kzZWd2TmgxM1QwVnNkUkZuR3ZhcWVlOVVuUGFodS9FLzE4Y3VJUjdlZGZBZ0FBTUJteWg5YzJCKzVYc3ZtMmVybVAxZHIxd1BWbW5SLyt0WUdNOTlkTDMvMUJ6L3l4ZFBmL1ozaEd2Z3JaY1RkNm5nL3luUzd1dmwvelRyNFlkd3Izanh6NzFuK0xRQUFBQUFBd09ZVHNBTUFBSUF4a2Z2OUhiRjNlamJLY3VhYnpuTnBKdTJhWHU5S2w3NCtqSVNVWWw5MTNEZThjV2o5M2w1ejhtRmVIZHl2YnR5cC9pMy8zWFFBZVBUb2J2SEcyUi9xbEFjQUFBQ1B5VmN1N291cGV0MlpEMVEzZDFkcnk1OTkxWkU5OWRwN0czeTlJM3phWDEyWlhiK25XZ2R2aS9XTmFPcDFjSlFQcWl1ZlZKZjdrWXE3OGRmZTNlS3QrZnV0RlF3QUFBQUFBQWpZQVFBQXdLaHFPdFB0MmprYlpmcjMrc1M4dEhkNnB2bURORG9odW1jMTdCcHdzUHEzSEd6dTZFME5UellzMTZwLzc5MUl4U2Z4cC85M1M2YzdBQUFBYWsyZ3J0ZWJYUS9TVld2a2JiMTliZGYwdEtxMThJSG1XSWZ2bXFWOUwySjcxSnZRM0swV3hHdk5Xdmd2ZVUzZ0RnQUFBQUFBdHBhQUhRQUFBSXlJYndKMThiTklhVGJ0bWo3US9NSDQ1K21lV0lvMHU3N0xmejR4N0hSM3AvcCszS3J1KzZRNE9uK3I3Zm9BQUFEWUdwTVFxSHRTVGRlN1ZIZStxOWJDNjRHN3V1UDdXcjBXamo5OXNXYnpHUUFBQUFBQTJGd0NkZ0FBQU5DaXZQcnU0ZlVPZGQwTTFQMllabmYvVk8vd0gyZlhPOXpGcmVyd1NVUzVWaHc3ZmJ2dCtnQUFBTmdZWFFyVS9aajF0WENxMThLbnZ0bDhSdUFPQUFBQUFBQTJpNEFkQUFBQWJMRzhzamdUa1g0VktRNm55THNGNnA1YzlhMDZXQjBPMXRmeTZ1QitsT1gxS05OSHhmSDVPMjNYQmdBQXdOTnBPcmxQN3p3Y09mMHFiZXZOdEYzUHFQcHU0Rzd4ZW5YOVA0cWpwMisyWFJzQUFBQUFBRXdDQVRzQUFBRFlBczFPL0ZONXJnN1dwWlQydFZ6T1JFZ1JleUtsVTlXVlUzbGxjQytpL0NpS1I5ZUxOODdlYmJzMkFBQUFmbGpUelQzU0w5S3U2Y050MXpLT1VxVDYrM1o0ZmVPWnVGbGRydGg0QmdBQUFBQUFucDJBSFFBQW5mWk40S1VqVXR5eHN6VnNuYncwMkJQYnlrTjI0dDk4S2NXKzZyZ1F2YW1GdkRxNEUyWDVVZncxWFMvZW1yL2ZkbTN3aitUVnhVTlJ4b0cyNnhoNUtkMk84dEdYMzdtLzdEMXdJakdNRnVQYUV5clR2VWlQN24zL254bmJnTW4wblc3dVBMZjFqV2ZpUkgycDFzSjNxK2ZnaitMaG8rdkZtMmZ1dFYwYkFOMVNQYysvMDNZTlc4WjdiYlFvTHc4T1JDb1B0VjNIYUNyVy91RWZQNHg3NXNrQUFNQS9JbUFIQUVDM1RjVytsTkpDMjJWc2xiS01xOVVIYi9yQkpzcjkvbzdZKzArSHFtdS9UTnZqVUhPNkcxdXErbzRmaUpRT3hQYTRsRmNIdDZyUjc0b1RIaGhaWmZwRlNqSFhkaGxqSWZXKzU3NkkzdXJnc2J2S0tOZSt1Wkh1VllmZkQyODlpQ2lhd0VweDdNeGFBSnZEdVBaa21pbmk5NHhyd3ovNzd0Z1c5NnZqTjExNnkzUzdPdnhsL2ZPSEllUy85dTdhWEFBWU5icTViNTNxNldOL2RUZ2YyM3JubTdWd0VmOFJmL3o4ZXJHdzhOMk5LZ0JnZzNtdkRiYk1nUzc5dmoyZDNqLyt2bXo3N3VzdHRUS2lmbzJsbmpQWDNhSC90N2t6eFowb2l3YzJRUUlBZ0c0UnNBTUFBSUFOa0MvM2Q4ZUxPMC9GM3VtVEtjSk8vQ09pK2xrY3JJNEg4OHJnWHBUbHhmampGMWVkWEFpVExVV2EvZGFOZUR6b3ZCNW0rZXBFaWpMaVRuVjhzQjVVaWYrTGVIUTdpdkorOGNiWnV3RXdRcG9PUlpIMmZPdU8yY2ZHdHpxRXZIMTlmUHRXR0cvOXhMQ3Z1dVVKNEFGYktLOE9xclZZZVNadDY4MjJYVXNYTld2aEhBZkx2ZE5MMVhyNGVqeDgxTmV0QXdBQXZxdWFPODk4L1JyTHQxOUtybDlyU1krOWxueTNPdDRmM3ZoaytQbDM0dEdqdTE1UEJnQ0F5U0JnQndBQUFNOGhMdzMyeEF2bG1kZzFmU0pGN0dpN0hyNWZTckd2T2l5VmU2ZlA1NVhCKy9IWHVPd0VjNkRwZUZrZm02QktyYmYrMzNwQXBkNjUrTjc2cnNYRm1tQUtNQzRlQytPbCtLWmIzdlltOFBKbE5iYmRqakxWSjM3OXZna1dmL2JsYlJzUUFCc2xyeTdXbmR3WHZwNW4wYXJtZFlxNnMreTIzbHkxRnI0YXhjT0xUdjRGQUlDbjEzU01qclIvZUdQMjZ6L29UWDN6ZW5MWmhQQis3L1ZrQUFBWVR3SjJBQUFBOEF6eWxZdjdZcXEzRU52amNJb2tXRGNtbXU2Q0tjNVdQN2V6ZVhYeGVwUnh1VGgyK25iYmRRR2paN2h6OGN3d21MTFFCRlBxYnBpcERxYkVmMGVaMW9yajgzZmFyaFBnYWF4dkNKRm1Id3NXNzUydWczZDNxckd0dXBUL0hZK0tXN29jQVU4ckx3L21Jc2VaOU5VSnA0eWNWQWZ0ZWxOejFaaC9NNHJvbThzQ0FNREdhVjVQVGw5MXd4dStudnpZUmtkbHZaSGJuZmp6bDNlS2t3c1AycTRYQUFENExnRTdBQUFBZUFwNWVYQWdjbmttYmVzZGJyc1duaytLZExnNkhNNnJpMnRSRnYzaTJKbTF0bXNDUmx2VERUUFN2bnJzcU0rVHlLdUQrMUhHclVqbGY4WWZ2cmlsQXhRd3JwcE9VNm0rcExuSXZYcDh1MXVOYnpjanl2KzBHUUh3UTNLL3Z5UCtaZWRjTlhhY1NibWVKekVPcWpIL1VPUTRWSTMxdDZKOGRORmFHQUFBTnNmakd4MDF3YnVJWGRQcnJ5dlhIZStLOHIrcU9mbWFMdE1BQURBYUJPd0FBQURnQ2VTVmk3T1JlaWRUamtQcmI0SXhLVkx6NW1adnRnbmFGZWx0dS9nRFQ2cDZOdGdUZFNlUVNIUEREbEMzb2lqL1UvY25ZTnhWNDl2K3B1dHZwTFBWMlBZZ29xekd0L1JmOGJlNFZidzFmNy90K29CMjVjdjkzZkhpem5yK2M2YVpEekdXcXAvZHdXb3RmTkNtTXdBQXNMV0c2NmhEa2RPaCtoVGVyemR5SytPVGVQUm96V3ZMQUFEUURnRTdBQUFBK0FmeXl1Sk1wRGlmVW0rMjdWcllYRTNRTHNlbmVYVndNeDQ5UEdmSFVPQnBOU2NwNTNUd1c5MmZQb3EveGxWaEZHQ2NWV1BiN3FnNy8rWTRITnViN3AwM0k0ci9LSTcrK25yYnRRRmJxK2xZOTlMT3M3RnIrdVQ2Mk1BaytHYlRtVUc5MmN5NTR1ajhyYlpyQWdDQUx2bDZJN2Y2OHMxcnkydVJpay9pVC8vdlZuRnk0VUhiTlFJQVFCY0kyQUVBQU1EM3lFdURQZkZDSGF4TGMyM1h3dFpLOWE2aHZhbERlV1Z3TmY0YTV3UmpnR2N4N1A1MFByYkgrYnk2ZUwyNjV5TW5Ld09Ub0prclJUNlVWd2VYb295clVUejh5TVlFTVBtcTMvbURzWGY2VWpQSFlTSlZQOXNEMVllUG02N01mM3YwbHE0WkFBRFFqdUZyeTlYYUs1K0lYZFBSYklaUmxtdVIwbi9GSHo1Zkt4WVd2bXk3UmdBQW1FUUNkZ0FBQVBCMzhzcmlxZGllRnV6STMyMHB4Vnk1UFE1WGo0ZjM0Ni9wb3FBZDhLeFMzZmtwNnZGa2NLLzZlQ1grL1BuN2RoMEd4dDF3ZC9XejBaczZtMWNIdDZPb3hyYy9mbjdkU1Y0d1dack5aN2FYbDRiekdUcWc3c3BjYnV2OXJwcTc5dU96ejk4enJnTUFRTHVhelRCU3FqZkVPRlh1bmY2eW1xdGZqMVQrWjNIMDlNMjJhd01BZ0VraVlBY0FBQUJEZVdWeEpsSmFTdXR2VWtIOXB1V082akZ4cXR3ZWM5WGpvMThjTy8xZTJ6VUI0eXVsMkZkOU9GL3VtbDVvVG9JbzQzSnhmUDVPMjNVQlBLOXF6alFUT1diS3ZkUG5xem5UeGZqc2kvY0ZNbUQ4ZmJQNVRMTDVUTWVzcjRXcmVldmU2Vi9sMWNIYk9qRURBTUJvR003VjU2cHJjOVZjL1g2VWNiTzZYUEU2TXdBQVBEOEJPd0FBQURxdjJaSC9oVGlmVXBwcnV4WkdVOVBOTUtWTGVYWHd5M2owOEVqeHh0bTdiZGNFaksrdlQ0SklkWGgzY0RVZVB1b1hiNTY1MTNaZEFNOXJ2YXRkdWxUdW5UNGphQWZqYTdqNXpLVnFqVHpUZGkyMHF4clg5MWNmUHE3V3dqZmpML0dXenU0QUFEQTYxbCtIaVJQMUphOE03a1dVSDBYeDZMcjNzQUFBNE5rSTJBRUFBTkJwZVhueFJHeFA1NXNBRmZ5SXBqdExiK3AzZVdWd0lUNzd2TytFY2VCNXBSUno1YmJlNGJ5eStINzgrWXQrY1hMaFFkczFBVHl2eDRKMnk0djk0dmpwOTl1dUNmaHgrWEovZDd5NGN5R2xkS3J0V2hndDFiaCtxTndlczlWYStHSnhiUDVDMi9VQUFBQ1BTeW4yVmNlRjZFMHQ1TlhCblNqS0svRzNkTk1tR1FBQThPUUU3QUFBQU9pa3IzZmt6M2JrNSttbEZHZkx2ZE9IOHVyZzdlTG8vSzIyNndIRzIzcEh1M1NxM0RVOVZ6MC9YWTdQdnJnZ3dBdE1naVpvbDlOU1hobWNpVlNjSzQ3KytucmJOUUhmTDYrK2V6aDJUVjlxZm0vaGU2eDNkby96MVRyNFYxR1dSNHBqcDIrM1hSTUFBUEJkMWR6OVFQMTZUR3lQcFdyK2ZpdUsrSS9pK1B6VnR1c0NBSUJSSjJBSEFBQkE1K1NWd2ZtVTB0bTI2MkM4cFlqOTFZZVBxOGZUMWZqejUyL3JPZ1U4ci9XVGx0TkN1WGY2emJ3OE9PZWtCMkJTck8raW5xODFvWXhIRDk4dTNqaDd0KzJhZ0hWTjE3cGRPNWRTNU1OdDE4SjRhTmJDS2YwMnJ5eStGNTk5Y2M3R0VBQUFNTHFxK2Z2QnlIRXdyd3dXb2l3dnhoKy91R29PRHdBQTMwL0FEZ0FBZ003SVM0TTlzVDF1cEJTNjFyRmhxc2ZUWExtcjZXYjN1bTUyd0VaWTcvZ1VIMWJqeWkvakwzR2tlR3YrZnRzMUFXeUUrcVN1c2pjMW0xY0cvZUxZL0lXMjY0R3V5OHVEQTdGcit0cHc4eEI0S3FudXdMeDNlaVpmdWZoNjhlYVplMjNYQXdBQS9MQm04Nk9VbHFvNS9FSmVXYndTZi83aVBSdEhBZ0RBNHdUc0FBQUE2SVM4T2pnWTIrTmEweDBJTmxqOXVDcUxjbC9iZFFDVHBRbWliSS9mNWVYQjI3clpBWk9pR3R0MlZJZnoxZno4Ri9IbzRSSGQ3S0FkZVhueFJPUjBxZm1kaEdkVVBYNW15bTI5VC9QcTRwSGk2T21iYmRjREFBRDhZODNtYmlrdGxMdW16K1NWeGZmallYSFpoaGtBQUxCT3dBNEFBSUNKbDFjRzUxT0tzMjNYd1lUTG9jTVVzT0dhWUxodWRzQUVha0ladmFsUHE3bjZlL0haNS8xaVllSEx0bXVDTHNqOS9vNTRhWG9wNVRUWGRpMU1odldOak5LTnZMSllqZWRmbkRPZUF3REE2RnZmQUNtZGltMjlVM2xsY0RXS2h4ZHRnZ1FBUU5jSjJBRUFBREN4OHRKZ1QyeVBHeW5GVE51MTBBR2xnQjJ3ZVhTekF5YlJzSnZkMlhMdjlNRjg1ZUpyZGt5SHpaVS91TEEvOWs3ZnFINzM5cmRkQzVNbnBYU3FHczlucXZIOGRlTTVBQUNNajVSaUxucFRjM2wxY0RQS1I1ZUxZMmZXMnE0SkFBRGFJR0FIQUFEQVJNcXJnNE94UGE2dDc2UU9XK0JoSVdBSGJLcHZ1dGt0L2p6KzhNVVIzVUdBU1ZHTmJ3ZktiYjNmNXBYRjE0cGpwMiszWFE5TW9yejY3dUhvVFMxWkk3T1ptdTZrMjNxZlZ2UFZJOFhSMHpmYnJnY0FBSGh5MVh6K1VLVGVvV28rdnhaRnFqZDZ1OU4yVFFBQXNKVUU3QUFBQUpnNGVXVndQcVU0MjNZZGRJc2Qrb0d0a2lJZEx2ZE83OHRMZzllS3QrYUZlNEdKa0NMMmxDbjlKaTh2dmwwY1AvMSsyL1hBcE1qOS9vNTRhZnBTU3ZsRTI3WFFEZXNoem5RanJ5eStGNTk5Y2M2bUVBQUFNRjVTcE5uSThXa3pwLy96Ri8zaTVNS0R0bXNDQUlDdElHQUhBQURBeE1oTGd6MnhQVzZrRkROdDEwSzNsQkVDTHNDV2FycURiSTlQOC9MZ1ZUc0pBNU9pR3R0MlJFNUxlV1h3Yi9IWjUyOExaY0R6eVZjdTdvdTkwemZxTHBGdDEwTDNwSlJPbFh1blo2ckg0ZXMycEFFQWdQSFR6T2wzVFIvT3k0Tnp4Zkg1cTIzWEF3QUFtMDNBRGdBQWdJblFuRGo0UXU4M0tXSmYyN1hRU1FKMndKWnJ1ajNsK0cxZWZmZEljZlRYMTl1dUIyQ2pwQlFueXIzVEIzVHFoR2ZYckpHbnJKRnBWN01wUlBVNHpNdlZlRzVUQ0FBQUdEdjFhOUNSNDhPOE9uZ3ppbmpMdkI0QWdFa21ZQWNBQU1EWXk4dURBN0d0OTNIekpnKzB3NG5mUUN1YWJrK1JyK1dWeGYzRnNkUHZ0RjBQd0VacFFoa3Z4Ry96bFl1djZId0VUeWQvY0dGL1RFMTluSkp3SGUyckg0ZGxpanBrOTRxVGNRRUFZRHpWcjlORWprL3p5dUo3OGVjditzWEpoUWR0MXdRQUFCdE53QTRBQUlDeGxsY3V6a2J1M1VnUnU5dXVoUTRyQmV5QWRxV1VGdkxxNGsvaUQxOGNLUllXdm15N0hvQ04wSVF5NnM1SFFuYnd4Sm9OYUhwVHY3RkdacFRVajhjeXgyL3k2dUQxNHVqOHJiYnJBUUFBbmsxSzZWUzVhL3B3dGZZOFZ4eWZ2OXAyUFFBQXNKRUU3QUFBQUJoYmVYVndNRklUcnR2UmRpMTBYZm43dGlzQVNKRU9sM3VuZCtkKy96VWhPMkJTQ05uQms4c3Jpek9SMDhmQ2RZeWlKbVFYY1NPdkRsNFRzZ01BZ1BGVnplMzNSSTRQcTduOW0xSEVXenBWQXdBd0tRVHNBQUFBR0V0NWVUQ1hjbnpZZGgzUTBNRU9HQkVwNG1DNWQvcEdkZlhWdG1zQjJDaENkdkRqMWplZ1NUYWdZYVFOSDU4ZjUrWEJFZDB1QUFCZ3ZGWHorNW5JOFdsZUdad3JqczFmYUxzZUFBQjRYZ0oyQUFBQWpKMjhzbmdxNVhTcDdUcmdhMW5BRGhnZGRjZ3Vyd3crTEk3TkgybTdGb0NOSW1RSFA2d0oxMFVJMXpFMjZnMlQ4dkxpanVMNDZmZmJyZ1VBQUhnK0tjWDVhbDM2cy9qVDU2OFhKeGNldEYwUEFBQThLd0U3QUFBQXhrcGVXWHducGJUUWRoM3dHQjNzZ0JHVFVzemxsVUVJMlFHVFJNZ092a3QzZDhaVnlta3ByeXp1S1k2ZGZxZnRXZ0FBZ09kVGIvcFc3cHIrWFRYSGY2MmE0OTl1dXg0QUFIZ1dBbllBQUFDTWpib2JUMHBwcnUwNjREc2VGZ0oyd01nUnNnTW0wZGNodTh2OWwrMktUdGNKMXpIdTZnMlU4c3JpUHhmSFRyL2RkaTBBQU1EelNSRjdxa24rYi9QSzRGeHhiUDVDMi9VQUFNRFRFckFEQUFCZ0xLeUg2Mkt1N1RyZysraWdBb3lxWWNqdXkrTFkvRnR0MXdLd1VacVEzYTdwYTlYVlY5dXVCZHFTbHhkUDFCM0EycTREbmxkSzZWUTFYOTF0VXdnQUFKZ01LY1g1dkRyNDkvalQ1MGRzamdRQXdEZ1JzQU1BQUdEazVaWEZTenJYTWFyS0NOM3JnSkdXVXB6SXk0UC9MbzdQWDIyN0ZvQ05raUlPVnV1RWQ0cGpwOTlwdXhiWWFubDFjRkM0amtteXZpbkU0dStONlFBQU1CbFN4S0h5eGVrRDFUei85V3FlZjd2dGVnQUE0RWtJMkFFQUFERFM4c3JpcVhvMzg3YnJnSDlBd0E0WWZUbVc4Z2NYYmhkdm5MM2JkaWtBRzZWYUp5emsxY0h0NHVqOHJiWnJnYTJTbHdjSHF1ZjFHMjNYQVJ1dEdkT1hGKzhYeDArLzMzWXRBQURBODBzcDlwV1JmcE5YRnM4VngwNi8xM1k5QUFEd1l3VHNBQUFBR0ZsNTlkM0RLZVZMYmRjQlAwTEFEaGg1S1dKSDJadTZrZnY5bDR1RmhTL2JyZ2RnQTEzTFZ5NitYTHg1NWw3YmhjQm1xeDdyKzJKYjd6ZjE4M3JidGNCbXFEc3o1dFhGKzhYUjB6ZmJyZ1VBQUhoK3pmbzFwVXQ1ZGZDeitOUG5SNHFUQ3cvYXJna0FBSDZJZ0IwQUFBQWpLYTljbkkzVSs3RHRPdUJIbFFKMndIaElFZnZMbDZhWHFxdEgycTRGWUtOVVk5dnVjbHZ2V3U3M1h4RWdacExseS8zZDhlSjBIYTdiM1hZdHNMblN0Ynl5K0VweDdQVHR0aXNCQUFBMlJyV1dQVlR1bXQ1WHJXMWZFYklEQUdCVUNkZ0JBQUF3Y3ZJSEYvWkhiK3FHWGZrWkQrWHYyNjRBNEVtbEZITjVlZkJKY1h6K2F0dTFBR3lVYXQwd0kwRE1KTXY5L283WU8vMXg5VmpmMTNZdHNObWF6c3NwZlp3L3VQRFQ0bzJ6ZDl1dUJ3QUEyQmpWWFA5QStlTDBwL25LeFZlS044L2NhN3NlQUFENGV3SjJBQUFBakpTOE5OZ1RMMHg5YkZkK3hvWU9kc0M0eWJHVVA3aHcyd25Md0NScEFzUXJpMWQwUEdJaTdaMnVONkNaYWJzTTJDcE5kOUk4OWJFVGJ3RUFZTEtrRlB2S3FkNXZ6UFVCQUJoRkFuWUFBQUNNakh5NXZ6dDIyWldmTVpNRjdJRHgwblFGNlUxZHE2NiszSFl0QUJzcXBicUxuYkdOaVpKWEJrc3B4Y0cyNjRDdDFweDR1NjEzSTEvdXYxS2NYSGpRZGowQUFNREdHTTcxZjV1WEI2OFd4K2Z2dEYwUEFBQjhSY0FPQUFDQWtaRDcvUjJ4ZC9wYWlqalFkaTN3VkhTd0E4WlEvWHlibHhkUEZNZFB2OTkyTFFBYnBSbmJWaFpQRmNkT3Y5ZDJMYkFSOHNyZ2JFcHhvdTA2b0MzMXVGN3UybmtqOS91dkZnc0xYN1pkRHdBQXNER3F1ZjZlTXNkdjh2TGdGU0U3QUFCR2hZQWRBQUFBbytHbDZhVVVkdVZuREQwc0JPeUE4WlRUUXI3Y3Y2NGpDREJSVWpxVGx3YlhpN2ZtemRFWWEzbDVNSmR5bkcrN0RtaGJpalJiN3AydXV5Ky8xbll0QUFEQXhra1J1NXVRM2VyZzllTG8vSzIyNndFQUFBRTdBQUFBV2xkM21VZ3B6YlZkQnp5TDRzMHo5OXF1QWVCWk5Mc0V2N2h6b2JyNmR0dTFBR3lVWm14N0llcXg3YTIyYTRGbmxaY0hCeUxIVXR0MXdLaW94dlpEZVdYeG5lTFk2WGZhcmdVQUFOZzRUY2d1NGtaZUFRMWttZ0FBSUFCSlJFRlVIYndtWkFjQVFOc0U3QUFBQUdoVi91REMvdWhOMlpXZnNWUkc2SXdDakxlVVRsVFB4VmVLTjg3ZWJic1VnSTJTVXB6SXk0TXJ4Zkg1TzIzWEFrOHI5L3M3WXUvMHRSU3hvKzFhWUpTa2xCYnl5dUt0NHRqcDIyM1hBZ0FBYkp4Ni9ic2VzbnYzU0hIMDE5ZmJyZ2NBZ080U3NBTUFBS0Exd3hNSGJ6aHhrREVtWUFlTXRlYmtoZldnKzJ0dDF3S3dvWEo4V0IxZmJyc01lR292VFM5Vno4LzcyeTREUmxPNmxpLzNYeTVPTGp4b3V4SUFBR0Rqckw5WG5LL2w1Y0dPNHZqODFiYnJBUUNnbXdUc0FBQUFhTTlMTzg4N2NaQXhKMkFIakwzcXVmaFFYbDA4VkJ3OWZiUHRXZ0EyU2pXMkhUQzJNVzd5NnJ1SFU4cHpiZGNCb3lxbDJGZnVtcTREMURhSEFBQ0FTWlJqS2E5Y3ZGY2NPN1BXZGlrQUFIU1BnQjBBQUFDdHlLdURneW1sVTIzWEFjK2xGTEFESmtWYXFBNUNLTUNFU2I4S1l4dGpJbCs1dUMrMjlaYmFyZ05HWGJNNXhQSmdUbGNMQUFDWVBIVW51ekwxYnVRUEx2eTBlT1BzM2JickFRQ2dXd1RzQUFBQTJISjVhYkFudHNlSGJkY0J6Ni84ZmRzVkFHd0VuWjZBU1RRTVlSd29qcy9mYWJzVytGSGJldGVxeCt6dXRzdUFzVkIzdGZqZ3dtMG4zQUlBd09TcDE4Wmxudm80WCs2L1hKeGNlTkIyUFFBQWRJZUFIUUFBQUZ0dmV5eWxpRDF0bDhIanlvZzcxZkdKM3FoS2tXWTN1Wnp4b0lNZFBMRnFqTGtmNWFQWG4rMXY1d1B4N1JQT1UvcjM2aXZ1YUs0YWp6YlN5ZERwQ1o1SVdUNTZwVGgyWnUxNXZrWWQvSXIwNkZ0aG10N01jR3o3NTJwd3E4YTl0S09hTTg4OFg2VkVMczlVeDJkOC9vR3RrVmNXMzBrcCtYMkhKOVIwdGVoTjNjajkvc3ZGd3NLWGJkY0RBQUJzckpSaVg3bHJaejNuZjlXY0h3Q0FyU0pnQndBQXdKYkt5NHNuVWs2SDJxNmppNzRPMEpYeFNYWHpRVVJ4Sng3R3ZlTE5NL2VlOTJ2bkt4ZjN4VlRzcTY3TlJxUi9qVlR1NjBUb0pRdll3Uk1yNDh2bkNLUDg2Ti9MSzRzejFiaTJZeGpHKzlkaE9HV21Qdm4yR2YrZm5WT1Ayem85d2RiNW50KzF0ZS83dk56djc0aVhkc3lzajIvcEo5VThhNy94N1dta1EzVUg3ZUt0ZWZNMlJsSmV1VGliVW0raDdUcGczRlRQZy92TGwzYWVyNjYrM1hZdEFBREF4cXRmcnk3Mzd2d3diSndFQU1BV0ViQURBQUJneStRUEx1eVAzdFNsdHV2b2dySUowTVh0OVRCZHVWWWNPMzE3TS85L3c1QmVmVm43OXYzRG4vbStLTXVaU1BHVGlIUXdmYnNMMWJqVHdRNUd4cmZHdWJWdjM5OEVnTGVsbVNqeno2cHhhTFkrRVhmcnF4c2pxZWxpZDZUdE1vQnZESGZwWG91L0g5K2FZSEdhclg1dmYxYmRuQlc0KzM1Tmw2TVhtaTUyQWhpTW5IeTV2enQyVFY5cnU0NnUrMjQzOS9TZ1dzUCt6M2MrOFZ0ZGxJZDM3SzdHbUFOYlVDSS9JS1YwS3E4dWZsSWNQYTBMTXdBQVRLQVU2WEJlR2Z4UGNXeitRdHUxQUFBdytRVHNBQUFBMkJKTjU0MjkwOWVjK0xzNXlvajZ4T3RiVVphZlJKbldScVg3VVBIRzJidlZoL3B5NjZ2Nzh1cmdZRlhuenlNMVlidnhEcm84TEFUc1lNUjlLd0I4dmI1ZGR6R0s3Y1ZzUlBwRjNkWEk4OUxmU1hHNCtoNmQwK2tKUnQ4d1dGeGZtaE9NOHVyaW9Xb2UrSXZxOS9qUVJHMW9zQkZTT2xHdFI4NE53NG93T25aTmYxajl2dTVwdTR5dUtLTmNxejdjcjY3OGJ6VXUzSTRpN20vRTJybnVBQnk1M0ZkOTNRUERqV1gyVlQvWG1lY3VtQ2VVUHF6bXI3Zk5Yd0VBWURLbEZPZno2cnYzaXFPL3Z0NTJMUUFBVERZQk93QUFBTGJHUzlNTGRuYmZlTTBKZ2tYNktENy8vR1p4Y3VIQmovK045aFZINSt1d1hYMTV1K2x3bDNzSEk2V2ZWNCtQZzIzWDlyU0d3UjFnakF4UHZLM2ZpTDllZDQwcHA2Y1BSWTVmanVNWXRCbUduWjVPVkZmZmFic1c0T2tNdS9mVWx5Tk4yQzdTbThhMmRjM1k5aTg3NTZxcjc3ZGRDM3dsTHkrZVNEa2RhcnVPU1ZiV203MlU1YTFxRVBnay92REZyYzBLMlE1RGV2WGw2eTVxNjkwSmQ4NUdtWDZ1aS9MbXFrUGw1ZmI0c0xyNmF0dTFBQUFBbXlWL21GY1c3dzAzbkFJQWdFMGhZQWNBQU1DbXkxY3U3b3R0dlZOdDF6RXAxazhTakkvaTRhUHI0eDd3K2xhSHUvZWFFeERYZ3k1bnh1SGt3N0x1ZkFDTXRXRXcrV3A5YVo2cnB2TEpTR211ODUyZlVub3o5L3NYZEhxQzhmVlYySzdwcXBUaVpFb3gxM1pOcmN0MTUxSUJPMGJEZXZocWVxSHRPaVpSR2VYMUtOSi94ZC9pVnBzZHpZYnp6SytDeit1dmkvUjZzNUhMbjZkSWg5dXFhMUxWZ2ZJNlhENTgvZ01BQUNaTXMzbFNTamVxdGRWUHgvMjlVUUFBUnBlQUhRQUFBSnR2Vys5Uy9jWkgyMldNdTZaYlhWbjBpMk5uMXRxdVpUTThGblJaV1p4cHVxNk05c25nQW5Zd1FZWnZ5citkKy8xejVVdlRweUxGUWxlZnU2cC85NTV5N3ovVkhYV3V0MTBMOEh5R1haV081Q3NYKzlXY2ZLbmpIZTFtNjFEVHVIUjlac0s5dUxPZVoreHB1NHhKMFd4K1VwWlg0cS9wL2VLdDB5TzVUaHZPTmEvV2w3dzBlRHRlaUpQVnBHdk80MkFqcGZQVlhIN1RPaFVDQUFEdGFsNjMzdGE3VmwzOWFkdTFBQUF3bVFUc0FBQUEyRlI1ZFhBd1JSeHF1NDV4VmtiY2l2TFJ4VWtOMW4yZjR0anAyOVdIMjNscGNDNWVpTG1tODhyb25YZzRraWR1QXM5bmVFTHVoV3I4dVZwdWo2WE9Qb2VWK2VjaFlBY1RZeGpzZUxXZW0xZVR5NldVWWwvTEpXMjVacWZ6WGY5VUJ3eU5iYlNxNlN5WjA0bTI2NWdFelZvNWlvK0tvNzhlcTkvcllXZTljL1Vscjc1N3VIcFUvS3JqQWVnTlVYMFA5NWN2N2F4L3Q5NXJ1eFlBQUo1Zk5kKy9XeDAzNkgyWWRLQ2FMKzdlbUs5Rm02cWY0MHhlR1p3dGpzMWZhTHNXQUFBbWo0QWRBQUFBbSsxODJ3V01xekxpWmhUUkgzWWU2YVRoaVlmMW0yUVgxazg4VEcrbVNMTXRsN1d1RkxDRFNUWWNmMTdMcTR1SHFySG5XdWU2MmFVbVdIaWs3VEtBalZVY25iK1ZML2RmTG5mdHZERXljNnF0SkR6TUtNamQ3Wks3VVNacHJUd01CMTVmRDE0Mmo0MXVidTZ3VVZJNm41Y0cxNGR6ZVFBQXhsa1JGNHZqcDY5dTFwZHY1dURwMGU1SXZSMVJsalBOblNsK0VzUE5IanY1dXNtNFNMR1FQN2h3czNqajdOMjJTd0VBWUxJSTJBRUFBTEJwOHNyaXFaVFNnYmJyR0RkbHhPMG95N2VIWGR3WSt2ckV3enJzVXFaTDdYZGVLWC9mN3Y4ZjJBckYwZE0zcStlelY4cVVQdTdTTHNmMXZ6V3ZYSnp0VXZkVTZJcmk1TUtEM08rL1d1NmR2dEc1amtrcERsWC85cmVHM1VwaHk5VnJtUlJKZ09vWmxWR3VSVm4wSjNGK01nd0x2bGJQdnlMbEJTZnpQcHVtVytrTHNWQmRmYXZ0V2dBQUdHMS90MkhIcmUvN25QekJoZjNSNisydkZpTUhJcVYvcSs3YVgzZE8zcG9LK1NITnZMODM5V0YxOWFkdDF3SUF3R1FSc0FNQUFHQlQ1S1hCbnRpZXpyUmR4emdwSTc2c0R2M2kyUHlGdG1zWlpYWFlwZnBRQjE1T1JVb0xyUVZlZExDRHpxZ0R6L21EQ3o4dDg5VEg3WWQ3dDFLdjd2UzAxbllWd01ZYkJzeGV6U3VERDZ0eGJhN3RlclpLUFc4c1g5cFI3MHEvMW5ZdGRFL3U5M2ZFM3VtRnR1c1lSOVZhK1U1MTdBL1hnaE50R0I1Y0czWlJydGU3TmkxNlN0WHoyb204UExneUNSME9BUUJvMTdCRFduMTViQzNTYkl4UjV2MlI0MmZWREhRMkRidmVzWFdxNy9sTVhobWM5WjRxQUFBYlNjQU9BSUQvejk3OUExZDFuWHZqWDJzZk1BU0Z1WFEvWmw2WXFMdTgxVXVxbDFTUnE1REt1QXF1WWl3OG1Bb3pJMFZReWFxTW9qTmpVNEhIU0pES3BES3BRaXJyVnBkVTRWYVgyK2xPbkJsdXg1MFlMbzdOWHIrOUQzb2R4K1kvMG5tT3p2NThacENQLzhGWDBqbGJlNSs5dnVzQjJCeXZsTG1jc2h0S3o2aTB1Mk4rbVk3VkoyZVV0cDVSUFQzN1lYVis0VXI1NGE3NW5QTzdRdzlRS2RoQmw3U0xLYW9ML1orVUhlbjNuVm5vbkZNN1llZHNkQXhnODlUVE04ZXE1Zjd0bk5PWjZDekRVNzJXRk95SXNHL1hPNTA1aDlnZ1hkNkU1dThieS9UUE5PZGtiZEZ1WjNTbUxhVXFIelFmWDQyT0FRREFlUHAvRzJNMHZ5NjJmMTlkNmg5TXVVeWxuSC9hL08xaDUrOUQwbHdyVlIrZnU3WmVoQVFBZ0plbVlBY0FBTUNHRzl4SXF2STcwVG0yZ3BMYWtsWjl1bjdyVjFlanMyeEY5YW41TzgxZlRsY2ZMWjVQMjNzZjVEUW9nd3lIQ1hiUU9XMEp1anEvOEdyWlBmRkpjN3c1SEoxbnN6V2Y0NEhtK0RwWm41aGJpODRDYko1NmV1WnN0YnowWmM2NUc1TzFjcDZLamtEM3JFOTQ3OFpyYklNMDE4bzMwb092ajNWOW9XUmJMbXdYakpiZXRzdnRoSWJvUEZ0RlRubXFuUUxZaGFtSEFBREVXNStlM1A3NnNQMzdhbm1wUFhjLzNKeVovakxuTkJtWmJaeTFSY2IyV3FsNStKUG9MQUFBakFjRk93QUFBRFplbGQ2M08rUFREUllNZnBsZXIwLytTbEhySmEyWFAxNnZsaGVuVXU1ZGFFc2htLzZIZmwzN3ZrRUh0Y1hlNmtML1dObVIvcjA1MXV5SnpyUHB0bFZ0Y2ZuRDZCakE1cXFuWjkrclZ2cXZkV1M2MXVhZko4SjNQWnp3UHY3bkRSdWtsSFF1Zlg1M29aNmZ2eCtkWlJRTUppa3ZMTHhhOWszTWQydmk2RXNxK1lQbTYzYmQ4d2dBZ0dHcnAyZHZwUFllWUVydlBTemI1Vittbkk1MjR2M2tJV3MzSW1rbmYzZHg4amtBQUJ0UHdRNEFBSUFOMWU0UW5sTWUrNmsrTDZ1VThtRTlQWHM2T3NlNHFhZm5WcXVGaFIrWGZSTVhjazV2YnVxZlphSVRkTlpna3QybC91bFVwY3ZSV1RaZHpqOUxDbmJRRFhVNjFoelgvaFFkWTdPMUc0RzBFN2ZYZDVlSFRkYyszM0tWMzQzT3NSV1VsRzQxRjh2SDFoZWo4aTNySmJGMjR1anZtdk96eTBQWlZHYUxheWVGbEgyNzNrbk9aUUVBQ1BTdHN0M0phdVhYUjVzejFkZHl5a2VqYzQyVm5PYmJ5ZDlkbjRBT0FNRExVN0FEQUFCZ2crWDU2QVNqcktSMFA2WDZXRDM5cTZ2UldjYlYrc0xEWTlWSy83Zk5YOXVGaDNzMytzOW92byttMTBISDFjZG5ybFFyUzcvTUtVOUZaOWxrWFpobUJhVEJjZTFtdGJ6MFljNGRLQUpWZFZ0TVViQmpPS3IwZm5TRXJXQXc0ZjJ2ZDMvZVRndU96akxLMnNXNTFmbUZuNVRkRTc5dkp6VkU1eGw1T2I5ZlhlaGZiVGZJaUk0Q0FBRDFXNE43ZzFlYmM5VFQ2Wlh5VG5PK2VzcFV1NWZYYnFaVWV0dmF6ZkIrRXAwRkFJQ3RUY0VPQUFDQURiTSt2YzVDL01jb0phMmxrbDZ2ai8vS1l0NGhxTithdVY2ZFgvamY1WWNUSDJ6Q05EdUw4NENVSGp3NFdYcmIvdFRld0krT3NsbmFrbkp6TE4xanNUdDB4QmYzRnNydWlhT2JzVUhCU0NuVi8yaysydkNDVGZkd2VsMHk0ZjBwU2lwWDA1L3ZIVnZmTElXbmFNL0xxb1dGVjh2K1haZE52bml5d1VMYlYwcjdOVExGRGdDQWtiRytBY1I3MWZtRkQ4c1BkNzJiY2o0eDl1L0ZiTEoyQTVKcWVlbmRlbnJXdVQ4QUFDOU13UTRBQUlBTmxPZWlFNHlxa3RMMTlNWGROeFFVaG12OTY3MFowK3dVN0lCVXYzM21WclhjWDBoNXpDZlQvSEJuVzU1ZmpZNEJiTDVCYVdQbDE2ZFRxajZKenJLcHN1bWNERW1WVEhoL2lsTFN1WHA2OW14MGpxMW12WXo0UnJXOGRMc1RrMGRmUnM1ejFjTENSUVZPQUFCR3pmbzlyUGVhODlWelpkK3VkcUxkbktMZFMzRHVEd0RBUzFLd0F3QUFZRU9zNzh4L0tEckhLQnFVNi81ODkzVTNkT0lNcHRsZDZQKzQ3QmlVN0Y1K2drUlJzQVBXZlg3M3c3SnY0a1RPYVRJNnl1YXBGT3lnUStxM2ZuVzFXdW0zQzdyR3VZUTJ6cDhiSTZMNmFIRXliKzhkaWM0eHlrcWRqdFhIWjY1RTU5aks2dW5aMDlYeTBuL21uRCtJempLcTJnWEtaZjhQMnRlaXlhVUFBSXlrOWZ1SEg3YmxzUFdpM1h4ekhyc25PdGRXTXpqM2I3OStKbGdEQVBDQ0ZPd0FBQURZR0hibWZ5VGx1dEZSbjV4cFMzRS9yNWFYM24zNXhZZmxQemNrRkxEbHRjZjNhcm5mTHRZOUU1MWw4K1Ivams0QURGbEp2eDNuS1cvdGdxdnEvTUllMDZYWlZOdXFVOUVSUmxWem5keGVINzllSDUrNUhwMWxITlRUc3g5V2wvcDNjcFV1UjJjWlhkVmNVckFEQUdERWZWTzB1OUMvV2w1SjcrZWMzb3pPdE9XWVlnY0F3RXRRc0FNQUFPQ2xWUmY2ZTlPT0RaZ0tObWFVNjBiVFlQSGh5dEphU3ZueUMrOEFhb0lkOEEvSzc1cGp5dmdXN01hNFpBTThSdjMxdGRUYjluNTBqRTIxYThmZTVxT0NIWnZpNFRWeWZpYzZ4K2dxYjlSdnpTclhiYUIyRW1CMXFaK1U3QjZ0bmNwYUxTOU8xZE56cTlGWkFBRGdhZFkzakR6V25NUCtKdVhlaGVaODlrQjBwcTNDRkRzQUFGNkdnaDBBQUFBdjc1VXlsMVBlR1IxamxDalhqYmI2cmRscjFhWCtXc25wMDV6VDVIUC9CcFdDSGZCMzlmVHNqV3E1di9aQ3g1T3R3UUlPNkpqNjdUTzN4dnk0MXB6UDViWmdkeXM2Qm1QcWxmS09hK1JISzNVNlZoK2Z2UmFkWXh3OUxOa3Q3Y3hWdmhDZFpTVGxYanRWY2pVNkJnQUFQS3YxRFNMK2Q3WGNQNU55bXM4cHVjNThGcWJZQVFEd2doVHNBQUFBZUNuVndzTE90SC9pemVnY28wUzVibXVvajgvY3JNNHYvTGpzM3ZWcFRubnF1ZjVuRSt5QTc3dmEvQnJMS1hidHRNOTJFcy82enNsQWQ0enRjVzBnOXl4S1kxT3NYeU9maU00eGloNlc2MmF1Uk9jWVovWHgyWXZWOHRMZW5QTjhkSlpSMDV6VEhxa3U5USsyN3dWRVp3RUFnT2RSVDgrY3F5NzByNVFkNmRQbXZQWlFkSjVSWjRvZEFBQXZTc0VPQUFDQWw3TnYxenZ0d3Z2b0dLT2l0Rk13L25yM0RlVzZyYUUrTlgrbldsajRlZGszOFVITzZaMW4vaCsvcnBWTWdPOTQ4SWVVZXVOYlJObWUya2xQam4zUUtXTitYS3NIeHpYWWVBK3ZrVDIvdnFPVWRGYTViampxNmRuM3F1V2xwR1QzQ0xuOHN2bW9ZQWNBd0piVGJuNVdMU3k4V3ZidGVyODUxMzgzT3MvSU04VU9BSUFYb0dBSEFBREFTOHFub2hPTWlwTFNuZlRWZzUrM3BhM29MRHk3OVp0cko2dmxwZi9JT1gvd1RQL1BpYm0xelUwRmJEWDE5TnhxdGRLL1BiWUw2dk1EWlhyb21QWGoycDN4M1V5am1HREhKbkdOL0YybHBIUHR4SVhvSEYyeVhyTDdKd3R2dnlQbmQ2b0wvVVdUbVFFQTJJclc3MmVkcmxaKy9jZVVxZ3ZqKzU3Tnl6UEZEZ0NBRjZGZ0J3QUF3QXVyVnBhTzVKd25vM09NZ3BMUy9WUWV2SzU0dFhYVjA3TWZWaXY5VzgzRFQ1NTBVN0tZNEFROFZsbE5LUitOVHJFcGNrOFJCVHFwWEIvZjQ5cVlGcUlKNVJyNSswcHpmdFJjYTUyTnp0RkpuOTg3Vy9aUEhHcXVidzlGUnhrVnpkZGlaM2tsdmRrOFZQZ0VBR0RMcXQvNjFkWHE0M00zUzIvYnA4MDU3b0hvUENQTEZEc0FBSjZUZ2gwQUFBQXZJYzlGSnhnWmRUcFpINTlialk3Qnk2bmZtcmxlWGVxL1dxcjAyUk5LZGdwMndLT1Y1dmlRbzBOc2tsb1JCVHFwNUxXeFBhNmx2Q002QWVNb3owY25HQ1dscExYMHhiM1hvM04wVmJ1SXRMclFmNzNzU0g4YTJ5bkxMeUtuVTlYQ3dvY1cyUUlBc0pYVmI1KzUxWnpYL3JqczMzVTVqK3ZtU0MvSkZEc0FBSjZYZ2gwQUFBQXZwTHJVUDVncnU2QzNTa25uNnVNelY2SnpzREdhNytYTnA1VHNGT3lBeDhqL0ZaMWc4eFFUN0tDYi9qczZ3Q1pTTm1GRFZjdUxVem4zRGtibkdCV0RLZStwdkZHZm1yOFRuYVhMNnBNenQ1dm41aHNwOXo2THpqSXFCb3RzOS8vZ1NQUHdhblFXQUFCNEdldWJScnhSTGZmdjV6eVkxTXgzbVdJSEFNQnpVTEFEQUFEZ3hlVDBpK2dJbzZDa3NscFB6NTZOenNIRytsYko3dmZmMittL0tOZ0JqekhPRSt5eUlncDAwamdmMXdibEg5aElQZGZJM3phWThqNTdJem9HemJkaWVtNjFXbDQ2blhQK0lEckw2TWl2SlFVN0FBREdSRDA5YzZ3NTU3L1RuUE8vRzUxbDFOaGdBd0NBNTZGZ0J3QUF3SXM2R2gwZzJtQkgvcS9xWTlFNTJCeURrdDFIaXo4cDIzcWY1WndtLy81dnluK0doUUpHV3pYT0JkeThJem9CRUdDc2oydGxqS2VPRWlLbkk5RVJSa1VwNllvcDc2T2xucDc5c0ZycC96UW56OU9IOHBGcVlXR25LUllBQUl5TDVwei9kTFc4OU44NTUvbm9MS09uK21WU3NBTUE0QmtvMkFFQUFQRGNxdVdsUXpubnllZ2M0ZXB5dWo0eHR4WWRnODNUZm4rcmp4WmYvWWVTblFsMndPUFV6ZkdoaWc2eGFVeXdneTRxNVU3SzR6ckNMaXRWc0dHcTVjV3BuSHQrVnFiQlJqUzMwdWQzVDBibjRCSCtldmRZMlQxeDZIdFQyanVvK1Jyc05NVUNBSUJ4VTAvUHZsY3RMeVVsdTMvVW5QOGZyaTcwOTlZblo5emZBd0RnaVJUc0FBQUFlQUg1dGVnRTBVb3FxL1h4Mll2Uk9kaDgzeXZaamZVa0YrQ2xmTlVjSDh4NUE4YkoxL1h0dEwwWG5XSnoyRFNCRGRYN1JYU0NrVkVlbkRRVmJEVFZwK2J2VkN2OVk4M0QzMGRuR1EyRDk3WVU3QUFBR0N0S2RvL3hTam5hZlB3d09nWUFBS05Od1E0QUFJQVhjVFE2UUtTUzB2MzBWWDBzT2dmRE15alpuVi80Y2RrOThabkYyTURqdER2ZzlsYjYwVEUyaTJNZmROSHQrN2ZUL29ub0ZKdWpLbmVpSXpCR2Nqb1NIV0VVbEpJdTF0TnpxOUU1ZUx6NnJabnIxY3JTMVp4eXA5L1hlU2dmcVJZV2RpcUVBZ0F3YnRaTGR2K1VjMzQzT3N2SXlQbVhTY0VPQUlDblVMQURBQURndVZUTFM0ZHl6cFBST1VMVjVYUmJ1SXFPd1hBTmR2cy92L0JxZEE2QUdPWEw2QVRBOExXbGc3RXREcGRhd1k0TlVTMHZUdVhjMnh1ZEkxcHB5L2lmM3owZG5ZTm44R1UrWFhha3FaeFNwNSszemVlL3Mrei9RVnVPTmNVT0FJRHg4L205czJYL3JvTTU1YW5vS0tPZ09mOC9XSDE4N2tEOTlwbGIwVmtBQUJoZENuWUFBQUE4cC94YWRJSklKYVdiOWZIWmk5RTVpTkdXN0tJekFLT3JPcit3Sis4ZTAwbFBLWnZzQVl5WDBuTmV4d2JwL1NJNndZZzRaaExZMXRCT1hhNHU5YyttS2wyT3poSnY4QjZYZ2gwQUFHT252VDZyemkrOFhuNDQ4YWVjMDJSMG5wRlFiV3VuMkoyTmpnRUF3T2hTc0FNQUFPQjVIWTBPRUtwT3g2SWpBRENpZHUwWTN5a2dKZDJPamdBTVgzV2h2emZ2aUU2eFNSNDhVTEJqWStSMEpEcEN0SkxLMWZxdDJldlJPWGgyOWZHWks5VksveGM1cGNQUldXTGxJOVhDd2s3bFVBQUF4bEc3YVdUMThibWZsOTYyUDdVVG5LUHpoTXZwemFSZ0J3REFFeWpZQVFBQThNeXE1YVZET2VmSjZCeFJTa3JYNnVNek42TnpBRENpcWp5K0JUdWdtN2FuOFQydTNiK3ZZTWRMcTVZWHAzTHVqZS9yNUJrMDE4bjMwNWY1ZEhRT1hzQlhEMDZXN2IxLzcvSkMyL1p6TC90LzBKWmtUYkVEQUdBczFXK2Z1Vld0TEwzUm5QMStHcDBsV25QK3Y3ZGE2Uit1MzVxeFFRd0FBSStrWUFjQUFNQnp5SzlGSndoVnA0WG9DQUNNc05LYmJPL1NqNldxS0tKQUYxWGpXN0JyZDNHUHpzQTQ2UDBpT2tHNFVpN1dKMmROdXQyQzZoTnphOVh5MHNXVTg3dlJXV0lOM3V0U3NBTUFZR3pWYjgxZXE1Yjc1M0pPWjZLemhDdXB2WTVYc0FNQTRKRVU3QUFBQUhnZVI2TURSQ21wWEsyUHo1cGVCOERqNWZFdG9xUlNLNkpBRjlYTmNhMktEckh4U2tyS1FHeU1uSTVFUjRnMG1GNzN0N3dZbllPWDBIei95bzcwVHBlbjJEVXY1Q1BWd3NMT2VuNytmblFTQUFEWU5KL2ZYU2o3Sm83bW5DYWpvNFRLNldoei9uL1MrVDhBQUkraVlBY0FBTUF6cVM3MUQrYXFtemRkQm9zR3Y4eW5vM01BTU9ySy81Zkdkb1FkMEVuald4eFdzT09sVmN1TFV6bjN4dlUxOG14TXI5dnk2cE16dDdzK3hhNHRGNWI5dXc0M0Q2OUZad0VBZ00zU0ZzcWE2OWhqS2ZVK2k4NFN5ZmsvQUFCUG9tQUhBQURBczhsbHFyT2xBWXNHQVhnVzQxdEVTZW5ydEJZZEFZZ3dwc1hoa2t5bVpnTlVVOEVCUWcwbVFYNXhieUU2Qnh2QUZMdjJDZjNUWklFdEFBQmpycDZlVzYyVysxZHlUbTlHWndubC9COEFnTWRRc0FNQUFPRFo1UHpUNkFoaHZxN1BSMGNBWUN2SVU5RUpOa003eWJVK01iY1duUU1JTUs3RjRWTCtHQjJCTVpCVGQ2K1JXNlVzMXFmbTcwVEg0T1daWXBmYTk3eW1vaU1BQU1CUWZISDNkTms5Y1Rpbk1YM1A1MWs0L3djQTRERVU3QUFBQUhoV1U5RUJJcFNVcmlrVkFQQTAxZkxpVk02OWNWMlVzQllkQUlneXJndU84bzNvQkd4dDFjTEN6clIvNGxCMGppak5kZktkOVBtOWk5RTUyRUFkbjJMWGZONEgyOWQxUFQ5L1B6b0xBQUJzcG5hamxHcmwxNmViSzl0UG9yTkVHWnovbjEvWVk5TVlBQUMrUzhFT0FBQ0FwNm8rUG5jZzk3YnRpYzRSby93bU9nRUFXMEh2WjlFSk50R3Q2QURBOEZYTFM0ZHl6bU5YSEI1TTVUdytjek02QjF2Yy81bzQwTlVpMGtBcFZ4U1J4c3RnaXQzSzByV1U4dEhvTEdIMjdXeExzNnZSTVFBQVlMUFZiLzNxYXJYU24ydUxadEZad3V6ZU5kVjh2QllkQXdDQTBhSmdCd0FBd05QbGJaM2NtYitrZEt0K2E5Yk5GUUNleGZndVJpNWxMVG9DRU9Kd2RJQk5vbHpIeTh0bGFyRG5mVmVWYkNPYWNWVHFqMUx1amU4NTdWTlZVMG5CRGdDQXppZ0x6WFh0cDlFcHdwVDAwNlJnQndEQWR5allBUUFBOEhSNWNKT2hlMHI1S0RvQ0FLTnZmY3JUWkhTT1RWUFNmMFJIQUFMay9Jdm9DSnVpbEJ2UkVSZ0RPWGZ6R2prTk5xSzVZUXJrZUtxbjUxYXJsZjZ0bk5LQjZDd2hjdjYvMFJFQUFHQlkyZzFHbS9QL201MmRZcGZ6VkhRRUFBQkdqNElkQUFBQXoySXFPc0N3bFpUdXB5L3VYWW5PQWNCV2tGK0xUckNwcXJ3V0hRRVlydXFqeGNtOHZUZWVCWXRjL2hnZGdiRXdGUjBnVEoxc1JEUE9TdnBOeXVuOTZCaEJEa1VIQUFDQTRlcnVGTHUyV0ZpZFg5aFRuNXEvRTUwRkFJRFJvV0FIQUFEQUUxVVgrbnZ6ampRWm5XUG9TcnJxcGdvQVQxTXRMT3hNK3lhT1J1ZllWRjg5dUJVZEFSaXliYjN4UGE1OVpZSWRMNmY2K055QjNOdTJKenBIaEpMU25mU1h1MWVqYzdDSi9wYXVsQjFwUHFlME16cktzRFdmODU3cVV2K2dDWTBBQUhSRjU2ZlkvWEJuKzNtdlJzY0FBR0IwS05nQkFBRHdaRHZLb2NFeW82N0o2YmZSRVFEWUF2Wk52SnZ6K0JiUjI0bXU5WW01dGVnY3dKRGw4ck54dkFab3kwR09hYnkwdksyN1U2NUt1VkxQejkrUGpzSG1xVS9PM0s1Vyt0ZWJoMGVpczhSbzN3TkxDbllBQUhSSWQ2ZllwVlJOSlFVN0FBQytSY0VPQUFDQUp5dnBwMk80dHZhSjJqSkIrdlBkMWVnY0FJeTJkb0pONm0yYmo4Nnh1VXg2Z3E2cGxoZW5jdTVOUmVmWUpJNXB2THpjWENOM1ZjbS9pWTdBTU5TL2JYNGFkTE5nbC9QL2JUNWVqSTRCQUFERHNqN0Y3bFpPNlVCMGxxSHI4dlU5QUFDUHBHQUhBQURBaytVOEZSMGh3SFc3OGdQd1ZMMXRsM05LTzZOamJLcVMvaVU2QWpBODFjTEN6clIvNGtKMGprMVRsOTlGUjJBc1RFVUhpRkJTdWwwZm56SFpxd3YrK2ovWHkrNkorMk4vbnZ0b1U5RUJBQUJnNkVyNWJjcDV6RGVTZTVSOHFIMHZ6RDFoQUFEK0h3VTdBQUFBSHF1OXFaRDNUeHlNempGMGRiTHdGb0FucWk0dHZaT3JmQ2c2eCthclY2TVRBRU8wYjllWmNkMnhmRENsK3U2OXE5RTUyTnFxQy8yOWVVZWFqTTRSb3FUcjBSRVlqdnJVL0oxcVplbEdTdDNiY0Nubk5ObSt6dXVUTTdlanN3QUF3TkI4WFY5SjIzdWRLOWkxbTRxVWZUdmI5L2hYbzdNQUFEQWFGT3dBQUFCNHZIMjd1bGV1YTMxbDRTQUFqOWN1dWswNzhnZlJPVGJib0l6eStmMGIwVG1BNGFnK1BuY2c5YmJOUmVmWVBPVmFXeHFKVHNFV3Q2TWNHaXpCNjZKc0FtU25sUFM3NXFrK0ZSMGp4STdVdmhmbWZTRUFBRHFqUGpHM1ZxMzBielJYdXgzWVVPNDdTdFZ1TkxVYUhRTUFnTkdnWUFjQUFNRGpsWFN3YTJzSFMwbzM3RlFPd09PMDAxM1QvbDJmNUpSM1JtZlpmT1ZHUFQ5L1B6b0ZNQ1M5M29WMjUrN29HSnNuL3lZNkFXT2dwTW11WFNPM0JxWDdQOStvblUwWUFBQWdBRWxFUVZSVE9PcVNyK3RyYVh0djdEZVVlS1JTMmdXMm51OEFBSFJMWFg2VHF0eTlnbDFPL3h3ZEFRQ0EwYUZnQndBQXdPUGwvS1BvQ0VQWDd0SU9BSTlRblYvWWsvWlAvTDR6Ty9tVzlDL1JFWURocUZaK2ZUU25haW80eHFZcEtkMnUzNXBSbG1BRDVJNHV2Rk82NzVyQkJJdmwvbHJPYVRJNlM0RHV2UmNHQUFCZjVXdGxSL3BndkRkZmVvU2NKNk1qQUFBd09oVHNBQUFBZUx4Y0psUG50dWQvY0NNNkFRQ2pwN3JRMzV0MkQ4cDFCNk96REUzSjE2SWpBSnV2V3VrZmJqNWVqczZ4cVVxNkVoMkJNZEhOc3BHTmFEcXJOT2VDK2Qzb0ZFTm5nUzBBQUIxVW41eTVYYTMwVjV1SGg2T3pETm1CNkFBQUFJd09CVHNBQUFDZUlFOEdCeGkrTCs3ZmpJNEF3R2lwUGxxY1RLLzBQc3VwTzR2cVMwcDM2dU16ZmliQ21IdFlya3VmanYzdTVQWFh2NG1Pd05pWWpBNFFvdVRWNkFnRXlJTnB4dDByMkhYMWRRNEFBSFg2YmFvNlY3Q2JqQTRBQU1Eb1VMQURBQURnU1RxMWExOUo2Vlo5YXY1T2RBNEFSa2QxcVg4d2JldDltanMzc2FaY2owNEFiSzZ1bE91YWMvd2I5ZHRuYmtYbllHeE1SZ2NZdHVZMWRGL3B2cU8rekRmU2p1Z1FJU2FqQXdBQVFJZ0hEMVpUMVl0T01WVHQrMkx0Qm52MWlibTE2Q3dBQU1SVHNBTUFBT0NScXZNTGUvTHVpVDNST1lhcldEUUl3RGVxNWFWM1U1WG5jMG9kKzNuWXlxWTl3UmpyU3JsdW9DNk9aMnlJZHNGZDN0NGIvOWZNOTdsTzdxajY1TXp0NXVmRjdlWm54ZDdvTE1QVW52dFhGL3A3Mjg4L09nc0FBQXhUV3pKcnJnSHVkTzc5OEcyRFRUYldnbE1BQURBQ0ZPd0FBQUI0dEltSnllZ0lRMWZTSDZNakFCQ3ZXbDZjU3JuM1FjNzVZSFNXQ0tXa3RYcDZ4Z1E3R0ZOZEt0ZTFrN2ZTM1h0WG8zTXdKcloxZEtwVktUZWlJeENxL2Y0ZmlRNHhkSytVeWVhamdoMEFBRjIwbXJwMkRWQ3FBK25oNXcwQVFNY3AyQUVBQVBCb1ZidVlLRWVuR0RZTEJ3RTZySjFNazdhM3hicGV0eFlRZkk5cFR6Q08yZ25WNlllNzVuUE83MFpuR1pwU0x0YW41dTlFeDJCTWxONWs5eTZSRzduWWlLYkwybzJJY3NjVzE3YnlvR0RuUFNJQUFMcW5sSDlKT1hmckdpRG5IMFZIQUFCZ05DallBUUFBOEdnbGRXL3g0T2YzYmtaSEFHRDRxb1dGblduZnJqTnBlMit1Q3hPZG51cnIra3AwQkdCalZaZjZiNmJkRSs4M3g3aTkwVm1HcGJTVGh6Ni9kelk2QjJNa3AzK09qaERpUWUwNnVjdHk2dWIzdjFTVDBSRUFBQ0JFeWF1ZHV6K2MwNEhvQ0FBQWpBWUZPd0FBQUI0amQycnhZRW5wVmowL2Z6ODZCd0REVTYwc0hVa2x2NWIyVHh6SktlMkp6ak1LU2lxcjlZbTV0ZWdjd01hb1BqNTNJUFY2RjNLVnA2S3pERjBwaTg3djJWQzVlMVBlbSt2a08vWGJaMjVGNXlEUVgrL2VTTHNub2xORU1NRUNBSUJPcW8vUDNLeFcrdmM3dGhIZFpIUUFBQUJHZzRJZEFBQUFqNVk3ZHpOaExUb0FBSnV2V2w2Y1NxbjNpK2JuM05HYzhwNk9yWk4vdWpyL0pqb0M4UEllVHVhY21NKzliV2VpczBRb0tkMnNwMmMvak03QnVNbVR3UUVpS05kMVhIMXEvazYxMHIvZHBRbW9BN21ZWUFFQVFKZTFrNndQUlljWUl1Zi9BQUFNS05nQkFBRHdPSlBSQVlhcXBOdlJFUURZZU5XRi90NjBJeDFzanZPdnBaeU81TnpyMXVMZzUxQlN1cC8rY3ZkcWRBN2d4WDFUSXQ0L2NiVGJrem5MUW5RQ3h0SmtkSUNoS3dwMnRFcnpQTWpkT29jdWVUSTZBZ0FBaENucFpzcmRLZGkxMC9yYSt3ajF5Um4zaWdFQU9rN0JEZ0FBZ01lWmpBNHdYT1Uvb3hNQThPSWVUbXZhZVNpVjZrREs2WitiWHdkVHlvZnlqclJ6OEIrWVZQZDBwVnlzNStmdlI4Y0Fuay8xOGJrRHFlcWRhQTUwYllsNE1qcFB0SkxTdGZxdDJXdlJPUmd2MWZtRlBYbjNSTGNLUmc5WlhFaXJjOCtEbkx2Mm5oZ0FBUHlEN3QwemZhVk1wZzVlK3dBQThJOFU3QUFBQUhpa2RyZSs2QXhEVmZKYWRBU0FzWmJUem9lVGxWNVE2VTJtUExqSi9hM2ZNLytmNWwvc2FTZE01UDBUayt0L0RpK2d0SXNIUHI5M05qb0g4R3dlbHVxMkhXbU9lYi9NdlcwSG92T01sRHFaWHNmRzI3bXpteE1oaTQxb1NBL2ZMM0dPRFFBQTNaRUhVNnlqVXd4WjNhMzc0Z0FBUEpLQ0hRQUFBTjlUZmJRNG1iZjNvbU1NVjM2d0ZoMEJZSnpsbFBhbTNQdnNaWDZEUjkvVXo5MjcxNzhaU2xrMHZRNUd6emZUT1ZQVlR1WDg1NVRMZ1p6eVZPNjV2Zk1vcFpRUDYrT3pONk56d05pb2JFUkRlbGkwek4wNzRXN2ZHNnRQeksxRjV3QUFnS0dybTJ2Qktqb0VBQUFNbnp1d0FBQUEwUG82clVWSEFJQUk2OVByTGtibmdDNTVPSUV1Ny8zT1A1MzY1bUhPLzdkNWNSNzRaanJuMy8vRkppZmJ1cHBqMmYzMHQ3d1luWU14dGEzYSsvVC9hQXpWelRrQ1ZKNEhBQURRS1hmdnJxWGRFOUVwaHF2MEpxTWpBQUFRVDhFT0FBQ0E3NnZLenVnSVEzZjd2Z1ZqQUhTVDZYWHczSEx1ZmRaYjZiLzQvLzhzRStoMDZaNVBuVTdXSjJlYzA3Tko2dVlhdVdOVDNsdnRva293dlFJQUFEcWxQalYvcDFycDM4NHBkWE96R1FBQU9rdkJEZ0FBZ08vNzNqU044ZFpPN2xFc0FLQ0xTa2xycHRjQlcxMXpMTHRZSDUrNUVwMER4a2s3RmJKZFZCbWRneEh3VmJxZGRrU0hDTEF0VFRZZjE0SlRBQUJBbExYVXFZSmRCemVmQlFEZ2V4VHNBQUFBb0NUbE9nQzZLWmZUU3ViQVZsWlN1cEUrdjNzNk9nZGpydlFtT3pkVnNpUVRJUmxvcDRPK3pOUldBQUJnS3lwcktlVkQwU21HSm5lcFRBZ0F3T01vMkFFQUFQQjl1ZG9USFFFQTJGd2xsZFg2cmRscjBUa0FYbFE3aVRwOTllQU5SV0hZQk5sR05QeGRPOUV3cDJTaUF3QUFkRVhKOXp1MzBRd0FBSjJuWUFjQUFNRDMxWGxQcXFKRERGRk9kNklqQU1Bd3RZdWswMWYxc2VnY0FDOXFjQndyRDk2b1Q4eXRSV2VoQzhyTzFMbVZoY1VFTy82dW5XaVkwMlIwaktISzJRUUxBQURvam4rS0RnQUFRRHdGT3dBQUFFaEZ3UTZBYnFuTGFhVVVZRXNyNVd3OVBiY2FIWU9PeUVuUkJycW1ya3pzQXdDZ3c5cDdwMTNhYUNidmlVNEFBRUE4QlRzQUFBQyt6K0pCQUJoYkpaWFYrdmpzeGVnY0FDK3FPWTVkcmFkblA0ek9BUUFBQURDbS9qczZBQUFBREp1Q0hRQUFBSTlRZG5aclYwSUE2SWFTMHAzMFpYNGpPZ2ZBaTJxT1l6ZlRuKzhkaTg1QjUveFRkSUNoSzNrdE9nSWpKSmUxNXNOa2JJZ2hzL2tVQUFCMFIwNG0yQUVBb0dBSEFBQUFGZzRDMEJsMU9sMmZuTGtkSFFQZ1JaU1MxdExYRDE2djUrZnZSMmVoYTdLRmR0QTU3ZVpUQUFEUVZibGo3NzBVMS8wQUFDallBUUFBOENqNVI5RUpBSUNOVlZLNlZoK2Z1UktkQStCRnJKZnJYcTFQeksxRlp3RUFBQUFZYXlYZFRqazZCQUFBREplQ0hRQUFBQURBbUNzcDNVcC92WHNzT2dmQWkyaU9ZVGZURjNkZnJVL04zNG5PQWdBQUFBQUFBSXdmQlRzQUFBRElhVzkwQkFEWUxDV2wyK21yQno5WFRBRzJvcExLYXZycnZkY2R3d0FBQUFDR3BleE1SdGdCQU5BeENuWUFBQUF3dUVrRUFPT25wSFEvMWVubjlZbTV0ZWdzQU0rck9ZWmRUMysrOTNvOVAzOC9PZ3NBQUFCQVo5aWNGQUNBRGxLd0F3QUE0QkhLZjlxVkVBREd3dXYxOFptYjBTRUFubGNwNlVvOVBYTXNPZ2M4MU1GcjVKejJSRWRnbE9RdVBoOU1UZ1VBQUFBQTZCQUZPd0FBQU9qbVFqRUF4bHlweThuNitPejE2QndBejZ1VThtRTlQWHM2T2dkMFczR2R6TitWdEtkckhkTlVzb0lkQUFCMGh2Ti9BQUFVN0FBQUFPRGhRakVBR0NPbHBIUDE4ZG1MMFRrQW5sZHovRHBiVDgrZWk4NEIveWpmajA0QUFBQUF3NU4vRkoxZ3FJb0oxZ0FBS05nQkFBQUFBSXlWVXRMRmVucm1iSFFPZ09kUlVycmQvT1ZZYy93eWVaUFJVNXJuWjllbWQ1bjB6cmZsdERNNnd0QlZ0V0l0QUFBQUFFQ0hLTmdCQUFBQUFJeUpVc3BDUFQzN1huUU9nT2RSVXJtYS9ucnZaSDFxM203aE1DcE1ldWRiY2twN296TU1YU20zb3lNQUFBQUFBREE4Q25ZQUFBQjhYOGQyNTg4NVRVWm5BSUNYVmVweXNqNCtlekU2QjhDektpbmRTWFU2M1J5N3JrUm5nU2VxeXAzVXBZdmtWaGNubHZGSTFjTEN6cngvSWpvR0FBQXdUTGx6bTJ5WVlBMEFnSUlkQUFBQWo5REJ4WVBWUjR1VDlZbTV0ZWdjQVBDOFNudnp2MDRuRlZTQXJhU2tzcHErekcvVUoyZE1DR0wwbGZwT3lyM29GRVBWVGl4cmkxWDEvTHhGaGwyM2QyZlhGdFlDQUFDcGE1dVRsditLVGdBQVFEd0ZPd0FBQUw2dmxFNU5zQnZZTnJoUnRCYWNBZ0NlUzNtNHMrN3I5ZkdaNjlGWkFKN0Y0TGhWMGtJOVBYc3VPZ3Z3RkErTFZXdlJNUWkycldzTGE5ZlZSUUVjQUlBdW00d09NRlFsT2Y4SEFFREJEZ0FBZ0Vkb0Z4RjFhM1ArbEVwdk1qb0NBRHlQa3RLZFZNclA2K25aRzlGWkFKNUZjOXk2bVI1OC9VYjk5cGxiMFZuZ3VYVHhHcmxsSXhwYTdmc2xYZHVFcVZWbjB4c0JBT2lrNnFQRnlieTl0ek02eDFCVkNuWUFBQ2pZQVFBQThDanRJcUt1TFI3TWFXOTBCQUI0VmlXbEcrbXJCMi9VSitiV29yTUFQTTE2SWZoOCt2emV1WHArWG1HQnJhZUwxOGd0RzlIUXltVXlkYkZoZC8vK25lZ0lBQUFRb290VHJFdnQvQjhBQUFVN0FBQUF2cTlkck45YjZVZkhHTFlmUlFjQWdHZFJTdmt3Zlg3dnJKSUtNT3ErS2RaOWNlL0QrdFM4aFVxdzFkaUlob0g4LzBVbkdMYjI1NWVmV3dBQWRGYXBEblJ1ajQydlRXOEhBRURCRGdBQWdNZG9GeFBsbFBaRTV4aWEzTUhkR0FIWVVnWkZsWlRlcUtkbnIwZG5BWGlTNW5oMVA1VnlNWDF4YjBGQmdYSFFia0pUcmZUdk45ZklPNk96REptTmFPanEreVczb3dNQUFFQ1luTHQzTFhqN3Ztc0FBQUFVN0FBQUFIaU1rdTZrM0tHQ1hlcmtnakVBdG9pUzBvMzBaWHE5UGpualJqOHdzcjRwMXYwdEw5WW5aeDJ2R0RkcnphOEQwU0dHcXB2RktyNnZnNU1NaTU5aEFBQjBWKzdXdFcvN2ZsWTlQMzgvT2djQUFQRVU3QUFBQUhpMFhOYWFENU94SVlacXNscFkyT2tHQ2dDanBwUjBycDZlT1J1ZEErQkptbVBWbGZUMWc0VjIwbGQwRnRna2E2bHJCYnZTc2MrWDcybmZKMG43SjdyM1BDaDVMVG9DQUFDRUtlbGd5dEVoaHFpWVlBMEF3RU1LZGdBQUFEeGF1NWlvUXpkUG1rOTFaL2xmZzBWak42T3pBRUNydEQrVFNqbFpUOC9laU00QzhEak5zZXBhK3VyQmFjVTZ4bDVKbmJwR2J1V2NKcXZ6QzN2cVUvTjNvck1RNUg5TkhHamZMNG1PTVh6bFA2TVRBQUJBaFBZYU1PK2VtSXpPTVZTRFRXY0JBRURCRGdBQWdNZHFGeE4xYmZWZ21Vb0tkZ0FFS3luZFNYVTVXeCtmdlJpZEJlQlpLTmZSRGVVL09uZU4zTnE5YXlxMVJWbzZxaHpxNVBQZUJBc0FBTHJxNFRWZ3Q1UjhLem9DQUFDalFjRU9BQUNBUjh2bFZ2Y1dVZVgvRTUwQWdHNHJwWHlZdnJpM1lGSU1zRlUwVnd4SHFrdjlOK3ZqTTFlaXM4Q215bWt0T2tLSWtnNG1CYnZ1eWgxOW42UlNzQU1Bb0tOSyttbm5iZytuWklJMUFBQURDbllBQUFBOFdzbHJuYnVCa2djTEJ3Rmc2RW9xcStuQmc1UDEyMmZzbGd0c1BWVzZVSDIwdUdxU0hXT3RicTZScStnUUFicGFzT0tobkE1RlJ3alJ2dDRCQUtDTGNwNktqakIwZzAxbkFRQkF3UTRBQUlESCtWdGVTenVpUXd4WFR1bGdkWDVoajZsQkFBeExLV2t0NVhLNmZtdldaQmhneTJyT28zZVc3YjFQcW9XRlYrdjUrZnZSZVdCVDNMMjdsblpQUktlSU1CVWRnQmpOTVgxbjNqL1J6WTJJdmpMQkRnQ0E3dW5zTllBTk5nQUFXS2RnQndBQXdDUFZKMmR1Vnl2OSsrMWkyZWdzUS9YRG5lMk5vOVhvR0FDTXQ1TFN6ZWJqUWoydFdBZU1oK2E2NFZEWnQrdE04L0M5NkN5d0dkcU5XSnByNU52TmMzMXZkSlpoYWo3ZlBkVkhpNU1tVkhiUXZsM2RXMWk3cm4xUExEb0RBQUFNM2I2ZDNaeGcvWmU3SnRnQkFEQ2dZQWNBQU1DVHJEVy9Ea1NIR0s1ZWUvTm9OVG9GQU9PcHBIUTlsUWVMOWZUY2FuUVdnSTJXYzU2dmxwZXUxOU96TjZLendDWlpTeDByMkEzMGVsUE54eXZCS1JpK1RpNnVmYmdSQmdBQWRGSHZaOUVKaHEyVXRGYlB6OStQemdFQXdHaFFzQU1BQU9BSnlzMlVjcmNLZHJtME40L09SY2NBWUx5VWtxNmtrczdYeDJjczJBWEdYUDZrT3IvdzQzYmFWM1FTMkhobHJYbU9kNjkwVkEydWs2OUV4MkRJY25vdE9rS01Zbm9GQUFCZGRUUTZ3TkRsNVB3ZkFJQnZLTmdCQUFEd2VDWC9XOHJkdXBtU1U1NnF6aS9zc1NBWWdKZFZVcnFkU3JtYXZxN1AxeWZtMXFMekFBeER6bW15L0hEaWcrYmhzZWdzc09GS1htc3VHanNvSDQ1T3dIQzE3NHVrM1JQZEs1TzJTdnBqZEFRQUFCaTJhbmx4S3VmZVpIU09vU3MyMkFBQTRPOFU3QUFBQUhpOG5MbzVaV2RpNGtpeU96OEFMNkNrZEtmNWNDMmxCNytwcCtkV28vTUFSTWc1dlZtdC9Qb1A5VnUvdWhxZEJUWlVTZi9SeFlKZDh5bnZhUmRiT3JmcGtOMC9PTng4MzNkR3h3aVJzd1cyQUFCMFVPK1gwUWxDNUdLRERRQUF2cUZnQndBQXdPUDk5ZTZOdEhzaU9zWHdWZW0xcEdBSHdITW9xVnh0UHY1T21RUzZvWlFIcno2cGFGSmQ2TzlOTzlLZmNrcDdoeGhyeEZRWHFvOFdiNWpneVpqcDVpWTBBNzJmTlI5V28xTXdKS1g2V1JmTHBBUHRlMkVBQU5BaDFjTEN6clIvc1BsbzkzeFZuUDhEQVBBTkJUc0FBQUFlcXo0MWY2ZGE2ZC91NE1MZ3crM05wSHArL241MEVBQkcwMkJTWGJ2SXZFNi9TM2Z2WG10L1prWm5Ba1pIZlhMbWRyWHk2OU1wVlo5RVo0blNUcndxMjZ2THpjTlhvN1BBUnFtUHo5eHNycEh2dE0vdjZDeERsMU83MlBKc2RBeUdKS2ZEMFJFaWxKTFduTmNEQU5BNSszOXdwSXZYdWUxNy9EYUdBZ0RnMnhUc0FBQUFlSnAyNTc1TzdWcVlVOXBaOWs5TU5RK3ZSMmNCWURTVWxOclM5V3J6NEYrYXYxdXRwMmZ0YkFzOFVUdlJzbHBaZWkybmZEUTZTNVRtYzUrcWxwZmVhNDZaNzBWbmdRM1VuZ04wcm56VVhDY2ZxRDVhbkxUNGNQdzF4KzFET2VldWJiVDBVTzd5bEVvQUFMcXIra1YwZ2lDcjBRRUFBQmd0Q25ZQUFBQThXU24vbG5MdVZNRnVvS1QyWnBLQ0hVQ0hsVlRXQzNYMWFqMDl0eHFkQjlpQy9ucnZaTms5TWRYQmlkQi9sL05jdGJ4MFhUR1pzVkhLSDV2bmRlY0tkZ1BicXZhOWdRK2pZN0RaOG12UkNjSzA3NEVCQUVDSFZCZjZlOU9PN20waU0rRDhId0NBNzFDd0F3QUE0TW02dW50M1RrZXJoWVdUOWZ6OC9lZ29BR3l1VXRKYXltVnRVS2JMNVZZcWVVMFJCTmdJOWFuNU85VksvMWp6OFBmUldhSU1wa1BuZkxrNXQvNnhjMnZHUTcyYVVtOCtPa1dNZkNvcDJJMjE1bGk5TSsyZmVETTZSNWl1dmdjR0FFQjN2VkxtY3NvN28yT0V5Tms5QUFBQS9vR0NIUUFBQUUvMjEzdXJhZmRFZElxaEd5d0UzcmZybldUeElNRFlLQ25kYUQ3ZWJ4N2NiSDc5UjhyMXJmVDUvUnNLSDhCbXF0K2F1VjR0OTYva25ONk16aEtsT2JjK1VQWk5YR2dlSG92T0FpK3RPWGNvK3lmdXQ5ZU0wVkdHclRtT1RWWXIvY1B0Y1MwNkM1dGsvNjdEblo2NitsV3RZQWNBUUdjOG5GNlgzNG5PRWVhdmR4WHNBQUQ0QndwMkFBQjBXNjcyUkVlQVViYytkZU5tVHVsZ2RKYWh5L21YU2NFT1lFT1VsTzQzSDIva2xLYzI2UGQ3V0piN3gzL1lMb2o5NytZQTN2enpCdzl2am4rZDF1b1RjMnNiOFdjQ3ZMQXY3cDR1UDV5WWFzc3AwVkdpdEFYRGFtWHBkL1ZiczllaXM4RExhSXY1elhPNU9jL1ltSE9hTGVoRTgwdkJibXpsRTlFSm9qVFhGM2RjTndBQTBDa2RubDdYblAvZmJPK0JSK2NBQUdDMEtOZ0JBTkJ0ZGQ2VHF1Z1FzQVdVc3BweTdsekJyaTBWVnN0TGgrcnBXVHNZQXJ5c2ttNDN4OU5YbzJNQVJCaHNXckc4ZUN5bDNtZlJXV0xsQzlXRi9vMzY1TXp0NkNUd1V0cFNmMDVUMFRHQ0hHNm5ISGdkajUvcW84WEp2TDEzT0RwSG9OWG9BQUFBTUN5ZG4xNVh5dStpSXdBQU1Ib1U3QUFBQUhpNmt2K3RiWnQxMDJEM2RnVTdBQUJlU2owOXQxb3Q5eS9tbkRxN2VLbTVwTmhiZHBSUG1vY0sxMnh0T2YxTDgvSGQ2QmdSbXRmeHp2SkthWTlqNzBWbllZTnQ2M1YyZXQxQVhmNFFIUUVBQUlhbXc5UHIxcG5NRGdEQTl5allBUUFBOEhRUEhxeW1xaGVkSWtaT1I2c0wvYk4yNXdjQTRLVjlmdmQwMlRkeE9PYzBHUjBsU2s1NXFscGVlcmVlbnYwd09ndThzTC9lVzAyN0o2SlR4TW41UkxXd2NLNmVuNzhmSFlXTjBYdy9kNmI5RTI5RzV3ajFvTGJBRmdDQVR1ajY5THFTMHUxNmV0Ym1xZ0FBZkkrQ0hRQUFBRTlWbjVoYnE1YjdhMTFjQ0x5K08vL1I1cUVGd0FBQXZKUzJqRkl0TDczUm5HWCthM1NXVURtL1gzMTg3bnI5OXBsYjBWSGdSZFNuNXU5VUsvMmJ6Zlhpd2Vnc0VRYlRLUGZ0YWhkanVrNGVGODMzcy8yK1JzZUlVa3BhYTkvN2lzNEJBQUJEc1NOZGJ1OS9Sc2NJVTB5dkF3RGcwUlRzQUFEb3Rsd21COHVDZ0dleDJ2eDZNemhEakhZQjhJWCtWVlBzQUFCNFdlME8yZFZ5LzF6TzZVeDBsaWlEVFN4NjJ6NnRGaForYkFJV1cxWkpONW9uY3ljTGRnTTV6eld2NFl0ZXcxdmYrdlM2dWVnY3dTeXdCUUNnRTZwTC9UZHpsUTVINXdpVnkrK2lJd0FBTUpvVTdBQUFBSGcydWY1RFN0V2IwVEVpckUreGF4ZWJuWTdPQWdEQUdQajg3a0xaUDNHa09jODhFQjBsU3Z1NWwzMjczay9Pc2RtcVN2cGo4MFIrSnpwR0ZGUHN4a2pIcDljTjVQS0g2QWdBQUxEWnFndjl2V2xIZWo4NlI2U1MwdjMwNTNzMjJBQUE0SkVVN0FBQTZMajhvK2dFc0dYOCtYK3VsZjBUOTl1eVdYU1VFRG0vVTMyMGVMNCtNYmNXSFFVQWdLMnRuZmhVWGVxL1VhcjByNTA5djA3dEtYWit0MXBlL0YwOVBiY2FuUVdlMjkyNzE4cnVpUXRkZmcyYllyZjFtVjYzN3EvM1ZxTWpBQURBcHR0UlBzZ3BkM3R6alpSV1hjTUNBUEE0Q25ZQUFBQThrOEVpNEpYK2F2UHdjSFNXQ0lNcGR0dDdIelFQWDQvT0FnREExbGNmbjdsWkxTOHRwcHpubzdPRXlyMVBxZ3Y5SDljbloyNUhSNEhuVVorYXY5UGxhK1NXS1haandQUzZWRkpaYlYvUDBUa0FBR0F6TmRldmgzUEtSNk56aEt2VGI2TWpBQUF3dWhUc0FBRG90bHdtQjh1QmdHZlQzblNvT3IxNDhFaDFxWCt3WFF3ZG5RVUFnREh3K2IxelpmL0VhODE1NXNIb0tGRUdCWjBkNlVLeWtRVmJVY2V2a1FkTXNkdXlUSzliVjlLL1JFY0FBSUROVkYzbzcwMDcwdVhvSE5GS1N2ZmJhZlRST1FBQUdGMEtkZ0FBZEZ6ZUdaMEF0cFN2MHZXMEl6cEVzQ3E5MzN6OGVYUU1BQUMydnNHVTZJL1B2VkY2Mi83VVRreU96aE5sZlNPTE4rdmpNMWVpczhCenVYdjNXdGs5Y2FIanI5KzlaZDlFTzRuemJIUVdudE8rWFdlNlByM3VvWG8xT2dFQUFHeVc5WTAxUG5YdTN5clhUSzhHQU9CSkZPd0FBT2kya3ZZYVlBZlByajQ1Yzd0YVdWck5LVTlGWjRuU0hESU9WNWVXM3FtUHoxNk16c0xvYVhjQmJWOG4wVGtBZ0syamZ2dk1yV3E1djlDY2FMNGZuU1ZVbFM1VUg1KzcwWDQ5b3FQQXMyb1g1bFVyL2RYbVljZW4yS1YzcTB2OTM1cjJ2blUwMzYrRHFjcWRuMTVYVXJwZFQ4K3RSdWNBQUlCTnMzL1g1WnpTb2VnWUkrSzMwUUVBQUJodENuWUFBSFJhem1reU9nTnNPU1gvSWVVMEZSMGpWSlUvcUQ1YXZGNmZtRnVManNMb3FGYVdqcVFkZ3dXS1A0bk9BZ0JzTGZYMHpMbHFwZjlhbHhjOHRSUEFTbS9iNVdwaDRkVjJzbDkwSG5obWRmcHRxcnBkc0J1OGZxdlV2bjUvNHZXN1JUVGZyeTVQWHZ4R0tWZWpJd0FBd0dhcGxwZmV6VGtmamM0eENrcEtkOUtmNzEyUHpnRUF3R2hUc0FNQW9MUGFLVU41UjNTS1lTdi9HWjJBTWZDM2RDWHQ2UFowamNIaXdlMjlUNUlpRmV1cTVhWDNjczd6SlpYVjZDd0F3QmIxMVlNM21uUE1mKzl5NGFFdEdKWjlFL1BOdzdQUldlQ1ovZVh1MWJKLzRrS1hYN3V0NXZNLzJMeCszMjBlbm92T3dwTlZ5LzB6T2FlRDBUbEdoQWtXQUFDTXBXcWxmempuL0VGMGpwRlIwbFVid2dBQThEUUtkZ0FBZE5mMnREYzZBbXhGOWNtWjI5WEswbXBPZVNvNlM2UjI4Vys3S0syZE5oS2RoVGpWK1lVOWFmZkU1Wnp6a2Vnc0FNRFcxazVIcmk0dG5VNVZ2aENkSlZMTzZVeTF2UGlIZW5wdU5Ub0xQSXQyZ1Y1empYeXRlZmFhQ3BEVGZQWHh1V3YxMjJkdVJVZmgwYXFQRmlmVDl0NThkSTVSVUZLNlZVL1Azb2pPQVFBQUc2MjYxRCtZcXZSSmRJN1I4c0RtR2dBQVBKV0NIUUFBM1ZVcDJNRUxxL052bXRmUVZIU01jQllQZGxyenZUK1Fkazk4bWxNNjhNMC9MSGt0TGhFQXNOWFZ4MmN2Vml0THYrajZaaFlwOVM1WDV4ZCtYSithdnhPZEJKNU4rWjJDM2ZxMDkxNnZMUW0vR3AyRng5aGVYZTc2dE1WdmxHS0JMUUFBWTJlOVhQZFpjOTYvSnpyTHFDZ3AzYlNSRXdBQXowTEJEZ0NBN2lybFFMczFmc2RZbk1qRytNdmRxMlgveElXdUw4cDZ1SGh3MnlmVndzSlAycWtGMFhrWW5tcGw2VWpxYmJ2c0JpVUFzT0crcW8rVjdiMC9kZms4bzdsVW55eTdkN1VsblRlaXM4QXorZlAvWEd1dWtlOTMvUnE1MVJhRVRYc2ZUZFh5MHJzNWQ3M0EvUzFmMTFlaUl3QUF3RVpTcm51TXVud1VIUUVBZ0sxQndRNEFnQzc3VVhTQW9TdFp3WTROMFpiSnFwV2xhM2JvSDVUc0RwYjlFNTgwRDErUHpzSndWTXY5OTNQT1p4N3pyMjhQTlF3QU1IYnFFM05yMWFYKzZWU2x5OUZaSXVYbVdxUDVPdnloUGo1ekpUb0xQSTFyNUgrVWMzcS9XbDY4WVVMQTZHaStIMU1wOTk2UHpqRXFTa28zMnArMzBUa0FBR0NqVkN2OXc2bEtuOXI0NVIrVjlyN2RYKzVkaWM0QkFNRFdvR0FIQUVCMzVYd2dPZ0pzYmZrM3pRZUxCOU9nWkhla0xWM1Ywek5ubzdPd2VhcnpDM3ZTN2wyZlBubkgvL0xsMEFJQkFHT3JMWlZWSy8xZk5PZVpoNk96aEtyU0I5VkhpNnRLRUd3TjVYY0tkdCtTZTU4MnI5OGZlLzNHcXk3MDk2WWR2VThzdFAyV3V2d21PZ0lBQUd5VVFia3VLZGM5VWtubjIwMXhvbU1BQUxBMUtOZ0JBTkJsQjZNRHdGWld2elZ6dlZycDM4NHA3WTNPTWdweVRtZXFTLzMvTUdGalBBMTIrOTg5OGNsVG4rL0ZCRHNBWUlOOG1ZNlZIZW5mbS9PUFBkRlJvclNmZTluZWE2ZEYveVE2Q3p6Vm4vL25XdGsvNFJwNTNmOTcvVllMQzY5YXpCaW4rZnJ2VFBzblB2VzgvTHVTMHYxMDk5N1Y2QndBQUxBUnFwVmZIMjArWGxhdSs3N0J1Zi9mMHBYb0hBQUFiQjBLZGdBQWRGSTdoU2p2bnVqZXdwTDhZQzA2QW1PbXBDc3BwelBSTVVaR2xTNVV5NHRyOWZUY2FuUVVOc1pnTWVLK2lmbWNlOC80UE04V2pnSUFHNkkrT1hPN1d2bjF5ZWFNNUpQb0xKRnlTb2VxNWFYMzZ1blo5Nkt6d0pPMEpiTG11YnFZY3Y0Z09zdW9hRisvWmQvRWhlYmhzZWdzbmJWdjRvUDIreEFkWThSY3IwL04zNGtPQVFBQUwrUGgvYXRkNytkY3ZSdWRaV1NWY3JFK09XdGpUQUFBbnBtQ0hRQUEzZlREbmFiWHdVYjRXenBmZHFSMzdZcjRVUHQxS0xuM2FmWHh1Wi9VYjUrNUZaMkhsMU10THgxSyt5ZmFYVDhQUFB2L1ZDelNBd0EyVFAzV3I2NVdLMHV2NVpTUFJtY0psZk5jYzI1MnZaNmV2UkVkQlo3b2kzdFh5dTZKOTEwai8xM082YzNtOWZ0dnpldjN3K2dzWFZOZDZyK1pxL1JPZEk3UlUzNFRuUUFBQUY1R2RhRy9kMzFTdGMwMG51VHIrbngwQkFBQXRoWUZPd0FBT3FxYUNnNFFveTUyYUdORFBaeXFzWFF0ZFgzQjc3ZmtsUGFVYXR2dnE0OFdYNjFQeksxRjUrSEZWTXY5OTNQT3p6K2RzZFFLZGdEQXh2b3lueTQ3MGxSem50bTlLZXpyQmh0WnBCbk9jaWdBQUNBQVNVUkJWUHhKdGJEd3Y5c3BZZEY1NEhIYXFWalY4dExGbExNSkF0L1NYRnQ5VUYzcTM2bVB6MXlKenRJVjFVci9jS3JTaGVnY282YWtkTE4rYS9aYWRBNEFBSGhSMWZMaVZOclJhOHQxZTZLempMTG0zUCthKzdRQUFEd3ZCVHNBQUxvcHA1OUdSd2h4NzBzRk96WmVuUmRUbFJUc3ZpWG5ORm0yOS82MXV0VC9lWDE4NW1aMEhwNWQ5Zkc1QTZtMzdYTHpQWHpCWFQ4ckM3NEJnQTMxY0ZPTC9ySG00ZStqczBRYW5HUHZtMmpMSXNlaXM4QVQvUzB2bGgzcEhWUHN2cU5LRjVwajJlMzZyWm5yMFZIRzNhQmNsOUtubm9PUFVKZVBvaU1BQU1DTHFwYVgzc3U1TngrZFk5U1ZsTzZuTDlQSjZCd0FBR3c5Q25ZQUFIUlVQaGlkWU5qYU41TGJuZFNqY3pCKzJnSlp0ZEsva2RPTEZwTEdVenRocEZUcHMrcFMvMVVsdTYyaFd1NmZTYjF0OHkrMUNQSHJXcEVaQU5od2JTR2xPVmU1a25ONk16cExwUGJ6cjFhV2ZtZjZFS05zVUlwZDdsOU5IWCs5ZnRmRFNaVHAwMnFsLzdxUzNlYXBscGNPTlFkTDVicEhhSjUvdDlOZjdsMkp6Z0VBQU0vcjc1dERadmRpbjBVcEYrdVRzKzdYQVFEdzNCVHNBQURvbk9wUy8yQ3UwcDdvSEVOWGtqZVIyVVJsTWFYOGFYU0tVWk5UMmpNbzJTMHYvYnllbnIwUm5ZZEhlL21wZFFBQVEvREYzZE5sOThUaGRpT0g2Q2l4OHVYcVF2OUdXMktLVGdLUFZkSjVCYnZ2KzZaa3Q3ejBxbXZramRlKzU1bXEvSHZsdXNjb1piR2VuemQxSGdDQUxhTmFXTmlaOWszTTU5NjJNOUZadG9yQjlMcS81Y1hvSEFBQWJFMEtkZ0FBZEU4dVJ3Wkxlcm9tbDdYb0NJeXZkb0pFdGRLL2JiSHY5dzFLZGpsL1pwZiswVk9kWDlpVGZyaXJ2VEg1N2tiOW52V0p1YldOK3IwQUFMNnRuVWhlTFMrK2tYTHZzK2dza1FibjF6dktKODNEVjZPendPT3NUM3EvMWp4ZmowUm5HVFdEa2wzT3Z6ZnRmV005TE5lbHo5cGpaSFNXVVZSU3VwTSt2M2N4T2djQUFEeXI1cHJ5Y05vL2NkbTkxK2RVMG9KTm1RQUFlRkVLZGdBQWRFL09QNHVPRU1RYnlXeXVPcDFOVmJvY0hXTVVmYk5MLzZXbDAvWHhXUXU2UmtEenZYZ243WjZZZDJNU0FOaEs2dW01MVdxNWZ6SG45RTUwbGtnNTVhbm02M0NtbnA0NUY1MEZIcXM4T0o5eVQ4SHVFYjZaOXI3U2Y4TkdOQyt2V2w0NnRENjVUcm51Y1VxNVlub2RBQUJiUWZYUjRtVGEzcnZRbk44ZmpzNnkxWlIyUGNUbmR6K016Z0VBd05hbFlBY0FRS2RVRi9wNzg0NTBLRHBIaUtKZ3grYXFqODljcVZiNnAzSktCNk96aktLMlpKZXFmS0ZhV2ZwcCt2TzlZeFoyeGFpV0Y2ZFM3bjJRcTd6aHo5T2l5QXdBRE1QbmQwK1hmUk9IYzA2VDBWRkM1VFJmWGVwZk53R0xVVFVveEs3MGI3cEdmclQxTXRqdnEwdExKMjFFOCtLcWxWOGZUYm02UEhqUGdVZHFydFh2cDcvbHhlZ2NBQUR3SklOaTNiYmVmTjdlZXpNNnk1WlZ5cUw3cndBQXZBd0ZPd0FBdW1WN2wzZDZ5LzhWbllBdUtBdk5jKzNUNkJTakxLZDh0T3lmT0ZoOWZPNzErdTB6dDZMemRFVmJzRTQ3eWdjNTk0NXUyaDlTa3B0MkFNQ21heGNLVmN1THgxTHFmUmFkSmRKZ1NuU1ZQcWtXRm41czhSU2p5elh5MCtSMkk1cmwvby9xNlptejBWbTJtbmFTWjg3Vis5RTVSbDRwRit1VHN6YkVBUUJnSkZXWCtnZFRsZHBpblFub0w2R2tkRE45ZnMvbUxRQUF2QlFGT3dBQXVxVktKNklqaERIQmppR28zNXE5VnEzMHIrZlU1VExyMHpWZm53T2x0KzFmcTVXbFkrM1hMRHJQT0tzV0ZuYW1mYnZPcEIxNUxxZTh1VHY2NTNSblUzOS9BSUIxZzhsWXkvMXpPYWN6MFZraURjNnI5MDE4MER3OEdaMEZIbVg5R3ZsVysxeU56akxLMm1OWmMzMDhhZHI3czJ0K0JseG92bTd2Uk9mWUV1b0hIMFZIQUFDQTc2cVdGNmRTcnVaemxhZWlzNHlGVWs2Nm5nUUE0R1VwMkFFQTBCbnQ3bSs1U29laWM0VEpEOWFpSTlBUmRUcWJLZ1c3cDhrcDdXa25HVlRML1l2cGk3dG42MVB6eWxrYnFEcS9zQ2Y5Y09LZHRIL2lWUE8xM2p1Y1A3WDRIZ0lBdy9QNTNZV3lmK0pJMTRzN2JjR2tXdW4vcm41cjVucDBGbmkwY3RZVXU2ZGJuL1krV1gxODdwaHA3NCszUHAzOWs1d3R3bjBXcGFRcm5rOEFBSXlLd2ZuOEsrVm95dmxFenIxT3Y1K3prVW9wSDliVHN6ZWljd0FBc1BVcDJBRUEwQjA1bllxT0VPcUwremVqSTlBTjlmR1ptOVZLLzFwTzZVaDBscTJnWFJCY2RrOGNxVmFXVHBwbTkvSWUzcHhzanZlN0o5NTVXR0ljcHF4Z0J3QU1UYnNyZDdXOGRLemsvRmx6M3JPNWszcEgzK1htUFBESDlja1prOXNaT1NhOVA3dm1hM1JvTU8zOVV2OTBmWHptU25TZVVWT3QvUHBvMmxGZHlDa1ArVnAzYXlvcDNVOS9TMmVqY3dBQTBHMkREU0VuSm82a3F2d3k3MmczeXNqUmtjWktjOTUvTzMxK3ozay9BQUFiUXNFT0FJQk9lTGk3Y3pvYW5TTktLV25OZEN5RzZxc0hwOHYyM21FTGZaL053d2xyK2ROMjBXWHp0VHRabjVoYmk4NjAxVlFmTFU2bWJiMjU1bGovWnRqenJpVEhXUUJncU5yZHVhdmxwY1dVODN4MGxranQrWFRaa1M0M0QzOGVuUVVlcVU1blM1V21YQ00vM1dDamxDcGRicTZQZjVHK1RNY1VaNytaMFA1Qnp0V2IwVm0ybEpJV1BIOEFBSWhRTFN6c1RQdC9jS1M1d25rdDdaNDQ4dkJhVUxGdWM1U1Q3U1pVMFNrQUFCZ1BDbllBQUhUREsybSswNHVZY2pLOWpxRnFDMkxWOHRMRmxQTzcwVm0ya25haVFkbmUrL2RxdWI5UVQ4K2NpODZ6RlZTWCtnZmJDYVY1ZSsvTjZDeXAzUjBmQUdEWVByOTNydXlmZUswNWx6d1lIU1ZTZXk1ZFhWcDZwejQrZXpFNkMzelhZTks3YStUbk1yZyszcEgrdlZwWk90YmxhZS9WU3Y5dzJqMXgrZUhHUER5cmgxTXM3bjRZblFNQWdPNm9saGVuVXVyOXJMbVltY3I3Snc1RjUrbUM1cnovV3BldkZ3RUEySGdLZGdBQWpMMjJmSkdyOUU1MGpsQ2wvRnQwQkRyb2IzbXg3RWp2ZExyYytnSUdYNitjM3ErVyt5ZWExKzVpK3N1OUszWmUvTDVxNWRkSG00Ky9iSTd2aDZPei9GMzVyK2dFQUVEM3RPZUt6WFh2c1ZLbGYrMzh1WGVWUDZnK1ByZGF2MzNtVm5RVStKNkgxOGhIRmFXZTNXQ2EzY05wNzlkU25SYmFvbUowcG1FWlRHbmZYcjJmVXo0YW5XVnJNc1VDQUlETlZTMHZIV3F1VjZhYUM1ZWZ0aHVFNU55TGp0UXBKYVU3NmN0ME1qb0hBQURqUmNFT0FJRHhWNlgzb3lPRU04R09BUFhKbWR2dEpMYTJMQmFkWlN2S09VMDJIeTZVL1JQejFmTFNZdnJpM3BYNjFQeWQ2RnlSMXFmVm5XaCtIYzJwMmhPZEJ3QmdWRHljanVYY3V5MFlsdDYyVDZxRmhaOG9WakJxSGw0ak45ZDJPWDhRbldXcmFWN2JSMUtWampUSHVTdnA2d2NMOVltNXRlaE1tK1gvWis5K2dxc3EwMzN4UCs4S0NEL1QxblYycUxwU2g5bmxqQTZPR2tlTkkzRWtqRnBHVFFpV010SlVKUUtqbUpHa3M2dUFFVktTU0kra1IrS29jV1FjZGM1STdxaTVNN3JrVnFWbjNHcmhZRXZXKzF0ckp5RGlQNFNFZDJldno2Y3FPenVveVplWXZiTFczdS8zZmFwenZSM3hURDZldG82WWR2aVljc1NTS1JZQUFLeVgxYzB2Um5aSHpudWI2N24vYlA1b2QycmZVaW9kcmVQeVdIMXNhcmwwQ2dBQWhvdUNIUUFBUTYyYTc3MmYwaUJOTnlyazIxckJqakp1M0RxVGQ0NitiWWYreDlmLzNxVjBPai9YTDlxZGphOXZuK2xTMFc1MWNXRWNicjRSN2JTNjNhWHovS3ljcnBlT0FBQjBWejArZWFwYTZMM1duRC91TFoybHBPYnZ2eWUvTURyZDNEMVpPZ3M4ckI2Zk90TThUdi9RL3B5V3pySVpwUlNIODlhUjE1dHI0dy9haVlCdGFiRjBwdlZTbloxNVBuN3o3RHV4TFIxUGtibzlqZlJKMWFaWU1MaFduK2RhV1gxKzYrczdWN3YwSEI4QURLclZ6UjFYbm85VVBSOTU3Vm90eGY5cWJuYzA1K2I3MHRhMXlYUUtkUU1qNTdqWVhGL2JWQU1BZ0hXbllBY0F3TkNxTHN5OWxhcDBvblNPMG5MRXpXSGUyWnZCMWs2TnNFUC8ra2dSenpmZngrbjgzT2p4YW1IdWN2UG8valMrK3UvTHd6aVpvNXFaMlI3L2MvVDFxT0wzYVp1U05BREFJMXU1TzVaSHRuelpUbklySGFXa2xPSkVOVC83V1QxK2ZMRjBGdmlCdkRJUmFlVHowakUycS83eExhVjM4clk0WE0zM0xrVjk5Mno5eG9scnBYTTlydjQwakMwamI4WnpvMi8xci90NUl2MkZ0a2NuYlRSR2Nhc0w5Zk9CNXFEMXUvYmpkbkYrLy8yMjluWnRrZjV6b3pHeTBHdWZ2Ny9UL1BRdTlmOHN4eGVSMDJVL3h3RFFxT0sxYW41dTErUDl4ODF2M1pSL1pnT2l0S09kUXRlL1Y3VzM5MHAwai9mVmVIcWFjNmRyY2VPV1RUVUFBTmdRQ25ZQUFCM1hsaGlHc3B5eDBOdWZxblN1ZEk3QmtMMFlUMUYyNkY5ZnE0dWwwK3Z0Vzk0NWVyT2E3MTF1L3ZEUDlaSEpLNld6UFlscWZuWmZjN3N2VW5vbDdSemRuRk5YcWhpYTZRa0F3T2JVbGt5cUMzTVQ0WHE0T1YwZStiZzZPL01mSnNNd2FOcmlaM09OZkxtNXRqdFFPc3RtdHJvSlRid1ZJMXZlYXI2ZlMxSEgrZmkvdHk1dGh1YzV2OXRVSnY4aGJSM1pWenJQc09pWGxQNWxlaW5sdEs5Sk5EK0lyelYzOTZjcWRqM3FDdjIxNS9yMnJYMndyM21iYmo3WGN2TzVya1NxUHh2V0RiWUE0SmYwcjVsU2VvTHJKbTI1WWRNLzUxKzVlOUM1RVFBQUcwWEJEZ0NnNi83bjZPdlZRdTk0MURHN1dSYWgvSkwrN3JCVmZGSTZ4OERJb1dCSGVUa2Z5eWw5M3ZWSkd1dHRiVUhoNGVidTRmc0xiL283WGQ5ZEd2UWQvS3Y1dWIzOXhVTXBmcGZhaFVkcHBIU2tKNWRYTnYzdlVBQmc4NnVQVG4xUUxjejkvdDZrbEs1cXpqRjM1T2RHUDJydUhpeWRCWDdnMjVXSnZIVmt2MnZrOWRGOEgvZEdGWHZ6enRIVC9hbDJzZkxuUVp4Z3VicXh6TWp2WStmbzY2dlQ2aXo0WFZjNVp1cGpremErNGFtckx2UU90Nlc0bEdMWGVqMnMyL09ZMWVmOHFzTnJHMnpOeG8xYlo0Ymg5UnNBZ01kV3g3RkJmLzBUQUlETlRjRU9BS0RyMHNyMUZDTzdvNHFQN2k5Q3FlK2UzYXhQVEZZZm50b2RJMXYrWW9IU0ExSjhVVG9DMU9OVFM5WDgzR3lrTkYwNnk3QzZ2L0Ntdi9obVM3dHJkanVwWXpGeS9GZkV5bEtweFlYOW5mbGYyTDQzOHNpdVNMbGRhUFM3SnUzZWxOTHdIYWZ6aU9rb0FNQmcrTFlleTF0SC90YjFhK04ydC90MjBYdDlkUEppNlN6d29Qck40OWVyK2Q2WjVvZjBST2tzdytUK1ZMc1lhYWZhdFNXVTVwbzRmeGIxeXBVU3ozWDJOd0ZMdVQrcHZmbHdYMG9qblQ0bWI2UWNlYkVlbnpwVk9nZmRVaTNNSFdpT1BOT3BpajBiK1hYV2ptM3Y1NTJqYi9lZlg3MXgrd05GT3dDZ2EzTEVaYy92QUFDdzBSVHNBQUM2cnM3THNUWTA2UDRpbEpFdDdTS1VwYWpqL0dhYWFsZk45MDQwMmFlN3ZvRHdRVG5pVG54MSswcnBITkNxeDZmZWE0NHRyL1IzbG1mRHJlNkdId2VhT3dlaU9kQ1BMUFRhWThKeWMyUzRGamxkYjk3L1BWSjd2L2s5OFBXZHEvWGIwNDlkRHF2TzlYYkVNeXU3Vno4YWFmNy81bjlydnU2ZUpzV2V0SFAwK1h1QmhuNTMvcFVWQlRzQVlDRDB5enNYZXNmYXpYUktaeW11aW5QVitkbkY5bnRTT2dwOHo0MWJNM25uNkQ3WHlCdGo3Zm5CL1pIUy9oalpjcm8vOVQzaWFuTU4vRityMThMcGVyc1owSHA5dmY1MHV2c2J5NlRmTm4rMEoxV3hZK2l2Z3dkQWpyalpGc3RMNTZBNyt1WFpLcDkrMnRPQ1Z6ZlhTcWZ6QzZOdlZ3dHpFL1dScWN0UDgrc0RBSlNTMjJ1NXIyNGRLcDBEQUlEaHAyQUhBTkIxdDc5Wmp1ZCtlRnJZWDl4VHhkNzdVKzF5bksrUFRsNHRrUEFYVmZOemU5c1hsbE95SU9tSDh0Sm1LVWpTRWQrdUhNcGJSNzVjSzMveGxQVVg0a1RhOFYzWkxhMitlMjYwWDhCN1VJNjQxdHd1LzhobjJmUHcvNyswcmIwZCtmNVg2cUo2eFBFV0FCZ1k3YTdlMVVMdjk2a3RtSFJZVzdKcHJrRStybVptWG5aOXpDQnBmeDZyRDArTjVaRXRYOW9zYXVPdFhnK3ZGZTdXcm9YN0c5SGt1QjRwWCsvL1N6bStlTVRQdHEzNWIxYWZoOHhwVjByUnZJMTBZMk9aUVZUSGhCSTFUMHR6YnJVL3F2ZzRSU3IyM0daN3pHbHVQNm5tNTg3VTQxTVRwWElBQUR3Ti9XdTJ1eXNIUGFjREFNRFRvR0FIQU5CeDdjU2lhcUYzNTZjVzh0eWZhdGU4OVhkNnpuRzV1ZjlwZldTeStGUzBhbVptZTd3d09wMVNPbEU2eThESzhXbnBDUENndFVrYUV5WnBETDdtK0wrN3VkMWRPc2RtVWgrYi9KRkNJZ0JBUWQvRVdONFdmK3Y2QmhmdEprTDVoV2ZiNXc3ZUs1MEZIbFMvY2VLYWFaTmxyUlZWZHExK0VQdCt4WC81dlhlVWtTTmZxbzlPWFN5ZGcyNm81dWZlU1NtZExwM2puaWJMTzlYQzNKNzQ1KzJEN2VzOHBmTUFBS3kzSEhHbnVUbG9RdzBBQUo0V0JUc0FBTnBuSnBlanY1ams1L1YzZW03TGR0RXYyOTFjTGR2Vm44VlgvMzM1YWU0WVZwMmYzUlZicWdQeHd1amI2UkZ5ZDFxOVVyd0lDUS9yVDlLWTcvMnVlZndlTHAwRjFrdi9SVDRBZ0FIVGJnQmdnNHRWS2FYcGFuN3VTajArdFZRNkN6eklOVEk4bnVZNmZEbitlZnRZNlJ4MFEzT2NQdGVjUzd4Vk9zZkRVcVI5K1Rlalh6Ym5ld2ViM3lkWFMrY0JBRmhuem5FQUFIaXFGT3dBQUloSStmcjluWm9mOVQ5Wm5XeDNPS0k2bkhlTzNxa1c1cFlpcDZYbWMvMVhmSk9XMW51S1QzV2h0NmY1M0FjaXBkK25yU01tS2oyQ25PTjZ1eE42NlJ6d283NitOWkYvTTdwUFNaYWgwWmJWQVFBR1VMKzhzekQzU29yMGV1a3M1YVdQcTdNekw1cnl3c0M1Y2V0WWZzRTFNdndxZWVXUTR6bFBRN1hRKzB0emZONWZPc2RQYVg5MzVCUi9yZWJuWHJhUkFBQXdMSExPRTgyNWpjMkVBUUI0cWhUc0FBQm9QVkVwSUVWc2IyNzNOWGYyOVQvYTF0L1I5WHFrdkJRNS9pdWk3dThxVm84ZlgveWx6MVY5ZUdwM1ZHbEgvNE5jN1c0KzNmOXFQdWVCVkxVTGpOS1R4T3dpVHpnenNOb0ZVTlg4N0ZqRXlPZWxzd0FBd05EN0prM2tiYkd2UDVtK3cvb0wwSDh6ZXJxNU8xWTZDenlvbnA2K1U4M1BIY3FSUGw5OW5nMzRPVG5uTTQveVhETThxV3ErOS80Z2wrdnVhWDkzNUpUK1VwMmZmYkYrOC9qMTBua0FBSjVFenZGQlBUNTFwblFPQUFDNlI4RU9BSURWcVR2cjNGMWIzWEU3N1dvKzcrc1JJLzAvRzFub1BmQWw0MnB6dTdiRGNOcDliNUZmR25uZ0ZGV2Y3c21rL0ZucENQQnoyb1ZRMWZ6Y1RFcHB1blFXZUdMOWFiQUFBSU9wblRKZkxjd2RhMDVhUGltZHBiU1U0bkMxOE1mUDZpUHZYaXFkQlI3VVRoMXFycEZQTmora3AwdG5nVUdXSTY3Rmpkc25TK2RnK0RYbkM2K25WSjBvbmVOUnBZam44OWFSdjFSbloxNHkzUkVBMkt4eWpvdjErT1N4MGprQUFPZ21CVHNBQUJycEgwLzlLMGJzMGFEYk9EbmlUbngxMndRN0J0K04yNmZ5enRGWG1xUEIzdEpSQUFCZ21OVkhwaTVYODcyTGJjR3NkSmJ5cW5QVitka2xFMTRZTk8wTy9kVkNyNzFHSHZocFNWQkNqcmdaSzNjUHRsTWZTMmRodUZYemMzc2pWUitWenZGck5iOC9kdWZuUmo5dTdyNWFPZ3NBd0srVkkxOXFyb3ZIU3VjQUFLQzdGT3dBQU5pUUNYWVVsdU9TaFNac0J1M1BhZlhocWJFOHN1WEw1akMwdlhRZWVBTExwUU1BQVB5aXIyOU41T2RHOTkrYkl0OVZxeE5lK292bVh5NmRCWDdnbXhqTDIrTExyajlPNFdIOURjVWlEdFZ2bkxoV09ndkRyVHJYMnhIUHBJODM2M09WYlVtN21wODdYWTlQVFpUT0FnRHdxSnJ6L1N2eDFXM2xPZ0FBaWxLd0F3QWdJcTFjanhncG5ZSjFsYytYVGdDUHFsMFlWVjNvSFlzcU50MnUwSEJmVGtyTkFNREFxOStldmxrdDlOckZTbjhwbmFXMEZHbGZOZDg3VVk5UG5pcWRCUjVVSDV0Y3J1Wm5EMFVhK2J4MEZoZ29kWjZvajA1ZEtSMkREbmdtcGxPS1hhVmpQSW1VMGp2VmhkNmY2cU9UVjB0bkFRRDRKYXZsdWxzbVZRTUFVSnlDSFFBQTdlS0VaZjI2NFpFanJ0YmpVMHVsYzhDdlVSK2R2RmpOei8xbnUvaWpkQlo0UFBsbTZRUUFBSStpUGpKNXBacnZmWkJTdkZVNlMzRXBwcHZya0VYWDBBeWFldno0WXZNNFBkazhUdDh2blFVR1FjNzVUSDEwNm9QU09SaCsxWVhlbmxRTnlUbFNGZFBON2NIU01RQUFmbzV5SFFBQWcwVEJEZ0NBaU52ZkxNZHpUZzJIUnM1L0toMEJIa2M5UGpWUkxjenRTSkZlTDUwRkhzUC9LeDBBQU9DUjNiZzFrVjhZM2IvWnA3TThxUlN4UGFmMFVUVXo4NktGWEF5YWRycGlOZC83ZDJWWXVxNWRjTnMrWjFRNkJ4MnhXa29iQ3MxNXpvRzJNR2lLSFFBd3FKVHJBQUFZTkZaUkF3QVE5ZHZUTjZ1RjNzMFU4WHpwTER5WkhIRW4vcFV1bGM0QmorMnIyMk41NStqenpmRm9mK2tvOE9za0wvNEJBSnRHdTNDcG1wOGRpeGo1dkhTVzBwcHJqOTM1aGRIVHpkMWpwYlBBdytyeHlXUFZRbStYYTJTNktrZGNpMy9lT2xRNkI5MndOcjN1UU9rYzY2cUtqNXJiRjB2SEFBQjRXSTU4cVgxZFdMa09BSUJCb21BSEFNQTl5NkZnTndUeTVmclkxSExwRlBDNCtndDl6ODRjeXMrTmZwNGk5cFRPQTQ4c2gyTXZBTENwMU9QSEY2djUzcW1VNGtUcExLVzFFOEtxaGJuUDZpTlRsMHRuZ1IvNDZ0YkJ2SFAwcjY2UjZacmNQbC85N2NxcjdlWndwYlBRRVVNMHZlNmU5bmRIYzQ1endEa09BREJJY3M1blRLa0dBR0FRS2RnQkFMQW1MMGVrM2FWVDhJUnlmYjUwQkhoUy9hbWFaMmRlenI4Wi9US2wyRlU2RHdBQURLMGJ0MmJ5enRFRDdSUzMwbEhLUytlcWM3MmwrdGlralJNWUtQMk5hTTcxWHMzUHhGOWRJOU1WT2VKTzVIeXdmdlA0OWRKWjZJYnEvT3l1dEhWa3VLYlgzWlBUYTgydGdoMEFNQkJ5anBQMStOU3AwamtBQU9ESEtOZ0JBTEFxcCt2dGRxWnNYam5pYWp1Qm9IUU9XQS85a3QzNTJaZnoxcEYybC80ZHBmUEFMMG9yMTB0SEFBRDR0ZnJGbmZtNXNVanByNld6bE5aZWQrUnQrZVBtN3N1bHM4REQydUxuMmpYeWw4M1A2dk9sODhER3E4ZnE4WGVYU3FlZ1EwYXEvYVVqYkpnVWJYRndySFFNQUtEYitwdG8xSEdzUGpwNXNYUVdBQUQ0S1FwMkFBRGNZNGYyVFMvUGxFNEE2Nm5kcGJ5NjBIczFWL0c1QllRQUFMQXg2dkdwcFdwK2JpYWxORjA2UzJrcDByN21lL0ZPOHowNVV6b0xQS3gvalR3LzkycE9xYjFHM2w0NkQyeVVuT05VUGY3dXBkSTU2SmlxUCtWdEtMWFBxMWJ6cy90c3pnY0FsSklqYmpidkR0VkhKNitVemdJQUFEOUh3UTRBZ0RYNUgyR0UzYWJWbjE1M1pPcHk2Unl3M3VxamsxZXJoZDZoNW1mOEV3c0lHV2gzNDNycENBQUFqKzNHN1ZONTUraHJ6VG4zbnRKUmlrdnAvZXJEVTFmcU4wNWNLeDBGSHRZdnhDN01IV3ArVUQ4cG5RVTJRbzY0WEk5UG5peWRnMjZwWm1hMng4N1JmYVZ6Ykt5UlY1cWJ4ZElwQUlEdWFjN3hyOFhLM1lPZVp3RUFZRE5Rc0FNQVlGWEt5d3AybTVucGRReXYrc2prbFdyaGoyTVIxY2Vsc3dBQXdEQ3FwNmZ2VkJkNlk3bUt2M1o5WTR2Mjc1OUh0bnhTemN5ODJINWZTdWVCaDdVYkxGWHpjeE1wcGRPbHM4QjZ5aEZYNHF0Ymgwcm5vSU4yUHJ0LzZNOS9VaHhvYnBWWEFZQ25xdDFBSS81NWE2eCtlL3BtNlN3QUFQQW9GT3dBQUZpVjg3SiszZWJVMzluWjlEcUdYSDNrM1V2Vi9Od09Dd2daV010M2xrdEhBQUI0RXYzcDBmTnpzNUhTZE9rc3BhV0kzZm1GWjk5djdrNlV6Z0kvcGg2Zk90TThYdis5dVVaK3AzUVdXQTlyNWJxRGlzMFVrZE52aC8yMWtmYmNwcDNVNXpFR0FEd3RPY2NwMDZrQkFOaHNGT3dBQUZoMU42N0gxdEloZUN4MW1GNUhKNnd1SU96OVcwcHhvblFXZUpnRlNnREFNR2pPdWQrckZucXZwSWk5cGJPVTFoYVhxdm5aVCt2eDQ0dWxzOENQYVI2dkU4MDE4dlBOTmZMaDBsbmdTZVRJbCtLcjIyT3VxeWxvUitrQVQ4V083ZTNmODNycEdBREFjTXNSelhsOVBWYVB2M3VwZEJZQUFQaTFGT3dBQUZqVlR0N1pPVm82QmI5U2YzcmQwY21ycFhQQTA5THVkRmpOOS81ZlN2Ris2U3h3VDNNc3ZsazZBd0RBdWxtNU81Wkh0bnlaSXJhWGpsSmNHdm00T3RkN3NUNDJhVm94QTZtNVJoNnI1dWYrbmt5ZVpKUEtPUzdXNDFOanBYUFFjYWtqQmJzdGxZSWRBTENobXZQNzY1SGpZSDMwWGVzWEFBRFlsQlRzQUFEb2EzY0lyaFo2TjFQRTg2V3o4R2o2dTcrWlhrY0gxZU9UcDZvTHZlV280cHhGdnd5RXJHQUhBQXlQK28wVDE2cjV1Wk9SMHVuU1dVcHJyamQyNUcxeHJybDdzSFFXK0NuOXlaUHp2VHMyb21HenlUaytxTWNuajVYT0FkR1YxMFJTNnNiZkV3QW9vdDA4STc2K05WRy9QZTAxTXdBQU5pMEZPd0FBSHRUdXlPNUYxczBpNTluNjZKVGQzK2lrK3Vqa3hXcWh0NXdqUGxZTXByZ1VkMHBIQUFCWVQvWDQxSmxxWWU2MUZHbGY2U3lsTmRjYkI2b0x2Y1B0TlVqcExQQlQ3bTFFazZyNHFIUVdlQlE1NTVtMkhGbzZCL1RsMk5IK3doOTZkVWNtOVFFQVQxVmVYV015MWx5WFhpbWRCUUFBbnBTQ0hRQUFEOGpMRVdsMzZSVDhzaHh4Tlc3Y1BsVTZCNVJVSDVtOFVsM292WnlyK0VzN1dhSjBIcnFzL2YwSkFEQmt2cTNIOHRhUnY1a2EzYWppWFBYaHFhVjJ1bC9wS1BCVFZqZWkrZU9kNWdmMkk0OWJCcGx5SFFNbmRlUjV4YTc4UFFHQXB5WkhYSWwvM2pwa2FoMEFBTU5Dd1E0QWdPL2tkTDBUTzdWdWNqbmlUdFF4Vms5UG01aEU1OVZISjY5VzUyZGZ5bHRIMnBLZGdqQUFBS3lUK3MzajE2c0xjeE5ScFhPbHM1VFdscFh5eUphUHFwbVpsMTJMTThqcUkrOWVxaFo2TjNQRUowcDJES0xjUHFkNWRPcGk2UndBQU1EamE2NDViMFlkRSsxR0w2V3pBQURBZWxLd0F3RGdRU2J3YkFZNVp0cFNVZWtZTUNqNkMzL1B6cnlVbjN2Mmt4UnBYK2s4ZEZCYlVBY0FHRUwxMGFrUHFvWGVheWxpZitrc3BUWGZnNzM1aFdkUE5IZmZLNTBGZms1LzJ2djgzTXM1cFhZam11ZEw1NEY3VnN0MUZ1QXlnSElzTjcvb2Q1V09zZUd5MTM4QWdDZlhuMXIzVFhOdWYyelN1UVVBQUVOSHdRNEFnQWZrZjRRUmRnTXRSeXpWNDVPblN1ZUFRVk8vUFgyem1wbDVOZTk4OXFNVTZmWFNlUUFBWUdoOEUyTjVXL3hOVVNjaXBUUmR6Yzh1MXVQSEYwdG5nWjlUajA4dFZSZDZMK2NxUHZmWXBiUWNjYWU1UFZRZm5icGNPZ3Y4cUpTdk56ZTd5b1o0Q3RMSzlkSVJBSUROSy9jM2E2NG4yc25wcGJNQUFNQkdVYkFEQU9BN0tTOHIyQTJ1L21LVWxidGpwWFBBb0txbnArODA3dzVWODNQTEthVjNTdWVoVSt6U0NRQU1yWFpIOHVwQ2J5S3ErS2gwbHNFdzhsRjFkdWJGZHBPUDBrbmc1OVJISjY5VzUyZGZ6RnRHUGs5ZG1NekVRTW9SN2JIeVVIMWs2a3JwTFBBenV2RzhUcDI3OGZjRUFOWmR6dmxNZkgxN3huTWhBQUFNT3dVN0FBQytrL095ZnQwQXEvTkUvY2FKYTZWandLQ3J4NmNtcXZtNXY2ZVVUcGZPUWxma2Iwb25BQURZU1BYUnlZdlZRdSsxRkhHZ2RKYlMycUpTZnU3WmM4M2RRNld6d0MrcDN6eCt2UzJFNXVkR1AvTDQ1V25MRVV2eDdjcWg5dWV3ZEJiNFdUbTY4YnJJN1c4VTdBQ0FYNlYvVHAvelJEc2x2WFFXQUFCNEdoVHNBQUQ0enQyNEhsdExoK0RINUJ5bjZxTlRINVRPQVp0RlBUNTFwbHI0NDNKRTFTNGkzRjQ2RDBNdWQyU25jd0NnMjc2SlkzbGI3RzNPcjNlVWpsSmFpdlI2ZGFIM1dWczhMSjBGZnNuYWhJR0QxWHp2UkVyeGZ1azhkRU4vd3NXTjJ5ZnI2ZWs3cGJQQUwwdi9LSjFnbytXSU95Yk9BQUNQcWorSk91ZVo5dlhXMGxrQUFPQnBVckFEQU9DK2RqZmhrWVZlNlJnOEpFZGNyc2NuVDViT0FadE5mZVRkUzlXSHA2N21rUzJmcElqZHBmTXd6SklGZ3dEQTBLdVBUUzVYQzMrY2lLZytMcDFsSUZSeHVqby91Mmd5cnk5RXZBQUFJQUJKUkVGVUU1dEZQVDU1cXBxZlc0eVVQbEdVWmFQMEYrSkdIcXZIcHk2WHpnS1BMTWVWR1BvQ2NqWjFCZ0I0SlAzTk12NlZadXRqVXphWEJBQ2djeFRzQUFENG5oeXhiSkhONEdqK2Z5ekZWN2NPbGM0Qm0xWDl4b2xyMWN6TWkvbUYwZE1weFZ1bDh6Q2txbXdIY0FDZ0UvcWJXTXozWG1uT3JRK1h6bEphaW5nK2J4MXB5NFl2bGM0Q2o2b2VuMXFxenZWZXpOdnl4eW5TdnRKNUdDNzk1ekcvWFRta2VNeG1VeCtkdk5xYzMxeHZ6bTkybGM2eVlYSjhXam9DQUREWWN1Ukw4VzE5MHZrOEFBQmRwbUFIQU1ERDJwM0lGT3dHUU01eFBiNis5V285UFcweUVqeUJ0Y2ZRc1dwaDdyT0k5Rkc3RUxaMEpvWk1yaFhzQUlEdStQcldSSDV1ZEwvTmVmb2x1NzNWL054NzlmalVlNld6d0tOcXAxRTI3MTV1ZjNaVFN0T2w4ekFjK2xNdWJ0dys2WGxNTnJFcnpkdndiczUxdHpaVkVnRDRVYms5RDZyalpIMTA2bXJwTEFBQVVKcUNIUUFBRDFzdUhZRCtFOWszbzc3N2F2MzJ0TklHckpQNnlOVGw2bHh2eVU3OXJML0tBa0lBb0RQYTY5UnFvVGZXM1AxTDZTd0RJYVhqMWZ6Y2xYWXlXT2tvOEd1MHhkQnFmbll4MHNnbk5xTGhjZldmdzR3ODF2dzhLZSt3eWEzOE9XSmtLQXQyemVQMHFrazBBTUREK2hPbzg4ckpldno0WXVrc0FBQXdLQlRzQUFENHZoekw3UmJzbExOYXJvdVg2emRPWEN1ZEJZYk5kenYxOTA2a0ZPK1h6c09RdUZzcnB3TUFuVklmbWJ6U25GTmZiTTZwRDVmT1VscUsySjRqZlZ6TnpQeUh5VTFzTnUxQ3l1cGM3ei95dG1oTGRudEw1MkZ6NlMvSS9YYmxrT0lPUStIR25hVzhjL1RtVUJhT2MvNjBkQVFBWUhDMDVmdm1kcWJkbUxSMEZnQUFHRFFLZGdBQVBDVC9QVFRzaXNrNXJrZU9nL1hSeWF1bHM4QXdxOGNuVDFYemM0dVIwa2ZORVc5MzZUeHNUam1pTFVKUFdFd0lBSFRTalZ2SDhndWorMUtLWGFXamxOWitENXJ2eGJubTdsanBMUEJyclcxRTgxSnpqZnhlTzVHeExZMld6c1RneXptZmlSdTNUeW9XTXl6YW4rWG1PSGl4T1E2K1V6ckx1c3ZKNG5rQW9IMU42MHJ6N215N2FWTHBMQUFBTUtnVTdBQUErRDRUN0lycDd4WjNkK1dnb2dZOEhmWDQxRkoxZHVhbC9KdG5wOU13THA1aHd6VEg2enZOelptNGNXdkdZa0lBb0t0V0Y2TFBqa1dNZkY0Nnl5Qm9wL2xWQzNPZjJnR2V6YXE1Um42dit2RFVwVHl5NVhTSzJGODZENFBwL2tZejQxTVc1VEo4L3BWbTg3WjR2VGtHN2lnZFpiMjBaZGo2NkpUTi9BQ2dvNXJ6OTV2TnphVzR1ekpyRFFJQUFQd3lCVHNBQUw2dml1WFNFYm9vUnl6RlAyKzlXcjg5ZmJOMEZ1aVN0Y2ZjUkhXaDk2Zm0rSGN1UmV3dG5ZbkIxajllcjl3ZHE5ODRjYTEwRmdDQTB1cng0NHZWL053WkcxYmNrejZxenZXVzFpYUN3YWF6ZHAzemFyWHd4OWNqcXRQRFZETGh5YXd1ek0wejlmalVtZEpaWUtPMHY3K2I4NXJaU09sMDZTenJvYjlCMUwvU2JPa2NBTURUbDNOY2IyN1B4dGUzTDFwL0FBQUFqMDdCRGdDQTd6UEI3cW5MRVZmaXExc0hUVUdDY3VxamsrMU96aTlWRjNxSG80cjNMU0xrWWYzRmhIVk1ORDhyRjB0bkFRQVlLRGR1bjh3N1IvYzM1OUM3UzBjcHJma2VQSiszNVkrYnV5K1h6Z0pQb2o3eTdxWHE3TXdWRTk5cHRST3c0dXZiTXhibTBnazNibi9Rbk5jY0g0cm5CblArb0Q0MnBmUVBBQjNTWDNjUStYdzlQblc1ZEJZQUFOaU1GT3dBQVBpK3UvVnliQjBwbmFJemNvNFA2dkhKWTZWekFLdmE4bFIxZHVheVJZUThxRGxXWDR4L3hVbVRTQUFBZnFqZExLYWFueHVMbFA1YU9zc2dTSkgyTmQrUGQweDVZck83UC9GOWZ1N1A3VFFuRTkrN0owZGVqRHBOMUVlbnJwYk9BazlMLzd4bTRZOFRFZFhIcGJNOGlSeXgzQlpqUytjQUFEYmU2bmw3L0RtK1RaZTlqZ1VBQUU5R3dRNEFnTytwM3p4K2ZXU2hWenJHME90UFFvcjZXRDMrN3FYU1dZRHZ1NytJOEVMdlQxSEZPWXNJdTZ2L29tU3VaK3J4NDR1bHN3QUFETEo2ZkdxcG11K2RTaWxPbE00eUVGSjZ2N21lV0Z5YmxBMmJXdnY0am5iaSsvemNPODNQOW5RN3FiRjBKalpXem5FOVVwNm9qNWg2UVRmMXAzZ3V6TDJXSXIxZU9zdmpxeWRNblFTQTRaVWpyalluN24rS3UvWGxkbjFINlR3QUFEQXNGT3dBQVBpQmRuZlRGTEdqZEk1aDFYeC9sK0xibFVPZTdJYkJ0cllZOXFYcVF1OXdwSmhPS1hhVnpzVFQwVDlPNTVXVGluVUFBTC9DalZzemVlZm8vaFN4cDNTVTBwcnZ3ZlpjeGNmVnpNeUw3U1NjMG5sZ1BiUlRHYXR6dlV0NVd6Njl1VXNuL0pUK2htQTVacHZqK1JuSExqcnZxOXRqelhuTjdzMTRYcE56bkxLeEh3QU1INlU2QUFEWWVBcDJBQUQ4bU9WUXNOc1FxeTl1VDU0c25RTjRkUFhSeVl2TnU0dUtkc092LytKazVCbTc5QU1BL0hwdEdhTTVaeDdMVmZ5MUxaaVZ6bE5hOHozWW5WOFlQZDNjUFZZNkM2eVgrdGhrKzV6aG9lYXhQaHRWUHE1b056eHlqZy9pWHpHejl2OFlPcTkvWG5OKzltRGVPdkxYemJRWllZNThxUjZmOHZvREFBeUIvbVRwaU1YbUYvd1hzYkt5cUZRSEFBQWJUOEVPQUlBZll5SEZPbXVuQWtaZU9XUWFFbXhlaW5iRHEvOGlaY29UaW5VQUFFK21uUUpkemMvTlJrclRwYk1NZ3VhYTRhMXFvZmRwZldUeVN1a3NzSjdXSnI0ZnFzN1Bub3d0SSszMThlSFNtWGc4T2ZKaTFHbGk3ZjhwOElCMkVYdHpYbk13cC9UNVp0ZzhJRWNzdFpQM1N1Y0FBQjZQUWgwQUFKU25ZQWNBd0EvbFdHNjNXbWQ5NUp6UHhOZTNaK3EzcDIrV3pnSThPVVc3NGRHZldGZkgyYlgvcHdBQXJJY2J0MC9sbmFPdnBJaTlwYU1NaUkrcWM3MFhUWVZpR0swdCtCeXJ6cy9PeEphUjQ4MDE4dUhOVUVLaGZ6MTh1YmtlbnFtUFRpbld3YytveDZlV3FvVS9qa1ZVSDVmTzhuUDZDL0wvRlFmYnlYdWxzd0FBajZaZmpzOXhUYUVPQUFBR2g0SWRBQUEvSXY4OU5PeWVXSCtoeXJjckU1NE1oK0drYUxkNTVjaVhtcHV6N1NLcDBsa0FBSVpOdTdDNyt2RFVXQjdaOHFXaVRmL1psUjE1VzN6VTNIMjFkQmJZS0d2UGZSMnJ6dlZtOGpQNWVLVDBsc2YvNE1rUmQ1cWJTM0YzWmNiemxmRG82aVB2WHFvV2V1M21lUjgzeDdiblMrZDVXSDhTNWRlM0Q5cmdEd0FHVTNNZXZ0emNyaGJwVXZPK3JxNlpJQTBBQUlOSndRNEFnQjh5d2U2SjlGL1F6bkZTY1FPNjRYN1JidUdQcjBkVWYyZ09uL3RMWitLSCtpOWc1bncrL3BVK3FJOU5tUjRDQUxDQjZqZE9YS3ZtZXpPUjR2M1NXUVpCZTQxUVhaaDdxejQ2OVVIcExMQ1IxaVkxVGxUbmVyUDVtZnhXcFBUMklKWlJ1cWE1SHI3WlhBOWZiSzZIWjAzVGhNZFRINW04VWwzb3ZaeFRmREpJbTJ6bEhCL0VqZHNUSnRjQlFGbjl6U3dpTDYxOThFVkVhajVlV1lxdjcxeFZnZ2NBZ00xRHdRNEFnQitxd2tLTHg1QWpyalczSitzalU1ZExad0dldm5ZMzYrYmRwZXI4N0s3WU12Sm1jLy8xUVZwdzAxWE5zWGtwNmppL1ZvUUVBT0FwcWNjblQxVUxjNitrU1B0S1p4a0lWVHBkZlhocXNTMGZsbzRDRzIydHhQVmVkWGJtVEI1OTl2WG01Ly9ORkxHbmRLNnV1WGM5SFAvMzFpWGxHM2h5N2FTWjZsenZwYnd0L2xMNm1OWmZ4Ri9uQ2VWOUFIZzZtdCs5VjV2Ym01RlR1eDdnSDZzYkZ0ZlhJby9jTkkwT0FBQ0doNElkQUFBL1ZLZnJVWlVPc1huMEY2dEVmWGF0WEFOMFhQM204ZXZOdTVQdFc3WFEyOThjSmY2UUlyMWVPRmFuNUJ6WG05dkxVYStjdDRBWkFLQ2diK3V4dkhYa2J5bGllK2tvcGJYZmd6eXk1ZU5xWnVZbFJSZTZZbTFTUTF2KytLRDY4TlR1cUViZWpKUmVieDRQTzBwbkcxYXIwK3JpVXRSM3o3b2VodlhYRm9qYjMrWDVoV2ZmVHltOVV5SkRmNEYvWHBtb2p4NWZMUEgxQVdBenlKRVhIK0ZmK3VLQmo1cHJsL3E3b3R6ZHVMNzJlaDhBQU5BaENuWUFBUHpRdDdFYzIwcUhHR3o5SFdKWEY2dk1XcXdDL0pUNnlPU1Y1dDJWNmx4dklwNkp3NUhpRHlsaWQrbGN3K2grcVM2blA5a3RsTTJrSHA4Y2E5Nk5sYzRCc0Y0YzEzalEybUswLzY5MERxQzh0ZWZQSnRxM2U1dlJSS1FEQ3Jqcm83K0F1RTUvTXEwT050N2FZMnlpT2o5N05yYU9uRzZPWXdlZXh0Zk5FY3RSeDhuNjZPVEZwL0gxNE5kYU9US1pTbWVBTGxqN1BYQ3hjQXdBQUlDaHBHQUhBTUFQdEx1d2ppejBTc2NZU0dzRmpyUHg5ZTJMYTd0d0EveWk5cmphdkR2VnZsVVhlbnNpeGUrYnQvMHBZay9wYkp1WlVoMEFBTURtYzM4em1yTXp6K2ZSMFFOUjlTZS83eXVkYTdOWkxkWEZuK1BiZExrK05yVmNPZzkwemRwR0FnZXIrZGw5a1ViZVR4RjdOK0xyckU2bXpETng0L1lIQ3JRQUFBQUFzSEVVN0FBQStGRnRhU0dsMkZVNnh5RG83d3liNDBxaytITTkzbDhBQlBEWTFvcGc3ZHZKNmx4dlIyek5CNkpLcnpRZjc3ZHoveTlyanNsTHpjMWk4L1pucFRvQUFJRE5hMjN6cW92dFczVitkbGRzcVE1SFNxOXNWRWxsR0NqVndlQ3B4NDh2TnU5ZWVtQlRyWFk2NSs0bitaejlVbDNrSzgzYnAvSFAvNzVpc3o4QUFBQUEySGdLZGdBQS9MZ1U3UUtOWGFWamxKTGI4a3RicWxQZ0FEYlEybVM3RDliZW9scm83WStjWDJrT3dnZVVuRmMxeCtOcnpmZWtMVGwvRWYrOHZXaEJFUUFBd1BCWm13VDFYdnRXemN4c2o1MmorNW9Md3Q4MTE0TDd1bHk0VzcwbWpzVkkrVFBYeEREWXZyZXAxb2VuZGtjMXNyODVocjIyK2svVDNwL2JXS3YvV0kvY2J2VFgvUGYxcDJ1bFBRQUFBQURnS1ZLd0F3RGdSOVZISmwrcTV1ZmF4U3Q3SThWdkk2ZTl3MXoyeUJGM21uZFhvczZmeFVwOVpXMVJEOEJUMVJ4NzJ5bVo3ZHRFZnlGTzJ0SWNnL04vTnNmaFBTblN2c0x4bm9wMmdtcnpiakZTL1ZsOFV5MnVsUkFCQUFEb2lIcDZldlY1dXRXM3FNN09QQi9QUGJ0V3VFdHQ0VzVQMllRYnAzOU5uUEpTMU9teldGbFo5QndsYkU3MUd5ZXVSYjgwRjJjZS9QUHFYRzlIUExPeU90M3VYeVBYUE84RkFBQUFBSU5Ed1E0QWdKOVVqMDh0TmUrVzduM2NmL0YzVzk0Yk9mMDJVdk0rMHA0VThYekJpSTlsdFV5WGw1cS94MUtrK24vSFNuMTE3UVZ2Z0lIeHdFS2MrNm9MdlhZUjRaNSs4YmxmdXR1OHUvZy9jQ3h1ZCtqK1A4M2YrR3JjdUxPMHRwQVNBQUFBK3RhbXRsMWVlM3VnY0pkZWlaUjNSNlRkemZYeGpySXBmNzNtdXJqNWUrV3J6WjB2SXFXbCtDYXVLdHZBY0Z0N2pIdWNBd0FBQU1BQVVyQURBT0NScmIzNGUzOHhTNnVhbWRrZUwyemZHM2xrVjZUY3ZLWGZObis4WXhCMmtyNi9TR1gxZ3k4aXhkWDR0cjVxNTJkZ3M2cVBUcmJIdFBidDRyMC82MDhiYlkrL09iV0xDdjl0YlhGaGV4emVYU3pvQTNLL0pKaWIzeC9wWnVUOHYvdUxCcjlkdWVaWURBQUF3T040dUhCM3orcjFjZXhvTGtUM05OZWcvOTYvVm82MHQ3ayszbDRrNkpyY0w5UGthMnNielB5aitSc3NScDJYYmZnRkFBQUFBQUNEUThFT0FJQW5zalpwYVBISC9sbC9OK25mYkY4cjJvM3NqY2pidjF2Y2NzK2o3ekQ5WFVuakIvL2dpOVZQRlZjajF6ZmpibHhYM0FDNjR1RnBvdy9xVHg1OVptVjNwT3I1MVFXRzhUL2F5WGMvOXUrbVNQdCs2V3ZkWHhUNGczOXdiNUZnVzJ5dXI2N21Pcjc0Nkg4TEFBQUFlREpyMThldDd4ZnZIdDRnN0w1N205UTg2TkUzclBuZTVsNzNOcFZaL1FmTGtlcHJxNWxjR3dNQUFBQUF3R2FnWUFjQXdJWloyMDE2Y2UzRHhaLytOd0hZQ0d1VFIrOFZreS8vM0w4TEFBQUF3K2puTmdnREFBQUFBQUJvS2RnQkFBQUFBQUFBQUFBQUFBQUEwRWtLZGdBQUFBQUFBQUFBQUFBQUFBQjBrb0lkQUFBQUFBQUFBQUFBQUFBQUFKMmtZQWNBQUFBQUFBQUFBQUFBQUFCQUp5bllBUUFBQUFBQUFBQUFBQUFBQU5CSkNuWUFBQUFBQUFBQUFBQUFBQUFBZEpLQ0hRQUFBQUFBQUFBQUFBQUFBQUNkcEdBSEFBQUFBQUFBQUFBQUFBQUFRQ2NwMkFFQUFBQUFBQUFBQUFBQUFBRFFTUXAyQUFBQUFBQUFBQUFBQUFBQUFIU1NnaDBBQUFBQUFBQUFBQUFBQUFBQW5hUmdCd0FBQUFBQUFBQUFBQUFBQUVBbktkZ0JBQUFBQUFBQUFBQUFBQUFBMEVrS2RnQUFBQUFBQUFBQUFBQUFBQUIwa29JZEFBQUFBQUFBQUFBQUFBQUFBSjJrWUFjQUFBQUFBQUFBQUFBQUFBQkFKeW5ZQVFBQUFBQUFBQUFBQUFBQUFOQkpDbllBQUFBQUFBQUFBQUFBQUFBQWRKS0NIUUFBQUFBQUFBQUFBQUFBQUFDZHBHQUhBQUFBQUFBQUFBQUFBQUFBUUNjcDJBRUFBQUFBQUFBQUFBQUFBQURRU1FwMkFBQUFBQUFBQUFBQUFBQUFBSFNTZ2gwQUFBQUFBQUFBQUFBQUFBQUFuYVJnQndBQUFBQUFBQUFBQUFBQUFFQW5LZGdCQUFBQUFBQUFBQUFBQUFBQTBFa0tkZ0FBQUFBQUFBQUFBQUFBQUFCMGtvSWRBQUFBQUFBQUFBQUFBQUFBQUoya1lBY0FBQUFBQUFBQUFBQUFBQUJBSnluWUFRQUFBQUFBQUFBQUFBQUFBTkJKQ25ZQUFBQUFBQUFBQUFBQUFBQUFkSktDSFFBQUFBQUFBQUFBQUFBQUFBQ2RwR0FIQUFBQUFBQUFBQUFBQUFBQVFDY3AyQUVBQUFBQUFBQUFBQUFBQUFEUVNRcDJBQUFBQUFBQUFBQUFBQUFBQUhTU2doMEFBQUFBQUFBQUFBQUFBQUFBbmFSZ0J3QUFBQUFBQUFBQUFBQUFBRUFuS2RnQkFBQUFBQUFBQUFBQUFBQUEwRWtLZGdBQUFBQUFBQUFBQUFBQUFBQjBrb0lkQUFBQUFBQUFBQUFBQUFBQUFKMmtZQWNBQUFBQUFBQUFBQUFBQUFCQUp5bllBUUFBQUFBQUFBQUFBQUFBQU5CSkNuWUFBQUFBQUFBQUFBQUFBQUFBZEpLQ0hRQUFBQUFBQUFBQUFBQUFBQUNkcEdBSEFBQUFBQUFBQUFBQUFBQUFRQ2NwMkFFQUFBQUFBQUFBQUFBQUFBRFFTUXAyQUFBQUFBQUFBQUFBQUFBQUFIU1NnaDBBQUFBQUFBQUFBQUFBQUFBQW5hUmdCd0FBQUFBQUFBQUFBQUFBQUVBbktkZ0JBQUFBQUFBQUFBQUFBQUFBMEVrS2RnQUFBQUFBQUFBQUFBQUFBQUIwa29JZEFBQUFBQUFBQUFBQUFBQUFBSjJrWUFjQUFBQUFBQUFBQUFBQUFBQkFKeW5ZQVFBQUFBQUFBQUFBQUFBQUFOQkpDbllBQUFBQUFBQUFBQUFBQUFBQWRKS0NIUUFBQUFBQUFBQUFBQUFBQUFDZHBHQUhBQUFBQUFBQUFBQUFBQUFBUUNjcDJBRUFBQUFBQUFBQUFBQUFBQURRU1FwMkFBQUFBQUFBQUFBQUFBQUFBSFNTZ2gwQUFBQUFBQUFBQUFBQUFBQUFuYVJnQndBQUFBQUFBQUFBQUFBQUFFQW5LZGdCQUFBQUFBQUFBQUFBQUFBQTBFa0tkZ0FBQUFBQUFBQUFBQUFBQUFCMGtvSWRBQUFBQUFBQUFBQUFBQUFBQUoya1lBY0FBQUFBQUFBQUFBQUFBQUJBSnluWUFRQUFBQUFBQUFBQUFBQUFBTkJKQ25ZQUFBQUFBQUFBQUFBQUFBQUFkSktDSFFBQUFBQUFBQUFBQUFBQUFBQ2RwR0FIQUFBQUFBQUFBQUFBQUFBQVFDY3AyQUVBQUFBQUFBQUFBQUFBQUFEUVNRcDJBQUFBQUFBQUFBQUFBQUFBQUhTU2doMEFBQUFBQUFBQUFBQUFBQUFBbmFSZ0J3QUFBQUFBQUFBQUFBQUFBRUFuS2RnQkFBQUFBQUFBQUFBQUFBQUEwRWtLZGdBQUFBQUFBQUFBQUFBQUFBQjBrb0lkQUFBQUFBQUFBQUFBQUFBQUFKMmtZQWNBQUFBQUFBQUFBQUFBQUFCQUp5bllBUUFBQUFBQUFBQUFBQUFBQU5CSkNuWUFBQUFBQUFBQUFBQUFBQUFBZEpLQ0hRQUFBQUFBQUFBQUFBQUFBQUNkcEdBSEFBQUFBQUFBQUFBQUFBQUFRQ2NwMkFFQUFBQUFBQUFBQUFBQUFBRFFTUXAyQUFBQUFBQUFBQUFBQUFBQUFIU1NnaDBBQUFBQUFBQUFBQUFBQUFBQW5hUmdCd0FBQUFBQUFBQUFBQUFBQUVBbktkZ0JBQUFBQUFBQUFBQUFBQUFBMEVrS2RnQUFBQUFBQUFBQUFBQUFBQUIwa29JZEFBQUFBQUFBQUFBQUFBQUFBSjJrWUFjQUFBQUFBQUFBQUFBQUFBQkFKeW5ZQVFBQUFBQUFBQUFBQUFBQUFOQkpDbllBQUFBQUFBQUFBQUFBQUFBQWRKS0NIUUFBQUFBQUFBQUFBQUFBQUFDZHBHQUhBQUFBQUFBQUFBQUFBQUFBUUNjcDJBRUFBQUFBQUFBQUFBQUFBQURRU1FwMkFBQUFBQUFBQUFBQUFBQUFBSFNTZ2gwQUFBQUFBQUFBQUFBQUFBQUFuYVJnQndBQUFBQUFBQUFBQUFBQUFFQW5LZGdCQUFBQUFBQUFBQUFBQUFBQTBFa0tkZ0FBQUFBQUFBQUFBQUFBQUFCMGtvSWRBQUFBQUFBQUFBQUFBQUFBQUoya1lBY0FBQUFBQUFBQUFBQUFBQUJBSnluWUFRQUFBQUFBQUFBQUFBQUFBTkJKQ25ZQUFBQUFBQUFBQUFBQUFBQUFkSktDSFFBQUFBQUFBQUFBQUFBQUFBQ2RwR0FIQUFBQUFBQUFBQUFBQUFBQVFDY3AyQUVBQUFBQUFBQUFBQUFBQUFEUVNRcDJBQUFBQUFBQUFBQUFBQUFBQUhTU2doMEFBQUFBQUFBQUFBQUFBQUFBbmFSZ0J3QUFBQUFBQUFBQUFBQUFBRUFuS2RnQkFBQUFBQUFBQUFBQUFBQUEwRWtLZGdBQUFBQUFBQUFBQUFBQUFBQjBrb0lkQUFBQUFBQUFBQUFBQUFBQUFKMmtZQWNBQUFBQUFBQUFBQUFBQUFCQUp5bllBUUFBQUFBQUFBQUFBQUFBQU5CSkNuWUFBQUFBQUFBQUFBQUFBQUFBZEpLQ0hRQUFBQUFBQUFBQUFBQUFBQUNkcEdBSEFBQUFBQUFBQUFBQUFBQUFRQ2NwMkFFQUFBQUFBQUFBQUFBQUFBRFFTUXAyQUFBQUFBQUFBQUFBQUFBQUFIU1NnaDBBQUFBQUFBQUFBQUFBQUFBQW5hUmdCd0FBQUFBQUFBQUFBQUFBQUVBbktkZ0JBQUFBQUFBQUFBQUFBQUFBMEVrS2RnQUFBQUFBQUFBQUFBQUFBQUIwa29JZEFBQUFBQUFBQUFBQUFBQUFBSjJrWUFjQUFBQUFBQUFBQUFBQUFBQkFKeW5ZQVFBQUFBQUFBQUFBQUFBQUFOQkpDbllBQUFBQUFBQUFBQUFBQUFBQWRKS0NIUUFBQUFBQUFBQUFBQUFBQUFDZHBHQUhBQUFBQUFEL1AvdDJJQUFBQUFBZ3lOOTZrTXNqQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQjd3NFZjQUFBZ0FFbEVRVlJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUFBQUFBQUFBQUFBQUJnU2JBREFBQUFBQUFBQUFBQUFBQUFZRW13QXdBQUFBQUFBQUFBQUFBQUFHQkpzQU1BQUFBQUFBQUFBQUFBQUFCZ1NiQURBQUFBQUFBQUFBQUFBQUFBWUVtd0F3QUFBQUFBQUFBQUFBQUFBR0JKc0FNQUFBQUFBQUFBQUFBQUFBQmdTYkFEQUFBQUFBQUFBQUFBQUFBQVlFbXdBd0FBQUFBQUFBQUFBQUFBQUdCSnNBTUFBQUJpM3c0RUFBQUFBQVQ1V3c5eWVRUUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBQUFBQUFBQUFBQUFBQUFBQVM0SWRBQUFBQUFBQUFBQUFBQUFBQUV1Q0hRQUFBQUFBQUFBQUFBQUFBQUJMZ2gwQUFBQUFBQUFBQUFBQUFBQUFTNElkQUFBQUFBQUFBQUFBQUFBQUFFdUNIUUFBQUFBQUFBQUFBQUFBQUFCTGdoMEFBQUFBQUFBQUFBQUFBQUFBUzRJZEFBQUFBQUFBQUFBQUFBQUFBRXVDSFFBQUFBQUFBQUFBQUFBQUFBQkxnaDBBUU8zYmdRQUFBQUNBSUgvclFTNlBBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN0FBQUFBQUFBQUFBQUFBQUFBQllFdXdBQUFBQUFBQUFBQUFBQUFBQVdCTHNBQUFBQUFBQUFBQUFBQUFBQUZnUzdBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQkxzQUFBQUFBQUFBQUFBQUFBQUFGZ1M3QUFBQUFBQUFBQUFBQUFBQUFCWUV1d0FBQUFBQUFBQUFBQUFBQUFBV0JMc0FBQUFBQUFBQUFBQUFBQUFBRmdTN1BQTU1Xd0FBQUFqU1VSQlZBQUFBQUFBQUFBQUFBQUFBQUJZRXV3QUFBQUFBQUFBQUFBQUFBQUFXQXB3b05vWkpadkpxZ0FBQUFCSlJVNUVya0pnZ2c9PVwiLFwia2V5XCI6MX0pXSldKTtcbn1cblxuTG9nb0pjcHJvLmRlZmF1bHRQcm9wcyA9IHtcIndpZHRoXCI6XCI5M1wiLFwiaGVpZ2h0XCI6XCI2MVwiLFwidmlld0JveFwiOlwiMCAwIDkzIDYxXCIsXCJmaWxsXCI6XCJub25lXCJ9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExvZ29KY3BybztcblxuTG9nb0pjcHJvLmRlZmF1bHQgPSBMb2dvSmNwcm87XG4iLCJpbXBvcnQgeyB0b2FzdCB9IGZyb20gXCJyZWFjdC10b2FzdGlmeVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBlcnJvckhhbmRsZXIoZXJyb3IpIHtcbiAgaWYgKGVycm9yKSB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgaWYgKGVycm9yLnJlc3BvbnNlKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzID09PSA1MDApXG4gICAgICAgIG1lc3NhZ2UgPSBcIlNvbWV0aGluZyB3ZW50IHRlcnJpYmx5IHdyb25nXCI7XG4gICAgICBlbHNlIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZS5kYXRhLm1lc3NhZ2U7XG5cbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikgdG9hc3QuZXJyb3IobWVzc2FnZSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgYXhpb3MgZnJvbSBcImF4aW9zXCI7XG5cbmltcG9ydCBlcnJvckhhbmRsZXIgZnJvbSBcIi4vZXJyb3JIYW5kbGVyXCI7XG5cbmNvbnN0IGluc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgYmFzZVVSTDogYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQVBJX0hPU1R9YCxcbn0pO1xuXG5pbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKChyZXNwb25zZSkgPT4gcmVzcG9uc2UuZGF0YSwgZXJyb3JIYW5kbGVyKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5zdGFuY2U7XG4iLCJpbXBvcnQgYXhpb3MgZnJvbSBcInNyYy9jb25maWdzL2F4aW9zXCI7XG5leHBvcnQgZGVmYXVsdCB7XG4gIGFsbDogKG9wdGlvbnMgPSB7IHBhcmFtczogeyBzdGF0dXM6IFwicHVibGlzaGVkXCIgfSB9KSA9PlxuICAgIGF4aW9zLmdldChgL2NvdXJzZXNgLCBvcHRpb25zKS50aGVuKChyZXMpID0+IHJlcy5kYXRhKSxcbiAgZGV0YWlsczogKGlkKSA9PiBheGlvcy5nZXQoYC9jb3Vyc2VzLyR7aWR9YCkudGhlbigocmVzKSA9PiByZXMuZGF0YSksXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgKG51bWJlciA9IDApID0+IHtcbiAgY29uc3QgdGhvdXNhbmQgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQoKTtcbiAgcmV0dXJuIHRob3VzYW5kLmZvcm1hdChudW1iZXIpO1xufTtcbiIsImltcG9ydCBIZWFkIGZyb20gXCJuZXh0L2hlYWRcIjtcblxuaW1wb3J0IGF4aW9zIGZyb20gXCJzcmMvY29uZmlncy9heGlvc1wiO1xuXG5pbXBvcnQgQ2lyY2xlIGZyb20gXCJwdWJsaWMvaW1hZ2VzL2NpcmNsZS1hY2NlbnQtMS5zdmdcIjtcblxuaW1wb3J0IEhlYWRlciBmcm9tIFwic3JjL3BhcnRzL0hlYWRlclwiO1xuaW1wb3J0IEhlcm8gZnJvbSBcInNyYy9wYXJ0cy9IZXJvXCI7XG5pbXBvcnQgQ2xpZW50cyBmcm9tIFwic3JjL3BhcnRzL0NsaWVudHNcIjtcbmltcG9ydCBMaXN0Q291cnNlcyBmcm9tIFwic3JjL3BhcnRzL0xpc3RDb3Vyc2VzXCI7XG5pbXBvcnQgTGlzdENhdGVnb3JpZXMgZnJvbSBcInNyYy9wYXJ0cy9MaXN0Q2F0ZWdvcmllc1wiO1xuaW1wb3J0IEZvb3RlciBmcm9tIFwic3JjL3BhcnRzL0Zvb3RlclwiO1xuXG5pbXBvcnQgY291cnNlcyBmcm9tIFwic3JjL2NvbnN0YW50cy9hcGkvY291cnNlc1wiO1xuXG5mdW5jdGlvbiBIb21lKHsgZGF0YSB9KSB7XG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxIZWFkPlxuICAgICAgICA8dGl0bGU+RVROSVBSTyBJTkRPTkVTSUE8L3RpdGxlPlxuICAgICAgICA8bGluayByZWw9XCJpY29uXCIgaHJlZj1cIi9mYXZpY29uLmljb1wiIC8+XG4gICAgICA8L0hlYWQ+XG5cbiAgICAgIDxtYWluPlxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJoZWFkZXItY2xpcHBpbmcgcHQtMTAgbWluLWgtc2NyZWVuIG1kOm1pbi1oLTBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInN1bnNoaW5lIG1heC13LWZ1bGxcIj48L2Rpdj5cbiAgICAgICAgICA8Q2lyY2xlIGNsYXNzTmFtZT1cImFic29sdXRlIGxlZnQtMCBib3R0b20tMFwiPjwvQ2lyY2xlPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29udGFpbmVyIG14LWF1dG8gcHgtNFwiPlxuICAgICAgICAgICAgPEhlYWRlcj48L0hlYWRlcj5cbiAgICAgICAgICAgIDxIZXJvPjwvSGVybz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjb250YWluZXIgcHgtNCBteC1hdXRvIG1kOnB0LTI0XCI+XG4gICAgICAgICAgPENsaWVudHM+PC9DbGllbnRzPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICAgIDxzZWN0aW9uIGNsYXNzTmFtZT1cImNvbnRhaW5lciBweC00IG14LWF1dG8gbWQ6cHQtMjRcIj5cbiAgICAgICAgICA8TGlzdENvdXJzZXMgZGF0YT17ZGF0YX0+PC9MaXN0Q291cnNlcz5cbiAgICAgICAgPC9zZWN0aW9uPlxuICAgICAgICA8c2VjdGlvbiBjbGFzc05hbWU9XCJjb250YWluZXIgcHgtNCBteC1hdXRvIG1kOnB0LTI0XCI+XG4gICAgICAgICAgPExpc3RDYXRlZ29yaWVzPjwvTGlzdENhdGVnb3JpZXM+XG4gICAgICAgIDwvc2VjdGlvbj5cbiAgICAgICAgPHNlY3Rpb24gY2xhc3NOYW1lPVwibXQtMjQgYmctaW5kaWdvLTEwMDAgcHktMTJcIj5cbiAgICAgICAgICA8Rm9vdGVyPjwvRm9vdGVyPlxuICAgICAgICA8L3NlY3Rpb24+XG4gICAgICA8L21haW4+XG4gICAgPC8+XG4gICk7XG59XG5cbkhvbWUuZ2V0SW5pdGlhbFByb3BzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBjb3Vyc2VzLmFsbCgpO1xuXG4gICAgcmV0dXJuIHsgZGF0YTogZGF0YS5kYXRhIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIb21lO1xuIiwiaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDbGllbnRzKCkge1xuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAganVzdGlmeS1jZW50ZXIgaXRlbXMtY2VudGVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBzbTp3LTEvNiBtYi04IG1kOm1iLTBcIj5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIHNyYz1cIi9pbWFnZXMvbG9nby1hbWF6b24uc3ZnXCJcbiAgICAgICAgICBhbHQ9XCJsb2dvIGFtYXpvblwiXG4gICAgICAgICAgY2xhc3NOYW1lPVwibXgtYXV0b1wiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHNtOnctMS82IG1iLTggbWQ6bWItMFwiPlxuICAgICAgICA8aW1nXG4gICAgICAgICAgc3JjPVwiL2ltYWdlcy9sb2dvLW1pY3Jvc29mdC5zdmdcIlxuICAgICAgICAgIGFsdD1cImxvZ28gbWljcm9zb2Z0XCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJteC1hdXRvXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgc206dy0xLzYgbWItOCBtZDptYi0wXCI+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9XCIvaW1hZ2VzL2xvZ28tdGVzbGEuc3ZnXCJcbiAgICAgICAgICBhbHQ9XCJsb2dvIHRlc2xhXCJcbiAgICAgICAgICBjbGFzc05hbWU9XCJteC1hdXRvXCJcbiAgICAgICAgLz5cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgc206dy0xLzYgbWItOCBtZDptYi0wXCI+XG4gICAgICAgIDxpbWdcbiAgICAgICAgICBzcmM9XCIvaW1hZ2VzL2xvZ28tZ29vZ2xlLnN2Z1wiXG4gICAgICAgICAgYWx0PVwibG9nbyBnb29nbGVcIlxuICAgICAgICAgIGNsYXNzTmFtZT1cIm14LWF1dG9cIlxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBzbTp3LTEvNiBtYi04IG1kOm1iLTBcIj5cbiAgICAgICAgPGltZ1xuICAgICAgICAgIHNyYz1cIi9pbWFnZXMvbG9nby1mYWNlYm9vay5zdmdcIlxuICAgICAgICAgIGFsdD1cImxvZ28gZmFjZWJvb2tcIlxuICAgICAgICAgIGNsYXNzTmFtZT1cIm14LWF1dG9cIlxuICAgICAgICAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRm9vdGVyKCkge1xuICBmdW5jdGlvbiBzdWJtaXQoKSB7fVxuXG4gIHJldHVybiAoXG4gICAgPGZvb3RlciBjbGFzc05hbWU9XCJjb250YWluZXIgcHgtNCBteC1hdXRvXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctZnVsbCBtZDp3LTEvNiBtYi04IG1kOm1iLTBcIj5cbiAgICAgICAgICA8aDYgY2xhc3NOYW1lPVwidGV4dC13aGl0ZVwiPkNvbXBhbnk8L2g2PlxuICAgICAgICAgIDx1bCBjbGFzc05hbWU9XCJtdC00XCI+XG4gICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibXQtMlwiPlxuICAgICAgICAgICAgICA8TGluayBocmVmPVwiXCI+XG4gICAgICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwidGV4dC1pbmRpZ28tNTAwIGhvdmVyOnRleHQtdGVhbC01MDAgaG92ZXI6dW5kZXJsaW5lXCI+XG4gICAgICAgICAgICAgICAgICBBUEkgRGV2ZWxvcGVyXG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTUwMCBob3Zlcjp0ZXh0LXRlYWwtNTAwIGhvdmVyOnVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgQ2FyZWVyXG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTUwMCBob3Zlcjp0ZXh0LXRlYWwtNTAwIGhvdmVyOnVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgT3VyIFN0b3J5XG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTUwMCBob3Zlcjp0ZXh0LXRlYWwtNTAwIGhvdmVyOnVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgTmV3IFNvb25cbiAgICAgICAgICAgICAgICA8L2E+XG4gICAgICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS82IG1iLTggbWQ6bWItMFwiPlxuICAgICAgICAgIDxoNiBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlXCI+U3R1ZGVudDwvaDY+XG4gICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm10LTRcIj5cbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtdC0yXCI+XG4gICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCJcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJ0ZXh0LWluZGlnby01MDAgaG92ZXI6dGV4dC10ZWFsLTUwMCBob3Zlcjp1bmRlcmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIEdldCBTY2hvbGFyc2hpcFxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtdC0yXCI+XG4gICAgICAgICAgICAgIDxMaW5rIGhyZWY9XCJcIj5cbiAgICAgICAgICAgICAgICA8YSBjbGFzc05hbWU9XCJ0ZXh0LWluZGlnby01MDAgaG92ZXI6dGV4dC10ZWFsLTUwMCBob3Zlcjp1bmRlcmxpbmVcIj5cbiAgICAgICAgICAgICAgICAgIE91ciBQYXRoc2tpbGxzXG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTUwMCBob3Zlcjp0ZXh0LXRlYWwtNTAwIGhvdmVyOnVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgQWxsIEZlYXR1cmVzXG4gICAgICAgICAgICAgICAgPC9hPlxuICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm10LTJcIj5cbiAgICAgICAgICAgICAgPExpbmsgaHJlZj1cIlwiPlxuICAgICAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cInRleHQtaW5kaWdvLTUwMCBob3Zlcjp0ZXh0LXRlYWwtNTAwIGhvdmVyOnVuZGVybGluZVwiPlxuICAgICAgICAgICAgICAgICAgUmVmdW5kIFBvbGljeVxuICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgPC9MaW5rPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L3VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzYgbWItOCBtZDptYi0wXCI+XG4gICAgICAgICAgPGg2IGNsYXNzTmFtZT1cInRleHQtd2hpdGVcIj5Ub3VjaCBVczwvaDY+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtNCB0ZXh0LWluZGlnby01MDAgbGVhZGluZy1sb29zZVwiPlxuICAgICAgICAgICAgSmVwYXJhPGJyIC8+XG4gICAgICAgICAgICBsLiBQYWtpcyBILiBSYWhheXUgTm8uNTE8YnIgLz5cbiAgICAgICAgICAgIFJULjAzL1JXLjAyLCBQb3Ryb3l1ZGFuIFYsIFBvdHJveXVkYW4gPGJyIC8+XG4gICAgICAgICAgICArMjEgMjAyMCA1NTU1XG4gICAgICAgICAgPC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0yLzYgbWItOCBtZDptYi0wXCI+XG4gICAgICAgICAgPGg2IGNsYXNzTmFtZT1cInRleHQtd2hpdGVcIj5Qcm9tb3Rpb25zPC9oNj5cbiAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdC00IHRleHQtaW5kaWdvLTUwMFwiPlxuICAgICAgICAgICAgU3VibWl0IHlvdXIgZW1haWwgZm9yIG5ldyB1cGRhdGVzXG4gICAgICAgICAgPC9wPlxuICAgICAgICAgIDxmb3JtIG9uU3VibWl0PXtzdWJtaXR9PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctd2hpdGUgZm9jdXM6b3V0bGluZS1ub25lIGJvcmRlci0wIHB4LTYgcHktMyBtdC02IG1kOnctMS8yXCJcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJZb3VyIGVtYWlsIGFkZHJlc1wiXG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJiZy1vcmFuZ2UtNTAwIGhvdmVyOmJnLW9yYW5nZS00MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGZvY3VzOm91dGxpbmUtbm9uZSBzaGFkb3ctaW5uZXIgdGV4dC13aGl0ZSBweC00IG1kOnB4LTYgcHktM1wiPlxuICAgICAgICAgICAgICBEYWZ0YXIgTm93XG4gICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlci10IHB0LTggbXQtOCBib3JkZXItZ3JheS04MDAgdGV4dC1jZW50ZXJcIj5cbiAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1pbmRpZ28tNTAwXCI+XG4gICAgICAgICAgMjAyMCBDb3B5cmlnaHQgTWljcm8gYnkgIEV0bmljb2RlLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gICAgICAgIDwvcD5cbiAgICAgIDwvZGl2PlxuICAgIDwvZm9vdGVyPlxuICApO1xufVxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBwcm9wVHlwZXMgZnJvbSBcInByb3AtdHlwZXNcIjtcblxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSBcIm5leHQvcm91dGVyXCI7XG5cbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcblxuaW1wb3J0IExvZ28gZnJvbSBcInB1YmxpYy9pbWFnZXMvbG9nb19qY3Byby5zdmdcIjtcbmltcG9ydCBEZWZhdWx0QXZhdGFyIGZyb20gXCJwdWJsaWMvaW1hZ2VzL2RlZmF1bHQtYXZhdGFyLnN2Z1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZWFkZXIoeyBvbkxpZ2h0IH0pIHtcbiAgY29uc3QgW1VzZXIsIHNldFVzZXJdID0gdXNlU3RhdGUoKCkgPT4gbnVsbCk7XG5cbiAgY29uc3QgW1RvZ2dsZU1lbnUsIHNldFRvZ2dsZU1lbnVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdXNlckNvb2tpZXMgPVxuICAgICAgZGVjb2RlVVJJQ29tcG9uZW50KHdpbmRvdy5kb2N1bWVudC5jb29raWUpXG4gICAgICAgID8uc3BsaXQoXCI7XCIpXG4gICAgICAgID8uZmluZD8uKChpdGVtKSA9PiBpdGVtLmluZGV4T2YoXCJCV0FNSUNSTzp1c2VyXCIpID4gLTEpXG4gICAgICAgID8uc3BsaXQoXCI9XCIpWzFdID8/IG51bGw7XG4gICAgc2V0VXNlcih1c2VyQ29va2llcyA/IEpTT04ucGFyc2UodXNlckNvb2tpZXMpIDogbnVsbCk7XG4gIH0sIFtdKTtcblxuICBjb25zdCBsaW5rQ29sb3IgPSBvbkxpZ2h0ID8gXCJ0ZXh0LWdyYXktOTAwXCIgOiBcInRleHQtd2hpdGVcIjtcblxuICBjb25zdCByb3V0ZXIgPSB1c2VSb3V0ZXIoKTtcblxuICBjb25zdCBsaW5rQ1RBID1cbiAgICByb3V0ZXIucGF0aG5hbWUuaW5kZXhPZihcIi9sb2dpblwiKSA+IC0xXG4gICAgICA/IGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01FTUJFUlBBR0VfVVJMfS9yZWdpc3RlcmBcbiAgICAgIDogYCR7cHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUVNQkVSUEFHRV9VUkx9L2xvZ2luYDtcbiAgY29uc3QgdGV4dENUQSA9IHJvdXRlci5wYXRobmFtZS5pbmRleE9mKFwiL2xvZ2luXCIpID4gLTEgPyBcIkRhZnRhclwiIDogXCJNYXN1a1wiO1xuXG4gIHJldHVybiAoXG4gICAgPGhlYWRlclxuICAgICAgY2xhc3NOYW1lPXtbXG4gICAgICAgIFwiZmxleCBqdXN0aWZ5LWJldHdlZW4gaXRlbXMtY2VudGVyXCIsXG4gICAgICAgIFRvZ2dsZU1lbnUgPyBcImZpeGVkIHctZnVsbCAtbXgtNCBweC00XCIgOiBcIlwiLFxuICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICA+XG4gICAgICA8ZGl2IHN0eWxlPXt7IGhlaWdodDogNTQsIHpJbmRleDogNTAgfX0+XG4gICAgICAgIDxMb2dvIGNsYXNzTmFtZT1cIm9uLWRhcmtcIj48L0xvZ28+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBtZDpoaWRkZW5cIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IHNldFRvZ2dsZU1lbnUoKHByZXYpID0+ICFwcmV2KX1cbiAgICAgICAgICBjbGFzc05hbWU9e1tcInRvZ2dsZSB6LTUwXCIsIFRvZ2dsZU1lbnUgPyBcImFjdGl2ZVwiIDogXCJcIl0uam9pbihcIiBcIil9XG4gICAgICAgID48L2J1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgICAgPHVsXG4gICAgICAgIGNsYXNzTmFtZT17W1xuICAgICAgICAgIFwidHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGl0ZW1zLWNlbnRlciBmaXhlZCBpbnNldC0wIGJnLWluZGlnby0xMDAwIHB0LTI0IG1kOnB0LTAgbWQ6YmctdHJhbnNwYXJlbnQgbWQ6cmVsYXRpdmUgbWQ6ZmxleCBtZDpvcGFjaXR5LTEwMCBtZDp2aXNpYmxlXCIsXG4gICAgICAgICAgVG9nZ2xlTWVudSA/IFwib3BhY2l0eS0xMDAgdmlzaWJsZSB6LTIwXCIgOiBcIm9wYWNpdHktMCBpbnZpc2libGVcIixcbiAgICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICAgID5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm15LTQgbWQ6bXktMFwiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0LXdoaXRlIGhvdmVyOnRleHQtdGVhbC01MDAgdGV4dC1sZyBweC02IHB5LTMgZm9udC1tZWRpdW1cIixcbiAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgSG9tZVxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm15LTQgbWQ6bXktMFwiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0LXdoaXRlIGhvdmVyOnRleHQtdGVhbC01MDAgdGV4dC1sZyBweC02IHB5LTMgZm9udC1tZWRpdW1cIixcbiAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgUHJpY2luZ1xuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm15LTQgbWQ6bXktMFwiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0LXdoaXRlIGhvdmVyOnRleHQtdGVhbC01MDAgdGV4dC1sZyBweC02IHB5LTMgZm9udC1tZWRpdW1cIixcbiAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgRmVhdHVyZVxuICAgICAgICAgICAgPC9hPlxuICAgICAgICAgIDwvTGluaz5cbiAgICAgICAgPC9saT5cbiAgICAgICAgPGxpIGNsYXNzTmFtZT1cIm15LTQgbWQ6bXktMFwiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvXCI+XG4gICAgICAgICAgICA8YVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e1tcbiAgICAgICAgICAgICAgICBsaW5rQ29sb3IsXG4gICAgICAgICAgICAgICAgXCJ0ZXh0LXdoaXRlIGhvdmVyOnRleHQtdGVhbC01MDAgdGV4dC1sZyBweC02IHB5LTMgZm9udC1tZWRpdW1cIixcbiAgICAgICAgICAgICAgXS5qb2luKFwiIFwiKX1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgU3RvcnlcbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgIDwvbGk+XG4gICAgICAgIDxsaSBjbGFzc05hbWU9XCJtdC04IG1kOm10LTBcIj5cbiAgICAgICAgICB7VXNlciA/IChcbiAgICAgICAgICAgIDxhXG4gICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgIHJlbD1cIm5vb3BlbmVyIG5vZXJlZmVycmVyXCJcbiAgICAgICAgICAgICAgaHJlZj17bGlua0NUQX1cbiAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiaG92ZXI6YmctaW5kaWdvLTgwMCB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgdGV4dC13aGl0ZSBob3Zlcjp0ZXh0LXRlYWwtNTAwIHRleHQtbGcgcHgtNiBweS0zIGZvbnQtbWVkaXVtIG1sLTYgaW5saW5lLWZsZXggaXRlbXMtY2VudGVyXCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwicm91bmRlZC1mdWxsIG92ZXJmbG93LWhpZGRlbiBtci0zIGJvcmRlci0yIGJvcmRlci1vcmFuZ2UtNTAwXCI+XG4gICAgICAgICAgICAgICAge1VzZXI/LnRodW1ibmFpbCA/IChcbiAgICAgICAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgICAgICAgc3JjPXtVc2VyPy50aHVtYm5haWx9XG4gICAgICAgICAgICAgICAgICAgIGFsdD17VXNlcj8ubmFtZSA/PyBcIlVzZXJuYW1lXCJ9XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm9iamVjdC1jb3ZlciB3LTggaC04IGlubGluZS1ibG9ja1wiXG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICA8RGVmYXVsdEF2YXRhciBjbGFzc05hbWU9XCJmaWxsLWluZGlnby01MDAgdy04IGgtOCBpbmxpbmUtYmxvY2tcIj48L0RlZmF1bHRBdmF0YXI+XG4gICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICBIaSwge1VzZXIubmFtZX1cbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICApIDogKFxuICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgdGFyZ2V0PVwiX2JsYW5rXCJcbiAgICAgICAgICAgICAgcmVsPVwibm9vcGVuZXIgbm9lcmVmZXJyZXJcIlxuICAgICAgICAgICAgICBocmVmPXtsaW5rQ1RBfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNzAwIGhvdmVyOmJnLWluZGlnby04MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIHRleHQtd2hpdGUgaG92ZXI6dGV4dC10ZWFsLTUwMCB0ZXh0LWxnIHB4LTYgcHktMyBmb250LW1lZGl1bSBtbC02XCJcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3RleHRDVEF9XG4gICAgICAgICAgICA8L2E+XG4gICAgICAgICAgKX1cbiAgICAgICAgPC9saT5cbiAgICAgIDwvdWw+XG4gICAgPC9oZWFkZXI+XG4gICk7XG59XG5cbkhlYWRlci5wcm9wVHlwZXMgPSB7XG4gIG9uTGlnaHQ6IHByb3BUeXBlcy5ib29sLFxufTtcbiIsImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIZXJvKCkge1xuICBjb25zdCBbc3RhdGUsIHNldHN0YXRlXSA9IHVzZVN0YXRlKCgpID0+IFwiXCIpO1xuXG4gIGZ1bmN0aW9uIHN1Ym1pdCgpIHtcbiAgICB3aW5kb3cub3BlbihcbiAgICAgIGAke3Byb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01FTUJFUlBBR0VfVVJMfS9yZWdpc3Rlcj9lbWFpbD0ke3N0YXRlfWBcbiAgICApO1xuICB9XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIG1kOnctMS8yIG10LTggbWQ6bXQtMFwiPlxuICAgICAgICA8aDEgY2xhc3NOYW1lPVwidGV4dC01eGwgdGV4dC13aGl0ZSBtYi01IGZvbnQtc2VtaWJvbGRcIj5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXRlYWwtNDAwXCI+VGhlIE5ldzwvc3Bhbj4gV2F5IHRvXG4gICAgICAgICAgPGJyIGNsYXNzTmFtZT1cImhpZGRlbiBtZDpibG9ja1wiIC8+IEFjaGlldmUgR29vZHtcIiBcIn1cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXRlYWwtNDAwXCI+U2tpbGxzPC9zcGFuPlxuICAgICAgICA8L2gxPlxuICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIGZvbnQtbGlnaHQgdGV4dC1sZyBtYi04XCI+XG4gICAgICAgICAgV2UgcHJvdmlkZSB0b25zIG9mIHBhdGhza2lsbCB0aGF0IHlvdXtcIiBcIn1cbiAgICAgICAgICA8YnIgY2xhc3NOYW1lPVwiaGlkZGVuIG1kOmJsb2NrXCIgLz4gY2FuIGNob29zZSBhbmQgZm9jdXMgb25cbiAgICAgICAgPC9wPlxuXG4gICAgICAgIDxmb3JtIG9uU3VibWl0PXtzdWJtaXR9IGNsYXNzTmFtZT1cImZsZXhcIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIG9uQ2hhbmdlPXsoZXZlbnQpID0+IHNldHN0YXRlKGV2ZW50LnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJiZy13aGl0ZSBmb2N1czpvdXRsaW5lLW5vbmUgYm9yZGVyLTAgcHgtNCBtZDpweC02IHB5LTMgdy1mdWxsIG1kOnctMS8yXCJcbiAgICAgICAgICAgIHZhbHVlPXtzdGF0ZX1cbiAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiWW91ciBlbWFpbCBhZGRyZXNcIlxuICAgICAgICAgIC8+XG4gICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJiZy1vcmFuZ2UtNTAwIGhvdmVyOmJnLW9yYW5nZS00MDAgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMjAwIGZvY3VzOm91dGxpbmUtbm9uZSBzaGFkb3ctaW5uZXIgdGV4dC13aGl0ZSBweC00IG1kOnB4LTYgcHktMyB3aGl0ZXNwYWNlLW5vLXdyYXBcIj5cbiAgICAgICAgICAgIERhZnRhciBOb3dcbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9mb3JtPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImhpZGRlbiB3LTEvMiBtZDpmbGV4IGp1c3RpZnktZW5kIHB0LTI0IHByLTE2XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwicmVsYXRpdmVcIiBzdHlsZT17eyB3aWR0aDogMzY5LCBoZWlnaHQ6IDQ0MCB9fT5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSBib3JkZXItaW5kaWdvLTcwMCBib3JkZXItMiAtbXQtMTIgLW1yLTYgcmlnaHQtMFwiXG4gICAgICAgICAgICBzdHlsZT17eyB3aWR0aDogMzI0LCBoZWlnaHQ6IDM3NCB9fVxuICAgICAgICAgID48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIHctZnVsbCBoLWZ1bGwgLW1iLTggLW1sLThcIj5cbiAgICAgICAgICAgIDxpbWdcbiAgICAgICAgICAgICAgc3JjPVwiL2ltYWdlcy9pbWctaGVyby1tYmFrLWFseXNzYS1jYWtlcC5qcGdcIlxuICAgICAgICAgICAgICBhbHQ9XCJNYmFrIEFseXNzYSBDYWtlcCBldXlcIlxuICAgICAgICAgICAgLz5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB6LTEwIGJnLXdoaXRlIHB5LTMgcHgtNCBtdC0yNFwiXG4gICAgICAgICAgICBzdHlsZT17eyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWCgtNTAlKVwiLCB3aWR0aDogMjkwIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTkwMCBtYi0yXCI+XG4gICAgICAgICAgICAgIE1ldG9kZSBiZWxhamFyIHlhbmcgc2FudGFpIHNlcGVydGkgbm9udG9uIGRyYWtvciBkaSBOZXRmbGl4XG4gICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LWdyYXktNjAwXCI+QWx5c3NhLCBBcHBzIERldmVsb3Blcjwvc3Bhbj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuXG5pbXBvcnQgZm9ybWF0VGhvdXNhbmQgZnJvbSBcInNyYy9oZWxwZXJzL2Zvcm1hdFRob3VzYW5kXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJlbmRlckl0ZW0oeyBpdGVtIH0pIHtcbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInctMy82IG1kOnctMS82IHB4LTQgaC0xMDAgbWItOCBtZDptYi0wXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNhcmQgcmVsYXRpdmUgdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwXCI+XG4gICAgICAgIHtpdGVtLmltYWdlTmFtZX1cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjYXJkLW1ldGEgbXQtMTBcIj5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwidGV4dC1sZyB0cmFuc2l0aW9uLWFsbCBkdXJhdGlvbi0yMDAgdy0xLzJcIj5cbiAgICAgICAgICAgIHtpdGVtLm5hbWV9XG4gICAgICAgICAgPC9oND5cbiAgICAgICAgICA8aDUgY2xhc3NOYW1lPVwidGV4dC1zbSB0cmFuc2l0aW9uLWFsbCBtdC0yIGR1cmF0aW9uLTUwMFwiPlxuICAgICAgICAgICAge2Zvcm1hdFRob3VzYW5kKGl0ZW0udG90YWwpfVxuICAgICAgICAgIDwvaDU+XG4gICAgICAgICAgPExpbmsgaHJlZj1cIiNcIj5cbiAgICAgICAgICAgIDxhIGNsYXNzTmFtZT1cImxpbmstd3JhcHBlZFwiPjwvYT5cbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCBSZW5kZXJJdGVtIGZyb20gXCIuL1JlbmRlckl0ZW1cIjtcblxuaW1wb3J0IEJ1c2luZXNzRGV2ZWxvcG1lbnQgZnJvbSBcInB1YmxpYy9pbWFnZXMvaWNvbi1idXNpbmVzcy1kZXZlbG9wbWVudC5zdmdcIjtcbmltcG9ydCBDb250ZW50V3JpdGVyIGZyb20gXCJwdWJsaWMvaW1hZ2VzL2ljb24tY29udGVudC13cml0ZXIuc3ZnXCI7XG5pbXBvcnQgUHJvZHVjdEFkdmVydGlzZW1lbnQgZnJvbSBcInB1YmxpYy9pbWFnZXMvaWNvbi1wcm9kdWN0LWFkdmVydGlzZW1lbnQuc3ZnXCI7XG5pbXBvcnQgQ3VzdG9tZXJSZWxhdGlvbnNoaXAgZnJvbSBcInB1YmxpYy9pbWFnZXMvaWNvbi1jdXN0b21lci1yZWxhdGlvbnNoaXAuc3ZnXCI7XG5pbXBvcnQgR2FtZURldmVsb3BtZW50IGZyb20gXCJwdWJsaWMvaW1hZ2VzL2ljb24tZ2FtZS1kZXZlbG9wbWVudC5zdmdcIjtcbmltcG9ydCBUcmF2ZWxHdWlkYW5jZSBmcm9tIFwicHVibGljL2ltYWdlcy9pY29uLXRyYXZlbC1ndWlkYW5jZS5zdmdcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5kZXgoKSB7XG4gIGNvbnN0IGRhdGEgPSBbXG4gICAge1xuICAgICAgaW1hZ2VOYW1lOiA8QnVzaW5lc3NEZXZlbG9wbWVudCAvPixcbiAgICAgIG5hbWU6IFwiQnVzaW5lc3MgRGV2ZWxvcG1lbnRcIixcbiAgICAgIHRvdGFsOiAxMjQ5MyxcbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlTmFtZTogPENvbnRlbnRXcml0ZXIgLz4sXG4gICAgICBuYW1lOiBcIkNvbnRlbnQgV3JpdGVyXCIsXG4gICAgICB0b3RhbDogODM5LFxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VOYW1lOiA8UHJvZHVjdEFkdmVydGlzZW1lbnQgLz4sXG4gICAgICBuYW1lOiBcIlByb2R1Y3QgQWR2ZXJ0aXNlbWVudFwiLFxuICAgICAgdG90YWw6IDQ3OCxcbiAgICB9LFxuICAgIHtcbiAgICAgIGltYWdlTmFtZTogPEN1c3RvbWVyUmVsYXRpb25zaGlwIC8+LFxuICAgICAgbmFtZTogXCJDdXN0b21lciBSZWxhdGlvbnNoaXBcIixcbiAgICAgIHRvdGFsOiA1NTMsXG4gICAgfSxcbiAgICB7XG4gICAgICBpbWFnZU5hbWU6IDxHYW1lRGV2ZWxvcG1lbnQgLz4sXG4gICAgICBuYW1lOiBcIkdhbWUgRGV2ZWxvcG1lbnRcIixcbiAgICAgIHRvdGFsOiA3MzA5LFxuICAgIH0sXG4gICAge1xuICAgICAgaW1hZ2VOYW1lOiA8VHJhdmVsR3VpZGFuY2UgLz4sXG4gICAgICBuYW1lOiBcIlRyYXZlbCBHdWlkYW5jZVwiLFxuICAgICAgdG90YWw6IDczLFxuICAgIH0sXG4gIF07XG5cbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBpdGVtcy1jZW50ZXJcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWF1dG9cIj5cbiAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1sZyB0ZXh0LWdyYXktNjAwXCI+Q2F0ZWdvcnk8L2gyPlxuICAgICAgICAgIDxoMyBjbGFzc05hbWU9XCJ0ZXh0LXhsIHRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICAgIEV4cGxvcmUgJiA8c3BhbiBjbGFzc05hbWU9XCJ0ZXh0LXRlYWwtNDAwXCI+TGVhcm48L3NwYW4+XG4gICAgICAgICAgPC9oMz5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LXdyYXAganVzdGlmeS1zdGFydCBpdGVtcy1jZW50ZXIgLW14LTQgbXQtNlwiPlxuICAgICAgICB7ZGF0YT8ubGVuZ3RoID4gMCA/IChcbiAgICAgICAgICBkYXRhLm1hcCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiA8UmVuZGVySXRlbSBpdGVtPXtpdGVtfSBrZXk9e2luZGV4fT48L1JlbmRlckl0ZW0+O1xuICAgICAgICAgIH0pXG4gICAgICAgICkgOiAoXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgdGV4dC1jZW50ZXItcHktMTJcIj5ObyBJdGVtIEZvdW5kPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Rpdj5cbiAgICA8Lz5cbiAgKTtcbn1cbiIsImltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IExpbmsgZnJvbSBcIm5leHQvbGlua1wiO1xuXG5pbXBvcnQgSWNvblBsYXkgZnJvbSBcInB1YmxpYy9pbWFnZXMvaWNvbi1wbGF5LnN2Z1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBSZW5kZXJJdGVtKHsgaXRlbSB9KSB7XG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgbWQ6dy0xLzQgcHgtNCBtYi02XCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cIml0ZW0gcmVsYXRpdmVcIj5cbiAgICAgICAgPGZpZ3VyZSBjbGFzc05hbWU9XCJpdGVtLWltYWdlXCI+XG4gICAgICAgICAgPEljb25QbGF5PjwvSWNvblBsYXk+XG4gICAgICAgICAgPGltZ1xuICAgICAgICAgICAgc3JjPXtpdGVtPy50aHVtYm5haWwgPz8gXCJcIn1cbiAgICAgICAgICAgIGFsdD17aXRlbT8ubmFtZSA/PyBcInNvbWUgaW5mb3JtYXRpb25cIn1cbiAgICAgICAgICAvPlxuICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpdGVtLW1ldGEgbXQtMlwiPlxuICAgICAgICAgIDxoNCBjbGFzc05hbWU9XCJ0ZXh0LWxnIHRleHQtZ3JheS05MDBcIj5cbiAgICAgICAgICAgIHtpdGVtPy5uYW1lID8/IFwiQ291cnNlIG5hbWVcIn1cbiAgICAgICAgICA8L2g0PlxuICAgICAgICAgIDxoNSBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtZ3JheS02MDBcIj5cbiAgICAgICAgICAgIHtpdGVtPy5sZXZlbCA/PyBcIkNvdXJzZSBsZXZlbFwifVxuICAgICAgICAgIDwvaDU+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8TGluayBocmVmPVwiL2NvdXJzZXMvW2lkXVwiIGFzPXtgL2NvdXJzZXMvJHtpdGVtLmlkfWB9PlxuICAgICAgICAgIDxhIGNsYXNzTmFtZT1cImxpbmstd3JhcHBlZFwiPjwvYT5cbiAgICAgICAgPC9MaW5rPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iLCJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5cbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcblxuaW1wb3J0IFJlbmRlckl0ZW0gZnJvbSBcIi4vUmVuZGVySXRlbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMaXN0Q291cnNlcyh7IGRhdGEgfSkge1xuICByZXR1cm4gKFxuICAgIDw+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXgganVzdGlmeS1iZXR3ZWVuIGl0ZW1zLWNlbnRlclwiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctYXV0b1wiPlxuICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxnIHRleHQtZ3JheS02MDBcIj5OZXcgQ2xhc3NlczwvaDI+XG4gICAgICAgICAgPGgzIGNsYXNzTmFtZT1cInRleHQteGwgdGV4dC1ncmF5LTkwMFwiPlxuICAgICAgICAgICAgU3VtbWVyIDxzcGFuIGNsYXNzTmFtZT1cInRleHQtdGVhbC00MDBcIj5Qcm9kdWN0aXZlPC9zcGFuPlxuICAgICAgICAgIDwvaDM+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctYXV0b1wiPlxuICAgICAgICAgIDxMaW5rIGhyZWY9XCIvY291cnNlc1wiPlxuICAgICAgICAgICAgPGEgY2xhc3NOYW1lPVwidGV4dC1ncmF5LTYwMCBob3Zlcjp1bmRlcmxpbmUgdGV4dC1zbVwiPlxuICAgICAgICAgICAgICBWaWV3IEFsbCBDb3Vyc2VcbiAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICA8L0xpbms+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC13cmFwIGp1c3RpZnktc3RhcnQgaXRlbXMtY2VudGVyIC1teC00IG10LTZcIj5cbiAgICAgICAge2RhdGE/Lmxlbmd0aCA+IDAgPyAoXG4gICAgICAgICAgZGF0YS5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gPFJlbmRlckl0ZW0gaXRlbT17aXRlbX0ga2V5PXtpbmRleH0+PC9SZW5kZXJJdGVtPjtcbiAgICAgICAgICB9KVxuICAgICAgICApIDogKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1mdWxsIHRleHQtY2VudGVyLXB5LTEyXCI+Tm8gSXRlbSBGb3VuZDwvZGl2PlxuICAgICAgICApfVxuICAgICAgPC9kaXY+XG4gICAgPC8+XG4gICk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRsbF81MDMwZjM4N2QzMjhlNDQxNTc4NTsiXSwic291cmNlUm9vdCI6IiJ9